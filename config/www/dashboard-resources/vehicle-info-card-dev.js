/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$3=window,e$4=t$3.ShadowRoot&&(void 0===t$3.ShadyCSS||t$3.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,s$3=Symbol(),n$5=new WeakMap;class o$4{constructor(t,e,n){if(this._$cssResult$=!0,n!==s$3)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=t,this.t=e;}get styleSheet(){let t=this.o;const s=this.t;if(e$4&&void 0===t){const e=void 0!==s&&1===s.length;e&&(t=n$5.get(s)),void 0===t&&((this.o=t=new CSSStyleSheet).replaceSync(this.cssText),e&&n$5.set(s,t));}return t}toString(){return this.cssText}}const r$3=t=>new o$4("string"==typeof t?t:t+"",void 0,s$3),i$2=(t,...e)=>{const n=1===t.length?t[0]:e.reduce(((e,s,n)=>e+(t=>{if(!0===t._$cssResult$)return t.cssText;if("number"==typeof t)return t;throw Error("Value passed to 'css' function must be a 'css' function result: "+t+". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")})(s)+t[n+1]),t[0]);return new o$4(n,t,s$3)},S$2=(s,n)=>{e$4?s.adoptedStyleSheets=n.map((t=>t instanceof CSSStyleSheet?t:t.styleSheet)):n.forEach((e=>{const n=document.createElement("style"),o=t$3.litNonce;void 0!==o&&n.setAttribute("nonce",o),n.textContent=e.cssText,s.appendChild(n);}));},c$1=e$4?t=>t:t=>t instanceof CSSStyleSheet?(t=>{let e="";for(const s of t.cssRules)e+=s.cssText;return r$3(e)})(t):t;

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var s$2;const e$3=window,r$2=e$3.trustedTypes,h$1=r$2?r$2.emptyScript:"",o$3=e$3.reactiveElementPolyfillSupport,n$4={toAttribute(t,i){switch(i){case Boolean:t=t?h$1:null;break;case Object:case Array:t=null==t?t:JSON.stringify(t);}return t},fromAttribute(t,i){let s=t;switch(i){case Boolean:s=null!==t;break;case Number:s=null===t?null:Number(t);break;case Object:case Array:try{s=JSON.parse(t);}catch(t){s=null;}}return s}},a$2=(t,i)=>i!==t&&(i==i||t==t),l$2={attribute:!0,type:String,converter:n$4,reflect:!1,hasChanged:a$2},d$1="finalized";class u$1 extends HTMLElement{constructor(){super(),this._$Ei=new Map,this.isUpdatePending=!1,this.hasUpdated=!1,this._$El=null,this._$Eu();}static addInitializer(t){var i;this.finalize(),(null!==(i=this.h)&&void 0!==i?i:this.h=[]).push(t);}static get observedAttributes(){this.finalize();const t=[];return this.elementProperties.forEach(((i,s)=>{const e=this._$Ep(s,i);void 0!==e&&(this._$Ev.set(e,s),t.push(e));})),t}static createProperty(t,i=l$2){if(i.state&&(i.attribute=!1),this.finalize(),this.elementProperties.set(t,i),!i.noAccessor&&!this.prototype.hasOwnProperty(t)){const s="symbol"==typeof t?Symbol():"__"+t,e=this.getPropertyDescriptor(t,s,i);void 0!==e&&Object.defineProperty(this.prototype,t,e);}}static getPropertyDescriptor(t,i,s){return {get(){return this[i]},set(e){const r=this[t];this[i]=e,this.requestUpdate(t,r,s);},configurable:!0,enumerable:!0}}static getPropertyOptions(t){return this.elementProperties.get(t)||l$2}static finalize(){if(this.hasOwnProperty(d$1))return !1;this[d$1]=!0;const t=Object.getPrototypeOf(this);if(t.finalize(),void 0!==t.h&&(this.h=[...t.h]),this.elementProperties=new Map(t.elementProperties),this._$Ev=new Map,this.hasOwnProperty("properties")){const t=this.properties,i=[...Object.getOwnPropertyNames(t),...Object.getOwnPropertySymbols(t)];for(const s of i)this.createProperty(s,t[s]);}return this.elementStyles=this.finalizeStyles(this.styles),!0}static finalizeStyles(i){const s=[];if(Array.isArray(i)){const e=new Set(i.flat(1/0).reverse());for(const i of e)s.unshift(c$1(i));}else void 0!==i&&s.push(c$1(i));return s}static _$Ep(t,i){const s=i.attribute;return !1===s?void 0:"string"==typeof s?s:"string"==typeof t?t.toLowerCase():void 0}_$Eu(){var t;this._$E_=new Promise((t=>this.enableUpdating=t)),this._$AL=new Map,this._$Eg(),this.requestUpdate(),null===(t=this.constructor.h)||void 0===t||t.forEach((t=>t(this)));}addController(t){var i,s;(null!==(i=this._$ES)&&void 0!==i?i:this._$ES=[]).push(t),void 0!==this.renderRoot&&this.isConnected&&(null===(s=t.hostConnected)||void 0===s||s.call(t));}removeController(t){var i;null===(i=this._$ES)||void 0===i||i.splice(this._$ES.indexOf(t)>>>0,1);}_$Eg(){this.constructor.elementProperties.forEach(((t,i)=>{this.hasOwnProperty(i)&&(this._$Ei.set(i,this[i]),delete this[i]);}));}createRenderRoot(){var t;const s=null!==(t=this.shadowRoot)&&void 0!==t?t:this.attachShadow(this.constructor.shadowRootOptions);return S$2(s,this.constructor.elementStyles),s}connectedCallback(){var t;void 0===this.renderRoot&&(this.renderRoot=this.createRenderRoot()),this.enableUpdating(!0),null===(t=this._$ES)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostConnected)||void 0===i?void 0:i.call(t)}));}enableUpdating(t){}disconnectedCallback(){var t;null===(t=this._$ES)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostDisconnected)||void 0===i?void 0:i.call(t)}));}attributeChangedCallback(t,i,s){this._$AK(t,s);}_$EO(t,i,s=l$2){var e;const r=this.constructor._$Ep(t,s);if(void 0!==r&&!0===s.reflect){const h=(void 0!==(null===(e=s.converter)||void 0===e?void 0:e.toAttribute)?s.converter:n$4).toAttribute(i,s.type);this._$El=t,null==h?this.removeAttribute(r):this.setAttribute(r,h),this._$El=null;}}_$AK(t,i){var s;const e=this.constructor,r=e._$Ev.get(t);if(void 0!==r&&this._$El!==r){const t=e.getPropertyOptions(r),h="function"==typeof t.converter?{fromAttribute:t.converter}:void 0!==(null===(s=t.converter)||void 0===s?void 0:s.fromAttribute)?t.converter:n$4;this._$El=r,this[r]=h.fromAttribute(i,t.type),this._$El=null;}}requestUpdate(t,i,s){let e=!0;void 0!==t&&(((s=s||this.constructor.getPropertyOptions(t)).hasChanged||a$2)(this[t],i)?(this._$AL.has(t)||this._$AL.set(t,i),!0===s.reflect&&this._$El!==t&&(void 0===this._$EC&&(this._$EC=new Map),this._$EC.set(t,s))):e=!1),!this.isUpdatePending&&e&&(this._$E_=this._$Ej());}async _$Ej(){this.isUpdatePending=!0;try{await this._$E_;}catch(t){Promise.reject(t);}const t=this.scheduleUpdate();return null!=t&&await t,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){var t;if(!this.isUpdatePending)return;this.hasUpdated,this._$Ei&&(this._$Ei.forEach(((t,i)=>this[i]=t)),this._$Ei=void 0);let i=!1;const s=this._$AL;try{i=this.shouldUpdate(s),i?(this.willUpdate(s),null===(t=this._$ES)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostUpdate)||void 0===i?void 0:i.call(t)})),this.update(s)):this._$Ek();}catch(t){throw i=!1,this._$Ek(),t}i&&this._$AE(s);}willUpdate(t){}_$AE(t){var i;null===(i=this._$ES)||void 0===i||i.forEach((t=>{var i;return null===(i=t.hostUpdated)||void 0===i?void 0:i.call(t)})),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(t)),this.updated(t);}_$Ek(){this._$AL=new Map,this.isUpdatePending=!1;}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$E_}shouldUpdate(t){return !0}update(t){void 0!==this._$EC&&(this._$EC.forEach(((t,i)=>this._$EO(i,this[i],t))),this._$EC=void 0),this._$Ek();}updated(t){}firstUpdated(t){}}u$1[d$1]=!0,u$1.elementProperties=new Map,u$1.elementStyles=[],u$1.shadowRootOptions={mode:"open"},null==o$3||o$3({ReactiveElement:u$1}),(null!==(s$2=e$3.reactiveElementVersions)&&void 0!==s$2?s$2:e$3.reactiveElementVersions=[]).push("1.6.3");

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var t$2;const i$1=window,s$1=i$1.trustedTypes,e$2=s$1?s$1.createPolicy("lit-html",{createHTML:t=>t}):void 0,o$2="$lit$",n$3=`lit$${(Math.random()+"").slice(9)}$`,l$1="?"+n$3,h=`<${l$1}>`,r$1=document,u=()=>r$1.createComment(""),d=t=>null===t||"object"!=typeof t&&"function"!=typeof t,c=Array.isArray,v$1=t=>c(t)||"function"==typeof(null==t?void 0:t[Symbol.iterator]),a$1="[ \t\n\f\r]",f=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,_$1=/-->/g,m=/>/g,p=RegExp(`>|${a$1}(?:([^\\s"'>=/]+)(${a$1}*=${a$1}*(?:[^ \t\n\f\r"'\`<>=]|("|')|))|$)`,"g"),g=/'/g,$=/"/g,y=/^(?:script|style|textarea|title)$/i,w=t=>(i,...s)=>({_$litType$:t,strings:i,values:s}),x=w(1),T=Symbol.for("lit-noChange"),A=Symbol.for("lit-nothing"),E$1=new WeakMap,C=r$1.createTreeWalker(r$1,129,null,!1);function P$1(t,i){if(!Array.isArray(t)||!t.hasOwnProperty("raw"))throw Error("invalid template strings array");return void 0!==e$2?e$2.createHTML(i):i}const V$1=(t,i)=>{const s=t.length-1,e=[];let l,r=2===i?"<svg>":"",u=f;for(let i=0;i<s;i++){const s=t[i];let d,c,v=-1,a=0;for(;a<s.length&&(u.lastIndex=a,c=u.exec(s),null!==c);)a=u.lastIndex,u===f?"!--"===c[1]?u=_$1:void 0!==c[1]?u=m:void 0!==c[2]?(y.test(c[2])&&(l=RegExp("</"+c[2],"g")),u=p):void 0!==c[3]&&(u=p):u===p?">"===c[0]?(u=null!=l?l:f,v=-1):void 0===c[1]?v=-2:(v=u.lastIndex-c[2].length,d=c[1],u=void 0===c[3]?p:'"'===c[3]?$:g):u===$||u===g?u=p:u===_$1||u===m?u=f:(u=p,l=void 0);const w=u===p&&t[i+1].startsWith("/>")?" ":"";r+=u===f?s+h:v>=0?(e.push(d),s.slice(0,v)+o$2+s.slice(v)+n$3+w):s+n$3+(-2===v?(e.push(void 0),i):w);}return [P$1(t,r+(t[s]||"<?>")+(2===i?"</svg>":"")),e]};class N{constructor({strings:t,_$litType$:i},e){let h;this.parts=[];let r=0,d=0;const c=t.length-1,v=this.parts,[a,f]=V$1(t,i);if(this.el=N.createElement(a,e),C.currentNode=this.el.content,2===i){const t=this.el.content,i=t.firstChild;i.remove(),t.append(...i.childNodes);}for(;null!==(h=C.nextNode())&&v.length<c;){if(1===h.nodeType){if(h.hasAttributes()){const t=[];for(const i of h.getAttributeNames())if(i.endsWith(o$2)||i.startsWith(n$3)){const s=f[d++];if(t.push(i),void 0!==s){const t=h.getAttribute(s.toLowerCase()+o$2).split(n$3),i=/([.?@])?(.*)/.exec(s);v.push({type:1,index:r,name:i[2],strings:t,ctor:"."===i[1]?H$1:"?"===i[1]?L$2:"@"===i[1]?z:k});}else v.push({type:6,index:r});}for(const i of t)h.removeAttribute(i);}if(y.test(h.tagName)){const t=h.textContent.split(n$3),i=t.length-1;if(i>0){h.textContent=s$1?s$1.emptyScript:"";for(let s=0;s<i;s++)h.append(t[s],u()),C.nextNode(),v.push({type:2,index:++r});h.append(t[i],u());}}}else if(8===h.nodeType)if(h.data===l$1)v.push({type:2,index:r});else {let t=-1;for(;-1!==(t=h.data.indexOf(n$3,t+1));)v.push({type:7,index:r}),t+=n$3.length-1;}r++;}}static createElement(t,i){const s=r$1.createElement("template");return s.innerHTML=t,s}}function S$1(t,i,s=t,e){var o,n,l,h;if(i===T)return i;let r=void 0!==e?null===(o=s._$Co)||void 0===o?void 0:o[e]:s._$Cl;const u=d(i)?void 0:i._$litDirective$;return (null==r?void 0:r.constructor)!==u&&(null===(n=null==r?void 0:r._$AO)||void 0===n||n.call(r,!1),void 0===u?r=void 0:(r=new u(t),r._$AT(t,s,e)),void 0!==e?(null!==(l=(h=s)._$Co)&&void 0!==l?l:h._$Co=[])[e]=r:s._$Cl=r),void 0!==r&&(i=S$1(t,r._$AS(t,i.values),r,e)),i}class M{constructor(t,i){this._$AV=[],this._$AN=void 0,this._$AD=t,this._$AM=i;}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}u(t){var i;const{el:{content:s},parts:e}=this._$AD,o=(null!==(i=null==t?void 0:t.creationScope)&&void 0!==i?i:r$1).importNode(s,!0);C.currentNode=o;let n=C.nextNode(),l=0,h=0,u=e[0];for(;void 0!==u;){if(l===u.index){let i;2===u.type?i=new R(n,n.nextSibling,this,t):1===u.type?i=new u.ctor(n,u.name,u.strings,this,t):6===u.type&&(i=new Z(n,this,t)),this._$AV.push(i),u=e[++h];}l!==(null==u?void 0:u.index)&&(n=C.nextNode(),l++);}return C.currentNode=r$1,o}v(t){let i=0;for(const s of this._$AV)void 0!==s&&(void 0!==s.strings?(s._$AI(t,s,i),i+=s.strings.length-2):s._$AI(t[i])),i++;}}class R{constructor(t,i,s,e){var o;this.type=2,this._$AH=A,this._$AN=void 0,this._$AA=t,this._$AB=i,this._$AM=s,this.options=e,this._$Cp=null===(o=null==e?void 0:e.isConnected)||void 0===o||o;}get _$AU(){var t,i;return null!==(i=null===(t=this._$AM)||void 0===t?void 0:t._$AU)&&void 0!==i?i:this._$Cp}get parentNode(){let t=this._$AA.parentNode;const i=this._$AM;return void 0!==i&&11===(null==t?void 0:t.nodeType)&&(t=i.parentNode),t}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(t,i=this){t=S$1(this,t,i),d(t)?t===A||null==t||""===t?(this._$AH!==A&&this._$AR(),this._$AH=A):t!==this._$AH&&t!==T&&this._(t):void 0!==t._$litType$?this.g(t):void 0!==t.nodeType?this.$(t):v$1(t)?this.T(t):this._(t);}k(t){return this._$AA.parentNode.insertBefore(t,this._$AB)}$(t){this._$AH!==t&&(this._$AR(),this._$AH=this.k(t));}_(t){this._$AH!==A&&d(this._$AH)?this._$AA.nextSibling.data=t:this.$(r$1.createTextNode(t)),this._$AH=t;}g(t){var i;const{values:s,_$litType$:e}=t,o="number"==typeof e?this._$AC(t):(void 0===e.el&&(e.el=N.createElement(P$1(e.h,e.h[0]),this.options)),e);if((null===(i=this._$AH)||void 0===i?void 0:i._$AD)===o)this._$AH.v(s);else {const t=new M(o,this),i=t.u(this.options);t.v(s),this.$(i),this._$AH=t;}}_$AC(t){let i=E$1.get(t.strings);return void 0===i&&E$1.set(t.strings,i=new N(t)),i}T(t){c(this._$AH)||(this._$AH=[],this._$AR());const i=this._$AH;let s,e=0;for(const o of t)e===i.length?i.push(s=new R(this.k(u()),this.k(u()),this,this.options)):s=i[e],s._$AI(o),e++;e<i.length&&(this._$AR(s&&s._$AB.nextSibling,e),i.length=e);}_$AR(t=this._$AA.nextSibling,i){var s;for(null===(s=this._$AP)||void 0===s||s.call(this,!1,!0,i);t&&t!==this._$AB;){const i=t.nextSibling;t.remove(),t=i;}}setConnected(t){var i;void 0===this._$AM&&(this._$Cp=t,null===(i=this._$AP)||void 0===i||i.call(this,t));}}class k{constructor(t,i,s,e,o){this.type=1,this._$AH=A,this._$AN=void 0,this.element=t,this.name=i,this._$AM=e,this.options=o,s.length>2||""!==s[0]||""!==s[1]?(this._$AH=Array(s.length-1).fill(new String),this.strings=s):this._$AH=A;}get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}_$AI(t,i=this,s,e){const o=this.strings;let n=!1;if(void 0===o)t=S$1(this,t,i,0),n=!d(t)||t!==this._$AH&&t!==T,n&&(this._$AH=t);else {const e=t;let l,h;for(t=o[0],l=0;l<o.length-1;l++)h=S$1(this,e[s+l],i,l),h===T&&(h=this._$AH[l]),n||(n=!d(h)||h!==this._$AH[l]),h===A?t=A:t!==A&&(t+=(null!=h?h:"")+o[l+1]),this._$AH[l]=h;}n&&!e&&this.j(t);}j(t){t===A?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,null!=t?t:"");}}class H$1 extends k{constructor(){super(...arguments),this.type=3;}j(t){this.element[this.name]=t===A?void 0:t;}}const I=s$1?s$1.emptyScript:"";class L$2 extends k{constructor(){super(...arguments),this.type=4;}j(t){t&&t!==A?this.element.setAttribute(this.name,I):this.element.removeAttribute(this.name);}}class z extends k{constructor(t,i,s,e,o){super(t,i,s,e,o),this.type=5;}_$AI(t,i=this){var s;if((t=null!==(s=S$1(this,t,i,0))&&void 0!==s?s:A)===T)return;const e=this._$AH,o=t===A&&e!==A||t.capture!==e.capture||t.once!==e.once||t.passive!==e.passive,n=t!==A&&(e===A||o);o&&this.element.removeEventListener(this.name,this,e),n&&this.element.addEventListener(this.name,this,t),this._$AH=t;}handleEvent(t){var i,s;"function"==typeof this._$AH?this._$AH.call(null!==(s=null===(i=this.options)||void 0===i?void 0:i.host)&&void 0!==s?s:this.element,t):this._$AH.handleEvent(t);}}class Z{constructor(t,i,s){this.element=t,this.type=6,this._$AN=void 0,this._$AM=i,this.options=s;}get _$AU(){return this._$AM._$AU}_$AI(t){S$1(this,t);}}const B$1=i$1.litHtmlPolyfillSupport;null==B$1||B$1(N,R),(null!==(t$2=i$1.litHtmlVersions)&&void 0!==t$2?t$2:i$1.litHtmlVersions=[]).push("2.8.0");const D$1=(t,i,s)=>{var e,o;const n=null!==(e=null==s?void 0:s.renderBefore)&&void 0!==e?e:i;let l=n._$litPart$;if(void 0===l){const t=null!==(o=null==s?void 0:s.renderBefore)&&void 0!==o?o:null;n._$litPart$=l=new R(i.insertBefore(u(),t),t,void 0,null!=s?s:{});}return l._$AI(t),l};

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var l,o$1;class s extends u$1{constructor(){super(...arguments),this.renderOptions={host:this},this._$Do=void 0;}createRenderRoot(){var t,e;const i=super.createRenderRoot();return null!==(t=(e=this.renderOptions).renderBefore)&&void 0!==t||(e.renderBefore=i.firstChild),i}update(t){const i=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(t),this._$Do=D$1(i,this.renderRoot,this.renderOptions);}connectedCallback(){var t;super.connectedCallback(),null===(t=this._$Do)||void 0===t||t.setConnected(!0);}disconnectedCallback(){var t;super.disconnectedCallback(),null===(t=this._$Do)||void 0===t||t.setConnected(!1);}render(){return T}}s.finalized=!0,s._$litElement$=!0,null===(l=globalThis.litElementHydrateSupport)||void 0===l||l.call(globalThis,{LitElement:s});const n$2=globalThis.litElementPolyfillSupport;null==n$2||n$2({LitElement:s});(null!==(o$1=globalThis.litElementVersions)&&void 0!==o$1?o$1:globalThis.litElementVersions=[]).push("3.3.3");

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e$1=e=>n=>"function"==typeof n?((e,n)=>(customElements.define(e,n),n))(e,n):((e,n)=>{const{kind:t,elements:s}=n;return {kind:t,elements:s,finisher(n){customElements.define(e,n);}}})(e,n);

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const i=(i,e)=>"method"===e.kind&&e.descriptor&&!("value"in e.descriptor)?{...e,finisher(n){n.createProperty(e.key,i);}}:{kind:"field",key:Symbol(),placement:"own",descriptor:{},originalKey:e.key,initializer(){"function"==typeof e.initializer&&(this[e.key]=e.initializer.call(this));},finisher(n){n.createProperty(e.key,i);}},e=(i,e,n)=>{e.constructor.createProperty(n,i);};function n$1(n){return (t,o)=>void 0!==o?e(n,t,o):i(n,t)}

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */function t$1(t){return n$1({...t,state:!0})}

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var n;null!=(null===(n=window.HTMLSlotElement)||void 0===n?void 0:n.prototype.assignedElements)?(o,n)=>o.assignedElements(n):(o,n)=>o.assignedNodes(n).filter((o=>o.nodeType===Node.ELEMENT_NODE));

var t,r,a=function(e,t){return o(t).format(e)},o=function(e){return new Intl.DateTimeFormat(e.language,{year:"numeric",month:"long",day:"numeric"})};!function(e){e.language="language",e.system="system",e.comma_decimal="comma_decimal",e.decimal_comma="decimal_comma",e.space_comma="space_comma",e.none="none";}(t||(t={})),function(e){e.language="language",e.system="system",e.am_pm="12",e.twenty_four="24";}(r||(r={}));var b=function(e){if(e.time_format===r.language||e.time_format===r.system){var t=e.time_format===r.language?e.language:void 0,n=(new Date).toLocaleString(t);return n.includes("AM")||n.includes("PM")}return e.time_format===r.am_pm},v=function(e,t){return _(t).format(e)},_=function(e){return new Intl.DateTimeFormat(e.language,{year:"numeric",month:"long",day:"numeric",hour:b(e)?"numeric":"2-digit",minute:"2-digit",hour12:b(e)})},D=function(e,t){return S(t).format(e)},S=function(e){return new Intl.DateTimeFormat(e.language,{hour:"numeric",minute:"2-digit",hour12:b(e)})};function O(){return (O=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n]);}return e}).apply(this,arguments)}function E(e){return e.substr(0,e.indexOf("."))}function L$1(e){return E(e.entity_id)}var P=function(e){return !!e.attributes.unit_of_measurement||!!e.attributes.state_class},U=function(e){switch(e.number_format){case t.comma_decimal:return ["en-US","en"];case t.decimal_comma:return ["de","es","it"];case t.space_comma:return ["fr","sv","cs"];case t.system:return;default:return e.language}},B=function(e,t){return void 0===t&&(t=2),Math.round(e*Math.pow(10,t))/Math.pow(10,t)},H=function(e,r,n){var i=r?U(r):void 0;if(Number.isNaN=Number.isNaN||function e(t){return "number"==typeof t&&e(t)},(null==r?void 0:r.number_format)!==t.none&&!Number.isNaN(Number(e))&&Intl)try{return new Intl.NumberFormat(i,V(e,n)).format(Number(e))}catch(t){return console.error(t),new Intl.NumberFormat(void 0,V(e,n)).format(Number(e))}return "string"==typeof e?e:B(e,null==n?void 0:n.maximumFractionDigits).toString()+("currency"===(null==n?void 0:n.style)?" "+n.currency:"")},V=function(e,t){var r=O({maximumFractionDigits:2},t);if("string"!=typeof e)return r;if(!t||!t.minimumFractionDigits&&!t.maximumFractionDigits){var n=e.indexOf(".")>-1?e.split(".")[1].length:0;r.minimumFractionDigits=n,r.maximumFractionDigits=n;}return r},W=function(e,t,r,n){var i=void 0!==n?n:t.state;if("unknown"===i||"unavailable"===i)return e("state.default."+i);if(P(t)){if("monetary"===t.attributes.device_class)try{return H(i,r,{style:"currency",currency:t.attributes.unit_of_measurement})}catch(e){}return H(i,r)+(t.attributes.unit_of_measurement?" "+t.attributes.unit_of_measurement:"")}var o=L$1(t);if("input_datetime"===o){var u;if(void 0===n)return t.attributes.has_date&&t.attributes.has_time?(u=new Date(t.attributes.year,t.attributes.month-1,t.attributes.day,t.attributes.hour,t.attributes.minute),v(u,r)):t.attributes.has_date?(u=new Date(t.attributes.year,t.attributes.month-1,t.attributes.day),a(u,r)):t.attributes.has_time?((u=new Date).setHours(t.attributes.hour,t.attributes.minute),D(u,r)):t.state;try{var c=n.split(" ");if(2===c.length)return v(new Date(c.join("T")),r);if(1===c.length){if(n.includes("-"))return a(new Date(n+"T00:00"),r);if(n.includes(":")){var m=new Date;return D(new Date(m.toISOString().split("T")[0]+"T"+n),r)}}return n}catch(e){return n}}return "humidifier"===o&&"on"===i&&t.attributes.humidity?t.attributes.humidity+" %":"counter"===o||"number"===o||"input_number"===o?H(i,r):t.attributes.device_class&&e("component."+o+".state."+t.attributes.device_class+"."+i)||e("component."+o+".state._."+i)||i},ne=function(e,t,r,n){n=n||{},r=null==r?{}:r;var i=new Event(t,{bubbles:void 0===n.bubbles||n.bubbles,cancelable:Boolean(n.cancelable),composed:void 0===n.composed||n.composed});return i.detail=r,e.dispatchEvent(i),i};function _e(e,t,r){if(t.has("config")||r)return !0;if(e.config.entity){var n=t.get("hass");return !n||n.states[e.config.entity]!==e.hass.states[e.config.entity]}return !1}

const defaultConfig = {
    type: 'custom:vehicle-info-card',
    name: 'Mercedes Benz',
    entity: '',
    device_tracker: '',
    google_api_key: '',
    show_slides: false,
    show_map: false,
    show_buttons: true,
    show_background: true,
    enable_map_popup: false,
    images: [],
    trip_card: [],
    vehicle_card: [],
    eco_card: [],
    tyre_card: [],
};
/**
 * Filters for binary sensors.
 */
const binarySensorsFilters = {
    lock: { prefix: 'lock', suffix: '_lock' },
    parkBrake: { suffix: '_parkbrakestatus' },
    liquidRangeCritical: { suffix: '_liquidrangecritical' },
    lowBrakeFluid: { suffix: '_warningbrakefluid' },
    lowWashWater: { suffix: '_warningwashwater' },
    lowCoolantLevel: { suffix: '_warningcoolantlevellow' },
    engineLight: { suffix: '_warningenginelight' },
    windowsClosed: { suffix: '_windowstatusoverall' },
    tirePressureWarning: { suffix: '_tirewarninglamp' },
    remoteStartActive: { suffix: '_remotestartactive' },
    engineState: { suffix: '_enginestate' },
    chargeFlapACStatus: { suffix: '_chargeflapacstatus' },
};
/**
 * Filters for sensor devices.
 */
const sensorDeviceFilters = {
    lockSensor: { prefix: 'sensor.', suffix: '_lock' },
    averageSpeedReset: { suffix: '_averagespeedreset' },
    averageSpeedStart: { suffix: '_averagespeedstart' },
    distanceReset: { suffix: '_distancereset' },
    distanceStart: { suffix: '_distancestart' },
    liquidConsumptionReset: { suffix: '_liquidconsumptionreset' },
    liquidConsumptionStart: { suffix: '_liquidconsumptionstart' },
    electricConsumptionReset: { suffix: '_electricconsumptionreset' },
    electricConsumptionStart: { suffix: '_electricconsumptionstart' },
    odometer: { suffix: '_odometer' },
    rangeLiquid: { suffix: '_rangeliquid' },
    rangeElectric: { suffix: '_rangeelectrickm' },
    fuelLevel: { suffix: '_tanklevelpercent' },
    adBlueLevel: { suffix: '_tankleveladblue' },
    ecoScoreTotal: { suffix: '_ecoscoretotal' },
    ecoScoreFreeWheel: { suffix: '_ecoscorefreewhl' },
    ecoScoreBonusRange: { suffix: '_ecoscorebonusrange' },
    ecoScoreConstant: { suffix: '_ecoscoreconst' },
    ecoScoreAcceleraion: { suffix: '_ecoscoreaccel' },
    starterBatteryState: { suffix: '_starterbatterystate' },
    ignitionState: { suffix: '_ignitionstate' },
    tirePressureRearLeft: { suffix: '_tirepressurerearleft' },
    tirePressureRearRight: { suffix: '_tirepressurerearright' },
    tirePressureFrontLeft: { suffix: '_tirepressurefrontleft' },
    tirePressureFrontRight: { suffix: '_tirepressurefrontright' },
    maxSoc: { prefix: 'sensor.', suffix: '_max_state_of_charge' },
    soc: { prefix: 'sensor.', suffix: 'soc' },
    chargingPower: { suffix: '_chargingpowerkw' },
};
const combinedFilters = Object.assign(Object.assign({}, binarySensorsFilters), sensorDeviceFilters);

var version = "1.0.3";
var description = "Lovelace custom card for displaying vehicle information from Mercedes Component integration";
var repository = {
	type: "git",
	url: "https://github.com/ngocjohn/vehicle-info-card"
};

const CARD_VERSION = version;
const cardTypes = [
    {
        type: 'tripCards',
        name: 'Trip data',
        icon: 'mdi:map-marker-path',
        config: 'trip_card',
    },
    {
        type: 'vehicleCards',
        name: 'Vehicle status',
        icon: 'mdi:car-info',
        config: 'vehicle_card',
    },
    {
        type: 'ecoCards',
        name: 'Eco display',
        icon: 'mdi:leaf',
        config: 'eco_card',
    },
    {
        type: 'tyreCards',
        name: 'Tyre pressure',
        icon: 'mdi:tire',
        config: 'tyre_card',
    },
];
const lockAttrMapping = {
    decklidstatus: { name: 'Deck lid', state: { false: 'closed', true: 'open' } },
    doorstatusfrontleft: { name: 'Door front left', state: { false: 'closed', true: 'open' } },
    doorstatusfrontright: { name: 'Door front right', state: { false: 'closed', true: 'open' } },
    doorstatusrearleft: { name: 'Door rear left', state: { false: 'closed', true: 'open' } },
    doorstatusrearright: { name: 'Door rear right', state: { false: 'closed', true: 'open' } },
    doorlockstatusfrontleft: { name: 'Door lock front left', state: { false: 'locked', true: 'unlocked' } },
    doorlockstatusfrontright: { name: 'Door lock front right', state: { false: 'locked', true: 'unlocked' } },
    doorlockstatusrearleft: { name: 'Door lock rear left', state: { false: 'locked', true: 'unlocked' } },
    doorlockstatusrearright: { name: 'Door lock rear right', state: { false: 'locked', true: 'unlocked' } },
    doorlockstatusgas: { name: 'Gas lock', state: { false: 'locked', true: 'unlocked' } },
    enginehoodstatus: { name: 'Engine hood', state: { false: 'closed', true: 'open' } },
    doorstatusoverall: {
        name: 'Door status overall',
        state: {
            '0': 'open',
            '1': 'closed',
            '2': 'not existing',
            '3': 'unknown',
        },
    },
    sunroofstatus: {
        name: 'Sunroof status',
        state: {
            '0': 'closed',
            '1': 'open',
            '2': 'lifting open',
            '3': 'running',
            '4': 'anti-booming position',
            '5': 'sliding intermediate',
            '6': 'lifting intermediate',
            '7': 'opening',
            '8': 'closing',
            '9': 'anti-booming lifting',
            '10': 'intermediate position',
            '11': 'opening lifting',
            '12': 'closing lifting',
        },
    },
};
const lockStateMapping = {
    '0': 'Unlocked',
    '1': 'Locked int',
    '2': 'Locked',
    '3': 'Partly unlocked',
    '4': 'Unknown',
};
const selectedProgramMapping = {
    '0': 'Standard',
    '1': 'Unknown',
    '2': 'Home',
    '3': 'Work',
};
const windowsStateMapping = {
    windowstatusrearleft: { name: 'Window rear left', state: { 2: 'closed', 0: 'open' } },
    windowstatusrearright: { name: 'Window rear right', state: { 2: 'closed', 0: 'open' } },
    windowstatusfrontleft: { name: 'Window front left', state: { 2: 'closed', 0: 'open' } },
    windowstatusfrontright: { name: 'Window front right', state: { 2: 'closed', 0: 'open' } },
    windowstatusrearleftblind: { name: 'Window rear left blind', state: { 2: 'closed', 0: 'open' } },
    windowstatusrearrightblind: { name: 'Window rear right blind', state: { 2: 'closed', 0: 'open' } },
    windowstatusfrontleftblind: { name: 'Window front left blind', state: { 2: 'closed', 0: 'open' } },
    windowstatusfrontrightblind: { name: 'Window front right blind', state: { 2: 'closed', 0: 'open' } },
};

var common$1 = {
	version: "Version",
	invalid_configuration: "Invalid configuration",
	show_warning: "Show Warning",
	show_error: "Show Error"
};
var en = {
	common: common$1
};

var en$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    common: common$1,
    'default': en
});

var common = {
	version: "Versjon",
	invalid_configuration: "Ikke gyldig konfiguration",
	show_warning: "Vis advarsel"
};
var nb = {
	common: common
};

var nb$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    common: common,
    'default': nb
});

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const languages = {
    en: en$1,
    nb: nb$1,
};
function localize(string, search = '', replace = '') {
    const lang = (localStorage.getItem('selectedLanguage') || 'en').replace(/['"]+/g, '').replace('-', '_');
    let translated;
    try {
        translated = string.split('.').reduce((o, i) => o[i], languages[lang]);
    }
    catch (e) {
        translated = string.split('.').reduce((o, i) => o[i], languages['en']);
    }
    if (translated === undefined)
        translated = string.split('.').reduce((o, i) => o[i], languages['en']);
    if (search !== '' && replace !== '') {
        translated = translated.replace(search, replace);
    }
    return translated;
}

// Format timestamp to human readable format (dd.mm.yyyy - hh:mm)
function formatTimestamp(timestamp) {
    const date = new Date(timestamp);
    const day = date.toLocaleString('en-GB', { day: '2-digit' });
    const month = date.toLocaleString('en-GB', { month: '2-digit' });
    const year = date.toLocaleString('en-GB', { year: 'numeric' });
    const hours = date.toLocaleString('en-GB', { hour: '2-digit', hour12: false });
    const minutes = date.getMinutes().toString().padStart(2, '0');
    return `${day}. ${month}. ${year} - ${hours}:${minutes}`;
}

/**
 *
 * @param car
 * @returns
 */
async function getVehicleEntities(hass, config) {
    const allEntities = await hass.callWS({
        type: 'config/entity_registry/list',
    });
    const carEntity = allEntities.find((e) => e.entity_id === config.entity);
    if (!carEntity) {
        return {};
    }
    const deviceEntities = allEntities.filter((e) => e.device_id === carEntity.device_id);
    const entityIds = {};
    for (const entityName of Object.keys(combinedFilters)) {
        const { prefix, suffix } = combinedFilters[entityName];
        if (!prefix) {
            const entity = deviceEntities.find((e) => e.unique_id.endsWith(suffix));
            if (entity) {
                entityIds[entityName] = {
                    entity_id: entity.entity_id,
                    original_name: entity.original_name,
                    device_id: entity.device_id,
                };
            }
        }
        else {
            if (entityName === 'soc') {
                const socName = 'State of Charge';
                const entity = deviceEntities.find((e) => e.original_name === socName);
                if (entity) {
                    entityIds[entityName] = {
                        entity_id: entity.entity_id,
                        original_name: entity.original_name,
                        unique_id: entity.unique_id,
                        device_id: entity.device_id,
                    };
                }
            }
            else if (entityName === 'maxSoc') {
                const maxSocName = 'Max State of Charge';
                const entity = deviceEntities.find((e) => e.original_name === maxSocName);
                if (entity) {
                    entityIds[entityName] = {
                        entity_id: entity.entity_id,
                        original_name: entity.original_name,
                        unique_id: entity.unique_id,
                        device_id: entity.device_id,
                    };
                }
            }
            const entity = deviceEntities.find((e) => e.entity_id.startsWith(prefix) && e.entity_id.endsWith(suffix));
            if (entity) {
                entityIds[entityName] = {
                    entity_id: entity.entity_id,
                    original_name: entity.original_name,
                    unique_id: entity.unique_id,
                    device_id: entity.device_id,
                };
            }
        }
    }
    return entityIds;
}
/**
 * Additional card listeners
 * @param cardElement
 * @param toggleCard
 */
function setupCardListeners(cardElement, toggleCard) {
    if (!cardElement)
        return;
    // Variables to store touch/mouse coordinates
    let xDown = null;
    let yDown = null;
    let xDiff = null;
    let yDiff = null;
    let isSwiping = false;
    const presDown = (e) => {
        e.stopImmediatePropagation();
        if (e instanceof TouchEvent) {
            xDown = e.touches[0].clientX;
            yDown = e.touches[0].clientY;
        }
        else if (e instanceof MouseEvent) {
            xDown = e.clientX;
            yDown = e.clientY;
        }
        ['touchmove', 'mousemove'].forEach((event) => {
            cardElement.addEventListener(event, pressMove);
        });
        ['touchend', 'mouseup'].forEach((event) => {
            cardElement.addEventListener(event, pressRelease);
        });
    };
    const pressMove = (e) => {
        if (xDown === null || yDown === null)
            return;
        if (e instanceof TouchEvent) {
            xDiff = xDown - e.touches[0].clientX;
            yDiff = yDown - e.touches[0].clientY;
        }
        else if (e instanceof MouseEvent) {
            xDiff = xDown - e.clientX;
            yDiff = yDown - e.clientY;
        }
        if (xDiff !== null && yDiff !== null) {
            if (Math.abs(xDiff) > 1 && Math.abs(yDiff) > 1) {
                isSwiping = true;
            }
        }
    };
    const pressRelease = (e) => {
        e.stopImmediatePropagation();
        ['touchmove', 'mousemove'].forEach((event) => {
            cardElement.removeEventListener(event, pressMove);
        });
        ['touchend', 'mouseup'].forEach((event) => {
            cardElement.removeEventListener(event, pressRelease);
        });
        const cardWidth = cardElement.clientWidth;
        if (isSwiping && xDiff !== null && yDiff !== null) {
            if (Math.abs(xDiff) > Math.abs(yDiff) && Math.abs(xDiff) > cardWidth / 3) {
                if (xDiff > 0) {
                    // Next card - swipe left
                    cardElement.classList.add('swiping-left');
                    setTimeout(() => {
                        toggleCard('next');
                        cardElement.classList.remove('swiping-left');
                    }, 300);
                }
                else {
                    // Previous card - swipe right
                    cardElement.classList.add('swiping-right');
                    setTimeout(() => {
                        toggleCard('prev');
                        cardElement.classList.remove('swiping-right');
                    }, 300);
                }
            }
            xDiff = yDiff = xDown = yDown = null;
            isSwiping = false;
        }
    };
    // Attach the initial pressDown listeners
    ['touchstart', 'mousedown'].forEach((event) => {
        cardElement.addEventListener(event, presDown);
    });
}
/**
 * Console log info
 */
function logCardInfo() {
    /* eslint no-console: 0 */
    const line1 = '   VEHICLE-INFO-CARD';
    const line2 = `   v${version}`;
    const length = Math.max(line1.length, line2.length) + 3;
    const pad = (text, length) => text + ' '.repeat(length - text.length);
    const repo = repository.url;
    const sponsor = 'https://github.com/sponsors/ngocjohn';
    /* eslint no-console: 0 */
    console.groupCollapsed(`%c${pad(line1, length)}\n%c${pad(line2, length)}`, 'color: orange; font-weight: bold; background: black', 'color: white; font-weight: bold; background: dimgray');
    console.info(description);
    console.info(`Github: ${repo}`);
    console.info(`If you like the card, consider supporting the developer: ${sponsor}`);
    console.groupEnd();
}

const fireEvent = (node, type, detail = {}, options = {}) => {
    const event = new CustomEvent(type, {
        bubbles: options.bubbles !== undefined ? options.bubbles : true,
        cancelable: !!options.cancelable,
        composed: options.composed !== undefined ? options.composed : true,
        detail: detail,
    });
    node.dispatchEvent(event);
    return event;
};
function tapFeedback(feedbackElement) {
    if (!feedbackElement)
        return;
    forwardHaptic('success');
}
const forwardHaptic = (hapticType) => {
    fireEvent(window, 'haptic', { hapticType });
    console.log('forwardHaptic', hapticType);
};

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$2 = i$2`:host {
  font-family: poppins, sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu,
    Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
}
*:focus {
  outline: none;
}

ha-card {
  position: relative;
  overflow: hidden;
  display: block;
  width: 100%;
  height: auto;
  padding: 1rem;
  background-color: #eeeeee;
}
ha-card.dark {
  background-color: #0c0c0c;
}

header h1 {
  color: --primary-text-color;
  color: var(--ha-card-header-color, --primary-text-color);
  font-family: serif !important;
  font-size: 24px;
  font-size: var(--ha-card-header-font-size, 24px);
  letter-spacing: -0.012em;
  line-height: 48px;
  display: block;
  margin-top: 0px;
  margin-bottom: 0px;
  font-weight: 400;
  text-align: center;
}

.header-background {
  display: flex;
  justify-content: center;
  align-items: center;
  position: absolute;
  width: 100%;
  height: 100%;
  max-height: 250px;
  top: 0px;
  left: 50%;
  opacity: 0.1;
  z-index: 0;
  -webkit-mask-image: linear-gradient(transparent 0%, black 40%, black 70%, transparent 100%);
          mask-image: linear-gradient(transparent 0%, black 40%, black 70%, transparent 100%);
  transform: translate(-50%);
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
}

#map-box {
  position: relative;
  width: 100%;
  height: 170px;
  margin: 0;
  padding: 0;
  overflow: hidden;
}

.header-info-box {
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
  width: 100%;
  height: -moz-fit-content;
  height: fit-content;
  overflow: hidden;
  gap: 0.5rem;
  flex-wrap: wrap;
  transition: all 0.5s ease;
}
.info-box {
  --mdc-icon-size: 17px;
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
  width: 100%;
  height: -moz-fit-content;
  height: fit-content;
  gap: 1rem;
  opacity: 0.8;
  /* text-transform: capitalize; */
}

.info-box .item {
  display: flex;
  align-items: center;
  gap: 0.4rem;
}

.info-box .item span {
    font-size: 1rem;
  }

.info-box .item ha-icon {
    margin-bottom: 3px;
  }

.item.chargeinfo {
  cursor: pointer;
}

.info-box.charge {
  overflow: hidden;
  justify-content: space-evenly;
  max-height: 0;
  opacity: 0;
  transition: all 0.5s ease-in-out;
}

.info-box.charge.active {
  max-height: 100px; /* Adjust this to be more than the expected height of the content */
  opacity: 1;
  padding-top: 0.5rem;
  padding-bottom: 0.5rem;
}

.info-box.charge .item {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  flex-direction: column;
  gap: initial;
  width: -moz-max-content;
  width: max-content;
}

.info-box.charge .item-name {
  color: var(--secondary-text-color);
}

.fuel-wrapper {
  display: inline-block;
  width: 40%;
  height: 5px;
  background-color: #909090;
  border-radius: 5px;
  position: relative;
}

.fuel-wrapper .fuel-level-bar {
    position: absolute;
    background-color: #4caf50;
    border-radius: 5px;
    transition: width 0.5s ease;
    height: 5px;
  }

.charging-icon {
  position: absolute;
  display: flex;
  align-content: center;
  top: -7px;
  left: 29%;
}

.grid-container {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
  grid-gap: 0.5rem;
  gap: 0.5rem;
  margin-top: 1rem;
  position: relative;
}
.grid-item {
  display: flex;
  gap: 1rem;
  align-items: center;
  padding: 0.5rem 1rem;
  background: #fff;
  background: var(--ha-card-background, var(--card-background-color, #fff));
  box-shadow: none;
  box-shadow: var(--ha-card-box-shadow, none);
  box-sizing: border-box;
  border-radius: 12px;
  border-radius: var(--ha-card-border-radius, 12px);
  border-width: 1px;
  border-width: var(--ha-card-border-width, 1px);
  border-style: solid;
  border-color: #e0e0e0;
  border-color: var(--ha-card-border-color, var(--divider-color, #e0e0e0));
  transition: all 0.3s ease-out;
  opacity: 1;
  cursor: pointer;
}
.grid-item:hover {
    box-shadow: 0 0 10px 0 rgba(0, 0, 0, 0.1);
  }

@media screen and (max-width: 768px) {
  .grid-item {
    padding: 8px;
  }
}
.grid-item .item-icon {
  display: inline-block;
  border-radius: 50% 50%;
  background-color: var(--chip-background-color);
  padding: 0.5rem;
}
.grid-item .item-content {
  display: flex;
  flex-direction: column;
}
.grid-item .item-content .primary {
    font-size: 13px;
    font-weight: 500;
  }
.grid-item .item-content .secondary {
    color: var(--secondary-text-color);
    /* text-transform: capitalize; */
    letter-spacing: 0.5px;
    font-size: smaller;
  }

.added-card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
}
.added-card-header .headder-btn {
  cursor: pointer;
  color: var(--secondary-text-color);
  opacity: 0.5;
  transition: opacity 0.3s;
}
.added-card-header .headder-btn:hover {
    opacity: 1;
  }

.added-card-header .card-toggle {
  display: flex;
  gap: 1rem;
}

.added-card {
  position: relative;
  width: 100%;
  height: auto;
  margin-top: 1rem;
  padding: 0;
  overflow: hidden;
}

.added-card:first-child {
  margin-top: 0;
}

.last-update {
  display: inline-flex;
  width: 100%;
  justify-content: center;
  color: var(--secondary-text-color);
  margin-top: 0.5rem;
  opacity: 0.5;
}
#cards-wrapper {
  animation: fadeIn 0.5s ease-in-out;
  position: relative;
}
#main-wrapper {
  animation: fadeIn 0.3s ease;
  position: relative;
}

.card-element {
  transition: all 0.5s ease;
  position: relative;
}

/* .card-element.swiping-left {
  transform: translateX(-120%);
} */

/* .card-element.swiping-right {
  transform: translateX(120%);
}  */

.slide-left-enter {
  transform: translateX(100%);
}

.slide-left-enter-active {
  transform: translateX(0);
}

.slide-left-exit {
  transform: translateX(0);
}

.slide-left-exit-active {
  transform: translateX(-100%);
}

.slide-right-enter {
  transform: translateX(-100%);
}

.slide-right-enter-active {
  transform: translateX(0);
}

.slide-right-exit {
  transform: translateX(0);
}

.slide-right-exit-active {
  transform: translateX(100%);
}
@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.default-card {
  align-items: center;
  padding: 0.5rem 1rem;
  background: #fff;
  background: var(--ha-card-background, var(--card-background-color, #fff));
  box-shadow: none;
  box-shadow: var(--ha-card-box-shadow, none);
  box-sizing: border-box;
  border-radius: 12px;
  border-radius: var(--ha-card-border-radius, 12px);
  border-width: 1px;
  border-width: var(--ha-card-border-width, 1px);
  border-style: solid;
  border-color: #e0e0e0;
  border-color: var(--ha-card-border-color, var(--divider-color, #e0e0e0));
  transition: all 0.3s ease-out;
  margin-bottom: 1rem;
  position: relative;
}

.default-card:last-child {
  margin-bottom: 0;
}

.default-card .data-header {
  color: --primary-text-color;
  color: var(--ha-card-header-color, --primary-text-color);
  font-family: inherit;
  font-family: var(--ha-card-header-font-family, inherit);
  font-size: 24px;
  font-size: var(--ha-card-header-font-size, 24px);
  letter-spacing: -0.012em;
  line-height: 48px;
  display: block;
  margin-top: 0px;
  margin-bottom: 0px;
  font-weight: 400;
}
.data-row {
  display: flex;
  justify-content: space-between;
  padding: 8px 0;
  border-bottom: 1px solid #444;
}

.data-row .data-value-unit {
  cursor: pointer;
}

.data-row span {
  height: 100%;
  display: flex;
  align-items: flex-end;
}

.data-row:last-child {
  border-bottom: none;
}
.data-row div {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}
.data-icon {
  color: var(--secondary-text-color);
}

.data-icon.warning {
  color: --error-color;
  color: var(--warning-color, --error-color);
}

.sub-attributes {
  overflow: hidden;
  padding-top: 0 !important;
  padding: inherit;
  max-height: 0;
  opacity: 0;
  transition: max-height 0.5s ease, opacity 0.5s ease;
}

.sub-attributes.active {
  max-height: 400px; /* Adjust this to be more than the expected height of the content */
  opacity: 1;
  padding: inherit;
}

.error {
  color: var(--error-color);
}

dialog {
  width: 100%;
  overflow: hidden;
  max-width: 500px;
  background: none;
  border: none;
  border-radius: 12px;
}

dialog::backdrop {
  background: rgba(0, 0, 0, 0.5);
  -webkit-backdrop-filter: blur(5px);
          backdrop-filter: blur(5px);
}

@keyframes slideUpDown {
  0% {
    transform: translateY(-100%);
  }
  100% {
    transform: translateY(0);
  }
}

@keyframes tap-feedback {
  0% {
    transform: translateX(-100%);
    opacity: 0;
  }
  64% {
    transform: translateX(0);
    opacity: 0.1;
  }
  100% {
    transform: translateX(100%);
    opacity: 0;
  }
}

.click-shrink {
  transition: transform 0.1s;
}

.click-shrink:active {
  transform: scale(0.9);
}
`;
styleInject(css_248z$2);

const amgBlack = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAH0CAYAAADL1t+KAAAACXBIWXMAAAsTAAALEwEAmpwYAAAE9GlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNy4yLWMwMDAgNzkuMWI2NWE3OWI0LCAyMDIyLzA2LzEzLTIyOjAxOjAxICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjMuNSAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjQtMDUtMzFUMjM6NDk6NDErMDI6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDI0LTA2LTExVDE5OjI4OjMwKzAyOjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDI0LTA2LTExVDE5OjI4OjMwKzAyOjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxYTYxOTdhOS0zNTg0LTQ2NTEtOTgyMC05NzYzODY5ZWVhMGIiIHhtcE1NOkRvY3VtZW50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';
const amgWhite = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAH0CAYAAADL1t+KAAAACXBIWXMAAAsTAAALEwEAmpwYAAAE9GlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNy4yLWMwMDAgNzkuMWI2NWE3OWI0LCAyMDIyLzA2LzEzLTIyOjAxOjAxICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjMuNSAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjQtMDUtMzFUMjM6NDk6NDErMDI6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDI0LTA2LTExVDE5OjE5OjE4KzAyOjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDI0LTA2LTExVDE5OjE5OjE4KzAyOjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxY2Y2Yjg4OS1lMGQwLTRjYzQtODMwYi1jNGFiN2ZjNmU3ODIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MWNmNmI4ODktZTBkMC00Y2M0LTgzMGItYzRhYjdmYzZlNzgyIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6MWNmNmI4ODktZTBkMC00Y2M0LTgzMGItYzRhYjdmYzZlNzgyIj4gPHhtcE1NOkhpc3Rvcnk+IDxyZGY6U2VxPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY3JlYXRlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDoxY2Y2Yjg4OS1lMGQwLTRjYzQtODMwYi1jNGFiN2ZjNmU3ODIiIHN0RXZ0OndoZW49IjIwMjQtMDUtMzFUMjM6NDk6NDErMDI6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyMy41IChNYWNpbnRvc2gpIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PpGocCQABGdsSURBVHic7F1neBtV2j0zo95lS7LcHZc4xUns9Di9EiekAClAAgQIbalLWBaWDqGXpcNSE9KAkN577z12intvkmXJ6tJIM98PexTZlp2E8u2yq/M8xkGWRnfuzNxz33Ze4vLlywgjNFiWBY/HQ5cuXfD666/j/fffR9euXaFUKhEREYHo6GgkJCSgZ8+ekMvlWLBgATQaDSZPnoykpCS8/PLLSE5OxoIFC7Bp0yacPn0aM2fOxBdffIHbbrsNRUVFKCgowH333YctW7agT58+OHr0KIYNG4bjx49j/PjxqKioQGFhIeLj4xEbG4vq6mpIJBI0NjbC6XJBExkJt9sNlmURHR2N+Ph4fP/994iMjERWVhaSk5OxePFiDBo0CHK5HNu2bUNERARGjx6NI0eO4PTp05g6dSq0Wi2KiorgcrlgtVphNptB0zRsNhtSU1Mxf/58HDhwACtWrIBOpwNFUVCpVFAoFJBIJJDL5cjKysK2bdtQWVmJzMxM2O12HDhwAFlZWRgwYABOnjwJqVQKkiRx9OhR3Hbbbbh8+TIiIiIgl8thMBjg8/lQWVmJhoYGPPTQQ2hoaEBxcTEUCgU0Gg2qqqqgVCqhUChAURTWr18PtVoNjUaDuLg4yOVyrF+/HnFxcRgwYACqq6vhcDjgcrng9XrhdrshkUhAkiRIkgQIAiKRCHw+DyKRCCnJKfj888/x9NNP45///Cf69OmDHj164KuvvsLTTz+NL7/8EoMHD8b48ePx0EMPYebMmZg4cSLuu+8+3Hzzzbj55pvx8ssvo6ioCB988AEuXLiAd999Fw8++CDmzZuHZUuXYce2bbDabFiyYhl16cJF6f79+xWHDh0SWq3W+sWLF7u9Xq/62LFjkfn5+ZqyklJFaWlpSYOpoeCDDz/kjxozSnrk4GFZdXW1tL6+XlxfXy9uaGgQNzY2wmQyNflpX63P5zM7HA632+32MwwDsVgMAHC5XCBJEiKRiJJKpUKKx1NRPCo6MjJSHRERQWg0GldUVJRTr9e74uLiHFlZWfaikmLne++8682/fDklo2dGalJyF3t6erpx0KBBjQKBoHHevHkiuVwelZ2d7RkxYoS1R0ZPx9zbbvcrZApMuGEC5twxF98vWoQvv/gCf/vb35CRkYEnn3wSKSkpePmVV7Bm9WqsWvkLvvruG2zZvBmrV63GF198ge3bt+PI0SN48KGH8O7b7+C+++7D5cuXcfbsWTzxxBN499138dBDD6GkpAQulws+nw8ulwsEQcDv94NhGDidTohFYvAFfIjEYkglEsTFxeHEiROoqqrClClTYLVaUVNTg4aGBjQ2NmLq1KlgGAZNTU1oampCfHw8Ghoa0NTUhJSUFERGRuLLL7+ERqNBQkICKIqCTqeD1WpFY2MjunXrhp9++gmDBg2C3++Hw+FA//79sXHjRowdOxYKhQJnz55FaWkp4uPjccMNN+D06dOwWq1wOp2w2WywWCzw+XwwGo249dZbkZ6eDoVCgdWrV+P8+fOIiIiAWq2GUqmEUChESkoKTCYTNmzYgMzMTKSkpCArKwt79uyBTCYLPG933nknSktLcebMGRgMBsyfPx+VlZWoqakB0fIcNDQ0QCwWIzIyEk6nM7DmVFZWIjU1FQkJCdi5cycGDBiAw4cPY/DgwThz5gxycnLw9ddfIz09HTKZDHq9HkOGDMGCBQswevRo5OTk4Nlnn0VOTg5uvvlm/PTTT1izZg1mzZqFe+65Bzt27EBZWRkqKipQX1+P06dP49HHHsVTC55CQUEBWJYFAAgEAvB4vMD/h9EavH/3AMII478BLMtCIBCAoqjgxUYAIJIkSZHD4aimaVpKkmScWCKJu3j58uVDBw9Vp6d3Vfh8vjgej6csLi52btq0yfnEE084jh8/zlqtVmd9XZ2Qx+OZHU4nu2vHTs/I0SM9NE03AgCPx4NYLIZMJgPDMODz+aitqYGjyQGCIAKLn0gkAgBQFAW/3w+CIPwOh8OpUquder2+RiqVQiaTQSwWg8drXhJomoZIJMJ3X3+Dw4cPE6nJKaa6ujo2QhPpJQjC2aNHD9dHH33EFBcXy/v375/q8/msWp2u6vChQ+7qmpq4qMyo7iRJ1tA0XeVwOGwkScYC8AJoAOBlWRYURUEgEIQX5zDC+J0QJvQwwviV8Pl8UKlUEIlEKgARDoejlqZpFUEQGQRBlIjF4joA0TKZTPXLql8M06dPdykVinqn0+lqMDWYd+7Y4e3Zs0eVUCiskkql4PF4OHH8BFatWuWkadqZnZ2N7t2745233oZYIET+5cv425NPQa/XQ6fTITo6Gt27d4dcLodMJkP/AQPw0IMPYs2aNa3GabXbQo5//ITx+PJf/8KpkydhdzhgtVphsVhgNptx/PhxrF+/HpXlFRDyBWx5eXnj03//e6NKrYLb7caaNWtw4sQJ8Hi8WplMVisSicDj8bBr5y6YTCaLw+EoksvlNoPB4Fr1yy98mUyWDMAqFoutBEHEEQSRQtP0BYfD0QggWiQSmVUqlcXn8/3BVy2MMP57ESb0MMK4dkgA6AAYAOhVKlXy/v37T6Wmpir1en3ymjVrLNnZ2Ta/319sMpnMdrvdAQKnNRoN8nJz8cvKlUhKSnJnD802HDpyGMeOHcNX//oKo0aNwsiRI7F3717s3LUTJaUl8gkTJmDSpEmIiY/FD4t/AMGyPdRq9XAejyeTSqVQKBRQq9VQq9VQKVVQKBXgURRmz56NhMRESioWkxSPRxEEQVEkRYIA/H4/wzIM4/P7/S63yzd48GCGoihERUVBbLOBx+MFXNZOpxM8Hg/qiAi7TqfbRxDE5ZtvuRk1NTXYvHkzfvjhBxQWFtoA4IknnoDZbMZ3336Lo0ePgiCIpuEjhjcxLINVq1bBZDKhZ8+euwmCgMPhgMlk4icmJhZXV1XZVq38RRQbG5dcXVVVcuDAAVapVA4AUAagGkAUACMAx7/peocRxp8KYUIPIwxccZkTBAGhUAiVSiX2+Xw6AAaWZXuRJOkSCoW1Ho8nOTIy0hEZGWlmWbZk27ZtrpEjR5q1Wm3ZmdNnsH//fkyZMsVus9lw//334+FHH8ETT/4Vt86ajY8+/lj4yCOPCMaNG4cuSV0ooUg4QygQxInFYiTEx+P1118XyiTSadGxMXFarRYajQZKtQrHThyDSCyWC/nN4yNIsvk3QYAAQBAEQBCgvV7Mnj0bs2fPvubzdrlc6J2ZCbAsWLBg2ea5YFkWLMOAZVl4aRoul8vm9/sgEAoxa9YsjBkzBtXV1VVOp3N9QkKC2+12QygUQi6XV3Xp0uWXYcOH+3fu3ImPPvrIC8Dz1FNPoaSkBA888ADS09PN06ZNMx84cAANDQ3I6tt3V3FxMXbs2Cnq0b17SWRkpCUiIkLidruThUKhkyTJJJZlZQDO+3w+nUqlMgqFQicXVnA6nX/MTRFGGH8yhAk9jDAAkCQZ63A4HBSPSqioqOAfPHiwVCKRJKnUaotQKKw2m820y+Vq0Gg0uzds2ACfz4chQ4aYL+ZdwOEjRzBmzCj88ssv+OGHH+Sr16zChAkTqI8//niOQCDQxsfH480335SrFMrb0tLTZfEJ8Th0+BApk8mkFEUBAARCIfr17/+bzoHXkvzWFlyEmgjxN3EHnwmGBIBKqZQDQFxsXPCfugPozrAsunfvjqnTpoHx+2F3OD60Wq2MRCpFt27dnE1NTcvj4+OtVVVVoGnaNHHixGW9evWiX3rxJdgcdtvYCeOwe9cuUCDcQ7OzS7Zt24ZNmzZBp9PtdrmcaGxsZAUCgUWlUgkkEknSoUOH7BUVFd0pivI5HI4ykiRlfr+/+nrmKoww/hsRJvQw/lcRB8DGMEx3oVBYFqmNjP3XZ18YdFpdXXFxMbV169bGHt2779u5fQfmzJ3TpFAo8PLLL2PevHn4xz/+gYsXL0oWLlxIpaSkRBEsOzcmJg7vvPNOtE6nu02pUOGhhx4i//rXv0pJioJIJEL24CHXNCgGLAgQYPH7J4r9XkcMHh8BAmRLhjQHqVQqjdLpkJaaijGjR8sB/NXPMujTpw/uv+9+uD3ut6qrq/3vvvcujEbjj3ExsTUESyA1NXV5ZlZW7QsvvMDU19c73nnrLbz+ykJEREQYaZrGrl270L17933bt29HaWmpoL6+nvn5559VDz74oN5kMvkdDkcXiqIuApCj2WUfzrYL438KYUIP478SIbLOYwC4WZZNFwqFRS6XK06tVhe73O6q8vJyW2xc7HGz2Yxz585h/vz5OHnyJCIiInD4yGEkdUmSDxw4ENu2bZup0+kS3nzzTXVUVNTcvn378mcdniXj8/mEWCIGRVIdjwdoR9JEkM3MthA5Qrzv3w0i6L8tjvkAqTePNfQGhHsPAQIUQQa8AVKZVBIZGYnevXsDwH1+hsGYsWNAe+mXKisrbW+++abPYDAs1eqiGr1eb9WYwWN/OnHiBA4fPmwbOXIkzpw5g/nz59deuHABFosFIpGovLy8XKJSqSolEgm/sbExTiwWux0ORxqAfABilmWrw1n1Yfy3I0zoYfxXoG0ZFEmSOofD4fd4PPFisdjicDi0EomkzOl0VpaVlVl69ux59MCBA5g4cSKOHzuGCJUKffv1w48//ihavHgxv76+fpxCqezz3rvvJnRJTp4xYMAAvPPOO3KpVArOTd5uDLg+Mm77XgZMK5IH2pM+91owqQa/r6P/Dz5eZ6+1PTbbcl5EJ8fo6Jy519lOZoUAAYokIZPKACmgVqvlLUT/qM/nw8233Ayr1frByZMn0SsjY7XP5yuLj4s7P3ny5B133nknPWzYMHdRURHKysqckydPdm7duhXZ2dkNeXl5PJlMVikWiymP1xMrFospj8cT4XA4KkmSpFiWNYQoMwwjjD81woQexn8FSJIETdMxDodDzOPxhFFRUeTq1atpjUZTFxUVZVcqlWX79+/HDTfcgC1btqBHjx4QiUQ4efKkfNzYceqi4qJ77r77buGUKVPu6dWrl3j58uVyoUgEPi/0I8IGfv82MmhL4G1f4ciVaPMX7t+dbQBCH//qr4U6NhOwxUOf868NE3RE9gQI8Hg8KBQKKBQKeVxcHADcRft8eOjhv6Cuts721ltvubVa7Xdr1651T5gwYdHZs2dNUqnUxuPx0NjY6Bs4cGDVtq3bMHTYUGOTxSKtr6/3Hj9+PDI7O1tYU1OjcTgcNE3TDpIka6574GGE8R+IMKGH8acCp94nlUohFAplPp9PwrKsJjIy0nPhwgV1fX19lUQisXo8HmNlZSViY2Nx9OhRDBo0CBKJBGWlZfIpU6ZoiouL7/rrX/+qtVgsd0yYMEFMURRPpVK1/z78cS5w8jrJl2FZ0DQNggAYpjkTHS0Z6QDgZ/xg/Az8DAOWZRiWZf0MwzKtvpMkSIIgKIIgSYokQVEUCJIACRItKfMgCAIkSYBlAQGf3/z/IVPqQo+V+R3m64oznwj6F8Dn8cCXySFPk8vT0tLkAP4+fsJ4sAz7/LZt25xqtXrZqlWr6qdNm7a0uLi4XqlS2miaxqlTpxzp6emO3NzcOo/HA4qitBs3bqT0en1cWlqayGAwiHw+X4NKpXI5nU6b2Wz+zecQRhj/3wgTehh/CjAMA5FIhIiICKXX6xUVFhbGNlma3BEREZRIJKozGAwOAMWlpaUYOXIkCgoKYLfbcerUKXLw4MFRZrP53r/+9a+xTqdzzvjx46UASKVS2f57fkfyJkJSdGs4nA5QFA8Mw8Dj8cDtctlsNhsMBgOMDUaYG83e2rranR635/LESTlwWG0oKSlFvaEeRqMRBoMBTU1NXqfTaXa5XAaPy21we9xmH+1z0j6f19+s1BJIdKd4PB6PogR8AV8sFAhVIolYL5FI9GKxWKlUKgVarRZarRZRuigkpyRDLpdjy+YtEAmFaXq9fpw6MkKs1Wqh0+k4dTm5UCQCRZLw+X2QSqRXJf9fN8dsIGEwGCQIqJQqAKBuvfVWOYAHBw8eDAAv7ty50y6TyX768ccfK/r27fvtkSNH6t1ut7+0tBR6vd64b98+REdH19XX14sFAoFMrVZHHThwgImMjBSpVKpqm83mAWD5FYMNI4x/C8KEHsZ/JNoktSnFYrGovLw8tqqqyldXV0dXVlbW0l66NjMrEz6fD6dPnwZBECgrK8OsWbPkNE1PvOOOO3omJSXdMWXKlDipVCr4NQQeKl7dFp0RmN3hAEWS8Hg8cDgcNpPJhOLiYuTm5p5P75q+MzYuFtu3b8fZM2ewe8+eLXfdddfFuXPnYs2aNTh79iwuXrzoq6urcwHA0OHDQACw2Zv1vhsbG9HQ0ACz2XxFr97lhtvjgc/ng8/ng9/vbzUeiqJAURT4fD6EAgGEEjEkEgkkEglomg78TSKRgGVZ2G02vLbwNQCAXhcl6t6zBz8zMxMzZs7Ah//8J35YsiR99KhRk/tkZRETbpiAmqpqFOTnj87o3SsrJTkFGo0GUqlULhQJ4fP7IZfKOpyvUN4QNgSJB6Pt9SNAoOU6E7fccoscwPzBgwfD6XI9v3HDhpqysrLF9fX1l+Li4jZXVlbaoqOj4fP5XMnJyS6CIIyrVq3C6NGjo8eOHasyGAxCAMkAqlmW9VAUZQkn1YXxn4wwoYfxHwmSJCUOh0NK03QMSZKsUql05+bm1mzZsqUuMzMTaWlp8Pv9oGkadXV1iIqK0vl8vvvee++9/oMGDRrbNb2rvMVya4XrtQ6DE7uAjsnbZreBAAGrzWYrKyvDkcOHzUlduiyRyWS+n1aswM8rV+6ZM2fO6cmTJ+OTTz7Bnj17bLfffjueeeYZWCwWGIxGOBwO0DQNtVoNrVaLuLg4uN1ueDwe8Pl88Pl8sH4GQqEQYnEzEUulUtA0DZIkwePx4OULILhGQhcIBBCKRZBIJBCLxZBKpYF/C4VCUBQFHkVBp9GC9tJITk52x8XFubVaLdRqNWiahsPhOGkwGk9aLBYolUp8+fkXWLFixcujRo2SP/bYY/jss8+wfPnyPjNnzBg3+7ZbYbc7eOWlpXcMzs5WJyUlQalQyBmWhUIub5cn0DzvCFyBa71ewe/kCF6pVAruu+++JAAvWZosKCossmkiNXt27NxxgsfjfV1bW1uvVqvRu3dvdO/evba6urqWYRiQJBnN4/HkJElG0TSd6HA46kiStCOsXhfGfyDChB7GvxUhmnREsiyri46O5q9atcobExNTFxkZWV9RUYGkpKRANym5XM5TKpW9LWbz1JkzZ47Nysrqn9QlSSQUCFsd/7e40EORN8MwsDvscLvdzrLSMv+BAwfqdTrdMpqm8fJLL5XlTJq0KrNvFp566inXHXPv8D30l4fQYDIFyJrrCsfj8aDVasGybKDBCgAIhUIwDNPue//TwDDNGwsAgcYuLMtCq9WCR1GIi4uzabVajvQPNphMBxVyBZYtWYaly5a+/Mlnn4m///57bNu0ZfpLr7yUwhcIYDQYbxs+Ynh0UlISJZaIJVKpDBTJXYXWCXrXg2DLn3PR9+/fX96/f/+p8++bP7W0tPT5s2fPnj5x/MT2zMzMTTab7Wx9fT0tl8vh9/trzWYzpFIpLl28GFVTWxcRFRUVRdO0D0Ady7JmgUDAhrPlw/hPQJjQw/i3oiU7XeNwOCJIkpSRJGkXi8VGi8XSaDabGblcDqlUiqqqKqjVaowfN24wy7IT+/XvP693796JWp0OvKAyMm7xbusiv1oWdqh4NwvAbrPB5XK5T506RRcXF+/RarVn3n//fevAAQMX9R/Qn37qqafs06dPZ2fPno3q6mp4vV7o9XpE6/XQ6rQAAKlUCuDPQ9a/F4JJn5sDrU4LfVSULzpabztxzIvq2uolYokEK39aiXUb1r38zTffyBcvXsw/fvz4XQuefFJpbGjonZqaOq5/v/58sUQsksnl7TZanSUutnXZM23uCYFAgPT0dGF6evqQW2bMGGJqaHjpzJmzVWdOn/rW7nBsz8/PP+p0OhmxWAy3x1NvajDWy5UKQq1Sa/h8fiTDMImO5nR5M0mSxt95CsMI47oQJvQw/l2QsCyrVSgUssuXL6O0tNQ6d+7cmjNnzthNJhMaGhqg0Wjg9XoBoH+39PQbs/r2vX3AgAFpWq22uZd5C0JZbKFisRyIdjZfM2gfDYfdgYsXL9qKi4oLY2JjNrz22mvujIyM70UikfPTTz+1vf/++7BYLHC5XYiKikJ0dDR0Oh1Ikgz0p/5fIu1fC47slXIlSJKELkoHvS4KUVFRNrfbDYvF8s8GkwkLFizAww8/LN+wYYPowoUL81544QVpbU3t5JTUlPQePXrIZXIZ+Dx+G9IGgl30bWvsg18Pvkt4LY1qJk68IW7CDRNeajAaXzp54kTxmTNnlrrc7q0Ajmo0GhiMRpYkSCOPxzP27t1bumzZsoguXbrounXrpmFZ1gOgHmGXfBj/BoQJPYz/b+hYllVTFCUSiUR+mqbrnU6n0Wg0wu12w2azITc3F/369YtOTEiYP378+On9+vfvG6WPAkl0TuJXQ1vLjvbRaGqy4vTJk7bcvLyNZrO5YPfu3buzsrLOHDp0yPbss8/CarXC5XIhLS0NqampEIlEkMlkEIlEfwhx83g8CAQCMAwDr9cLssWVy7Is1BFquOxOOBwOUBQFtVoNs9kc6JJ2vSAJgtswQSQSgc/nQyaTQavVQigUwuvxQKpWw+v1gvbSgfCISCSCVCpttan6vcBVM3BznJqaioSEBFtubq6tqanp3YaGBrz3/nsvDx06VH769Oneo0ePHh8REZGcmZU5feCAgXKJRAKBQIBQLvqrlR8yQZX2JEFAp9Nh0uTJKRMnTXrJaDC8dOrUqXO7du5cIxSJvjl58mT1wIEDAcDR2Njo0Ov18Hq9GqFQqKcoKoVlWS+ARjR35gsjjP8XhAk9jP8PCFiWjSFJksfn80Usy1pcLlehw+FgCgoK0NDQgPj4eOTl5Sm6det278iRI3MmTJgwsmt6uoDqwBK/FpnUtgTuZxhYrVacOH7clpeXt8loNOZv3bp1Q2JCYsHOXTtts2fPhtVqRUREBJKTkyEUCiGVSv8w8mYYJiCewrmkuQ0ERVGQSCTw0TT4PD78Pj92bt+JaL0ePXr2wJ7de7B//36IxWK4XK7m871GgmVauqh5aBoJSYnQREbCbDY3Z8w3NuL06dMYNWoUBg4ehMLL+RCJRBAIBFx4pFXfdOBKt7c/ChzJt2gPIDk5GRERETabzXaorq7u0Ntvv41nnnlGfvLEyeSCgoKbMjIyUjMyMqYOHDRIrlAqwGsjydvZZrCZzq+8h9Oqj4qKwqRJk/rcMHFin6LCwud2bN++z2A0bsvPz/86NTW1yWq1orS0tCE+Pr7B4XAQJEnGUhQVRZKkgmVZhmXZaoFA4AnH2sP4IxEm9DD+SMgB6BiG0YrFYpvP56s1m82NOp0OVVVVOHr0KEwmE8Qi0YRbZsy4MSMj4+4RI0bIqDYxce53cAlZ82vtF8a2JN5ktaKqstJ24viJM3X1dXvWrVu3U6fTndu5c6dt5syZsNvt0EXp0LVrV0ilUkilUhAE8Ycvuj6fDzExMdBoNDh//jzy8vIQGxuLgoICrFixAj179kS3bt2wcf0G+H0+pKWl4eDe/cjsl4U77rwD69etx+nTp5GamhrYbPD5/MBkhRq/3+cHAQJiaXMmu91hh16vR3KXLjh58iTq6upQV1OLRosZaWlpiNRqcPjgIdx97z2oratFTXUNLl28hB3btuPnn37C+PETEB8fj4aGBvho+rq8BM3iNeSvmmeWZUEQROB6JSUlIS4uzmaxWM5VVVWd++mnnzBmzBi58cUXe02bNm1CdHT0qAEDBvRNSEyUKxWKVvdIW3IPlX8RHKOnSBLp6en89PT0cX6/f9zBgwdfvnjx4qJffvllg9Vq3XHmzBnGaDSyUqm0qqampsrv90eIRKJYAL2dTmejQCAwkiRpve6TDiOMa0CY0MP4XdCmbjwSQCwAViAQmEUi0Vmj0eiuqKiAyWRCnz59IBAItFqN5v475t5xV5/MPmmxsbFXjoXQZM22+veV/wteoFmWhdlsxpYtW8x1dXVfG43GCpVK9cPixYtt48aNg81mQ0ZGBtLT0/9fCTwYQqEQMbGx2L1rF/bv348tW7YAALKysqBWq2GxWFpZ6P4WCzVSEwmRSBRwuQOAQCAA7fOB9nrh9XpBEAQoPg9+xh9wkzMMA7CASCKGVCaFQCgA2GZS9Xo8cDqdYFk24HJvtJghFArhdrkhFouhUChgtphbWeiNpkb847nnMGTIEBw8dBBkyxySJAl0Mpcsy8Lv94PH58Nut8PtdoPxMxAIBPB4PACaNybXez0YhgGfz4dcLkd6ejqioqJsJSUlh6urqw8vWrQId955p9xqtc7RarWJcXFx90+eNClCplAg2AN0pUTuyuaxvd7+FcudoiiMHDlSOnLkyIenTZv28Plz50q2bd/+nVgs/rrRbDZcvHgRSqWy0Ww2N8bFxQnWrl2rGzhwYJJMJgPLslUURTWG69rD+D0RJvQwfheQJEk4nc5or9crYBhGwDBMI5/Pr6qqqsKwYcNQUFCAiooK6PX6CYMGDZp77733zhg0aJA42Bq/1rg4AxZUEInTPho11TX+06dPX6iqqlqzZMmS7fX19WeTk5Odw4YNg1QqRUpKyq8mcI6ofk2cOhgSiQSxsbGwWa1gfH7s2LkTAALWptfrDSSLBcfQmRYS7GzMRItkKwBQPAoiSgyCJOFyOiEQCiCTyyESiQGw7WrTOzsmy7LweDyg6dYxdIgAu92O+Ph4jBs3DkajEbTHi/r6evhaPAbB88UwDKRSaaD+/fLFS2BZFhm9MyCRSlBbW8sJwsDj8cDv9wdCHS314Nc8z20t+NTUVMhkMpvT6fxyxYoV0Gq1r1VWVva2Wq0T+/btO6Vvv76942LjeHw+P3BXXe1eDKZ6EgRiYmIQExOTPH7ChIWzZs16/tLFS2uKCgsX19bWbquoqIBWq/UWFRVVDRgwoMrn88VQFBXp9/tVDofD26IlH86kDOM3I0zoYfxWCFiWTdXpdPK1a9eaKyoq6hISEqwkScJgMKCiogIFBQWKgQMGPPjKK6/MHD58eP/o6OjAh4PLzK4GshWJ+1BUWOQ+duzokf379u1nGHYRwzJler0eNpsN8fHxiImJAY/H+1WuXYIgwOfzQVEUaJpuJleSRGRk5HVtCLjNgFAoRIOpAZ9+8inWrFkDL02DT/FA8qirkvX1giM0kVgEkVgEvoAPgiDh9/l+t+/gyNrpdMLlckEsFqOiogLdu3fHsGHDYLVa4ff7A+/j8/nIzc0FwzAYOWoUysvKEBsbC4Zpts4bTA246ZabwefzsWXLFvTq1QuVlZXweDwQiUSBPAGhUHjdc8VdAz6fj+joaCQmJjpZlj1aXl5+tKSk5OU1a9bEkyR576iRI4cPHjIkO61rmojP4wc+33nMnQjqYd8s3DNkyBDRkCFDbps0efJthw4dPFtSXPLTyVMnv2hqampyuVxQqVQ1YrEY586dU9hstujBgwcPbmpqsgAoAuC9rpMLI4wghAk9jF8LEYBElmU1fD7fwefzLxYXF9soisLQoUNx8uRJlJeXJ951110Pzpkz58GxY8eqyBDuzavReDCJ+3w+lJWV0ceOHTu8bevWnfUGw9cOh6Oez+cjOTkZCbEJoCjqV7vRufcrlUqIRCKYTCbYbDYkJSWhuroapaWlOHLkCHg8HjQaDRQKRSADvS04F7Berwefz4dCocDSH5aC65Ui5P+xrlZuXDweD2ABv//3I/NQ3+X3+2GxWNCnTx/06dMHly9fhs/ng8fjgUajgU6nw8GDB0E1i87A6XTC6/XC6XTC7/dDKBRC1NIvnUtMvHTpEiZMmACZTIampqaW7PVmIZvfMnfctZHJZIiIiEBNTU1lSUnJy18VFGD5ihU6nU53/6ScnLGDBg/O7tKli4AX1HHvagl1TMtvAoBeH4Vbbrklk2XZzN27dz8jl8u/rKyq+iY+Pr6ooaEB+fn5VrlcbuXz+XKSJLuwLNsPQAOAKgCuX32CYfzPIkzoYVwVbdTchARBRDMMI/f7/W6Kok77fD7X6dOnYTAYIJfLQVHUhMzMzEcefOihnH59+wbusdD14u1bd7Yl+fLychw/fvzw1q1bt1sslm9sNlu10+lEREQEYmJi0NjYCD6fD4ZhOuxVfrXzIwgCYrEYIpEIeXl5OHfuHAYMGACGYaDX6wPk/s4770AoFCIyMhJJSUmBLHiu1Axotl6FIhEAYP/+/di1cxfMjY1gWAYUSYIif1umM9miDQ8ANpsNLBDS+ubc98FjC4bf74fX64XL5YLdbofNZoPV2pyv5fF4rrssjc/nB8roUlNTUVdXB6lUiltvvbVZRrbFW+JyuUKGL+iWEjqBQACv1wuJRAKVSgWn04mMjAzs3r0bTz/9NLp06YK4uLjANf8t4MhdoVAgIiICDQ0NhtLS0oXfL1q0cOUvv8So1er5OTk5Y7OHDh0RGxvTpnSydRIdEdRcNvjqkgSBsWPHKseOHfv3s2fPPl1SXLLl0KFDH3m93u0WiwWXLl2yURR1niAIEU3TMQzDJBME4WBZtk4gELjDmfFhXCvChB5Gp2AYhtP5Flut1iiCIMROp9MmEokuSqVSv0AgQHl5OSorK5GRkXFTTk7OX6ZOnTpOp9NdOcY1xMZZtLbGLU0W7Ni+o2Ht2rX/iomJWV1UVHTaYrFAp9MhNTUVZWVlv8uCzlmxLMvC7Xajuroa+/fvh1arhVQqDSRrcQTEkeOWLVtw+PDhVuQqkUggFImg1emg1Wrx2aefwe6wN3+Ox4eA154gGYaB3++Hy+WC1WqF3W6Hy+WCz+eD1+tFQ6MJAFBSUiIWi0Q8dWQEGhsbwePxIJaIJTqdboTP7z9PAPmhCNjv98PtcjfnALTZKlEkSUgkkjtVKlUXnVYHHo9Xzqd4p1wedwWPx/NzpWkGgwHV1dUoKytDTVWNzeawAWj2mHDnEAyapsEwDFwuV+Aa/ZoNAhFUJ8+1zD148CCKiooCCXVarTZwHX8rOPe/QqFAUlISGhoaakpKSl5dunTpq7t27cpISkqanZ2dfX/37t11UVFRaD4b4qp17tzfSRDIzMwkMjMzJw3JHjJp08aNu7bv2PGv8+fPr4yNjUV0dLSbYZgSs9lMulyuaIIgkqxWq1ssFhtUKpXz/zt5M4w/H8KEHkanEIvFQrPZHP3555+Ljhw5YpPL5ZV6vd6fkpICm82GsrIyXnx8/P133nHHAzdMnNibc4sC10bkwUrdPr8fBw8ccF6+fHnZgQMH1p48eXJPZWWl67nnnkNycjKKioo6tDZ/DViWhVAohFwuh8lkwrJly0AQRKDpSSh3OifiwuPx0NTUBB6Ph2XLluHgoYNgGAYOux1LF/+A8+fOg/bRAJrJvCMIBALwBQJSJBSq9Hr9eK1W212lUoGiKCgUCvzjH/+ARCxJiYmJzlFHRAgiNRpotRq8+NJLeOvtt/l8Hk+0bdu2dxwOx9/beidkMhnOnTuH3PO5Aa34YNTUVEtvu/XWRVOmToWf8YNlWNA+Gk6Xy+H3+RiapjFm7FjYrFY0WZtgbbLCZrNXmRqMBxwOR61SodwLlt0ravFGBIMiKQiFQpAkCbfbjWC39a+B3+8PXHe/3499+/ZBJpOhqKgo0KzG4/FclfA4b9PVMumDyT05ORlutzvPaDTmffHFF69bLJZRN95445Q+ffrMGz58uIQkOi6Da3XMIGKPjo7G/PvuG3vnXXeN3bFjR/6ePXs+r6mp+TI2NtYbGxvLXL58ubq6uppcu3at/uLFiwm33367m6KoWpIkPdczb2H8byFM6GF0BAGAGJFIJL58+bLVbDaX9+nTh01LS4NIJILb7VZotdqHp06d+tCYMWPiQ8fHr63laG1tDY4dO35i9apVa9Zv2PCvm266qREAuFI2kiR/V2EXblHX6XSw2+3YtGkT7HZ7oPSOs9g7+zxH/JwVefHCRfD5fPy04kfYnQ6QIK4aJ/f6aMTFx0MqlYoefuThgjvuuCOSIAgQLXMp4PMxduzYq57P+XPnnP/66qt2pOnz+cDj8TBn7lwoFYqAJ4EDX8gndVFRLqFQKA5+XaVUSTv5uu4tP9izd6/O4bDvbdsQhwULqVQKo9EIH+0LdG7jwFmaDocDDocjMJ/XCk5Nz+l0YsWKFRCJRGBZFiqVqsPcCc4TIxQKwefz4fP5IJPJwOPxrnq9g8nd6/W6rVbr1o0bN249c+bM8/v27bs/uUuXaaNHjxkSExsTuK87InYiyKInW7TkJ0+enJ6Tk/PR3r17nzl27NhnLpfr0759+zalpaUxeXl5NUePHq0tLi6Ojo2N7SKTyVwAahFOngsjBMKEHkZbUABSAAhomm7y+/2F8fHxvtGjR0OhUKCxsVGp1+ufGDJkyBODBg1ScQtxR/HxYASTuN/vx779+5zbtmz9RqlSrblw4cLekpISKBQKxMbGoqam5poT266V7LljqVQquFwu7N69GwaDATabDWq1+leLnHCtTUmShNPhBAniqiQBABRBoq62DgzrdwkEgnKJRBIZ8jsCv9mQHeDUERFpDQ0N7axwt9sNtVqNmOhoyOVyuN3uVn/n8XisSCTycd9xvUV5NTXVBrvdjraETlIkSJLEyRMn0WhuDPRWb3VOLEsoFIoXNBpNhdvtXlVUVAS9Xm9jWRZNTU3weDyQy+UdfjfnXaFpGm63G6+88kpAX6C6ujrgXeGs8djYWNhszaGCDRs2QKFQoHv37tBoNDCbzYFr2Nl14zYeQqEQarUa0dHR5vLy8rcPHTr0dnFJyTCL2XzztOnT7x8xYoS0rdUeSgwp+JkhSRJjxoyJHjNmzMLjx48/dfz48Y+sVuuH2dnZlh49erDnzp2rsVgs9Xw+X8/n81PRTOilAK6tBjGM/wmECf1/HEGCMDyWZbuSJKmmKMrCMEyBTCbzqtVqyOVy8Pl8pUqlemLs2LGPZ2dnq7nPX92tTiA4cmo0GnHq5Mn8devX/7Bs6dJ/9czIMM2dOxdJSUkwmUwwGo3XRNDcgs2VlMnlcqhbdMe5vwe/l7Oo+Xw+KisrUVtbi0uXLoHr7X21Gm+apq86Ji4JzddSs301q5NH8eD1uOFjGfZyfv5OAH3bHZNlAaJFghQE7A4HbDabzc/4YTFbYLNaUVRU5KcoCpGRrfcDXDlZUlISoqKi4HBc6RdCEASaLE0B0iQAeGkvCguLXAQBn0QihVAgAI/PE4hEYiGPpACyudadIkl4aRqVFZU6q9WKti53sVgMk8mEb775Bh6PB8FhGKC51E2pVCrPnj37SlRUFIxG48f/+Mc/oNFofnA4HA2xsbFFPB5vXWFhIWJiYmxdunQBwzDt5pOzuvl8PmpqalBTU4Py8nIQBAGtVguZTAY+nw+bzYa1a9fi5MmTqK+vR1NTU0CbwO12w2QyQSqVwmAwBHIarnb9uPtFJpMhOTkZCoXi4HfffXfQ1Ni48MyZMw8kJiTePnTY0AydThdktXeMYKt94MCBqoEDB7509OjRx0+fPv2R2+3+sF+/fhaTyeSvq6urdrvd9QBSSJIcxLJsE0VR+QKBwBeOr4cRJvT/cZAkCYfDES2Xy3UikYhlGOacw+Gwc6pbbpdLkpSU9OTYMWMXDBo8SMV97nri4wCQm5uLstKybd9+9+1HVqt1i1KphFKlQkJCAgiCuCYS9/v9EIvFoCgKPp8Pfr8f8fHx6Nu3L7Zs2QKpVIpBgwYFmntQFBUQhGFZFk6nE9XV1Thz5gxEIhF0Ol2HZWcEQcDj8aC4uBj19fWcqWi72jgJggDJo+Dz0lfNuPcxfggEAgzs1xc8Ps906NAhm6mhAQ0NJldBceH6LolJNXfNu+tpUUvKPMOwGD9m7L9yc3P/tnr9WhiMRlw4n4sDBw7YAaCpqanV8a1WK4YOHQq9Xg+/399uPCKxiJXKrnjXGxpMuO/e+bPuuOOOfbfefitefeVVfPnll7KePXoM0ml1vaOjo8no2Bh06dIFGo0GFy9e3BtcTgZcqflWqlSYPHlyoH4/GDabDUKhcE5cfDzLoygiISFBfu+99wLAw3aHHTk5OWhoaLDt27cPEolkWWlpaaHVav3SYrE4Q80j11OeZVnk5+eDz+dj3759aGpqwpo1a1BRUYF9+/aBz+dDLBZDLpdDIBBApVLB7/cjJSUFXq8XJSUlqCivwIiRI8CiebPYdjMSCpzwTVxcHKKjoxsbGhre/O67795MSEiYeO+99z6WkpKS07t373ZJdCGPFUTsgwcPVg0ePPilE8ePP75v//4PDQbD+9HR0Xaz2ezzer35BEHIZDJZCsMwfex2ex1JktVXHWwY/9UIE/r/GNqUoGm1Wm3kypUrnWPGjMmXSqXuEydOwGazQSKRoGvXro+PGzfu76NGjQoowVwPkTMsg3179zk2bNjwr6qqquW9e/c+BQBarTZgLV+rNU4QBFQqFS5fvoxu3bohISEBfr8fkZGR6NGjBz744APU1taihQSgUCig0+kgl8uRkJCAiooKbN++HUKhEARBwO/3B7K028LpdEIgEERGRUU9+tZbbw3p1q3bELlc7lm0aFFXm81mvtoiT1EU/CwDv4/pNCHOz/jB44kxZcoUUDzqw3Xr1n1x/uw5nDt3jq4z1LvT07piYk7OY4kJCSKg2YLWaLSXZXK5jWEYaDQaREZGBhTW2sapZTIZiouLMXPmzHalYm63G1KplD1x6mTgNaFQ6D929Ogpi9lsmzptKjweD9xut+306dNr4+Pi1/p8Pkhk0oBQj9/vD/xw4JLgSk6dRmREBAiyfdiEYRj0ysjQkC0DYoJCCTJpc9hAJpPJk5KSAOBBm82GgoKCZwsLC+8GsDFYsKYtBAIBfD4fjh07Foiti0QiqNUBpxLoFt15bpPjdDq5ckvIpFJkZmaivq4ehrp62B0OJCcntzvPUODOUy6XQ6/XA8DWM2fObF2yZEmfuLi4udOmTXtw9JjRMq707Vrj7AMGDlQNGDjw5QMHDjy8e/fud0pLS99zOBxobGy09+7d+9yZM2fEBw4c0CUnJ6ezLNsoEAiM4VK3/02ECf1/DCRJwuv1Cl0uV5JQKJQDKBcKhUag2R2+e/duzJgxY+rdd9/9Uk5OTt/OYuStk96uuNZZlsXpU6csv6xa9dEnn3zycbdu3RoHDhyIqKioQObztS42fr8fMpkM1dXV8Hq9sNvtsNvtSEhIQH19PTweD+x2O1QqFWpra2G1WmG1WpsbjdTVIS8vDzk5OUhPT0d9fT00Gs1Vv9Nut0OpUEhGjxnzkq6lLAqAfMqUKfNomv4n1xmtIzQnpxH4cfly2J2OTpPjWJZt7v2u1Xg1Go03NjYWBoMBsbGxSExIUF66eFGQmJAQeP/ocWPUPTJ6oKSoGBqdtpXka9vjUhQFs9kMt9vdzkpuIUWxSCQOBMBtVqsTBFGbX5CPmTfPQHlFORQKBebfOx9yuRwejxserxe5ubnIysoK1LgHb3DEEjEqyytx6vSpzqaI6N+vfyCRkmxRWWMYppW2Oge5XI5+/fppFi9evCEnJ+emkydPrlUoFB1uBjl9dIFAcE15GBy5Ay2leERzTb1SqcLpM2cQEREBpVKJ5ORkOByOq25Cg9UB9Xo96urqzu3bt+/c119//eajjzz66MyZMx7r179/BHf+bXsXhIqzkyAwfPhw7bBhw97dvn373UuWLHluz549a8+dO4e+ffu6tFptOcuyEQKBoIvNZtNKJJISsVjsvl7Z3DD+3AgT+v8AguPkUqk0qbCwkKyrq3P26tUr3+12N8cSPR6IxeIJ77zzzt8fe/TRMZwwSlsib1vLHCwE4/P5sGXLlvNHDh9exrDsl3V1dVaFQoGEhIRflanu9/shkUhQWloKu90Op9MZyGT2er3t4uRA84aFW8CsVivOnDmDM2fO4IEHHsDf/va3gHDK1VBbW2sqKiwER+gMw6B79+6SQ4cOBeL0HYEgmht3DBoyGEeOHIHT6bxmZTgejweZXA61SoWiomKf0WgIrMYUSSIrM5OVyWTw0T7whXzwKV7A0xHYfLXMM1f+Fup7rVYr9Hp9hkgoDLCx3W5H927d9D6fz3H8+HGbvyXqe8+998Dv9+PI0aM4f+4cDh8+jNOnTwcs4ODYfE1NDZKSkvDGG280X6M29w9JUigsLJQMGzHsdu41n9+P1atWHVEoFNtramompKSkZPTMyJALhQLIZc3RDgYsNBoNNm7cuGbs2LEDvF7vSbG4VXJ+AAKBAI2NjTAYDFc60F0jCIIA42daWsw2E3t1dTXi4uKQn58Pu92Ojr43FDhCTUhIQF1dXWN1TfUrP/700/srf/nlwewhQ2ZPvvHG/s0a8kQrYm9bIRIgdoLADTfc0GP06NFrVv78895/PPfcmwzDbO/VqxdKS0sb+Xx+46ZNm+IrKioSJBKJPykpqYxlWX/YWv/fQJjQ/wfQEiePEggEeh6P52VZNl8gEDBnzpxBSUkJunXr1m/Y0KGv33LLLTdENbsKW2XmBiNYd537q9frxfr1649s2LDhs5KSkmVpaWno2bMnXC7Xb6obF4lEEIlEqK6uhtvthlwuD2QqXwu4mnGaprF48WIkJSXBaDR2aNUGw2g0epKTk7dnZ2dPYBEonRuwdetWQqVSdbg6ctaZw+HAvLvvRlpqGr7815fw0N5OSZ1hGChUSphMJtTV1sLU0ID8gnxHk7npBIDhAEDxeCguKfYdPXK0ORmMx4fBaEBJSQlEIlEghOD1ehEdHY2YmJgONx9CoRAajaY/v6XUjQXQJTlZ9uFHHxXW1tawdru9zGAwHvL5ffU2mw12ux0kQUCtViM+Pn6Px+PZF0onn6IoeL1elJaUwOdr76L2ej0gCMLZvXv3wAXweD348osvP+/WvdvSAwcOvJydnS3fsWNH9ORJk2+fe8fcoRm9eo2TSCQAgKioKEyeNPkv77z7zr0ajSbkZHIbulCbmeB8Cq4ffce4ktUulUqxs6WZTlJSUsjM/c7Alb6pVCrodDp7bm7ue2++9dZ7P69cOWvq1KmP3nTTTcOEQmGA2Ds8TstfBQIB5sydO2r0mDGj1q9fv33nzp0vlZeXHyUIArGxsZV79uwhevfunZaWltbHbDbXkiRZe82DDeNPizCh/5eCaWm5qVQqJSqVKn316tXuQYMG5fv9fjePx0NycjJ2796tGjly5IuPPvroX/v06XPlsyF6QnMItsjdbhd+XPHj7g0bN35WWlq6WqPRICEhIRDT/bVlYFwzDj6fj5iYGPj9/l+tCsdlQrvdbrhcLkydOvWaNgUOh8PPo6g9DMNM4Ahi4KCBUyffOFmUkJDQoc42j8eH1WrFhbw8iEUixCck4OabbsLqNWtCkjpN06BpGkqFEvv27MGqNatbHS+/oGAvWgidJAicO3tO8O2337Z6j0AggEQiCeQFCAQCdO3aFWKxuMPsfKlUCo1Wq+Q2NixYSCUSYtz4cVztW6+WH/hZBjRNY+TIkfB4vVi/bp3O6XTuC5VLEKWPwoply7H4u0XQ6aPa/d3aZIVGp50WpYsSBr3mLCgs2HLk6BH0798faWlptm+//dYmEApeXrduHdavX7/99ddfH8+9f+y4sTPOnT/3WExMjL39/DeXna1ZsyawoWyLluTKiIaGhkYul+NqYRS/34+IiAgYDAZYrVaYTCZMnDgRDMO0KwfsDMGlk4mJiaitrf35jTfe+Hn58uXTpk6d+uic228fK27ZvCDUM8i2eGEIAGARExODBx98cEJ2dvaEzz///NNz5869OGbMGLPFYmElEknBuXPnxCdPnkzIzMzUKZXKEpFIdNXEzjD+vAgT+n8pxGIxv7y8PMFutwsVCoXR4/FUWa1WsCyLy5cvY+jQoY9+9tlnr2VnZyu5zzAdxPE4cIlLXq8Xq375Zf+KFSvey83L2xAdHY2kpKSAe/PXEDln6bEsi6qqqoCLXiKRBJKYfiucTiekUinUavVVy9AcDgdKSkt5HEECQFpaV9fBfQf8Lq8bIr6w/YeIlkYlDAOlUgmKomBqaECfrEyQJIlfVq1qR+pCoRAKhQJ8Hh89evTA3XffDbFIBIZh4fP7kJWV6WVYFlxdc1pq2lCSJJGSkhJy3DRNQyQSIS4uLpAg1tFcREREMLiGeaUIElRLrTmfz0ejyWRoClGuxrIsLE0W9MzohaeeeTqk9evxeKBSqQYLRaLAFxcXFkqmTZtmB4ATJ04gPz8fvXv3xoULF+B2u+H3+39yOp3jOSs9NjZWcNNNN5Eqlard8RUKBXJzc6FUKqFWq9u53FvU5GJ+/vnnQovFUrV27dplBoPh26KiouqmpibQIbLyOTAMA5lMBkdz6SDOnTvXHCJpKY+7nvueey9XFlpbW7vu5ZdfXrdq1apJt99221MzZ80aLRKJWlnsLFiAaJNg2JJQ2Lt3b3z55ZePHDt69I6t27a9Wlxc/EFqaiq8Xq/L4/Hky2Sy2OPHjyeYzWaXWCyuBHD1Osww/nQIE/p/CYKz1xmG0UokkhiTyUTv3bv34qhRoxAdE4Oamhqkp6dPePGFF5994MEHRnEL19Uy1zki9/sZ/PLLysM///zzu/n5+WvFYjFSUlIgFAoDY/g14+bz+YF6ZS4pjCRJSCQS+Hy+dmROkiRomobNZoPBYKD0er3E4/F0anbzeDwYjUZ89tln1zPWJa+99toLWq1WAAAx0dGS/gMG3OZyuxaHEj0hAJgaG9GnTx+cPn26OXYuFMJQb0CfzEwQBIGVv/wCD33FDT5p8mSMHz8elZWVGDlqFJRKZasELZfL1bypaCGmiMiIIcldkqVJSUmOdgNo+QyXjCUUCjskdLfbDaVSybZW+GPhdjVbmyRJBjLU+XwBgoVSGkymiIaGhnZWLY/HA8Mw2LRpE6qrq0PGmk0mE5595lmWH0T2R48d2/7DDz94ZsyYEcg6nz9/PpYvXw6Hw4HY2Fhl8MbD7/fD4/GEDCf4fD7U1NRAr9dDo9G0us4EQaCyshLZ2dn39O/fXwKg66jRo1+pKC9/7siRIwfXr1+/c9+evf+qralpBIiQte+cmz4yMhL5+flwu90YPHhwQJXvehFM7GKxGHV1dZtfW7hw888rV065dfbsp2bfeusIXlBYJBSCE+cGDR6sHDBw4PvR0dE35efnv5afn789LS0NKpWqevXq1dU9evToplAoejIMUx2cDf97bJjD+PcjTOj/BeBUs/x+P+FyuVJ5PJ7Y7/cX2Ww2h81mg8vlgkggiErrmfHxkwuenKUPipN3Bo7IWZbFrl27ylauXPnckSNHlkulUiQlJcHr9Xbay5t7XSwWQywWB0rG2i6ybrcbDocDbrcbsbGxAU3uUGTk9XpRXFyMrKysbsnJybdOmTLlrsjIyEiCIMYBON7Z+fB4PPh8PiQkJCAjI6NVMleosVsslpqioiIB1wBEKBIiq29WyokTJ9pZ+FxYoGdGBgYMGIDjx4+3ChEYDAb0yMjALQwDg9HYLDFL8dCrdy+cOXMGbrcbZWVlrY7p9niglCswZGh24DWVWsX2zOhJxcTEhBw3N47YmBjwBYIOS628Hg+kMllgISdBYNXq1Z7XFy58Mysri4iNjUVMdAySkpMgVyiwdfMWSCSSBJlM1m/Xjp17bDZbO3c21+0uPT0dmZmZ8LVp2UqAQElxsTCpS9Jdwa9fvnx5r91ux8CBA3H8+HFQFAWJRILExESsXr0amZmZWknQ5qC0tNS1fPlyJj4+vt15SaVSnDlzBnl5ee02FFzs/O9///s8oHkDw6MoJCcnC5KTk8fMmj17zNEjR56vrqnefOrEqbVGo3FNRUWFMzY2NmSVgFQqhVgsRkFBASwWCyQSCQQCwXVVcQSPDWgmdp1Oh9ra2g2vLVy4YefOnTNvve221yZMmJDObao6em4DxE6SuP/++4cZ6uu3/fPDD9eVlZX9hSTJGoZh4PV6L3u9XjFJkikul0vj9/vzhUIhc7VEzzD+HAgT+n8BWsRToi9duhRz6NCh2ujo6MLS0lK01O/i5ptvfvzVV19d2Kt374A2aGfLTbAgzOHDhy2bN21+LTcv9yOfz+dPTEwMkERHmtkEQUAqlUImkwXEWUiSRGpqaiuZVJZlERERgTNnzsDhcASsU4qiQrfXpGloNJpRkyZNemPatGlD9Hp9YKF95+13VsyYOSPlWhZSkUgUsKY6skxIkkRTUxNx6tSpY0OGDBkEACRBgsfjxezbt4/g8/mBLwruCjZo0CAMGjgw5LEbjEZ079EDqTQNn88HiqJQUlISsqwMaHaLR0ZG8lnmyjlpNVp/dnY221H5HWdBJnZJCljMoeCjfSDbJAdWV1UZcnNzX0lOToZUKoVUKgXF48Hr9WLhwoUAAKVCCdrrhdMdOo2AAKBQKkB7vfB6W296WIIFj8/3Z2RkRAJX7sH77rvvxQH9+4+I0uuPSaVSC5/PX5Sbm+s3GAx49NFHR95+222PBh/n7Nkz686ePWuvrW2f58VZ75GRke3uT7fbjYT4hBE5OTkpQLNyW7DUDp/Hw/DhwyUAZkyeNHnG4cOHGyM1kZ+eOHHiQ6vVag4lFERRFGiaDijQeTweREREXLcLPjBHQcSu0WhQVV298oMPPli5a+euR6ZMnfLK8OHDI66mF8/lwOiiovDmm29Ou3DhwvgNGza8XFpa+m50dDTcbrcrNjY276efforRaDRZUVFRYVGa/xKECf1PCs5VTZIkpdFo+ixbtszF4/HyCYKwJyUloaSkBEKhcMLChQv/9sQTT4zr0L3OEgFvZjD97Nmzx7F9+/YPALxfW1vbFBMTA5vNhqampk4XKpFIBLFYjMLCQtTW1iI1NRVFRUUoLi7GqVOnQJIkWlyAXE08YmJiYLVar6p/7nA4oNPpZj300ENDuNeYlnHfMuOW5Pfee2/zU089NYlzO4cCSZKB8Uil0k4T7Wia9hbk568HMIh7bdiwobePGjXq0S5dugQYjeuZfuDAATQ1NXVoFXOiK3V1dbiQdwGSq5Q/2W12WKOabAiaE7VaDb1ez4bqngZcybJn2OYYfEfTybAMxBIpG0zojJ854/P5cOrESXSZNRMKhQI+n6/5/HRR8Hg8iIuPR21NDWJjY6GOUAe8KARBgCQplJaUYOeuXZ2dVkJ8XFzzWFvuxUGDBokGDRo0kWGZiWPGjoXDbl94+sxpZsCAAZg6bapcIpYEYsVWqxUrf/llkV6vbxfDB5q9MC6XC23FZ0iShN/vR86knNsVCkXzayDgdLlQXFTkTuuaJhIJrxxPLpfjhhtuiLjhhhte3Llz5+M/rlhxm8lk2hLK6ucSNpVKJY4ePRpw9f9aUueOC1yJsVdWVX66Zs2aH9auXbtg0qRJT44dO1YWTOxtteLZln+RINCzZ09J9+7d35FKJDfs2bv3HQDb4+PjcenSpZry8vImhmES58yZo7darecRjq3/qREm9D8ZuFi5UCiEub4+Nkqn04tEolqGYWoMBgOcTidSU1N5I0aMeGfmzJl/TU1NBdCJe5248uADQGVFBf71r38tW7R48YLExMT6u+++G06ns13ddzBIkgRFUXC73fB4PKioqEBjYyNUKhVUKlUg27q+vh4A0NjYCACBbmWcCMfV0OLiNXi8HggFwsAiz5H6ggULctavXz9///7933R0DC7ZrlevXhgyZEinGe9OpxMul4sfHB/t3r07cebMGd+RI0cgFAoDcdb58+ejT58+2LZtW6fnQNM0YmNjcfbMWeQWFjbryHfw3iZLE9we9w4P7X1DLBYTACAUCtkFCxb4XS5Xp3MWXI0QCm6vBw8//DCRPTiwN4LJZMoDgNS0VEycOBFlZWU4cugwampq0L1nDxgMBpSXlSEqKgp33T0PZ86cgaCljJ1Ac3lgcnIyunTpApJsL+frdLpAUeSdCpUq4KsP9gaRBAmFXA6FXC6dHD058Hrw/fn9d99vvJB3YW9H5yUQCBATE9MuXOPz+WCz2TB9+vQZ3DEJANu2br108803j549e/ZtkydPnjJ8+PAxiUmJrWZv3Lhxyvj4+M1z58zJstlsZ0NtJIDme8vn86GoqAgsyyI5OblT6Vgu/MTn8+F2uzsUCAKas+JTUlKsixYtemnZsmWf3j1v3pvz7r773vT09JZnIHR7nWA3/KOPPTZ28o03jl29evWnBQUFC+rr670CgcAhFAov8ni8WIlE0othGAOAqg4HHcZ/NMKE/idCUKyclEgkmbt37fIU5OdfyszMdJIkCbfLBbVaPeHOO+/8aOzYsd24z3VWhsYtlG6PB++89db2i5cuvd/Y2Lhdr9cjPj6+0xg5R8ac6EvPnj1x4cIFlJWVITo6OpChDiCwCeFUufx+PwwGAwwGAxITE6+pJI1hOMGPK+IbzedwZYHetGnT16NGjSo6derUXolIHNKVLRGJUVFWHhCsIchQPcwCtcNLX3/jjX/odDoBAOijY0R9+/ad5Xa7l8nlcvj9fpw/fx5cl7Cr6bf7/X7w+HxkZmUi70IerI52lVet0FRovWhtsjpVCqUUAKRSqYSmaZXD4XB1lPAGALTH02kHNaZ5LK0Gez73fB0AvLLwNfD5zeV3FosFRoMBHo8HDocDVrsNSqUSPB4PNpsNYt8Vi5UrOaysrATLctusK7A77Rg9arSLS4gjQMDUaHLSXlqijlAHurYFC6yQQdT66aefbvnnh/+cwokHBV9bmqYRERGBxMREOByOdtZ7U1MTevXqNXrUqFGRCBrZ8ePHV1EUVV9TU/Ph4sWLP9y1c1fXxMSEO2+cMuXBAQMGBEID6enpmDN3zhdLli4blpCQ4O/sfiVIEhaLBUlJSRCLxYHQBxeOEggEAateIBCguro6UMmhUCg6JHa/34+EhATQNG3ct3//fFNj449jxoz527jx4yZoIjWB69puPC2Z8gSA5ORkPPXUU4/s2bMn5/jx4w87HI5tMpkMFy9erKYoyqTRaJIdDkcmRVF54YYvfz6ECf1PAM4qb1mk9JcuXYo7d+5cdUJ8fO2FixfR0NAAmqalt91++7dPLVgwO6rDpDcCCFooOezZs6fy888//8svv/yy8aabbkJqaipOnTrVIckSBAE+n4+mpia43W5ERkYiNTUVI0aMgMFgQFVVVad9qbnFWCQS4dy5c0hNTYVYLG7Xr/tqIADs3bvXn5KSQsXHx4NFc/ert956a82E8RPUPr8fghCEzmVSR+mjMGTIkA69Dy2JceXFxcUCnU4HoDmk0Derb/eTp082k4hajREjRgSaxVx1zASBJosFMTExmD9/PhiWBdPB5xiWhY+mSa/XE3iDSCTipaWlDa2rq/uFcx23PT7DMHDaHSGztDlUVFVCq9UmBr82756756SmpkaKhSKYLRYo5HJoNBp4PJ7msfh8hQ6b/WhEZKTB6XSyLMs6GOZKgJ/H48HhcODs6dNwOJzgB+vYE4DR1EAOGjBoDEfEBIB/fvDPd959992d77333vjBgwePzsrKGsFJ5wKAzW53nzpx0rl5y+ZPVq9e/XJ5eXnA6uWuGUeWMTExiIyMbJd9T5IkbDYbbr755gdFIlGA3IwNRmzbunV5165d4fV6odfr0WRtKqiuqXl+2bJl7zQ1Nf0ybty48dx2cfwNNwz+5edfpEaj0crvRKMfaNYMuHzpEooKi5Cc0iUQbmHBwmg0wmKxBKxyHo+H3r1749KlSzAajdBqtRB0kNDIJR7GxcVBr9fvXLdu3c4PPvhg0uuvv/7R+PHjU0PF1zkxqOBs+NGjR6ds375960cffbRm06ZN806ePGmlKMrdpUuXi7169dLz+fy+RqOxMi4urjasC//nQZjQ/wTgYs0ymaz3+vXr/R6P55JcLne43G7weDxIpdKcN99881uuiUqH7nUWAHFFc/3w4cPYsGHDqyaT6a3KykpXbGwsZDJZh6VOHJG7XK6ANdqnd2/ExcdDKBTC5XLB4/FccwmMUCiEyWTCpUuXMGzYsOsg9CvHX7du3bHCwsKyjRs33s5tV8aNG6dasnTJlrlz507y0l5WoVC0W5AoAQ8gCPB5PLD+5paZbWuyCQB2q408fer08SFDhgwEmhdqkiQj9+3dBwC4cdKNyOidEVCgu6bREwQsFgsSExMxJDsbPB4VcvEmQKDB1EDabfbAgSmKgl6v70WS5C+h4ugcoTc1NXVK6CZzI6FUKgcDnFXH4qZp0wfdNG36IJZl4aW9GDZsKFimWRuAYdlmERWPm6EI0rF27VrHgQMHuspkskDMgvMgzZg1C1KJtF2We21NjWDI0CETuP9nmt8v6d2796Hq6upDjz/++AdLlixpSklJCVzhpxYsWPj9d9+/3zOjp7tfv34oLi5uN1d+vx9yuRzR0dHNHpA25WM0TUMTGSmbNGnSjcGvf/HZ52tyz+demnXrbPh8PjQ0NIBlWfTr1w8nTpywfvvttz9nDx06nst1iImJcR0+cph3vdSWlpqK0WPGwOv1wmK2wFBvgN/vD5RfcuWaEokEhYWFqKqqglgshkaj6fD6MQwDPp8PnU6HgwcPbl6yZMnObdu2/WPatGnPDx8+nCKDCLxt8IV7XafT4fXXX79p4sSJw1988cW7i4uLN9rtduj1+rrdu3dbTSZT0sCBA7VerzeXJMkwo/8JECb0PwEkEkl0cXGxtri42CSTyaopisKIESPwzw8+kD700EPf/+3pp2dypVUdkTmLK+IkZrMZa9es2f7pZ589zefzz91yyy2orKxEVVVVh5Yq13qyuroaLpcLkZGRSElORkREJDweD3w+36+qZ5VIJLh48SK6d+/+q6z0zMzM6A8//HD44sWLo+66666x3Otz5syZ+PPPK19Yv37dq6HKiERCESwWC7Zs3QqRSNSh5rnH6/VeunxpNYCB3GvZ2dlzbrzxxgVOu8N557w7kZubG8iuttvtcLvdKCoqQmJiojwiIsITERHhDSVB6nQ6sW/v3kAP7lBzV19Xj4g5EVdeIAkkJSWRSqUSkoCiWOvjMgwDg8EAP+MH19mrLWialul0ulQAuGIvXzkG5/5uC5lUSgKQKxQKuclkIoLr8SmKAsMwWL9+PcxmcytRF7vDDpVSJXjzrbecACRAc7/2tWvXnnQ4HNi7dy/y8vKse/bsOZaSkjKIs6J79ug5RiqTvt6jRw9UVlYCaF1dwTAMxGIxJk6cGLCC286j1WpFt27dburbt2+rCRuSnR05c/as55xO53dWq7W2sbERPXr0QK9evXDy5ElQJJnI519ZIp12hzg2JpZ1ez0QdTA/wWBZFnaHA3Fx8VAoFEhLTYPdbocX3oD2AufJcjgc8Hq9SExMRFNTE8rKygLSxx0J3QQnznXt2tW7Zs2al7du2fLjo4899tGMGTMmREZGNs9R87vbfZ7LQRk+fLjml19+2fDBBx+sXbt27Z3btm2zGY1G5/Dhwy/+/PPPMSRJ9tZoNHUA6q960mH8WxEm9P9Q+Hw+KJVKUigUJgMQsyxbdf78+cZ+/fqhqakJNptt4uIffvj+5ptv1gMdP7Rtk6P27tlb9vIrLz8mk8k2JCQkgMfjdRgn515TKpWwWCzYtWsX9Ho9unXr1lyu4/PB4XCA4oUuM+M0zTtK+AGarfTGxkZcvHgR2dnZ103oUqlUSxAEc++9984dP358bUxMTMCl+tNPP750yy23nNi8efOWKK3uCsGwLNCi8a5WqjBi1EjIZLKQ6nEulwsEoKZpOvD53pm9+Y0NJmdBYSF8Ph+qqqpQVFgoj46JgVqlvlmj0XR59913MxISEibs2bPnuU2bNn0Sinw5V3FKSkqHLtaKigrS6XQGWFMsFGHs2LESq9UaMimOz+fD6XRi586d8Hg8HTYn0el0oGmadblcBFrK15qvEQsenw+qg40AB6vVWldaWuoIPj7XiKRXr17tpHptNhvEItEdEZGRgYmoqa52FxcXr/Z4PDAajYiKisLRY0dXz58/fxB3t9x6+21jli1f1rWkpKTA7XYjKyur1b3EbSIbGxs77G1fXl6OmTNn3gVcic+zAMaPHz9i/PjxIy5duvTi8ePHD23YsGGXyWT6urGx0dWjR4+Ro0aNepzP44NB86bn0KFD+QKR0JHaNa3TueHgdDqRnJyMhIQEWMyWgERsKILmiN3j8QR6EFRXV4PH40Gn03V4btwc+P1+xMfHg6bpyytXrrxh0aJFkxYuXPjR2LFjUzvrw87NR2RkJF5//fXpN9xwQ/E999xzV5cuXbakpaVh27ZtNV27dnWwLBsrFAqVSqWy2H8tsaUw/i0IE/p/GDhrWK1WS/bv358oEAiIyMjI3G3btkEqleJyfj5m3HLL57fOnv1QXIuwRiDDlSXaSUNyS19JcTFWr179cVFx8dPV1dWeESNGwGazdRj35eL2UqkURqMRhw4dQmlpKbp27QqKogJk0RGR+/1+VFRUQKfTZQmFQtJms53i2lq2hVgsRklJCbKysgLiL9cKj8fjT0pKkpZXlNfNnj176s5du9YLBQIwYCESiciXX35584H9ByQMw7hauaBbNN5ZlsWB/fthbbKC9tIgyLaJXA5EqNWrXl248Em1SsUHAKVSKbDZbMNVKpXP6XTecNNNN+lMJtPcUaNGISIiQi6VSUGRzflmly5fmnX+/PnP4+Li2k00Nx4uOSrUtaiqqnIVFBRcKCsrSygtLUVtbS2OHz9+uSNlMl5L3fiBAwdgNps7zLL2er32559/PnvRokU5UTodomNiEBcXhy4pyZDL5di8cRN4FKXQ6aMGy2XyDJlcBqVSCaVCifj4eJSWlq632Wz++rq6NudDQqVShTyfjF69IoVB4ykoKCAHDhgojE+IdxYXF8Pj8eDsmbNr6g2Gt6NachZ0Wi0GDBhw++bNm19OSEhol3QoFApRXV2N06dPh2y60+I1iRw6bNhYoHXGPIfu3bsLunfvPvr2228fXVxc/HxVVRV90003yVUqFRgW4G6JN9988y8lJSVei8XSaUyZJElYbTbweTwMGDCgWaPgOhxXnDtdJpOhrq4ONpsNffr0gVwu77QdLPc5tVqNAwcObF66dOnOI0eOvHHr7FsXpKalggxB6tyhGKLZWh8xYoR2965dm1evWbNo/fr1d0dERODy5ctN3bp1a2poaOheX1/fVaVSVfH5fFs4rv6fhzCh/4eBJEk4nU6tXC5PPHz4cLHNZjPPmDED+fn5GDly5Li77rzrtXl3zxvMvf/KA8q2WjSCF61PPvlk79atW9+USCTbBw4ciNOnTzd/opMHkqIoyGQy5OfnY8WKFeDz+dBqtYFM847GzjAMysrKoNfrIyfl5Pz9qb/97W9HjhwpmzNnThdukxAK9fX1KC0tRbdu3WC3d575HeyJYFmWUKvVJMMyOHjw4IYFf/3rik8/++w2rsf2gAED8PPKn9ffeeed42vr6wL92Dn4/X4wDIMhg4dArVa1kxOlaRput+dkWWkZoc7KBAtAoVSS+w7u38/n8eFn/FAqlOgIo0aOHnbrrbdKY2Nj2/VtpSgKFEnhwMEDKC8vD+lCdzqd3qqqqj55eXmS9evX48SJEygvL7d1JL7DxbFZloXL5epQs56mabaxsfGY0Wg8RlEUxBIJlEolWLCw2+148803AQACvgDRMdHyxMREpKSkIDk5GWPHjkVtTa0NQEAqFkBAe//s2bPwer2txme1WqkpU6YMDZ77w4cO/7Rj5w4XBQLxiYnQ6rQoLS0t3Lhhw7F777034HYfNnz4bZs2bXo5VOiEEyISiUQhPRY+nw/Tpk27tVdGBoBmS9vPMCgpKrLpoqLkXCMhoNm70a1bN1G3bt0CKfIk0Ryi+stf/vL52bNnd3PJkR2B80qJhEJMnjwZcrkcFoul08+EApc8yuPxUF9fj/PnzyM5Ofmqvc2D3fCpqaneY8eOPbVv377tORNznn5ywZNjryTNAWijDc+tJQmJiXjiiSfmaTSaXsuWLXvmxIkTO7U6LZb8sOSSUChUDxs2LM3lclWQJNlw3ScWxh+KMKH/h8Dv90OhUBAxMTE91q5d6yVJ8vyoUaO83377LY4cOYKcnJzHP/jggw/T09MBdC7byj20Fy9cwKefffbSli1bXk1OTkavXr06LUMDrljmYrEYZ8+exe7duyEWiyGRSDqs2eYW7qamJhgMBtWYMWOe+Nvf/vbkqFGj5ACQlJSU9MorrwwvKCg40NkcFBUVoW/fvtdA6K2/3uPxYNTIUSiILsCiRYtuT+rShX788cfv5LW4gydOnDjuxhtv/Nf333//AO2jweddEfzg4tcswUKpVqHJ0tSKiMQSCeoNRfzTp0+VZ2VlprBgwad4UKvUVx2Y3W4Hj0eZ9u7ew7q9Hgj57a1lkiDh8/sQoYmEUCQE42+9WeLxeBCJRH6pVGqLiopCQkJCcxigpWQwFHg8HiwWC/h8fof64izLQiKRQCaTBSRMhUIhKIoCj+JBExEJh8OBLinJ0Ol0tpiYGERFRSEiIqIVeQZv0BiGgVgqQUJSYruNRFVVFVVaWirJzc21JXVJkvN5fHi93trhw4ezQoEAVpsNNpsNfD4fe/fs+fHee+8NuN0nTJjQ9fvvvutPUdTJtqTNxaK57nxtYbPZMHny5NuBK6WNp0+dtv7znx+k6PX6yWPHjp0VGRk5esCAAWLuXLgyz9LiEmbFjyt+3rZt2+Jjx45t5WSJOwofcXkRPp8Pt99+O1JSUlBd3bkAG6cyGCqHgrtHIyIi0NjYiJUrV4KiKKjV6qvmqnBu+JSUFJw8eXL7e++/t/3y5cvP3n//fW/0HzAAJAAmqOolGFxsfe7cuf0GDRy4429PP/2306dOv+d2uzFlyhTznj17rAzDpAwcOFCvUCgu+P3+sKn+H4Iwof+bwbIs1ydZdvjw4Wi32+1UqVSleXl5nPUYMWHChKUPPfRQDveZjurKg63yN15/fcfPK1e+SJLk0e7du3faeStwXIaBQqGASCRCXV0dDAZDoLVkKKs8mMh9Pp8iJibmyY8/+uiJAQMHKtu+79NPP93+7DPPRMTExobUDOV6eDc1NXW6YDb/rdXfyZrqapt89Gj069cPWVlZmRcvXiS83ubEI24R//zzz++/dOnS+qNHj24SCoStiIhlWRw+dBinT52GTCZr5yq22WzewsLC5QBeCF2xDjRZm+D3+ZGXl2crLi7OjY6O3vHxxx+7ZDLZIqFQaK8zdJxPxCOpkK1Gfy2upd/7HwGBQACz2QyDwdDu+51Op3fbtm3DY2Nj5StWrEjIysqaabfb90ZFRUEml8FQb4DL5YJWq8XRY8dW1hsM/+Tc7hFqNdLT0286cODAyfj4+HZJcQKBAJEaDag2Gxy3x434+PiUadOnZwe/vm3b1q3r169vmDdv3uLy8vLFf/nLXyJHjhz5wG233XZ7Tk5OT+4akxTp//yzz7+tqa3ZmZqaCpfL1aEsMYBA5vott9yCHj16XJXMKYqCxWIBTdPRTqfTZbFYLCKRKGRDGKlUGmj2wyVwXks5mc/ng1wuR8+ePbF33943L+df3v7II4+8MWvWrAmhYutEC8lza0xa165Yu3btu998/c24kydP3iWVSuvNZrM/ISGhoLa2NqGpqSlNpVLVCwSCprAL/t+PMKH/m9HioouSy+Wpu3fvvmi1Ws0PPPAAzp49i4aGhpyvv/p66Q0Tb4gA0EoNqiMyz8vLw4f//PDZ1WtWvxUdHY2MjIyryrVy4+AaTZjNZjQ1NUEqlQZivMHgFhyLxQKH3S7p2q3bk2NGj/7r4CFDIsgQi93Ro0eZ48ePr5h+002QyWQhx0JRFBoaGgISsKEQiqj4PH6TUqnKkkqlNw4bNuzmESNGZHL12cEJUCKRCCtXrtzYNS0t1el0FkdERAQSjQiCgMPhQFZWFkaPHt1uvlwuF1iWDbCF1WoFwzCoqKiw7d27t0Eqkfxw6fJlbNy48ccRI0ZU79u3z/biiy8GPBpcXXQoC53xM+DxO5e8vR7w+XwQJAHG7weL5tKwUNfkjwBHMqHCKh6PB1qtFgqFwlZfV3/BZDJdcLlcAdVAp9MZsLCtVmv1l19+uf1vTz01wefzQaFQ4I4773jgk08+eSk/P98XfH84nU6kd01Heno6nE5n4HWCAEwNJgwfPmyurqUChECzgNK6dev+5fF40NDQALlcDrFYbCouLn7j+++/f2PDhg0vvL7w9VfVEWokJSXxz54/u2NSzqRsj8dzpLMyMu4cNRoNunXrBpPJ1OlcURSF2tpaMAwz8YMPPlgrlUrdS5cufTEvL+9js9nccg6tk/+4UIrJZAroOHDiRle7LlzSXGRk5Kn9+/ff8O033y5497133+vdu3eI2DpH61dUJOffN/+GLl26FG7ZuuU2giA2jRs3Dh9//HGFSCSKnDp1ai+Hw1FAkqSh04GE8YcjTOj/BnALH5/PR0RERPf169d7TSbTqREjRri3bduGy5cvY+TIkW8/88wzT8e16F4Hx8qDdZuDLcb333tv9+IffnjR5/MdysjIgNfr7dAq5+JzXq8XPB4voF51/PjxQHe0tggmcpPJhIEDBj48deqU54eNGKEPtcydP38eP65Y8fXOXbvelEqlpYMGDUJdXV1I1yLX0KUzOdO2ZMECGDI0O3LHrh2nk5KSwKNa387NtjwReG9cXBy+X7Roxf333z+Qy1rn3NZKpRIlJSWorKxs17LV1azAtz02NnZuXFzcL6dPn7avXbN2/R133lH48ssvO0aNGsVkZWXBaDQ2l/O1tJSVSCQQiURXVcHjNiq/htS5cdrtdthsNigUCtitNvh9PkiEIjBgQft8QEtM9t8J7jrLFXJIpVIE95ovLCwM3ItWqxUH9u+/YdvWrT2GDh06q2+/flRFRcVtkRERMabGxoq2rvWioiJUVlSACZ4/loXD5cQLLzw/F0AgU33Txo21586d252WlgaXy4WjR48iNTUVCoUCDocDX3zxxWt6vX7Qiy++OBkAtBotJk2a9Mhrr712JFR3t2CYTCYkJCRAJBJ1KilMURSMRiO8Xm/O559/vrlfv34AIHz77bc/2rFjx30ff/zx87m5udsAuNs+KwRBQCKRoKmpCTt27EBkZCRCtfINBc6bkZCQgCVLlrw/a9asA/PmzXv9mWeeGddWF54N+s254MeOGyvv3qP7RqfT+WFpaelfVSoVhg4dajp69OjxoqKixMjIyCgAeei891MYfyDChP5vQIugBOF2u3sKBAKKpulL586dQ5cuXcCybPTw4cN/uPvuu8cBrWUwAYQk85LiYnzxxZdvLV+x/FmFQoGuXbsGRDKCwe3yWxLvOKICy7LYvn17QOTCbreHjGM7nU7U1tZi5MiRd997772PTJo0qW8oi+XSpUvYumXLun3797/Z0NBwLDIyEklJSaivr8fy5csDlj8Hr9cLiUSCO+64AzKZLBAjbou2FjoLFgnx8SF3AH6GQUFBAWO32T0DBvQP7E5mz549IO9C3pqFry28KTIyMpDpzsViTSZTyNI5mqb3L1iwIHXmzJm+bt26wWA0QKFQoFu3boiKigKPx7tqFnJbsAwLmvGBdjdvIPw+P+x2O6RS6VUb1XDz4XK5YLFYkJ6ejuzsbHzz1dew2qxQq9SgSBIigQA+vx9erxe0n24uY/ydLXbOi+P1esET8K8qfxsK3H3JbXQVCgVKS0svCgSCl39asQLr1q9/IT4+XuTxegPH5+ZHIpG0S8Jzu92Ii4sbNjEnJ6jWHjh58uTPNE1j6NChUCqVAc9MWloannrqKQBAZWXlbgABMfmsrKzpWVlZsoSEhE6TO2w2GxITE+Fyhe5EB7RY5nW18Pv9OZ999tnmfv36BZ5xkiAwYcKEjIEDB66dPHny/RaL5euOxIN4PB5qampQXFyMqKioa76mnLXetWtXmM3m4++///746urqVx579LEX07qmhcyEB64QfUxMDD7//PMnli5d2mv/vn33iMXiipKSEq9OpyskSbIXQRDdAVxGaBXaMP5ghAn9/xEcccjl8qiCggL9xo0bK3JycsxqtRq1tbWwWCw5n3726U/jx42XA6ET39gWtztH5kuXLj2zbNmyvzc1Ne3o2bMnLBZLh1a5QCCAwWAIyEceP348YBU/9thjVyURg8EgHjVy5Onbbr+925XubVcWy5KSEuzYsWProYMH3/LS9L6oqChQFAWfzweZTNYsqtEisxpsLbJsc2b1uXPnkJOT02EtOkG0rapvv4jV1tYiLy+v+siRI99UVlb+UFtT633p5ZcqBwwYEBjrq6+8Or20pHTOqlWrlkkkksAYSZKEUqmEy+WC1+sNjJGmaYhEIsTExPh0Ot2vIu9gMAwD2u8DRZIYOWIEPB4v8gvyMXr0aLhcLly8eLG5dWkHMVKCIALNRpRKJWbMmIE777wT0dHR+GHR4sBdw6m78Xk88Fu8MR6vN7BB/D1i7dy95HK6IJaIwRcJQbckef2WbmMEQUAul4PH4yFKr0diYiJomnZzte7cJoJhGNA03e7edbvdxO233XY3l8XO/eX++++fp4mMTCspLV1fVFS0nGVZm1AoRHJyMiZPnoxly5Zh+vSb/g5cSQ4DICEIguhso+JwOBAXF4eEhIQO3e2cZe7xeHI++fTTzX169w4E0ThpVhLNWu8nT57cc609yv1+f8jOc52Bi63HxcXh4MGDL+Xm5h6YN2/e6/PmzRvINTxqG9YLdsHPnTt3bFxs7OWly5bNsJjNm1NTU5GXl5cbERGhYhimr1qtrpbJZLXhkvX/X4QJ/f8RJEnC5XJF+P3+BJIkK8xms9nj8cBqs2HkyJF/ff311z/o0qULgI63txyR11RXY9Omzct/XvnzHJfLhZSUFNTU1IRcQDlXG0EQgXpdvV4PgiBQVFSEqqoq3HzzzYFs245gt9shl8vlJEkGHnUCQH5+flNRYeHRc+fPf1BeXr49Sq+H1+uF0WiEQCBAdHQ0pFIpysvLATTXnYfyHpw6dQp9+/aFXC4PSep8Ph88Pi9IobV5OaRpGhs2bGjKv3z56x07d+6Uy2S7k1NSaIFAgLLyMtx11103Hj9+fCNn7RAEgSeffHLpmjVrtng8nkYuvMCNSSQSgW3WLv9drVkuo5kBCwGfj+49euDFl17C1q1bcfTYUchkMsyaNQtVVVX48MMPIZVK4fF4As1shEIhZHJ5wDWdlZmF4SOGY8CAAVCrVKiqqgq5meNc/nweDyzTLOtKoHlTUFtbC4qiEBHRrEYnk8kgETdbvFxds8fjAU3Tga540qDEQZqm4XS5MHRoNqZNn46fV65E7vnz8Hg8cLvdUCgU19R453rhdrshl8sxd+5ciESiduWGBoNBOmbs2HsCc4/mZ6pLly7KBU89NYn2+Sbt2b373bLS0qVnz507bbFYfmL8DH/BggXLJk+epGu+s5qvfW1t7Yaqqip7RzX9DMPAarWCe3ZD3TMURaG2oRZ+vy/nk08+aUXmAHcnN/9fcUmJddy4ceVtSyxDgbsmDofjujeYnLWempqKsrKynd9+++1Ou82+aPpN0+9qDvV1LEZDABg1erS4S3LypsrKyn+YzeY3JRIJ7Ha7RafTVe7fvz9OqVR6JBJJ4zUPKIzfjDCh/8Hg4uUCgQBqtTp906ZN7osXL54YM2YMIiMjcfr0afzj2Wc3zJg580aOKNvujLlYVlDiG3v33XdPF4lE6wcPHgwuIz4UOEunrq4OaWlpgfFwCzTQvDguX778Wk7HdeHChVtunDLlaPBC8+477yxev2HD4w888AD0ej2qqqpgNBrB5/MRGRmJ2tpaEAQxbuLEiTknT558xe12WznS5CASiWA2m3HhwgVMnDgRRqOx3ZeTJNkqwYsEgVOnTnmfe+65ufX19ZtFIpFDoVBAq9MhIiICFRUVsFgsqK6u3vTkk09+//FHH9+9a8/uxpMnTny1devW/QzD2Nq6NLn54fF4gQ5YvxXcMdxeDwR8Ph555BF4aRq7du1CU1NT4Fy5MMigQYMCc9O1a9dAPL6kpASnT56CTCpFSnIKMjMzoVAoUG+oDyTedTZehm22sQiCgMfjhq0JuPfee6HRaAIbgdyz52G1WhEdHR3ohte9e3dIJBL4/X7YbXY0GI1gWRZJSUno3bs3Nm3ehO49eiA9PR0upxNyuRzz58/Hhg0bUFNTEyCa39vVL5FIUFBQEFIbwWw2O7Zu3fo4j8ebIJXJxvbv308UnGPB5/EwYcIEOYCHmqxNMBobPnj2uX9Q3dLTJQAnQNMculm1atWHMTExbNtkTe68DAYDsrOz0atXr0CL4GBwljnto3Peefudzb1692rl2Vq+fDnGjhuLKF1zpUN1ZZU8JamLODEpib4aQfP5fFRUVIBp2fRx9zPnceLKMrl/hwKnhd+zZ0/8sOSHeV99/dWqJT/8sKpPZiafc8EHV9VwljoBAomJidi6desb69atG/r222/f6HQ6kZGRUb906dL62tra5JiYmBg+n3+Boig2nAX/xyNM6H8wOK1pn8/Xm8fjURRF5dtsNjQ0NEAikfS97777/jlr9uwRQPt4eTA4Ml+5cuWun3766Qm3253XEnPv0CoXiURwuVyBDHYuPttW6IJzjQoEgkCrx1Dw+Xyoqak59tVXX5168MEH+3E79UceffSOb7/77vkPPvjAlp6ejoSEBPh8PjQ2NoJhmAFDhw59Zvr06TenpqaisLDQs2jRon90lMke3FQk9ALQmhTKy8tdLqdzpVarhUQiCRAH55rlxFoOHDjw5Pz75q8sKyvb53a7nX6/v9WiF4zOZDavB1zOgt3WHHoVi8UYPmwYHnvicSz6fhEsFkur+mOutazFYgnIwvbv3x8ajQaxsbGgKAqX8y9j6JBsiIRC2O12KNwdi9p0Btrng0LGx9w5c8AXCJCbm4uSkhKcP3sOhYWF0Ov1MJlMsNvteOihh2CxWHD48GFs2rgRn37yCd567x0MGZaNA/v3w+/zw2azwWq1BjTt+/fvj4aGBvzyyy8QCoWw2Wztwi1c/3CapjttJBMKnMhMWVlZyNrwhoYGtl+/fh/n5eV9/Nlnn+mGDRt239ixY8cNyR4yIimpCxm8MVQqlFAqlIHMsmCy/deXX27ZtWvXbh6P16r6grs/3W434uPjkZSUBKfT2W4cFEWhvr4ePp8v5/3339/co0ePwGYBALbv3PF+QVFB7ZSpU97jPnPh4oVjn3z+mSMuOuaq88Ddq3Hx8SDIZgnclJQUqFRXRJK4+edkZUOF1rjjxMTE4MKFCxue/cc/esydO/eL22+/fRwn0tTuuzkXPEFg+vTpkw0Gw8Evvvjibw6H44hSqYRIJCohCCLT5XJ1o2n60r87KfN/AeEZ/oOh1+tFS5YsSfzqq69q+Hz+GYlEAqvVCofDMWnZsmWnHn744QCZhwLXD7qqqgrz58//5MCBA+O0Wm0e5yIN9WAKBAJQFIWCgoJApzYuE7azlqherxc0TTd312ohlOAfbkF7/fXXH/b5fAFqzczMVN9+++3PO51OqCMiUFlZicbGxsThw4d/8+orrxx/6qmnbk5NTQUAvPD88wukUmm82+0OZK1zP3w+H/n5+TAYDIEkqfY/rRdMkVhEJiYmyuPi4qDT6WA0GgNkHjw/CoXC0tDQsEWn0zljY2MDvdl/T6uBOx5FUYiOjobFYkFBQQESkxJx//33Iz4+HixBoLamFk6ns9PkMe5Ywa5kLh7s9/vh+42xSU5SpL6+Hg0NDYFELplMhoiIiECFhEgkglKphFAobGWhy+VyUBSFJktTu3ETBAGz2QyLxQKVSoWnnnoKaWlpIIhmSWBuI2W32wOdxkQiEUwmU4dNajqCUCiEWCwONDLhfrg+5FFRUZDJZIaSkpLXFy9ePPq5fzyX9sLzz7+ydcvWIqPRCIZt/zxwi+KXX3655+GHH57E5/MDDXw47w3XCCYtLQ0PPPAAxGJxu2Q4iqLQ2NgIv9+f89qrrwXInDu7rVu3bln46mtPiUXiarnsSqa6xWJZJ5VK/bTPh2v5oXg8lJSWwOlyBe5/pVIJs9mMzMxMdOnSBQaDAUqlEjRNo6mpKTDWtqVxABAZGYkovb5o9+7d4++48863a2pqQKC9ZC4Hbgbvv//+oUuXLj3scDgmORwO6PV6MAxzdv369bWFhYUpEolEGvIAYfxuCFvofwC45DeSJPVKpTJ13759uVVVVU0xMTFYsWIFho8YMf/ZZ5/9OiEhAUDzA8HVfQYjoPh28SI9c+bMmwsLCze+//77KCoq6pCYhUIhiouLA4prJpMJer3+muLBXLIVFysM9R18Ph9VVVXHvvnmm5MPPvhgf26BeuaZZx5fvnz536sqK3k5E3Peu/322x8eOGhgu/srOSVF8Mbrb8xtsja9Gao0jpMsvdaEILVKLeULBERSUlLA2lar1aAoqpXMK1cWx51jZyBJEk1NzUTV0Ri52KXH44FcLg+035RKpWhoaMCiRYtw0003YeOGjZDIpBg1ahQ2b94Mr8dz3XFO7uf/O8Eo2ArlSJiLoXu9Xng8nk5jvBw5R0VFQa1WY8jgwYiJiQnUnguFQvTt2xfdunVDfn4+brjhBpw6dSqQI9BZUiBN09d0T3N5AAqFArGxsbDb7CWlpaUv2+32V44cPTJUKBCM69Gz56zevXvHaXU6OY+icP78edvq1au/fueddxYAzcmkwZoFDMPA6XSia9euuPvuu+H1emGz2SASiQLXiNNV8Pl8Oa8vfH1z1/SurSz/rVu3btm3b9+kAwcOoF/ffrdy46X9NDJ6ZQg//PijDvUYgsHj8SAWi/HG62/AYjYHNu5c90OxWBzwZqSkpGDfvn0gSRIDBw7E8ePHwSWFtp0zAZ+P6OhoLFmy5Jn33nvvwOTJk38aO3asNHQWPAsGzW2Ze/bsib/+9a+bzp8///j58+c/HjNmDHJzcy0tiaf91Wp1gVwuDyfL/UEIE/ofgJbkNxVN0wkej6cwLi6uSSaToampCbfccsval156aRpFUa1c7G0fEY7M33zzzd0///zzgwzDFMbFxYV0B3Pudc4iUKlUiIiIQPfu3VFYWHhdSUksy4Km6Q4tWD6fD5qm8d577z3xwAMPHCSIZndcr169hB9++OGetNS0+EmTJ6WEOvaJ48eb9uzb96EmMvKrbt27tSNtgUAAh8OBvLy8kNKmFEWBJEk/19qTZVlUVVV5zGYzwy26CoUCXq8Xubm5IVXfOgNFUQGXf3Z2NioqKlBVVQWgWTSEcwtLpVJUV1ejsbERGo0Gx48fx2233Yb+/fvDYDAgKioK33zzDU6cOAHaS2P5iuUwm83/NgW3fxe4+8fpdMLpdEIg4AW8DDRNIz4+PtDtTygUYvr06SBJEhUVFTAajaioqGhV4shJqwKASqUCRVEwm82B91xto8QwDPgCPiR8CeLj41mbzXawvKLiYElp6cs//fijfNfu3TcOGjSosVu3boe3bNlii46OhslkChB58PlwZM5VG3A5DEDz829szjPIeeGFFzZ3Te/ays2+f//+LbnncycBwKCBg2TDR44IlMj5fQyOHD4is9lskEjba/u3hUwqQ35BAU6fOoV+/fq1ktzlNq/cfUvTNJxOJ9RqNXr37g2LxQKj0cgJJ7U6LuelS05OBoBNDz/8cPeFCxd+P2PGjLGcC761AcK2GCYE4uLisG3bto/efPPNcS6Xa6rf70dxcbFFo9Fc2L9/f2y3bt1cEonEctWTC+O6ESb0PwCRkZExmzdvJgsLC48PHjwYZWVlsNvt6N+//9bZs2ffAHTc7pQj8vq6Oixdtmz5xx9/PEetViM2NhYlJSUhHzy1Wo26ujrQNA2ZTIaEhITAItqWFDkLI9RDzP2d03vn3KxtIZfLUVxcfOj7778/c88992Rxrz/++OOjQs3Hnj17be+99+4HZrP5w0mTJlmcTmcgphf8vSRJoqysDF6vN2S3LpZlQfF4yfX19cjNza0sKir67oUXXviloaHBEZyBzJ0DR/JXq4vm5qS+vh4ZGRlgWRZjx46FWq3GqlWrUFRUBB6PBz6fD7vdjpqaGowZMwabNm3C+PHj8cUXX0AikWDcuHG4cOECFApFQH+7qampw45n/0toJhd/wKoO1jDnfmpqaiCXy/H3v/8d3333HQYMGICamho4HA74/X6YzWYkJCRALBajV69eAW/I+fPnQRAE1Gr1NW/ggjuaqdVqnD9/3mY0GlcYjUYMGTIEsbGx7XJNOiLz4GeMs8y9Xm/Oc889vzk5uUvgKXe6XP5NGzZ+s+LHFQ9mZGSgd+/e0Gg0vtSUFDcAGQDQXhrr1q3bXltbC07xsLM5lUqlqK+vD4QBOgMXNqNpGmazGQMGDEBeXh6Ki4uhVCpDejxaekxAr9dXHj58eNyhw4e+efqpv90bHRMTKLVr9R1cXJ0k8dxzz01Zt27dttdff33S9u3b/YMHD2749NNPGwiCiJ84caISQHmnAw7juhEm9N8ZDMP0kkqlHrvdXhAfFw+hQID6+vqB33777UezZ88eDHTcWIUjc5PJhLvmzbupurp6bVZWFkwmUzs3Mef2lclkKCsrQ2FhIXr06IGkpCTY7fZAGVIweDwebDYbDAYDVCrVU1ar9UMA7fzPnGAJ95m2xM8R5JtvvPHoXXfddZCiqEANbXCM8OjRo54lS5Z8tGnTpnfqamtNE3NyoFKpAuMPBkeWe/fu7bCPN8uyEIlEG1auXLkjKirq54EDB/q4TUEoF73P5+uwH3jwuRgMBpAkiaFDhyIjIyOgR65SqdCjRw9QFIUhQ4bg3LlzSExMxMGDB3HnnXdi6dKlYBgmEHM2m83g8/ntRE7CuDZwFrjdboder8fkyZOxePFiDB48GEqlEjExMZgzZw6qqqpw6dIlJCYmQqvVQiqVoqmpCUePHkV8fPx1zz3DMIFYvEwmC2ntd0bmnAeMJEmuBj3n6aefDpA5V6FiNpv9X3391YqdO3dCq9Xi2LFjOHnihHTuHXMDO06TqcFutVp3cdoIV5uvioqKQHjpWkM53IaXs+CTkpKgVCoDm9C2Hj2u7DU1NRXPPvvs/DOnz2z46aef1kZFRYUUogmuqZ82bdqExYsXn3jvvXcfVSqVh3r27AmapitFIlEPv9+fxefzz1yLJn0Y14Ywof9GcC5wjUZD8Pn8ASKRCAaDIffEiROIjIhEhDoiZ8mSJZuzs5v7Q1yp326tyc6R+ZIlSwpOnTr1F4IgdnGtGju62YVCIVwuV0AghqsZDiUXybAsamtrIZVKBzz55JPvP/jgg8NPnDjB7t69+/22x+UWKa7BSai2lQqFAkXFxYeWLl167q677urDnQsBAocOHbKuXbt20ZEjR9612+1VsTExEIpEgeN2ZElwVpvD4eisj/dqi8WCjIwMyOXygMxmR8TdUbkOt2jX1dWhb9++iI+PR7du3eByuWAymRAREQGapgPZ2TKZDBRFQSKRBAR6uL7v15uhHUbH4MiGpmkYDIaAJLFGo0F6enogpk/TNDweD4xGI/r16xewto8dOwaCIH6VWl1H4PI6OrPMubwLmqZzFixYsDkpKSlAakTLRjc2JkawbPnyvZ9+8sl2g8Hwvsvl2p6SmjpcIpEGEjVqa2t59957r1Sj0XSsHYvm3I6GhgZ8/PHHsNvt113rz80zt+nt1q0bSktLUVZWBolE0u4Z5Z7/mJgYkCS57vnnnx+bnZ39wd13392nLalzaxp3/nfeeWdWt27dDh46dGhSdHT0lry8PIwaNeqiSCTq7/f7M5VK5TmCIMJlbb8DwoT+G8EwDKKiosj9+/cnVVVVmbt06VK4fv165OfnY8KEG2586OG/bOCsZa6eMxjB2mc//fjjtnnz5k176KGHPFFRUaiqqgoZLxcKhdDr9Thw4EDA1dhRDLFFZhYmkwmKlJQ7P/nkk8VcMt533333Tr9+/daYTKaSUCQbUE9TKQG2dYBASBBwOpz44IMPnrzzrrt2ter09sYb32zevHnBmDFjAiIxvJYsdoFA0GnCG+fa7shC57q/XUvMlIsnto1dE0RzeY/P58OECRMwYcIE+P1+nDhxAlqtNuRixsXQrzcL+/cCSZKBEIXNZoPD4YDL5YLH4wmIwNA0jUZLc2MP7ndnaLSYm+V+hcJAkpvL5YLD4YDNZkNTUxP4QsEfUkN+reDCITRNw263tytx4/F4MBgMSEpKwqhRoyCRSFBbW4udO3cCwO9C7C6XC2lpaVclcz6fn/P4Y49tTkpKCiiqBc4Dzc+PTqvFq6++OqGiomLChg0bvisrLZOLg1TeSsvKPFu3bvWlpaV1OiaJRIKLFy/CbrdDKBT+avEebn4lEgmOHTuGM2fOYMKECSHfyz1vUVFR8Pv9u++5554sHo+3+Y477ph4Ja4OoBW5N5/7wIEDkZ6evnnPnj3TCwoK1u3btw8JCQknv/zyy1iZTBaXnJxcW15e3rlLIoyrIkzovxFRUVGCrVu3ap977jljcnKyjcfjYefOnRg5cuQ9ixZ9/+0VMr8iEANcsWYJNBPP888/v9LhcMyKi4uDUqkMZFkHg2VZyGQyNDY2oqysDJWVlZDJZBCLxXC73a3eyy14JpMJTqdTcc8996y49957JwU3ckhMTCQXLFiw5q233uofFRXVuoE1rlixNqutxbIOWtRZFmq1CufPn9+9fNmyvDlz5mRwD+9LL7102+bNm5/bvXu3WywWQ6FQQCKRBLKlk5KSoNPpWsXQRSIRrFYrKIr6zcpinKXP4/ECkrMc8VEUBYfDgczMTCQnJ+PGG2+E3+9HZWXlNWUV/94IJmqHwwGapuH1elFTUwMASEhIkMfHx8NisTRnmEulXaKiosZpNBqFSqWCXC4P1N/L5XL8/em/g/b7eHKpTMDj88Q8Hk9CEAQJACzL+v0+n8vn83tsdpuHR/FomVweWNDlcjlUKhU0Gg3cbrej0WzezrBMidPpRIPRiOrqahQWFtoZsCxX4uhwOADgqhnvf/Qc0jSNyspKDBw4EFarFWazOZDg2VZq+Hrg9XrRs2dPPPzww6BpGlarNZDYx8Hj8VCRkZF33DXvru+1Gm2wZCzWrl37U35+PvvYY4/eKhZfSXJLSEjAww8/fE+T1Qoq6L47e+b08tzcXFdubm6n4+IqK7h2q7/1meFyTpRKJfLy8kCSJHr16hVy0+z3+6FUKhEdHc3u3bs35+TJk0vfeeedOVxjJU50hm0lQdNcdvn111+vvePOOx89fPjwp1OmTIHZbK5+/PHHpYsXL46TSCR1ANztvjCMa0aY0H8DWJaVR0RExC9evLgMgPOWW27B2bNnMWPmzCVfffXVXF5LbLmtAjlwZfdeUVGBmTNn3tXQ0PDDI488AoFAEPLhbIkfQywW49ixYygoKIBOpwupksVZpDU1NRAKhTlffvnl4uzsbC3QWjRjyQ8/HN2/f/+nffr08SsUinaudT6fD7fbjTMnT8PXQpCtzoFsPot33nrrsdtuu203t2gOHDgw+sYbb3x248aNL3m9XtTX10MgEKCurg65ubkYPHgwALRKYOLc1x6P57p1qYPPm7PmoqKiMHnyZKSkpOCHH36ASCSCTqcLLEZ9+/YFy7K4fPkyEhMT/1AyCmyMbLZA0xuj0YiqqipBXV2dkEfxIJPJ+mgiI8fxeDwoFAq8+uqrfJVKNSM+Pj5ar9dDLpfj2WefxYsvvSgXCoRXqgAIAgRJgGWavRcDBw68rrExLaTXt38/sAwLlmVafrPweL3vOB0Om9vjQZcuXZDaNQ1Tp0yttzRZVioVCm+jqRGayEjIZLLdPB7vTF1dHYqLi71ms9njdrvBJT/+f1n4nLUul8sxduxYeDweFBUVQSwWB+6tYE2Dq3l4uCSyyMhInDp1KtC2tC3q6uqo6dOnv6rVNLdp5Z7tzz77bNsjjzxyK4/HQ25u7oqZM2e+dOONN/YN9hooFYor2vsMA70+umzmzJkdbi65qoANGzYE9PI7I3Nuw2i1WuF0OmG1WjvcfBEEAaFQCJ/Ph8uXLyMhISGgpx/KU8jF1T/55JO5Bw4cWL969eqfkpKSWmLobcOKzf+OiorC1i1bP3n44b+MMBgMs+bOnYv169c7iGZ0Y1m2FEB7ayaMa0KY0H89lARB9GAY5pJWq3XecccdkEgkGDZs2OYXX3wxB7jieAo0w2i5qbkH/tLFi/j4408mHz9+fPO4ceOa39tB5jmX9PKvf/0LlZWViIiICPkg83g8NDY24uzZs7hj7h2Lbrr5pruC2z6SAKqrq7F48eKP169f/7jBYEBqairq6+vbuZM5kuUJ+CB5VDtRFwDQ66NxPi9vzy+rVhXMmjmzK/foLly48KmNGze+4/f7HZzFDAClpaUoLS3tcFITEhKQmZnZafvJUOCsMQAYN24cUlJSIJVKIRKJIBAIoNVqERUVBZfLBbvdHljYfm+rnFtAOQ+LwWDA5cuXBU1NTUKNRhOp0+rmWq1W3rRp08S9evWam5mZKZ88eTI+/uRjuaDFwhEIBODuh9+CtncSgeAcjpbxEgSEHeQrSCQSqFUqOQCkNJcvAYAcwLN+lkF2thdz5szBR5988lKTxWKrrq7G22+/7ayrq1sSERHhkMvljFarXWq1Wo2XL1/29s7I8ADNaoAejydkjf9vBac+Z26pybbZbFCpVKioqEBGRgbq6uoCHhu1Wt1p33IuxFNbW4vS0tIONyV2u927evXqbrW1tbfdcsstCwcMGKBftGjR7kceeWQiAKSnp6O+vn79G2+8sX7rlq13zZo967VRo0bFc8fjvHV0c+24bsiQIR1uapVKJS5evBh4VjsKs3m9XtjtdlRXVwuFAkFEdHT0nREREeLo6GibQCD4oby83CSRSBigtbgMwzCQy+VwuVz4+eef0b17dwiFwkDFSNv5AYCUlBQcPHjw55deetm2YMGTm5t7rF/R1wg+RwYASRL44osvZr799tubxWLxJKPRiO3bt9vHjBlTQRBEJoDzAK4eMwqjHcKE/uugAZCl1+tPrVu3znLgwAEseHIBEpMSN8+YMSMHaJ3JHux+4sj8559/zvvwn/98dNDgwXsTExMDymyhQJIk+Hw+SktLUV1dDalU2s7C4Cy2wsJCJCYmjp8xY8ZL8+bNG9o8litW+fr162v37Nlzd2lp6bZ+/fph48aNUCqVcDqdKC4ubrXIcq5KgVDQqvtYMKiWePc/P/jgr7NmztzEPcB9+vSRTJky5ekNGza8dC0NOrgkHbPZjJqamkBS2tXALUY+nw96vR4ajQbTp09HRUUF6urqoNFoAklWnPrZ79UsJNjy9vv9MBgMKC4ulsfExCA2NnaKzWbrevPNNwn6D+h/18iRI+X3P/CARCIRUwzDQibtXDSrMxng1tTc9i+t28u2PSb3nlCVFlzyViiRo7bvowgSXOxXLBJBqVDIExISMGTIEDmAp/x+P6ZPnw6P1/NSVWWVQyKWOOPj4xbbbDZXbGxsEY/HW9eikWBLSEj4Qyx5jpCBZm8Qp97ndDrR1NSECxcuICkpKZC30ZFnjMfjQaVSdXjf8Hg8qNVqZ2Vl5bdLlixZvXv37vsWLlz4XvAxVCoVVCoVqqqrFn/++ec/lZSUPN03K+vB7j16RAlFIhIA/D4ffljyw8XamtAlayRJQqFQBHrHS6XSVmPi5q6xsRFut1udlJj46JAhQ/7SvXt3lfz/2LvquKrOP/yc20l3iCBgoGChCAYWaWB3TMWcujlnb+o2N521udlzdjctdge2qIgg3XkLLrfO74/LuVzKntt+4/l8NvXGOe8597zv837r+QqEbBqdBpVaDbFY9P39e/ezU1692nH+/PmfqDbCFPR1LZKTk3Hs2DFYWFigZv8F6to0Gg2sra3B5XCix48d13nWF7PXabu21VXRQ1auRwTmz58feOfOnajt27cHxcfHw8jIqNjMzCw+Ly/PC8A9APn1/rgNqBMNhP7usATgaWhoeOfVq1fFO3fuBAA0a94sOjg4OACom8yBKst87dq1sXPnzu3Xo3v3Copw6gKNRgOfz8edO3cgFAphYGCgm3j6E4sSlHn+/Dn69eu3aP78+Sucqiwq0ACUlpZi8+bNkatWrRr+5ZdfSqnkIXt7ex1ZU1ru+qBIi7LWayWMqdWwsLDArVu3oo4fP544aNAgnZX+3XffzS0oKPjZ0tJS9jYubX0VLop8KblN/eulxkOn03VCI56enhg+fDjOnTuHV69eQa1Wf9RMZ2p8VPlSeXk5kpOTYW9vL7SwsGhVUVHhN3DgQJOSkpLxvr7dYW5uJiQBCOvoZw28ibBfMwadG7P6a3W1uqxJ/NXjmqj1ftUrZLXP1x7760dOQJtlLhAIIICAZmpiKvTw8BACmCeVyfDo8WMUFRZKLl26BGNj471JSUkFFhYW54qLix+9Sk6WlHfujLKyso9G8NTzQiU2Uh6rR48ewd3dHVKpFPn5+bo8CyMjI5AkCZlMBrlcjvLy8nrL2ajjA6AEnUrEYvHPVK5Lzc+Ym5vDyMhIfuTIke8WLFjwZ1xc3MvGjRtzAEAkEpWVlpQelsvldXqO6HQ6MjIydDkPdZF5Tk4OHBwcBmzdunWnu7u7YV33T8Dnc2362DQB8KOBoeHQEydOzC0sLDxfs6Uxk8kEg8HA8+fPIZfLweFw6k3AU6vVsLAwA41Ou/7ZZ591NDAwiBk4cKC/fga8/lND5Rl06NAhcOrUqTGff/55wObNmzFy5MgiHo93T6lUtjc2Nr7LZDLz61p3GlA3Ggj93WAMoBWHw7lVVFRUePbsWQBgbN++/VxwcHA3oPaOtCaZnz59Onrr1q1BgC5btN6TUW61kpISXce2ukqkysrKYG9v32nWrFnfzZ49u5avNvHFC9XCRYtGJicnH3VwcEBJSQl4PB6eP38OFouFkpISplwut5VIJKl8Pr/WmKjmLjKZrE7xCSqWu2rVqtmDBg2K1tN45/Xu1WvxufPnF5ubm78VexEEoROVoWq6xWIx2Gx2tf7aVA0tnU6Hs7MzOnbsCDabjaKiItDp9I8ik0ot4DKZDGVlZUhKSkKb1m2EQqGwt6Wlpfu8efN6u7i4tFq5cqWQIAjoJxzq433JG6hfP7uuaom6/03oRIyIOj5XV095/c/U/Hx9Ggr6qI/waSB0ngmhQCAcP348AEyXSCSYFBq69Gl8vMTT0/MpQRBnBALBU7FYHJOcnCxp3rw5ZDLZRyN4KmHS1NQUPB4PCQkJkEgkCA4OBofDweXLl8FkMuHm5gY6nQ6CIJCWlgYWiwUul1uvpU6Nj8PhVKvSoDapVB/3vLw8PHv2DI0aNfKzsLTU+dbz8/PVM2fO1FBaDfrg8/nIz8/HsmXLdPeCArURfvbsGSZPnnxk8eLFQ0xNTbVjQl2/cBXGjRvXukuXLue2bt0aVFJSEl2T1AGttntBQQF2796ti53XBZVKDUNDI1haWSIuLi4gLy8vatq0aYF1y8VWkfqMGTP8DYQG18eOG+sfExMj9fT0zDc3N7918eLFpqNGjpJbWFiI8/LyPvoG/f8RDYT+BlCWnrGxsYlKpWpJo9HiVCqV6MGDB5BKpRZHDh+OGjJ0aDvgDYIxJImp06Ydo9PpQ1q2bImXL1++VjiCzWYjJycHWVlZMDExqVZPXdNKKC0txZgxY0ZTZE4l4pXJZOqDhw4dunHt2vcMBuMF1QgjMzMTzZs3R1paGpo3b959/vz5vxgZGdkMGDDAorCwkKwrtkktpFTjl5pjcGjUCHFxcTFhYWGZ/fr1s6Ne79O378LcvLwfbWxspG9xu3VeAErJjuriVV5ejsLCQp0AyP379wEAEyZMQEJCAkpKSupUxntXUE03FAoF8vPzkZubKxQKhW2sra17LFiwwLd169ZtF7gsEPL4PNCI2ufSbzVZU2ugLou3roTJWsckNVBUKACCAKnRQKOti9bI5XIZr7KLXmlpKaRSKcrKyiCXyyGXy8FisTS9evcWcrlcGkBArqjA2dhYkbxcTuNyuVTWPAQCAQwNDSEQCFBWXg4Ol8Pjcrl0GkGARqMDJAkWmwUaQat3g6F//TWvj7oH9bn5qY2Qt7e30Nvb20tDarwGDhyI5ORkiaOj44PSktKLBgYGl3Nzc+/m5+dLFAoF5HL5B//WlLtYpVLByMgIvr6+SE5OxvHjx9GhQwe0aNECJiYmulK4S5cuoaSkBIaGhu/U2MfAwAAdO3aEubm5dqNJAIGBgSBJsild7xqSU5J5Z8+eZVBdFHX3iCAgEAhw6dIllJaWgsFgVGsEQ8m6DhkyZMO6deuGANCrgde2gE14/lzyPOE5hAIhWrVqJbSxqerk5uTkhM8//zzqxIkTPiUlJTf0N84UaDQa7ty5A7FYDB8fnzpj6kBVslzjxo0RFhYWdPv27b1//vnn6PpaQ1PjHDN2jLfQQHh75MiRfV+8ePHK0dGxOOx02KNR5aNddu3cmWphYSHKz2/wwL8JDYT+GqjVatjY2KCsrEx46dIlR6FQ+IjBYIiSk5NRVlbWKiIiIjw4ONgBqGsh0/6fACCVSjFo0KCvHjx4sG7hwoXIycl5q/NTHakoV2F9YLPZ2Llz57LQ0NDprVq10p2fJEn1z6tWrSgtLX3RpUsXXSMRLpeLhIQEeHl5fbV+/fo1TZs2BQCMHTvm199++32WsbFxrXNQsUQq6aguK10oFOKXX36Z269fv0MkSeL0qVPXd+3evfXFixeyt5GxpBJ5WrdujU6dOiEnJwdGRkaws7ODSCQCl8vVqbA9ffoUZWVlsLS01DUueV/rjSp7kkgklDfEjCTJ0J49ezb39fUN8encWWhgYAB6DQLR1EHa1N+ru8YJXQ5DXfQtlclAp9NRUSGHSqmSFBcX43nCcyQ8T0gXiUQnx3/2mTopMRHXrl3H8+fPkZjwIufZi+dnGTR6weGjRzRyuVzx8uVLZWFhIYqKiiCRSJhZWVmclFevLB8/efLU3t6eBQClJaXk1KlTAyzMLZ7a2trKhUKh0tTUFGZmZnBxcWFyOBzW8KHDaCqN2rS5a9Nerq5N7Zq5NUfnzp3h0tQVu3bsJAwMDPq1aNG8SbNmzWFsYgwWiyVkVzYlEfD59RJ+fdRXvbCpUlWN0Cogenh4CD08PLqqNZqu4yd8huvXrkkYDEbEsWPH4ul0+vbk5OQCOp0OpVL5QeROhZOKi4trudw1Gg3Mzc3RokULsNls3Lx5E0VFRboY85tInc1mQ0NqUFhUiLz8fKhU2rwQqVSKvn37EVSpFwAkv0y+EhsbK7W0tKx2DLVaDar8s3Xr1rU0FdLS0uDg4NBn3/59MwFUK5vbv3//9fPnzx9wc3PbezY2Fm4tW+LypUvNVGr1ku+//74fm80GCcDe3h4//vjj/ilTpjS1sLCoVyiCqtSgRKfqAnVPmjZtiu3bt4/JzMy8unv37q22trZAHZtdarwhISEtTp06dWf8+PFB+fn5d9zd3cvCw8JejBo1ynb//v1KCwuLMmpD04C6wfivq/NQsWMWiwUmiwkmg0k1AQGfz4dEIhGOHDnSOTw8PKFjx46yyvKP9kePHr3Sq1cvLlCfZa59ZHOyc+Af4B/y5MmT076+vgDqV37TB5PJREFBga5r0utcyBwOByKRqGD8+PH9bt26FcZkMkECEAgErNWrVx8bMGCA261bt9C8eXNkZGRAKBDY9e3bd0fo5Ml+QJVb7ocVP87Mysq+BuCI/kJDgc/n4+nTp3j69Gm1ZhQUjIyMcPfu3cMrVqwYq1Qqz0ZGRv4il8uRmZlZb9auflyaxWKhQ4cOMDc3p5pb6ARFqAYeSqVSl/XPYDCqNU15F1AkLpVKkZGRwdBoNE6NHRxGent792zXvn07KytrrqFh9U3I27rOawqKUBBLJABJQqVSSdLS0hB2+rTIp0vnvY0bN1b8vOpnbN++/Va/vv2ujx49qmLbH9sV165eg1wux5PHj8FgMiGvkIPJYKF5yxboHeCHI4cPY9CgQWCz2TA2NtbGZw2NQBKkMi83V0mn0VlcHk/np+Rw2ASXxZGXFBdL2Gw2JGIx4uPjUVhYiJKSEmVFRYXS2soaQ4YNlWRlZv6hUCjw6NEjvHjxAkqVEpERkWAxmEu7dO6C0NBQ5r79+zgRUZEdJ02c2HnOvLlIS0mj37p+fXTf/v1NHRo7gMVkCUEABkKDOoleU43KqyuM6YNOo8HI0BDBwcFCACO8OnkhLy9/yb27dx/cunnzrEajOZqZkZEoKytTMpnMj5o9T7mz8/PzYW1tjcGDB+PixYt4/PgxBAIB6pon+mAwGLh/7z7uxt2t9Z5ELJWG9O+vG29JSUmMQCAga2adU61ZKcu55logEAh4e/fuDWcxWTpyrKhQYO2aNUePHT821MTEBF27dkUjBwfY2dlBo9HErVu7tv+dO3dmnTlz5lfqGoYMGdI4PDx89vnz51dbW1vXeT3GxsZ4+PAhqDh/fRspao1zc3PD+fPnt02ZMiX76NGj4dprrb0Jpsbt5+dneuDAgVuhoaG+XC73Sps2beQxMTEZo0ePttuzZ0+ehYWFrLi4uCGmXg8Y/+W4BJUok5+fj5KSEohKRZDKpCgvL4dcLodQKDS4cOGCc3h4eKJ7K3eZVCpFeXm574EDB85169aNDtRN5tTilZmZiT/++CPoyZMn0bqYVh266AqFAiRJgsfjQaVSgcvlQiQSIT8/H9QC9bpNAPXd+/fvh//www+nly9f3p96r3///i3mzp27bc2aNZOZTCZatWo1cMWPP+5r1aqVbtWjlo87t+9cy8vLkxQXF4PHq93piU6no7y8HCwWS0esNe8njUbD1q1bg319feHg4IC8vDxwOJw6jwdAl91vZGSEZs2awcXFRecKrXmNVNOY992E6lvi6enpMDQ07Ojg4BDYrl278R4eHg4WlhZg0Kt2/xSB15ccBlTpdNe0vEtFpQBJICsrU3LixIncpk2bHiBJEiNHjnzZr1+/sN5+fpJVq1bBZt8++Pj4ID09HSNHjMCVq1cRFh6G9u3bY978+YS9vT0/dNIkwtTEtHe37t3c27RpC482rdGrZ0/09vdDZHgE187erqWhgaGHQCAw4HI4yMvP/3Hfnr0rnz57ykcN47hCoeDa2tqif//+852cnBbL5XJIpVKxSCx6lJmZGd+nT9/y7j174MKFC3j44AEe3LuPS5cuxRcXFZ3d8eef6qz0dFlERCQ5fNQIpb29vXLkyBHnkl+9OvfTih9x4+p1ZGRkfGNqbo7l3y0XhoeFB+3bt685jUZDYmLikAEDBtjb2dsLaDSCMDI0qkXyZD3Z+zUVFg0NDGFoYMh1dXHxHjp0qHd+fv7Sx48fZz18+PAPsUh0NiM9/bpEIgGbzX4j4b4taDSaLpejW7dusLGxwc2bNyGVSl+7maQ8SjXXWbVajRs3rv/Ut2/fuAkTJszp27dvL0dHR9fFixdXi1FTcsN//PEH7t69W+041PoVFBT0dYsWLbSvVd6nmTM/P/jw4cOR3t7eOpEitVoNBoMBoVCI1m3aICoqasP+ffvHTpg4oR11zJCQkM/j4uLWmpuba+q7Lmp+Uj0X6jM2aiSyRhw5ciTI09NT1xe+JihS9/X1JXbv2n152rRp/lweN7ZFixaK6OjorDFjxtgfPnw4x9bWVkY1zqHGQqk4/tcNVMZ/eadDNQTJyMjAixcvkJyYhPSsDBQUFKC4uNhQIpF6MJmMxy1btpSqlErIFRXddu3adbFz584A6iZzauF5+vQptmzZEmRpaRlNxc5qk7mWPAQCAZRKJRISEmBkZIRXr17B1tYWzZs3R2pqqi7j9HUPK1V28/333w8aOGigysPdQ1eu9t1334WeiYkJ69qtm//y5cs/r9m4JTUlFUuXLf3J0dFxUc34XK3rIwiduEXNCU91NrOzs4NQKNRlKtd3HJVKheLiYlhbW8PT0xM8Hg9FRUUwMjL6aOVLVE2uSCRCSkoKjI2Mmjo6Oo7o0qXLUE9Pz+bmFhag6Z1L3wqvy50O1E5UU6lUkGnV1CQnTpzIt7a23peUlIS1a9ceDg0NfbV71+4KNoeNDh06YNCgQbhx4wZOnTqF1atX42zsWcGePXs8hg8f3nv2F1+gf0gIrl+/3qZTp07dnZ2dYdfIHrl5eQSPyxXQKy0iGo0GlVKJ4MAgBAcG1brm/IJ849u3buLO3bha70mlUrJJEycMGDjApFnTZlQWnxCALYAgQJtk6dezF3p27wFSo4FKrUJ5WbmUBMisjEy4Nm2GGzdvXOnStcvdxo0bY/269di7Z++FQP+A+zO/mCX94osvYGtrIxk6eMjho0eP4tatWygvL19WVFjI2v7HHw5z5swZ5eLigpyc3BEjRgy3NjUzFXLYVCKZnnVag8j1s/OpvGk6nQ5ra2tYW1vb9vbzW1pYWLj0blzcy2vXrh0QiURHU1JSnorF4g92ywPaZ5bqleDq6gqFQoH4+HgUFxe/9jmv67xqtRqmpqbK7Ozs6EWLFkVfvXo1lMViFZaWllYjbTabg/z8PCQmJsLE2Fi3ZgDa506lUmHWrFlfaO+G9u6dOnXq6R9//DHSzc0NiYmJoMpiuVwu8vPzsX//fjx58gQcDgfLli2dMXjI4OsGBgZ0APDy8mpUVlbGvX37tqy+TTignesKhQItWrSAUCjUbvCBWglz1H2p1M2IXrZsWdCSJUui3N3d6yyfpK7B28cbW7duPTN12lR/Pp8f29TVtSImJiY7NDTUefXq1clyuVym37mPmhf/9Z4K/2mXO5WVymazIRQKYWJqggqVAkwm05zH47lXKBT3odGUiktFoNNo3Xbv23vJx8cHQF2laVW13jdv3sTy5cuDWrRoEW1sbFynkhug1Yi+cf0GQkJCoFKpkJSUBIFQgFfJr9C8WTP4+vrixo0bePToERgMRq1SlZrHrFR2U48fN77f7du3w1gsFkhoXfIxsWfCra2sdWOnSOnA/gMPjh0/Nj8+Pv6st7e3rkysLs8N5X780GdGv3Vmv379UF5ejtLSUl2G+4eCGicloSqVSk29vb2n9OnTJ7iTl5e3ja1ttUW2vmRGfXlefahUKpSVleHRo0eSe/fvnaURtCd79+69MWzYsKu//PJLuVKpRPfu3eHWsiXWr1+PmZ9/jmfPnwvPxJwJOnHiePPhw4fj/v37Q7p06WI/atQocLlcIZvNhlqjRocOHTB06NA3XiOrMn6pvwGhQbtJys7NKS8rLweTRqehmtefAKPSy5Kfn1/epEkTMBlM3fVT10ot5PoRUqFAKAAASwsLtG3XFsOGDwsGECyVyvDHHzuwcePGpXK5XJKRkYHFixdnt23b9hCPx8PAgQOTfDr7nG7RvIXkl19+UXTy8nqZlJS0bNu2baDTaMtUKiX32NFjncaOG9uVAFq0bdcuoHWb1kI+nw8mo3qMVt9BT/1f/7ejEQQszM0RFBTkEhAYsDQnO2fprVu3bkVFRUW8evVqa3Z2diGle/++Cz/1bBUWFsLU1BSdOnXCzZs330tiliRJmJiYwMDAAGKxeLuBgQHKysp0c48gCKjUKqSlpkGtVIFBo0OjqrKGpRIJbK1tfLt06WJE3ROlUoU5c+ZMJ0kS8fHxiI+PR79+/XQVNXK5HPb29qDi9GVlstvp6emyli1bGgBa4rWysBygUan3GQhfn/cil8vx4nkCQCPA4XKhrNyg63u5KFBdCVksVvSMGTMCf/zxx+guXbrU6tama78KAl6dvLBl65YzkydN9mfQ6LGurq5lMTExKc+ePWthaWmZJBQKSywtLWFvbw8HBwe4urrC0tJSF6b8L6Ihu6A2LAB4MhiMuPLy8pKiwkLQafT2Bw8frJPMKVDT+Pr165gyZWpA48YOZ0xNTau5o6jEMkowRS6XIyMzA54dPFFRUaHr72xoYKhzDXM4HAQFBeHChQsQi8VvJHUWi4WHDx+G//jjj6eXLVvWnxovRebasRLIysxCzJmYE4cPHx5EkiRcXFw+Clm/DtRiSMXE/fz8MGLECJw8eRKpqamoKxnvXaBvjctkMg5Jkv7t27cfMmTIkIFenTpxGXqblDeVX9FQ3WqXSCRIeP5c8uTxk1tl5WU3fvvtt3OtPTzunDp9WuHo6Iju3bsjLi4OHTt0BEAaP3/2bPyadWsNHz963Kx582ZBCxctAl/A15a3CYQYOHBgved+m9Kw14GoLFB7U614TbypvrwmaCAgEGhzKbhcDgAIrays4Onp2RTAUolUiuycHJSVlUke3LsPezv7M63btH469+uvZb7du/9pY2VV9O2335Z38PS8cOjQoQsP7t9H3759WQ8fPWo7Y8aMAIFA4Onu7t7FraWb0MDAsNpvoq9CVjX+quugETTY2tpi0KBBXiEhIV63b99enJaaGn4mNvZoaWlpJJfLLa9PLOmtrp1GQ1lZGdRqNRwcHFBeXo6ysjIolUoIK/XxAdSp3VBtzJWbAC6XW20zTWWuq5RKBAcHY9DAgdCQJPRDEuVl5TA2Me7P1stPuXz5UrlEKrlCdaCTSCQoKCjAs2fPYGlpCUtLS3Tt2lVnzGRmZhpwuVwdcxMEgSZNmnQ0MDDYJ6hHQ4ECg8FAXl4elGoVQvr3B58vQPzTeJgYm8DU1LRWeEytVsPMzAxZWVkx48aN6/Hnn39G+/r6silS1w9tUUaHV0ctqY8dPaabmtRcsbC0lIjF4lSCILxUKtVdLpdbIJPJ3pg4/F9BA6FXhwkADy6Xezs/P7/w5cuX4LA5rmHhYde6du0GoK7FtmppPHPmjDQ0NLSXlZXVbV2JSg3QaDRdHM7IyAiZmRk6EZWa0Gg0KCkpQd++feHi4oJNmzbpiL8+4mUwGNBoNFi+fPmAkJAQTevWrUGCcl9q3akvXrzInzJ5yiQjI6Pw9u3bIykpSafU9VeBUoKrqKiAiYkJHBwc4OTkhMLCQpSXl7/3wkptEioqKpCTk4Py8nJrCwuLqX5+flNbtGhhoR9eqLlo6KOmG12hVCI7K0v18OHDNIIg9m3cuPFeU1fXs/v275e7urrC2NgYp06fRkhICOvGjRttPD09A62srGwkYvFwvwB/Gp1G5/OFAvj1rqdzFQANNJVWcf0x+n8y6ipR0/cWUKI6BkKhMDAoEIFBgYM1Gs3gixcuAMDy69evq8wtLI6wGMzMnbt2nhs2bHjciZMnKtzd3W8dPXLk1rNnzzBy1Ch2YmJizxnTp3cgaLShbdq0cbazt2dSHgpq9tUUL9EfG51Oh7e3N9fb23toQGDg0OfPnxeeP3duq7y8fHNOTk7W+yZWUmEjSqXQw8MD8fHxuva/HA4Hcrlcp6nwLiBJEiKRCH5+fujbty/EYnGt+alSq8FmscTQez0qKmp/YUEhNGqNrlXx06dPcevWLYwYMQIymQwPHjzQXa9Coah48ODBdyEhITMDAwON2Ww28vPz72dlZdVqQlMTGo0G5fJyGJuagM/ng8FggMVioai4CPfv34eJiUmte6quFKLKLyi4OGTIkPY7d+6M6dOnjy2tjg0oRere3t7YuWf3pcGDB3uWFRbes7W1LTAyMrrH4/HaczicOywWq4jBYPzn3e1AA6HrwwhAM6FAeCcpKUlU2e3IMCw87LKvry8beL1lHhsbmzd8+HB/c3PzR/WRuYWFBY4dOwYmkwl/f39cv3btjQ8hjUZDZmYm2rRpg8DAQERHR+tUm+ojYC6XC4lEQk6YMCHk9u3bp5hMpo7MUl6lyEcMH9EyIzOjYOiQoSgvL9fFzC0sLHSx+rrGVbMN6duCWvjEYjE6deoEb29vXL58GR/i/qS+IxaLkZubC6FQGNi2bduJQ4cO7duuXTtWTZe6PnHq/6l/ZolEgqysLOmtW7fu3Lp162phYeGf5ubm6YWFhdp7KpXC1cWFIZPJOk+bNs13+PDhrdq3b997x44dQhKAQR3CMq9LrHtzBfq/F7VL+rT/otFoFFFwg4KCEBQUNFGhVGDqjGlL4x/HSzp28rrIZrMebN285aqHh8cVjUZTYWhoGHXo8OEoIyOjZbt377Y1MzOb5O3t7e3l5dWpkYOD0EAo1NuQVb/P+nFaGrSthr29vc28OnktDgoOnvfq1auoV69ebc/Ly4sUi8Xa77zD80g92wRBoFGjRsjNzcWLFy/A5XIxYsQIFBQUICYmBkql8p1IvaysDNbW1ujt7wcuj6e9phrj0miT3EjqdZIkYWVtnTBgwIBq10CSJAwNDVFUVKRr/8rj8VBWVgZjY+OKEydOLH316tWquLi4yUKh0P/JkyeXqWe+PmjUatAZDFjb2oDJYFYl9nK5EIvF+PXXX9GvXz/UJZKjVqthYW4OiVgcP3jw4C7Hjx8/Fxwc7FRXSiRF6l06dyb2799/KSggoOnLly+z6XR6voWFxW0ArQA8AVBc60T/QfynCZ3KkDQzM+PJ5XKbMqnsSdy9u5IHDx4AAE6cOHExwD/ACkC1OCNQld0MABEREZlDhw7tZGJikkl19KoJPp+PtLQ0xMXFwdvbu3LCvZ1VRqPRkJeXB1tbW7Rt2xb379+HVCqFQCCot5kLj8fDgwcPTq9cuTLim2++6UON283NjdWtW7c527dvX3jv3j1oNBrI5XJwuVxER0ejpKSkXl3r92nTSBCErsSlXbt26NWrFyQSyWsT5t50LzQaDdLT05GRkSHo3LnzlGXLlo3s2rVrW3Nzc93n6tp8VSW7Vf2OUqkUT58+lRYWFp59/vz5ValUun39+vVSIyMj9OnTBzKZDGlpaZbt2rWb1L9ff2eVWjWoW7duQg6XC2aNetjXlbW9zgL/N1rndaFu+dnq/6rLv8VissBisuDt4y309vHup1Kp+o0cOQrXrl6VMJnMsPDw8Bf3793fbmxsnOvg4JB1+vTp5YcPH8asWbP4QoHgMzc3t65m5uYB7h4eQqFAoGe11y6NokAjaGjXrh2zXbt2/bt3797/+vXrj+Lj4/dfv359a0ZGhtjJyemtvUb6pZd0Ol3XSInBYMDGxga+vr7Izc1FfHz8W5E6Va7p7e0NQ6EB8vPy6vycWqMBi8kk9K+xuKiIfPz4MVgsFgiCgFQqxdChQ9GrVy9s27YNZWVluHPnDrp37w5DQ0Od1kajRo3K0tLSfomIiPiltKSEQYKs1ZJZf3wAwOewQa/RiY3yChAEgfPnz8PBwaHODRJlqZeVlaX069fP8+ixY1cHDhjQQut+B1Djd6OBQK+ePQUnTp683LdvX7dnz54phEJhcadOnR5yOBwnHo+nIAhC+l+NnVNg/JfcFNSPTafTwWAwwOFwYGxsTPz6669G169fTyouKlY8e/4MALBz584LAwYMaAOgVtKGVihEe9+io6NTBg8e3EsoFNZL5gwGA2KxWCcow+VyK13sb3/vaTQaSkpKYGRkBFdXV+Tl5UEqldZb381isaBSqbB06dK+wX2CybZt2monBkHQNmzYsOBuXFzEg4cPr1MTTiKR4OjRozA2Nq63hav+WN5WyEUmk4HD4cDIyEinlPU+Kl8UkWdkZEAqlVoOHjx45qhRo2YE+AcYEXpd4OpzA+uTuEKlRNztO+UKhSL26dOnl+/fv79dJBJJLSwscPv2bRgbG9PMzMx6dO3atTNBEEOXLFniaGZuzjGq4YJ827r0BtSPuuL2DAYDQoEAgYGBQgCjPD09UVxcvPj+vfupIHDo3r17N9hs9vkLFy7I2rVr9/uduLjf+Xw+v127dp+1bNmyK4fDCe7UqRNPP2u+LpIAtFa7mZkZ+vfv79GvXz+P2NjYRRYWFpvi4+M3isXi7CZNmrxzohsFKg/G2NgYHTp0QG5uLgoLC994DI1GA1NTUxQXF+Po0aP1NikqLy+HibGxQSsPdwDajYW5ufmAlJSUdY6OjhCJRHB1dYWLiwsSExNBEAT4fD5evXqF8vJyDBw4sJo2u0AggIODA8qkMpVGrqlXwIXyFtDpNOA1XkLKu0iSJAwMDGrl/1CkrlQqiwcNHNjt1KlT5/v37+9OdWqrdk8qSb1Pnz7OBw8evDhixAif27dvgyRJUWBg4HORSGRlbGxcQRCE8r9M6v/JLHelUqlzW0dERNgtXbq0GICiTZs2mPDZZ+jTt2+0v79/d+D1bvYzZ86IBoSEdOILBHk1yZxKCDE2NgadTodIJNLtzj+kjjo/Px+tWrVCnz59sGrVKigUimpJOPpgs9lQKBSY8NmEfnfv3g1jMBjQQJv1vurnnw8NGTLEXqVS6bKa9RWqXreIUddBqbfpEzz1H9VDmcfjoXfv3iguLkZRUdE7u9gpIs/KykJpaWnTLl26zOzXr9+kzp076wqM64uNUy51isizsrJw7dq1a8ePH4++cvnK1gEDBxQxGAwkJCRALBYzlUpl7wEhA7o1a9E8NMDf35gvENRR0kalm/13NsKfGjVnh6GhIQwNDdmOjo5NNSS51N/fH2fPnhUlJCRsv3///pW0tLQzAoFAZmpq+ntCQsLvR48cMe7SteuU4cOHB/j6+nazsraqlOklam3C9M9FEAT8/f2N/P39F928eXNueHj4ridPnvymUqniGzVqVE1++W1BqT0SBAFra2uYm5sjOTm53u6F1Jrx4sULnDx5UpcgVxekUiksLS1PTwyd9IWAr81XGDZsWOdt27aZyWSyQkNDQ/Tv3x/Ozs6Ii6sqYRQKhcjJyUF4eDiGDRv22kTbWiAI7X8k+VoHI+WhoDq3PXv2DD4+PjAwMKimlEmRulqtLgwJCfEJDw9/1qdPH/u69N8pUh8+fLi3WCyJ2b59W4BcLsfq1avlNBotd82aNWZTpkzJkUqlkEqlOqW//5LRynhdzfH/G6gOXfHx8bhz5w6ePn3a7vbt2zIAGU2bNoW9vT18u3eP8vf3r9U1TXeMyoX8/Pnz4uHDh3fRJ3P9HS1BaHf+9+7dQ0lJCRgMBiiZyg9FeXk57O3t0adPH9y+fRsFBQU6Yq2pAc1ms/Ho0aPwn376KfKbb74Jphz9vXv3tpsyZcr29evXhzo7O7/zJoPFYsHV1RVFRUUoKysDh8PRSbdSOuhcLheenp4Qi8XvtRBqNBrk5eWBy+X6duzY8UtfX99+bdq00X3mtdr5lVCqVDhx/HjhuXPntllYWJx+9uzZHYIgkJefh7Nnz9JatmzpP3jw4F6Ojo6TunfvblAz5lefCmAD/npU5R5U/ZtWqWs+YMAAQwBzRSLR3EuXLonT09N3XLt27Vx8fHxsqUhUQqfTVx48eHDlpUuXWrf28BjUyt091M3NzdLExKTeRDpqw0YHgU6dOrE6deo0+dGjR5OvXLkSkZCQ8EtFRcV5MzOzd/YuURnrIpEI7u7uEAgEuHfvHqRSKczMzKp9lhKays3N1Qm31AcGg4HMzMxL586eSw0JCWkMAHZ2dpg/f/7hNWvW9JRKpboeBzXLUAmCQHp6OsLDwyEUCnVyt69dBwii8tF/t7XCxMQEN27cgEQiQd++fXWNZiio1WqYm5uDIAjpkCFDup08efJaQECATd2krjWoJk8O9Xdr2SJqy+YtQRVyOV4kJsoXLlpIF4vELWzsbJ9ZmJujUaNGrxW++X/Ef85Cp4hFqVR6FBQU0Bh0RoJQKIREIoGPj0/UoEGDavUzp0AtBDdu3MDIkSN7cDicJ0ZGRrVKU0iShKWlJeLi4rB7924AqFPtjWoEUlFR8db6xPrZ4mZmZmjZsiXi4+NRVFQELpdb6zhU57Fvv/22T9++fcnWrVtDU5lfs3z58klnzpzZ8+jRo6uUJvrbQCaTwcXFBQMGDMCJEydgZmYGc3NzMBgMPHv2DFwuF5mZmaCsGrlc/tadsihrPycnBwRBdOvQocM8Pz+/oGbNmuk+o5/PQOotyvpEnpycjLCwsNjHjx/vePr06cm4uDjlgAEDwOPx4OTk1E4oFA4ICAiYHBgUaG5kaFRtDG8qG2tws/+1qKmLr49qcXAQqLRCDQB8OXbsuC/PnIkpPnfu3FYHB4ew5OTkW4mJiQ+zsrIenr9wYamFhUXI0CFDQg0MDQPatWune170FeoIVHfHe3h4wMPDo8/Ll4l9zp07H/P48ePVIpHoAp/Pf6+wUW5uLtzc3GBpaamV1FUqdVLTFCid9KZNm762w1hl2Rk2bty4KCQk5AD1+oQJE3oUFRVFL1y4cHRGRkYRoE2yS09PB5vNFsrlcgm12U9ISACNRoOrqyscHR3rbbpSReaok8+pdakug4UkSZiZmeHJkyfQaDTw8PAAh8OBVFrVr4ki9dLS0pRhw4Z1Dw8Pf9G1a9caiZXav1H91H28fQLvxt2NunPzVpCJkTEqKhSZa9asad+hk1db365d79vY2IDNZr+2Cdb/G/4TMXRKwYzFYsHQ0BAcDsdWqVRKGXRGslQqhaxMhqFDh+6dN29eLTKvmRF99+5dTJ48OYDD4dwzMjKqU1XNxMQET58+RXR0NIC6yZxOp6NUJAKAPlwul5eenn7kbfv+Ukk4UqkUIpEIn3/+OaKionD79m2dpa4P6qEeP358/7t3755mMBggoXW9r1u77siSb5a0MjIyKnybTQW1i2cwGJBKpSBJEmw2W+eRaNq0qU6SUq1Wv3WsnSLyrKwsmJubd+3UqdPCnj17BlCNY4C6ibxavThJ4vz58yVbNm/Zampmuj88PDze0NAQnTp1QkJCgolAIJg6cODAfu3bt+9oZ2dX7fwfWvvdgE+P2uRugKFDh5oMHTp0YXZ29sL79+4/DA8PO3bs2LEt/gEBRYWFhSeOHjt2Iic725UvEIwfMXzElMCgQBPtfKGIA5V/ktWI3cXFFS4urgFJL5MCLl66GHvn9u1VuXl5FwwNDd+Z2JVKJfh8Ptzd3VFUVASxWKzr+FZaWoq0tDSkpqbq5tWbcO7cuYPr1q0LnTNnTnfqta+//jrAzc0tPTMzc2tJSYnYxsYGc+fO7c3j8VodPnzYSaPRFNJoNPB4PCgUChw+fBjNmzcHn88Hm82unhCnT+Z1gFqPKC+EpobAjn4v+BcvXkAsFqNZs2a1jA/K/S4SiRLHjx/fY/+BAxc6eXnVOTMp9/vs2bMDk16+PPb7xo2DeVweGjVqdLd5s2bNnZ2dnTgczqv/EpkD/5Esd6q0hCRJ5Ofnc1etWqW+efNmMuWK8fX1Hbt9+/bRQF39zCuPAeDFixf48ssvgxgMxhlzc/M6s0CFQiEyMzNx7do1APWTeWFhIRQVip5/7NgR3rp1a+zYsWNMZETEV2lpaYktmrV4a2KnWn0OHz4c+fn5SElJAYfDqbUQMJlMPHr0KGzlypWRS5YsCabe7dGzh1W/uH4TZTLZqjc1taDkI6n2pVRtrFqt1tWCU+73d7XI09PTQaPRmnbu3Hn5kCFDhzVvXt0i1y87q2mNFxYV4uKFi/efPXu2//Lly1vT09NlwcHBsLKyglAoDOjcufOwCRMmDPXy8uLpLyKvq0tvwL8HNSVEaSBgY2MDGxub1oFBga3HjB27OOVVyok9e/fsLywsjLa2tk7cv3//ooKCgu+uXL0S6u7uPqp3b7+OFhbmek9VdZETakPv7OIMZxdnv65du/qdOHHixLVr15ZmZGTEGxsbv9NmvKKiAgqFAk2aNEFOTg7S0tIglUrRuHFjpKamQiKRQCKRvHEOUe9/9dVXAS1btnzl5+dnS70XFBTEA/ClSCyGUCjU5YPs2rXrxIoVK7qmpqZCo9GAyWRCqVTiyZMnMDMzg1qjrvIMvCWZp6Sk4KuvvrrXvEVz2ujRo9uUlpbC2tq6VqhNIBCgoKBAt3Goq069cm29OGP69MC9e/dFu7m1qPZ7UKBI/bfffx/0IjFx2tmzZzc/fvIYao36ecqrV1Y//fQT19nZuTwjIwNyufw/EUtn/L+3oqPRaKASn6Kjoy0uXbrU+OnTp4+YTCbs7OzQrFmz4BMnTuwmiNrxGi20D012TjbWrFkTxOFwoinNcUo/mDoPl8tFRkYGEhISAEA3UWqisLAQKpUqcMvWLVGtW7cGAMyZM6dPd1/foLXr1v386NGjVSUlJaXAm2tiKcUquVyO3r17IzY2FmlpabWaobDZbKjVanzzzTd9/Pz8FB06dGAmJiZi4cKFiywsLLaYmJiAqsOtDwwGA/n5+RCLxZDL5XXWmL4tqOsSiUQoKioy6dat2+Lp06fPqR4jrw4S1S3yxMREFBQUxG7cuHFDQkJCZKtWrZCQkIDAwEDDJk2aTO/evftIHx+fljXL2erWB2/A/wtqisp07tyZ27lz51H+Af6jHj58mHTy5MmdTCZzc0lJSUlubu5vERERvx09ejRw9qzZs6ysrQKaN2+uS6bUPxaVKU8DgaZNm2LhwoUDHz96PHDL1i2bUlJSlolEogLg7evY1WotcQoEAshkMiQlJcHNzQ0dO3aEsbExIiIidB6w14XDKmvcFQMHDmy3cuXKQ59//rmv/vuGla2LKQIcPXp0FxMTk8fBwcEdCYIop9ZIJpNJtQ8Gg1XVO+J1OvUUmc+aNSuqW7dubQGgrKzs7LSpU/sUFhZW6OcAUAYIn8+HVCqFUqkEg8GAQlG9WytF6iqVKubbb78JWrlqZZSLs8trLfXw8PBNQ4cOzXj67GnE48eP8eDBgzy5XN5izJgxeRYWFoWWlpZ/uRLmPwH/32xeiUphBQOCIFxlMtlLgiAqOBwOunTpErh9+/YIDodTp7VG7cqlUinWr18fJJVKo3k8HkpKSrSyjJUqUYA2SaysrAw5OTkwNDSsNxYllUppZmZmYxYsWLCLalFIJXq0aduWtm/fvgXXr1+fdiYm5vvMzMy1xcVavYTXLRLURKHRaLC2tkZJSQk0Gk2tJD1qwi5ZsmTK6NGjQ0+ePPnt9evXz40fP15nKdcFyjI3MjJCVFQU6HQ6qI3Iu4K6jpKSEuTm5nKdHJ3mrVmzZk7btm118pO1a/6p2nEtHj16hKtXrhxPSU3dnJ+ff76goADdunVDRkaGR3Bw8KgxY8ZO6dKls0G1NpSvics24N+N1/2e+m5zCwsL+Pn5Offs2XPFsGHDFh47dmyrWCQ61K9fv7v37t2L3rZ9W7SRkVFXJ0fHaT179Rratm1bGrWB1NRzTHcPd2zatGn6o0ePxty8eXNdXl7e6pKSEhnwZmKndB1UKpXOIKioqIBSqQSHw4GdnR3EYjHEYjGYTOZrj2diYoKSkpK87du3d8/Ozv4uMDBwtruHhwFF5tR4lSol8nLyUF5erjIwMCD0N/FUEyjq72+CRqPBy5cvMX369JNffvllIPV6aGhoLzqDfmf9uvWe1tbWCupa1Wo1ysvLkZKSoss+pzwBlNIbk8nUtrJmMmFtbQ0DA4Pow4cOBy1ZsiRKX01OP2GShNZgOX7iRPisz2cGnTp9Kjo/P5+MjY0tkkgkLUNDQx+ZmZmVUEJW/8/4v7bQSZKEUCiEtbU1Tpw4YXD9+vW7EolETpIklAqFy9y5c6M4HI6OPmqXPQEVFRXo1rVr3/sPHkQLhcJ6W3iq1Wrw+XyYm5u/NltULpfT+/bps7iKzKtbjADg4+Nj2KlTpzVRkVFDFy9ZvCwvLy/a0tLytS49KpNWo9FQgg2Qy+XVkmoIQptE9Pz5850bNmzYaWxsDFdX19fuXCmRmoKCAl3Pcjqd/t6iMEqlEgUFBbC2tu4/derU37t07WpHuQL1Xeu686OK2O/evUsePnx4a2Ji4gY2m/1cIpHg3Pnz6Ozj4xcYGPillZVVgLu7u+67NWuPG/DfRU2r3dfXV+Dr6/vV0/inXxUUFsQ+fPhwXURExBlfX98r+fn5V2LPnl3crFmzL0aPGj2to1dHBk13nKoEuhrJc8JW7q2WtmzZcsqff/458/z588fatm371smuFPSbv3Tq1AlGRkbYvn07lErlaxsXqdVqCIVCNG/eHDdv3vx2w4YN66ZMmTItwD/A8sWLhDGGhkZMpVJxPi8v/1FKWkq0vZ39bSMjozd65eqb55Q07ZAhQ9Zs2LAhhLof2k2DCmGnw7YWFhSqFfIKXZc6Go2Grr7dUFhUCJlUBqBKqrqoqAhsNlunZV9aWorc3FwYGhriyeMn0ffv3Qves29fpIDPr8P40npSGHQ6Znw+I+rQ4UOt1Wr1IxMTk1wjIyOJSqWytLGxKZFIJDq1vP9X9zujpKTk7x7DXwJq95eWloZ9+/a1WLRoUa5arZYzKltQ7t2374iHh0e1GLnWEqzeOa1///5f3n/wIAKALqal/x9Q1bWNmoivI7uysjLlocOH586cNes0dV6VRoWK8goI+NpGFxpok0r69O3ToaNXx6gzZ87EXr9+fU1WVtbZNyXOUb2BDQwMdCpw1KJCKeMZGhrC3t4earUaEomk3mORJAkOR9vW8saNG7C2toaJiQlE2mS+twZl/WdnZyM/L88vODj4q549e/pRLnuN7s7XVuEDgLi4OM2xY8f+uHXr1mqSJJMEAgHy8vJgaWExaOPvv0/r169fTysrq6p70EDiDXgN9GPibi3dAMCvRYsWfpGRkRdjz5zZlpeff4jP57+6f//+rFu3bq318vL6etSoUaFeXl4s7cwjqnmRdK54gobOnTtbeXl5HXVxdo599vz52hcvXsSamJi8V68CpVIJtVoNb29vyOVy3L9//7WkTuWz2Nvb4+HDh6VMJvOnyMhIbNjw6yLnJs50iUQiGT5iBBgMBkxMTOrN/qZc6frrGpXgqg8fH58hhw4d+kp79VXhsD5BwbNjz8Zu4jBZKC0pgVqlhlKjQicvL3C4XMjLq+LZGo0GQqFQp1NBGQs1Lem79+5G9evTZ+L5Cxd20AiimiGkb4i5ublh586dx4cOHeosl8tx/vx52Y0bN/ISEhKc2rZt+8rZ2RnGxsYfpXz4nwgG5dL9fwOTyYSxsTHSM9Obbd+2na1Wq0VcLheOjo5YsWJFdEhISGug+sNA7fqoB3PWzJknzpw58wulb17fpKRq0B0cHHS9wuuDSqXCs2fPws6fPy/u2bOnAQECdNCwaMGCCEMjI/H3338/Ut/NZ25ujtGjR/t16NDBb9++ffu3bdv2FY1Gy3ud4AQ1GaisWX1Sf1uQJAmBQIDbt2+DyWSCy+WCzWa/tld6TVDjKy4uRn5+vmH37t1Xzp79xVQXVxfd9VXPK9YuCtREjY+Px+HDh3dfuHBhOZ1OTzExMYFEIoGVldWo0NDQOcFBQW1ZbJ2+TINF3oB3AiUyQ7njP/vss+6jR4/uHhMTs/jMmTO/EASxg8Vipd2/f//za9eu/dSzZ88lY8aMmerh4aFX8lbz/1qrc+GiRX6ZmZl+q1at2nnz5s2viouLS4C3j69TRCqRSGBpaQkrKyvcv38fCoUClFFSHygxFyaTCQFfABdnlzIHBwfIZDKtiEyZ5rWuZ8oLSY2BwWBAKBRWtpg2BQHAxsYm6ODBg0doNFq1dszjx4/fEXs2dgOfy9OJS6loKtjbNEIjBwco64iXMxgMODs7IyUlBSKRCGy9OQ1UbVQuXrr0Z2hoaPc//vhjtH6HNt11V46jf//+TcLCws4sWbLE/+XLlygoKCjbsWOHAY/Ha9WyZcsnBgYG77SO/ZvAeNcuQP8WMBgM5Obm8iLDIyVl5WUJgFaQJSQkJDwkJEQnHKO/y9Mn88OHD0efO39+kIODA3Jzc19L0nQ6HRqNBqmpqW8VNxOJRNi8efNvPXv2XAxoLVj/wADrPsF9+srl8vMjho9Y3bZdWxP9Kevq6orvvvtuVLdu3fpHRkauffny5ZqSkhIpdcyaoDSV34fUSZKEkZERlEolbt++jdatW4Nf6T14W+i71zkczogtW7Zs9PHxMdaNrw7ipe59cnIyLl64EH7u/PkV6enptymZXkdHxyk9e/acHhAY4E71XG4g8Qa8D+rTeGcymejbt2/L4ODgP87Gxi64cvXqbxqNZoNIJMq6fPnytBcvXmz18/P71s/Pf0DTpq6VT2xV9YX22Npn2c7ODr/99ttnt27dGnjkyJEvUlNTd/F4vHfaXNNoNJSXl6OoqAjNmzcHk8nE48ePdfLVHzPJi6oG0id7KinPyNAIjk6OMLewQEs3t8CFCxdGEgQBNbRCPACwdOnS6JMnT06ys7FFaWmp7vs8Pg9cLhdyuRw1W7JSoUImkwlHR8d6Sb1S1hYRERFjNm7caDpjxozAmqRO/QIEAH9/f7+4uLiob775Jkg7DPLhhQsXGoWEhAgsLS2lGRkZ/5dud8brhAv+jaDRaGCxWLh3757l1q1bbZ48efKQeq9bt27jV6xY0QeoqxtUFaFs3bo1dvXq1UEajUZXmvW6H5+ST6U02t/0oPB4PERHRW9ITU1d3LhxYwBAcFBwuyFDh87ds2fPGqFQeOzsubPzu3TuvMhbrwc7DQR69uwp6Nmz59LLly5N27t376zr168flkqldfYSr4vU3wTKzZ6dnQ0jIyNdksrbfBeoCnWkpqZCIBC0//LLL1cEBgb6Gehl2lb7vN4eOz+/ANeuXY09f/78mpSUlLPFJcWQiCVo37794OHDhi31DwhoSVkmVb9fA5k34ONBZ7XTaPAPCHDu7ef36/nz52eeOHFi+f379/eVlpY+DA8PH3j37t2e/n5+83r07OlnZWVVR0Z81Zri5eVl6OnpudPM1GzEgYMHlr98+fKGra3tOxEKJT41efJk/P7770hISIBara5FfO8LfTKvOS7K/Z6ZmQkWkxU4fPjwKG1VUFVocs+ePVGRkZHB9vb2yM7IgrRMBiadCTqDBjbB0R1XrVbrhHP0z61P6qmpqSgtLa3z2uzs7BAWFhbk2NgxJig4yP91anJLliwJvHz58oxz585tLCkpwaVLl9IXLVrk/sUXX+QaGhrm/z9mvTP+nwrvSZKEiYkJTExM6AUFBVaFhYU5BEGQLBYLffv2Ddy9e/dOQPuD1yRz6t+RkZFpU6dO9aeOSemSU8ev65wkScLR0RGNGzdG+VsQHwEgKSkpPzIi4uqMzz/vQu0qJ4eGLjh65Miau3fviiUSyeKzZ8+eHDVq1Dft2rXr2srd3UhTOVo6CHTz9bXw6dz5kFvLllPS09NXpqamxtYVX69J6vXFvyk3HYfDQWJiIq5cuYLhw4e/NmZXEwwGAxKJBCkpKQgODl42YviIpV6dvLTHf41FriFJREdF3f7++++/c3Z2jlKpVIiOjkZgYGDfr+Z8NW/AgAGdqd+gIVu9AX8lqmdPa4m9d+/ezj179twbHhb2+d59+34KCws7PWzYsPOnTp8+/+NPPwV89913i0NCQjrrbzYpUB4kOp2ORYsX+fXp28dv9+7dP0RHR39jamr61tY6pbgol8thbm4OU1NTPHr06KO4jl9H5tS5CwoKYGVl2WPFTz9GOTk5Vcsz+vPPPy9s27YtuGnTpiguLoaZqSkYdAZepaQgNS0VAlSvv5dIJAwWi6Uy0MvA1yd1BwcH0Ol0iMXiaqQul8uRlJSEhIQEnD93PuDI0SPxAwcOdNMX/wKq1P5oIBAREfH75MmTX508eTJaKpXiwoUL+U2bNnUYOXKkqKioqKK4uPi920L/E8F4UxP7fwsonfa0tDRi//79Tf74448kuVwuq4y/NF62bFkUj8erJHMt9Ps0EwCSXiZhcmjoEP3jvQlUbF1RoUB6Wvpb6QYT0BLoH9u3z/tswoSbVM14jx49TBs3btw5PDz8mpOTEzw9Pe+GTp7cf+CAAb8fOXJkhr6utQZatbYvv/yye15eXvcjR47EXLt2bX5paWm8TCbT1Ez6oNFoYDKZUKlUtdTbSJIEn89HQUEBlEolpFIpVCpV/TKQNa+n0ipPSkoCh8PpNXv27MUzZ870pd6v6Q3RT3iLf/JEcvzEiR+OHz/+s0AgoLwdft9+883chYsW9+Zw2JXHgK5+rcEub8BfCbLa86oFjUZD/5CQjoFBQad+/vnnc/n5+aulUmmsoaFhzMKFC2Nu3rw5e+TIkcvbtGljWJUDo584p33u3d3dsXbt2iXOzs5dT548uSIpKSnW2Nj4rQiFIt7CwkIMHDgQ9vb2OHTokO6998XryJzqxMhkMKz++GNHbOvKRGL9tdPW1taRJElfsVh8ycHBASwWC3b2doiJjkFKaoqOzBMTE7F06dLbo0aNMhs4cGCH/Pz8Ijs7O52LnyJ1BoMBOzs7ZGVlQSKR6IwKkiR165dao8b48eOHNm/W7GnzFlrhGaB2KIXNZmPx4sVRx48fb06SZIKJiUlufHy8eNeuXXatW7dObtq0qS5n4P8BjA8RB/mngJIiNTExQXx8fNMDBw6wJBJJGY/Hg421NVavWXPEzc1NF+HS/+koMpdIJFi2bGkQSSKOaj36tuDxeMjPz4NCoXwnUYm0tLRbMVHRSQMHD3IGtIvGjBkz1v7w/fcdLSwscPPmTfQJDl7566+/jgdQzcWlT4qWlpaYOXNmQEBAQEBoaOhYKyurvTXbqpIkqZ1odnYQiUTVro+yEo4ePYqmTZvCzc3treNzlFWem5eHgQMGrJg4ceIiV1dXaMdLAqSWgWuGNTIzMrB69ept12/cWNSzZ88ipVIJGo3WwsfHZ/WAAQOCKGnWapZ95SX/f0y9BvyTQdZYLahnjsViYcmSJb1ysnN6hUeEn8nOzl5SUVFxl06n/zpy5Mg9PXr0WL5gwcKZ9vZ2qN7bm/q7dg5Pmzata+/evbvu2bPn51OnTs3ncDh4k1KjPuRyOdhsNrhcLsrLy3UJb291bZX15pRHgfLsUaFFKglNH4ePHD3btVtXnYWjn7jr7+/vaG1tfXHu3LlBWVlZ0VZWViguKtaF6TQaDRITEzFnzpyoYcOGdQCAw4cP35oyZUpgfn5+Ul2udTqdDkNDQygUCl0iIABdr/VKNcxnixYuCtq5e1eUkZFRnesCCW3+0b59+w7Nnz+/dWlpKc6cOVN248YN7vfff9+qSZMmT4qLi6FUvv3a/U8Go6ZKz78RBEGARqMhJSXFKDw8vIwkyQRA25BgyZJvooYMGeIJ1O2iJaB9wAMDA0ddv349WigU6moh3wZyuRwWFhZwdHKC/B0zwDMzM3Hi1MntAwcPWkW9Pm7cuA779u2zVigUOSH9Q07+uuHXEO3YtQuBWCzGkiVLto4ZM2acp6dnNda+dOnSVRcXl/MCgaDOh5PJZKK0tBR37tyBSqXSTRImk4nk5GRkZ2ejffv2b+dlqLTKExMT4eLi0nXChAnLZ82a5Uu9r9u/E1XZ6xTWr19/7urVq6szMzNjK8vshEOHDJnnHxCw2Nvbm9A/RgMa8E8CZWlb21hj8uTJ/h7uHv4XL138Sa1WrzIxMSm5evXqrMTExPCePXt+PX/B/N60SpOhypVf1VzE2dkZ33333Txra2uvQ4cOLU9MTLzQtWvXtxakkclkMDAwQOfOnREXF/dW8qYajUZH/AqFQjeP9fOEKMKkXOTbtm2LHTAgpCVQJfL0/NkzNHFxBovJAgnA3d0dq1evjlqwYEFQUVFRtIWFhe54RUVFGDx48I8///xzIHWMkJAQZwaDcX/NmjVmdnZ2tUiICp/evHkT9+7dqzc0cSrsdHRWb79BN2/dPE6n0+tdM0JCQjxkMlnU6NGjgwCAyWTGx8bGNvb09DQUCoUiShr83w5GWVnZ3z2GD4ahoSGkUqnRDz/80OLEiRMPKTLu7tt91qTQSfV2T6NIZu7cuSeuX79+AEC9fYrrA5vNRn5+vrYpwTuqEKlUKuw/cGDr3K+/Xtraw4MHaMvUPDw8ptBpNKE+mRPQ9vMOCgrq9/jx4/BXr15tCAoKWjts2LAALpeLb7755sSdO3cGtWrVCuXl5XU+nEwmU9dQBQDYHLautOVtm6gA2l2yQqFAamoqvLy85qxbt24t1Q2NCmlULWCEzqvw/PnzsoMHDnyzZevWdV5eXnBzc0NxcfHQASEhm719fEyo49clttOABvxToJ/w1tGrIzp6dVx4+/btaUVFRbO3b9++RyaTnX327NnZgoKCGePGjVvp7u4u0E/e0k+go4HAtGnTuvbq1ev8vHnzFmdkZPzIZrPfeg0qLS1Fx44d0bFjR6xcubJW50cK1Jw3MzdDUVERdu/ejaKiIvD5/GrzXqVSgU6no0uXLuDz+Rg2bFjU4MGDewNV61DcnTh8PvPzPt7e3v3Wr18/mQqBeXh4YO3atVHz588PEolE0RS3dOvWbdzhw4cX6h9DpVLhzz//nJOSkqIuLCys89qYTCaKiop04jP64yQIQicZG3c37sTMmTP3bdq0aXTNJDkq850GAqNGjQrcs2fPvNjY2J/FYjGioqKyFQpFuyVLliQaGhoWUZos/2ZL/V/dPpW68TQaDWfPnjW8efPmEw6HUyaXy+Hj4+MfFh72K6AvGFO95hwATp06debkiZOD+Hz+O5O5fhe395EUZDAYAEmK/ti27fDvGzd+Rr2+4dcNSw2MtLkN1AQoKCjAnj17gh4/fhxtb28PU1PTZ7dv3w7k8Xghjx49an306NFl/v7+OpfZ68ZMTdrMjEwUFhaCwXp9XSsF/bpyPp/vOHjw4C2TJk3y0x0bVWQOVIUz8vLycPz48diDBw9OcHFxyWrUqBE4HE63oKCgRX5+fn5UHkfNJiwNaMA/ETX7qdNAoGPHjkaenp67jYyMRt2+fXt1RUXFuZKSko3jx48/OnLkyJ2jRo0K0leHpI5DhdFcXFxw8uTJFbt37/Y9ffr0jOLi4pc1ybY+lJaWokOHDjAwMACNqGpXTIEKSXK5XGRmZGDf/v0oLCxEXS1gqfWjsKAAI0eOjBo8eLDOIKKBwKtXr7B4yeIgMzOz6HPnzkXOnDnT9rfffgumSL1Fixb4ccWKqJ9WrvTn8/mxA0JC/Pbs27erZr36gJCQbyMiI/+gVCjrAyUJW1fiGo1G0zWXOXHixJguXbqYjhgxIrCu9YM696lTp1aG9O//5Oy5c9EsFktx//79hIsXL5qEhIQUUffq38yJjPdRMPongHpIzc3Ncfbs2aYLFy6UqtVqiZGREQiCoK9atSpGIBDU29ecABAREZk7ePDgABaLBarW+V1Aua09PDzeu++uVCrFk/j4TWKx+DMDAwNoQMKwBpnHx8fjyJEjQcbGxtHGxsY67Wdzc3NoNJpTIpHolImJie6+1AdqArBYLBgYGCDu9h2QBKq52+oDNaGys7PBZrP7rlq56qhHaw82AKhBgpJorRkrv3r1asGPP/74WUJCQqRKpYKlpSUxePDgVQEBAV9TevANmesN+Dehvh7tNBoN3377rV9iYqJfVFTUhidPnnwtEony169fH3z69Gn/5cuW/9GjZw87fU1yypcFaOf6uHHjerdr1+5paGjo4Nzc3DAnJ6c39nEAtKE4oVCIjIx0mJiaQqlUgiRJXVyewWAg/mk8Ll+9Ao1GA4FAoIub66OycyJ3+IgRUaNHj/alro+az0eOHAkyMjKKtrCwAJfLxcmTJ/soFIpjW7duHaTNLgdaubvjqzlzzpw8dWrNDz98P5dS1qOOMXny5IMRkZHfGxgYgBLtqu/aSI0GShpdKzhVx31gsLTe2JKiYowcOTKIy+Umh4SEONXXnY3L5RLf//BD1O07d/gsFqusoKCgZPny5WwjIyO3gICAZ4WFheS/WRr2X0vogNYlk5WVZbR//36lRqPJodFokMlkxL59+6J9fHzqpAaKzOVyOebNmzfkXVzNtY5FVPUlp/p/v88xkpOT7x4+fPhOaGhoh5ruuAcPHmDZsmVB7du3j64kcN139Xfer7PMqeYqarUaNjY2aNKkCVJTU8Hj8yGveHOZHYPBQGFhIZKTkzF9+vQdI0eOnGBrq+3SSE1Uqn80JTKRk5OD7du3n969a9dYM3NzsVQqhampqd/UqVPX9erVy003tgYCb8D/Cai54OrqCldX11mXLl3q8+DBgxkqlSqmoqLizIiRI1ynTJ6y+8svvxxibKLVjajKGK8SpGnZsiXzxPHjp48dP35w06ZNI83MzGoJstSH0tJSeLRuDYFAUOmyLoSBQIjsnBxkZmWBw+HoqlfqWi8q1xd2p06dfPXHJJXKMHbsmD6ZmZnRCoUCr169gqWlJdzc3HDq1KnBDDr9xMZNmwbQKr/Trn17tGvffq7+fQGAlStXRp86dWpk48aNUVpa+kZrWLc2U9ZNXSABjVq7Ln75xRcjevbsdVsoFOi+Vv2jJDp06IC9e/eeHj9+vB+TySSVSmXB0aNHBe7u7gI+ny8B3q45zT8RDKFQ+HeP4Z1BNV1RKpX8xYsXO54/f/6pQCDQyGQyhISEfD906NDe9X2XgFakYdiwYf0yMzOuvatykz5oNBo4HA5SU1PfyzoHtA9scXEx9u7Zuy40NPQQtVcnAESERzxbuvTbaU2cna8YGBhAJpOhvLwcHA7nrbPQqZK08vJyXLt2DZMmTYJKpYJCoXjryZSdnQ2BQNBqxowZv86dO7c7UBcRE6DSCG/dvFm6cNGi0ffv349s0bw5cvPyBFOnTt05Y8aMwZTmuua1M7QBDfh3gsohIQD4+vo6nTlzJnrbtm3hR44cGdeoUaOS02GnhzJZzEAPD49d/fr1s6gZ86XmhbWNDWbOnDlCo9HYnjlzZm52dnYc8Pr4LuVpk8vlGDRoEE6ePIkTJ46jd49eyCsoACq7mb1u3leGD0vHjRvXdfv27Re7detGV6lUCAwMGHnt2rVI/c8GBwfDyMgIbdu2RVR09MDp06bt2bBhwxi6nmiMfkJseER49K1bt4JatmyJzMxMXTJzfaDRaFAplSBIgKDTXnvtTBoTNA0NObm5dwYNHNgnLDwsQtt4q/q1UqtO3759e/Xt23fd4cOHv+TxeOobN24krVixwv23335L43A4IrFY/K+00v+1MXQ2m01ERUVZx8XFJXM4HIVUKkX37t399+/fvxiovvOlQD1YCxcuPBAWFhbOZrPB5/PfezemVCphaGiIRo0avbWSWl1Qq9XIyEg/fe3aNUnnzp11O6yHDx+k5ublXbGzt8eFCxegUqng7Oys6170pjpxyuXGYDAQGRmJrModelFR0Vu52AFtIp6lpWXf7du3n3Z2diYAatdLVKsLJwCUlpRi166d0evWrx9tYmJSzGazwWKxg/bu2bOjc5cuVkCV0IZ+TX0DGvD/hCoRWK1c6eLFi/v27NkzedmyZRNSU1NPRURERO/YscM56WXSgbHjxvYxMzMDoL9JJqGpTCadPXt215D+/e+MHjMmJCsr6zTwelKnPHUKhQLl5eVQKlV4kfQSpEYD5lsYLiRJgsfjgUajXZ08eXLnjRs3xkRHRx++du3aQSaTCSaTqdNff/HiBRgMhq7ka/OWLWMlUilj7969I7RXUbVl//3336M3bdoUxGKxUFpaColEgoqKitevQ9oiGTAYdIAgXl/2QgBMMFFWXoaz585GfjH7i21btm6Z/DoluR07dnyRn58fGx0dHc3hcPDo0aP0c+fOmQ8cOFBE3Yt/GxgZGRl/9xjeCRqNBs7Oznj8+LHDokWLGPn5+WIejwc6jYZly5dHMZnMeuPmAPDnn39e2rx58ygmkwkGg4GKiooPGk9WVhYKCgo+6McnCAKlpaXyX3/9dXPnzp3nUY/4uPHjgrZs3ep0+/btV1QszNDQEGKxGE+fPkXjxo3B4XDqTMijyJxGo+HMmTPIysqCsbHxWyXvUVnsiYmJGD9+/Nrvvvtujo2Njfa41JhBgiSqMtgLCgrw+eefD71///5RHx8fnD59mjN37twDs2bNGlB7wWqIlTfg/xVktb9TJWpeXl7GBw8ePLlx48aIrVu3jrSwtJAsXLyw79VrVwf8/vvvJ2xtbWvUrVeRukPjxjh65Oip73/4fuvLly+nvk3yLkW6ACASicDhcGBoaAiZTPZGj6RGo4G5uTkyMjJu7d271/bVq1cyLper6+QIVKm21UQ3326W1BVQ69iePXuuzJw5M6jmZ990DSSpbYlK1yYPv/azFOgMBjRKEtu3b5/i0drDadq0ab2qjAf9DZO21v2bb7+NunjxIpPNZquKiopKFy1aZNa4cWPnxo0bJyUlJf3rVOQYdWmA/1NBEATYbDYePnxocfToURaTydTVm+/atSu6a5cutNfFzV+8eIGJEycOBAAOh/NBLfTUajWYTCYaNWqkSzb7EAiFQty5c2dTfn7+PAsLCwCAvX0j+Pn5fb5z5845lEwi1R0vNTUVHA4H7dq1qzVBKT12Op2O8+fPIzk5+a0lXOl0OkQiETLS0+k9evSImDBhQgBALTHav1GbI2o6/vTTTxcOHTq00NHR8Q6fz0cTJye/PXv2bB88eHAjoHp71AYib8B/DdTzb2xsjCVLlvTp3r37y9DQ0PEsJitGIBCc7NatW+sxo0evXbpsWc+q9qwARTwECFhZW2Hjxo1T9u3b13jfvn2DRCKR7G21Muh0OphMJqjwqlQqxZuacqnVanC5XFhZWclKS0t1KnXUsQDoxGlIkkR5eTm2b99+dtLEST30Z/iZM2eyxo0b5w/gvUKbGpKESlHxTmWsBE2rGT99+vTgtm3bVnTs2BFAXfF0oJOXF3bt3h05fNgwfwBgs9lJO3bscB00aJB5s2bNChQKxQev7Z8SDIo8/g1gMpmwtLTEn3/+aXrs2LE8iuR8fHymjBs3rpJ46haPkclkGDxoUBCAEqo72oeAEnegmiZ86PGYTCby8vLSdu7ceXv+/PkdqR3uypUrvzxw4MAPYrG4mMrCp/Tlb9y4gUOHDoGqAQeqW+YXL15Eeno6DA0N8aa+95SrLjc3F87Ozj127dmzYeyYMW4A5Savklyl4vwZGRn4/fffN0ZGRn7+9OlTKBQKfPbZZ7+PHDFihp29PbTfrSpha0AD/qugMsBpAHx8fCyjo6Ojw8LCdhw4cGBSWnrao7379vUqLilZM2/evK+01jqg0QtMUYllo0eP9qfTGfFXrlyelJubex54u7ppSjiFWu/fhtR1Y6+s+dZoNHB1dYWBgYGuxNfGxgYcDgcjR42KCunfvxdQJYJ1/fp1DBs2rCeDwZBTjVDe1dolCAIM2ntsBLTnUyxbuiwgLDwsRnut1Q0KSitj2NChflu3bPny4sWL6wmCQFhYWJ6VlZX9sGHDCnJycnQCPP8GMD4k9vupQD0IhoaGOHXqVPPdu3cXcLnc4qKiItjY2HiePn16C1B3iIWKm0+aNGl9/NOn0QB0XX8+dEyA1lL+mNiyZctXc+bMuUZNtvPnz18lCEKhjUdXWdksFgsikQjx8fGwtrbWJbtwuVyQJIlLly4hLS0NhoaGbwwr6D+sNIIIXrlyZQTlYq/uJtdrcZqUXDF4yODBDx8+jBgzZgw8PDy6tvZovfzreV/7Up+t2fimAQ34GCD+oieqrrybj3fs6k1fHBwcMHPmzIkataZp69atl4rF4gt79uyZa2xsfMG3m+8h3+6+Qm3GeBUJUaQ+YsTwxj179jg3bPiwfnK5PBx4M6lTBgiNRoOZmZkuMfZtrHwq4dfV1RXm5uZQKBRgsVggCAKFhYWYOm1aVEj//tXq1RMSEjBr1qwAFov1gsVioaio6J3vmVqtBp/Ph0AgeGeDieKMmDMxZ0aOHLni6NGjiymDpNrnoN1snTx5cp2np+etpKSkm4aGhqIjR47QOnfu3KJXr17PxGJxvVr3/zQwPjSG/KnA4/GQlZVl/s0336CwsLDUyMgILBYLGzdu3G1qaqqbKPpNQKi/x8TEXImIiJhDNVz5GKV6arUaBgYGEAqFH7w5oFCpvnb97NmzWUFBQbbr16+PmTNnTiCHwwGPx6v1UDMYWkEYavfN4/FAp9MRERGBnJwcmJiYvHEiUA/ps2fP4Ne796ydu3b9WjNeToEi8x9//PH8mtVrQn27+6aUl5ejuLh44I4dO45bWloCqJ0B3+Bmb8CHoC59AwBQazSgf+BcJgFoNGrQaXQ9LQXqvY/73NZsHEIDgdlfzO5cVFh0flLopBGdO3c+VFFREdWvf79mO//cuWfQ4EE9a5IQZeVbWFjgwIEDYZNDJy9LeJ6wvFmzZm9FONR6YGBgALFYjMoeCnV+ltoElJWVwdLSEkKhUOfpI0kS2dnZmD59etTYMWOqkXlubi5++vHHIA6Hc8bS0hK5ubnvdb8A6Pq+v+8aW1krv+TEiROdBg4c2KNmZzYqgdHQ0BC//vrrvmHDhjVRqVSQyWSSZcuWWTRp0sRcIBAU/Ft4kiEWi//uMbwWVFMRAwMD+rfffmsXHx+fYGpqqhKLxZg2bdpvISEhzYHazRQou/Dly5eYPHnyUAsLi4/WOxjQZribm5vDzMzsg2Lx+qDRaMjLy0N4ePgJS0tLn4MHDwYC2s1MfQ80NRkpfebIyEgkJyeDIuU3nU+hUCA5KRkDBw0K+/qrr/qCqLIigOrWUE52NvYfOLD38OHDY0tKS1BaWooffvjhdGcfn371kXkDGvCxQAOBsrIybNq0+Uy7dm2jLS0toVB+aC8KAiw2C7k5ubh44YLP119/PYQSePqrQRGgqZkptm3ddvDGzRujfvzxx74WFhbZ8U/je12+emXT/K+/nmara1REue61Y7O2skZ4ePiyjb9vbP8qJaWvQqGAgM9/83krrU02m63LUK8rqVehUEAgEKBjx44wMDDQVdUQBIGioiJGSEhIzPfff9+TGpu2Xl2KX3/9NUhaVhZNqcC9TzhSo9HoGm59SEiTx+NBLpdjcmjogKZNm4rc3NxQVwCQBBAYGOg0adKkP9evXz8BgOrVq1cpmzZtavnNN99ICgsL5f+GBi4MDfnPDfiTJECjETA0MkRkZGTzw4cPpwEoLyoqQpcuXXqvXbv2c6C2JUmRUFlZGUaNGtUnIyMjz8rK6oMz2vUhk8lgbW0NOzs7yGSyj3ZcCwsLZGZmzr927Vq5k5MT4uLiXvswkySp26iEh4cjIyMDVK3368BgMCASiVBUXAQfb5/o0WNGBwC1ddSpv0mlUkyePHlARGTkqeDgYDg5OXXq3r37ysGDB3elvteABvwVoFruajQajBo1aumpU6e++/3331FWVgapVPrBx6eI54cffvj1blzc/LDw8J+YTCZRlXH+14HaPJtbmKN///59crJzbtyJu7MwMTHx8oEDB6Y/fvQo5uTJk6eNjY0r4+q1rfwZn8/oc/jIkei1a9YE0t+h7TMAXevQunQt+Hw+Hj16BAcHB5ibm1d7TywW07y9vVtQ/6ZBq+/RpUuXvg8fPoymjBBKwOZdvaL6CnhvkrN+03E0Gg2Ki4vFw4cPD7p161YUn8+vFV6hrPbvv//+s8jIyMOJiYlnuFyu4snjJ6mnT5926tyl83OVWkWq1Rr8kzmd8U8eHUEAHC4X2bk5lqtWrVIplUoR9d633357msFg1Pph9C3KH3/8cX9cXFwkjUZDYWHhR60rVKvVKC0thUql+qgbBbVaDR6PV25kZPTGXalGowGfz4ehoSHi4uJQUVGBt6laoNPpyMvLg1xe7vTnjh37Ro8Z3QmoTeaUe/PEiRMpFy9eDHVs0uQ8AJSUlPQ9duxYWF3a1A3u9Qb8VZCIJTh16tQaOoMBLo+bJhAItNlSH/jIsdgs2NjYEL169pobc+bMqsKiomXWVlbvpgP9niBJAESVNOrUaVM7DRg44NLw4cNDAJx2c3MLm/PlnF7de3T/ZezYsS2puuqqzm3a7w0bOjRAWaG4P2fOl+Pz8/Mfv20GPFC965o+jI2NcffuXURHR9eSxZbL5YqLFy82271797nhw4d7ajQa9OnTZ9LDhw8jAK0xBVS1O31Xy5bKnn+f2Ht9iI+Pj/7mm2+2r1u3LrS+eDqfz8eePXsivby8GGq1GqlpqcUnT540bd2urTmDyczXkP/s7qQMZcU/c4DUrtHMxJSx4ZdfLVJTU1/QaDS1RqPBF198cbBXr15coP4415kzZ15t2bJlNOUq+tiuEplMBj6f/7eWNHC5XBQUFODo0aO6bPs3gU6no7CwEBUVFT2PHT9+PCAgwBCoImVqp0qR+YoVK2KXLFky0N7eXtajRw+EhoauXbp06ZyaZE59twEN+KsgNBBi0KBBC8/Gxi69G3fXfe2ataK3TeyqDySpAY1Gh0MjB979e/cYgQGBiywszCtjc5/geSZqW9yWlpY4cODAqdWrV+9Qq9WTYs7EnN+zd08bDocTMXToUH+qXr0mqY8eM7qNtY31vZUrV/YpLCw88zb3hSJbhUIBNptdq/OaUCisk+xZLBYyMzPFI0aM8Gaz2Q/u3buXfu7cuR2U8MyH5ilRxpeBgcFHWbupHu/bt2+f7Ovr27lfv37NaxogZGWKXMeOHekLFiw4uXLlygE8Hg8pKSnJu//c2Wzu3LninJwc+fuqgn4K/GOlXwmCgIGBAa5fv948OTk5RyAQKKRSKZo3b+73888/DweqyqmqfQ+ASCQip02dOrqoqAhOTk5/CelSsoUfKyHufc7PZrPx8uVLAFVdiV4HGo2G0tJSKBSKwM2bNke1cm8FoLa7nJKD27R5U/iBAwf6AUBGRga8vb2jJk+eXG872gY04K+CBtrnd9zYsV/H3b7z3YWz5xnubTy+EggFUCnff4FlspiQSaREbOzZ0xqV6uVnn42fS6fRCUo54VNvUinr29raGuvWrZu4e88e2w0bNgS6u7urHj9+HPD8+fOTS5YsCaHT6XW633v27MmwsrKKiYmJCSooKNBV9bwNKioq3jppWKVSwdzcHDKZTLVly5ZWVP/yjxECAaBz01MluB/qXaXuQU5ODiZPnjzWx8fntqmpaS3dEirr/fvvvw+Jjo4OfvToUaSJiYnm+fPnhbdu3XLt2LHj45KSEm0ewgeN6K/BP7I5i0ajocqtLL///ntFSkqKroh6+x9/nGQymbobr/+DUFbllMmTf0pJTb1paWn50R6wmlAqlUhNTYWtrS1YLNZ7a7m/D6iHUyaTgUajvXECUp8vKiqCUqkMXLBgQZR+cxXd5yod7nm5uZg4cdISkVi0IiQkBEwm03vq1KmrJk+e3LnmdxrQgE8JpUqFUrFIaWllGXTkyJE1H+u4Y0aPNoiMiPy2rKyscj9bPfz0KaHfw3vc2LEBKqUy7sjRI18DuLRt27YBN27cmL1r565frG2sq4UcKVJ3c3ODna1tVHRMdDCAqLftpghoSZ3L5eoS5l4HyhK3tbWFTCb7qCFNkiTBZDLxsYVdjIyMkJeXd3f8+PHLwsPDv6stDasV82EwGNi+ffupDh06MKVSKZ48eVKwevVqo4MHD1pZWlrmfsy8qY8Jxo0bN/7uMdQJIyMj4ty5c+bPnz9PAqAGgNmzZ+/38fbmUapl+o+oTtp15864w0eOfMtgMFBWVvaX6fGqVKq/xd1OTTytTnP9JSf6nydJEhUVFWjevHnQpEmTIq2tqy8EQNVmKDsrC9ExMX0joyIj+vfvD3Nz88Ct27ZFdezQAUDdXpEG/DdA+wfYJHQ6HQwaHUwG86MKaCgqKqQESYLBYJJA1bV+alKvbnVrk80mTpzY3sfH5+Jvv/0WlJ2dHS2TyX49dPhQ0qBBgyIaNWoE/Q6NlIVvaGSEXbt2R/bp06f/o4cPwxwcHN7KUqfT6ZBIJCgsLARVufJ3gNIKqdnb/WMclyAIRERE/LB582b/adOm+dTliSEBeHp6MhYsWHh85cqfBgEgU1JSUjds2OC8bdu2PLFYTH6s6qaPCcbbtuX7VFCr1WjcuDEePHjgtGvXrixDQ0O5SCSCvZ2dz08rfxoJVG83SIEAkJeXp/l8+vQxANQMBuODGqa8CVQJg0qleuc+6u+L9yXz3Nxc+Pj4DIuMjDxkaGhYy8KmFq/bt27hyNGjQRYWFtEAQKfTB4eGhh7lV5bCNFjm/01QzwcJ7bP3obXf7wuCICCTStkqtQoVigqytKQEvA9orkQds7y8HOUVFUqlRg2ZTGaoVCigqeeYulf13tclfVWSEEmSb70NoFYytUoNoVAIfYuRKlGjgUCzZs2wYMGCqNu3b49OSkraL5VKI5cvXx40ccLEKG8f72rfoyx8O1tbXL927XSf4ODPLl2+vKtp06ZvJHU6nQ6lUomnT5/qXN5/lZezPuh7C/5CkNOnTx8xbOjQdBNTU9SnIrd8+bKBx44d7ZGSknKBzeEoDh85nD98+PBmjo6Oz9PS0t67U+dfBcbfuQurC3w+H0VFRcYxMTEsDocjodFoEAqFtH379x/icrj1lqgBwMhRIxeUy+UvKlsA/qU1gywWC3K5HKmpqWjfvj0Uir82ufB9yBzQKtl169ZtbGxs7G4Wi1UvmUdHRed+Pe/r4b6+vpdPnDiBkJCQVVu3bJlHlXg04L8JanY9f/5cfO7cud9ioqIlPB5PRVRNrk9mwnK5XLx8+fI+QRDIzs4+OXHCxDlsNpvxIeEuBoNBVlRUkPGPn2wmCAJ/bN/e88b16+0rs7RrRvVIgiBIgtBmspFVOwkaqdGwQBBsvlBAqFQqaNRqaEhS19BEo1ZDqVKBzWaDzWZDrVbrXpdIpXB1dUXv3r07de/e3U8gENSKjxMgYG9vj5s3b+4bN3ac77Vr10KbNGkSPWbsaJ9169bv7t+/v3NdrVj5fD7Onju3Mzg4mBsbG7u5efPmb2zBSrm64+Pj0ahRow/ue/GuUKvVoNPpsLS0/Cjx87qg0Wggk8oyvpwzZ9bu3bs3UP6YmuI/LBYL+/btOzpw4EBTlVqNinJ56fyv55nNnD3LxNjYuFgkEn0UobKPBcbb6vl+ChAEAUtLS9aNGzdsrl27lmpiYqLKzs7GlClTVnft2tUOqD+TesvWLTcvnL+wmnpYP0XrOypz8q/+QalrKisreycyf/XqFQICAmaFhYX9WlcXOorM9+3bd2PcuHGDevTokcvj8RAQEBCxfPnyYKC2hGtDJvt/B9RmOSI8PHX8Z595dfftnnfzxg2UiEWV73+SPPBq4wGhbaxUUVqqPnnq5PqPcX4CAJPJAp1Bx7379y/df/DgEo0kQNABVOao0Ol0sFgscDlc0AjtfREIBGAwmNBoNBBLxCjIL4CBkSEcHR3B4/N0IixUngsVBqTmMPUfFbfesWMHfvvtt+9jY2OXVLfUtfNUAy3ZHjh4YNLGjRttnz9/HpSXm38jJCSk3ZYtW8KnTJnStSapk9DGg6OjozcNGjjQ8tTp08veZKlTYl5UnpCdnR34fP5fbrRQoERlbGxswGKx/rLEY7lcjsOHD/8WEBA4dMSI4Z3rK2Xr2LGjyZAhQ37fsGHD51YWlqrnLxLS0tPSm3Ts2FGSn5//j/K7M5KTk//uMejAZDLx+PFjs6ioqDIzMzNZZmYmLC0t265Zs2YOUH9We15enmb2zFkjqWN8yj62Go3mL890JwgCMpnsndzsqampCAwMnBEREfErjUarVuYCVJH5+vXrz8yZMycA0IrH9O/XP8qns08gUEXm+jKJDfjvgACgUirxy6+/ri4qKsorLy8P3rRl81f5+QUWBJ1Wof0ISQmY/eUgSZB0Oo2gETSAAE2t1pAajUZD1BPo1rrCKUKmgUajg0angU6jsRgMJletVkGlUtN4PC64XB7YbDbJYjGNKuQVwqSXSSBoBMlkMlFRUQGFQoGKigqxRCzJUavVDIIgGBpSw8zKytK8Sk4uycvP+02urDgoL8hXKJUK0AiaVniqkT2cnJzg4uICf39/rF27Fjt27ICzszMcHR3h6uqKDh06ICkpCYmJiUhLS/vmdFjYnP79+vGqXXuNxLcZM2YEHjx4MHrjxo2BAMRTp07tZmlpGR0SEhJQF6nTaDScPHVq6YABA9SnTp36/k0xdcpSV6lUyM7OhrW1NQQCwSchdWqNk0qlH6Xx1etgYWGBBQvmD/P27pTp4OBQ64ZQuVo//fTTjOPHj+/MzMy8Z25mVn7i+PHSLl27mPXo0SMnOzv7H6Mgx3B0dPy7xwBAu4sUCoW8r776in/lypWXVBb2smXLdggEglpRc31X+8SJE5cqlMpUSv70UyIzMxOlpaUf1S1FlWxQ3pO3tcwB7QYjNzcXAQEBX0RERKzXknn1u0eR+YMHD6LDw8J1fYpHjhwZ49PZxx9oqC9vgBZFxcV4npBwxMXFBTNnzYzw9/f/u4f00aBTS9OokZ2VjfT0dLx8+fKeRCy+N2rsGOTm5uJVUjKZmZlZnpWVVZGVkRn/LOH5hREjR5b1CQ4m53w5hywoyJeCIDSOTk5o5tYck0JDEX46DMePH9cKT2nUQqFQqJNi5nA4YDAYxuZmZv5mZma25mbmMDc3R05ODths9m5TU9OURQsX9m/fvl24rY0tR6OLiFehqknLiIDikuJzn8/43N/ExESdkJAQGBEREdWnT59AitT1841oIHDy5MnvBgwYQD916tQyS0vLN5I6g8GASqVCTk7OJyN1akxZWVl/uXFGEATKysqyJ0yY8PX58+fX1PSMUHeQy+Vi+fLlf06aNMmDLxAgMell5u7du1u0bdtWlpqaKlapVP8IUmdQdcx/J1QqFWxtbZGcnOyUl5dXxOPxUFhYiKFDh06fOnVqa+pzVRZmFZnv37//cWRk5I/6vXk/FShZwY9drkGj0cDn83WlcG9L5gBQWlqKHj16jAkPD69G5hT03OzRWVlZQSq1CgBM9uzdGz5m9GhvoCH5rQFVMDIygomxsW98fPyxdWvXjgWwQSAU0BUKBUgSOmlPbU4YDUwmAyqlCjKZrNKyerdFjiIRbYtjbZxZrVFDrVKDBAk+lw8Q0MaoNRqo9TxkZuZmoBM0FBYUIj09Pf1x/JNYT09PsWeHDrh08SLSUtOU6WlpZVlZWQ8SEl9cGTt6jKZfSH98MfsL5OfnAdBunq2tbdCluy++X7YcJ0+eBADY29rB1dUVnu3aw8LcHK9SXuHypUsQCARtvby8urq1aslr5eHOau/pCWhIODVxYjeyb+RrZGzsZmJiDDNTM7BYLCxatAjLly/ncrlcBkEQICrd+T179kRgYOCCXr16eWdkZJz79Zdfd/38889T6wtz6Sz16TN6mpua3flswoTBly5dSikuLg7KysyMmjJ1amBdMXUaCJw4cWJpUFBQXkxMzOY3JfTWR+qfokyXSjD8q0Gn03HhwoW1f/755+gJEya0runwoaz0CRMmuF+/fv2r48ePr+Xz+Thz5kzxli1bbIODg8VUR7a/G4yP2bDkfWFmZoa0tDTTtWvXlpeVleVUxpo4P/zww29AddevPqlLpVLMnzdvAgDN36HaRrUj5HA4MDY2/ihZ9SRJwtDQEGFhYYiMjNRJJ74O1MZCpVLBy8traExMzB5KFlcfFJlv27YtOj4+PujevXu4c+dOq7CwsFN9+/Z1AhrIvAFVIAGw2Wz8+OOPX0+cOPFY7Nmze2/fur2Xz+drY8JMBphMJug0ula+VKOBVCLhWFhaMB2dnHRx5wpFBVRKFRRKBRQVCkglEpiYmsLExETnzq50aaO8vBwsJhMcLgcEQdPFoCmlsopyOQAoaTSanEajgaDTwGazoVBU4Pq166DTaGAwWVAoFCiXl8PE2ATOLi6YM2cOAIDP46NJEyf4+fmhlYd7ZXOiJBgIhW06dPTq2qp1K27z5s05MqkUfn5+sLO1ZTo5OfmamZm3srS0hIWFBXh8HjhcDl6lpYLL5QqZTAZola59pUqFcePGvdf9dnd3Z3/55ZfbFy1a1O7GjRuxMpls6uuSUimCHjpsWFtDI6O7I0aM6KtSqW7k5OQEySsqombPnl03qRMEIiMjN/Xo0UN2+fLlPW/Ko6qL1IVC4V9qqVM5B5+C0FksFqRSKRYsWPDZoMGD7hsaGBJ15S/QQGDJ4iWrdu3atdnQ0LCspKQkd9euXdxJkyZZODo65peUlPztVjqjadOmf9vJqaQRR0dH5t69ey2zs7OTzczMUF5ejgULF25zcXGppuRTU5Z00aJFv2RlZ9+ztrb+224kSZK4ceMGjIyMPsqulSLwhw8fAsBryyJUalW1LI4+wX2CDh46eJgS3qmrznzDhg3Rd+7cCcrKysKLFy+8Y2JizvXs2ZMLNJB5A6qD2jj37du3w8mTJ6+uX7/+5PVr146Zm5sTpiYmzQqLioykUqkhi8tilpWVycRi8auikuLr2bk58szMTHTp2hVJL5NgYmIMgUAAC3NzmJiawtnFBXF37uDu3bswNzeHkZERbG1tYWpqipatWmHv3j2IjIiEq6srGjdujCZNmqBDhw7gcrkYOnQoAMDS0hKurq5wc3NDx44dITQQ4kxMLDQajXE7z3YBbi3cbNq0acNr3LgxXaVU4quvvgKXx3NyaNTIz9zcnGdpaQkjIyPw+XykpqeBx+UKGSwWaJUbCKVKic7ePu98z1gslt79o/5fZYS8Lo2QBgKenp5tWSwWcnNzkxRKBfh4ffc0imj8/f1Nwk6fvj5x0iR/FosVe/bs2aCysrKohQsX1iJ1KqYeHR2928fHp+TBgwfhujFUEilQPbGYJEnQ6XRdTJ0S1PrYoDyUPB7vk3pcWWw2CgoKHn4156uf//jjj/n6IYuqHCLA0cmRvnDhwr0rVqwYBABpaWm5mzZtch4wYEBxQUGB6lN6iOsC4/Hjx3/byUmSBIfDQVxcnGVERESZvb19RUZGBpo1a9buh++/HwPUH7+9fetW8aFDh+Y0atQIAoHgk7raAa1VzGAwUFxcjJSUlL/k+K9L8CNJEoZCQ5iamYLBYMDWxiYwLDwskiBqKh9VkfnG3zdGX758OSg3Lw+5OTl+p0+fPuPjo120Gsi8AXWBJLVNknx8fDr7+Ph0LioqWnvl6pXS/fv2H3dv07q4devW7Dt37tBSU1NFmZmZUjqdzpBIJOrQ0FAkJSfjTtwdmBmbwL5RI7Ro0QJNXFwQ1CcYMVHRuH//PgDAxcVF2Lp1azR2aIwOXh1x89YN0Og0UxMTE38TY2NrExMT8Pl8WJibY+7cueByuQ62trb+pqamAgsLC1hYWMDIyAivUl6BzeHweDweXWsxa1sBs5hM+Pn5vdN1U2RFiVi9Sz5/TTc5AX1RntcbHr/+8ssPCoUCzk2adBHw306WmyL1zl26YN++fWdmTJ8eJBAKo8+dOxdEo9Gi5s+fX43U9ePCly5dChs8eHBwbm5ulEqlQn5+vq7uvK4wH6WKmZ+fDxMTkw/S0a8LOg13oRB0OgPkJ+sGSoBBo+PQwUOLx44dO0pbVaXdgOm35iZAYNGiRQN37NjRITc39465uXn5rl27Cr28vMz9/PxysrKy/lYrneHt7f33nZzBgIGBAWPSpEm069evp9rb2wMA5s2bt5NOp9c5hQhoY8oTJ00aU1hYSDo5Oek6+3wqUC4ouVyOgoICrXrVX+QequvhoM5jZGQEMzMzdOjQIXDlTz9FvY7Mt23bFn3h4oWg3Nxc5Ofn++0/sP+MV0cvAA1k3oDXgCChAQEatGU+W7dunbxnz579WVlZZRt+/w03rl/Htu3bweNw4eDgAK9OndhuLd2EM2fOxOrVq8HhcPiOTk5dLC0t3UxMTMBms5Hy6hWCgoPQxLkJy97e3tfY2LiliYkJTE1NoVGp8PXceViyeAmPy+XRaZVxZkBLJl26dn3vS6nptarzcivJuGYLYVLv/bdZruv6lFqtBggCdBoNCqUSSoUCMpkMFQqFRCIW4/Hjx5dzcnO/AYA+ffsOYTJrh83qA1Wr7unpic1btkRNnz49iMfjRcfGxgaxWKyoL7/8sk73u4GBAcIjIiKXL1sWFBcXF61WqyGVSnWhjrpAlZIVFxdDrVZXhjwUH43IaAQNigoFCEL5SQ01DouF/IJ89cSJE8Y+ffrsgla3ozo0IMHj8fD777/vHjF8eHMDAwMkJyfnHD58uHFQUBCLJEnF3xlLZ/xdJydJEubm5njw4EHjs2fPSgGgoKAAffv2nfLZZ5+1AmpPPmqSbN269dLTp0+jDA0NP2p7vbcF5QqSSCQ6V9Tf4SHIy8sDl8vpMWPGjCi+QFDr4aPI/MDBg9HXr18PevnyJcQSid+Rw4fPdNBJuTaQeQNeDxqA7OxsLF26NOjmzZvRL168wDfffLOgh68vR15WjtmzZ7OcnJy6mZuZtbKwtIS5uTnKysvx1VdfYeGihSwul8em06ri4UqVEj6d3t+QqJ6FDFBubcqeQuW7r7OqX0fMdb1T8zWlSgUmgwGVWgWlQgWFogKlIlG5UqFQAdr8mqysLGSkpSPxZeKVUpHo7qgxo5GdmYUnT56QGRkZZZnpGeLEFy/OGBoZpY4eOwaXL1+Gvb097O3t13z++ee+wJs3IPqg3Prt2rXD1q1boyZOnBhEo9GiL126FCQUCqMmTZpUp/udzWJhwsQJUWfPng3Izc098zZaHjQaTSeaIxaLoU2S/AhrCaEtPS6TlUGl/vSZ43wuD0lJyRc3/Lrh7Nyv5/aunZSoHc+gQYOaDR4yZE5ERMQ6AwMDPHz4UHn06FFnJyenZ39nLJ1x6dKlT35SigQdHR3N9+3bZyAUClMlEgnkcjl36dKlvwNVU7Sm6yo5OVm1YsWKoZaWlqAkST8lKJnHvLw8nQDCpwRJklCpVFpRG0JlvmXLlphmzZrVcgtSZH7nzp3oWzdvBt2+fRu5ubk+UVFRDWTegLcGRWRHjx49tnfv3mgTE5PmUVFRl3v06GGuVqsxbdq0dz5mdXe2fmy5NglXJ+2q8egTrL7GfHXiffOiWlZeDh6XC5VajYqKCpCkBjJZWblGo1ZpNCSysrNQWlyCkpISlJaUZr16lXymV+/epc5NmuDEyZPqrKwseWpqqiI7O/tpwvPnF8eMHavu168fvvziS+Tn54EgCZSVl8HaxhoTQydh3759OHXqFADA1tYWri4u6NChI/g8PiQSSa/x48Z9PWLkSD/g/eYndT9bt26NrVu3Rg0bNsy/oqIi9sqVK0EWFhZR/fr1q+V+Bwg4N3HGr7/+GtOzZ09XuVz+kk6ng8lkvpaYqITgsLAwnQw2nU7/IDe8WqMGjU6DgdAAJEF+WuWiSnDKOFixYsXgvv37FTZ1dWXWpHPqSZ0/f/5PBw8e3MTj8eRlZWW5O3fuNB4xYoRZWlpaoVqt/ltI/W+pQycIAsbGxsSRI0cMY2JiUiwsLFQSiQTjxo9b3q5dO0Y11xhJAASpm7Tzvp73Y25ubgGLxUJxcfEnt4ypjFulUvm36PjSaDQwWSwoKipw8NChmG6+vsz6EuA2bd4cc+jgwaCMtHRkZGa4Xrh48aK3t/dbuR4b0ABAu3BVVFTg4cOHFwFgzOjRSwIDA831P0Pq/qSWurre1S6FtTfpRI2/1WUdV3+9pjucOjf1ukKhgFKhgLSsDBKJREKqNQAByKRSvEpJQXZmVt6jJ4+jPTt0KO7YoSPOnztLFhcXIy8/n7h06dLzpKSkCyOGj5BPnTYVsbGxSE1NRXJyMp7HP5OIpGKcOHkSzVybIioqCkJDA5iZmcHW1hb9B4Sgbft2UKpVSH6VDKFA2L6DV0cfd3d3bouWLThlZWUICAhAo0aNWE5OTj3MzMxbWFlZwszMDHyBAEOHDRWampoC+LDNNvU7tG/fHvsPHDjj16tX57Kysut8Pj+ITqdHBQcH10nq3t7eOHjwYNjAgQObs1gsnUjV60Cj0XTVPR9DdZRBZ0CpVCK/qABKhRIa8q+V8K4LlY1hxF/NmfNjRETEUqr/PEhoNxnaT8HDw4M1dcqUVVu2bp2tUCjUV65cSbWysrIYMmRIkUgkIv+OBDlGly5dPukJSVIbt5HJZKaTJk0ql0qlJcbGxrC3s7P54fsfvgZqkI3eb3n79u2Ss+fO/mBjY/Neu0BqF0llUr7rDaeyPAsKCj75Q0bJzJqZmcHJ0RFfz5sXNXDgwLZA3WR+8ODBmzOmTw+sfJkXHR19sWvXrsyan29AA94EkiTx6tUrZkVFBVq0aOEAVC8lrelFqz4zalvMr4tCqyotm2px5jIZJBKphCAISMRiiMViyMpkyM3JJROeP78sEonujxw9GjnZ2XiekKBKfZVSnpGeXvoy6eVZgEjf/sd2hIeH49DBg6DTGdCo1ZCVl8HU1BRNm7riq7lzwaDT0aiRA5q7tYCLiwtu3LyBh48eYv78+eDz+cjJyUGjxg7w7OCJXX/uRFJSktCrY8f5bdq169S4sUNbx8aORhaWFnB1bQprKyuUl5fXujaFUvFWoYaP4Tmjfhuvjh1x+nTY2R49ezgnJydnb9myJejPnTsvfDZ+fPeapE6AQEhISLPIqMjodWvXBSYkJCA/Px90Ov21691fke0OAMYmxh+kFKdrmvMe0Gg0iI2NXXHlypXQrl27alWBiKrfhbpf3y5bNuvipUsbKioqkisqKqQXLlwwWrFihQWfz8+TSCTvde4PAeOvyNB+HUiShK2tLf3w4cMWSUlJKQ4ODmCxWJg+ffpeOzu7Oh5lrXVOkiQmTZo0WqFQKA0MDN6ZjAmCgEgkAkmSMDMze68kDjqdjqKiIt2G4FODJEnk5+dj1qxZUQMHDgwEavczB4ALFy5IRo4c2Yt6/dChQ+cDAgJsan6+AQ14G7DYbNja2hIAsHvPnuhx48f7aIn79QQtKyvTJotWPnPycjlKS0rKlEqlmqpbz87KQnpaGl6+TLoqEoniRo8ZjYzMTDx7+pRMTU0ty8jIKH2RmHiWIJC6/pdfUJCXj1s3bwpv3LgpLywsVDKZTDg7OyMrMxMjRowAADDpDFjb2sDFxRWtWrWEjY21tiVoUZGJl5dXgJubm1W7du34jRo1ogPA13O/Zhw8dDDqVcqrG3PnfT3Tt1s30wXz5yP+6dMwU1PTly9evMDNmzfV5eXlZX/s+AN2dnb4Zf16ibyi4g//AP8Ne3ft4cU/fDx+8JChRidPnkR6errHwJAQX0cnJxWXxy3ncLhCggBYzDcT38ecn1T2e/ce3bmnT58+379//+YAMOGzz3pZWVqmBQYG2ulvyKjPBwYEBiQkvIg6d+5cEIPB+OSeSMozQKfTweVy34vQmUwmcnNzoVAoYGFh8V7Gm1KpVH722Wdjnj59ep7D4dTKUSIBWFtZYdq0abu/+OKLzgCQlZVVvGPHDpehQ4cWZWdn//XqOzXAyMnJ+aQn5HK5yMrKanz16lWVh4dH+ZMnT9CiRYsOM2fO7AHUlQinxdq1a+/Fx8dHMRgMJCUlvfN5VSoVDA0NMWTIECQkJEAikbyTlU+n01FRUVEtCe9TuFSoXSYl4tC7d+9ZixcvrkXmgPZePXz4EMOHDw+0trYus7e3w6RJoTHDhg3zquvzDWjAm0ACoBEE/Pz8Bh08ePAXsVi8YufOnW3bt2/f28bGhqioqCDT09ORlZUFqVSKktKSG1lZWbdbubuTbdq0wYO795CaloYHDx6UZ2VlxSUmJl4aM2aMpn///vhi9mzk5+WDBAl5uRxWNtaYOGki9teIMzdp0gQtW7aEtaUVUl+lIDw8XFJaUop+If1n+Pr6Ct3d3TkajQazZ88Gn8+3tbWx7WJsYmxjWZmgJxAKsXLlSqxdt5bP4XBpNBoBGkEDCYDDZqNb127Iz88jIyIjbjDo9A0uLi44ePgQlArl0tLSUolQKETjxo2VIpHoiEwmyzMzM4NHmzZFz+Ofbk5PTVNVKCpw/MTxZQw2C63btsGqlSux888/8cu69cL7jx7g919+C5i/aIGbl3cnXLtyFSZGxv2bu7Vo0sTZGSYmJmyBgM8iSYDL4eg8bB9rrlIk3a9fv2Y7/txxfuKEiT0BaEaNGBl85mzsI09Pz2pnoj7/5RdfBF64cOHbiPDw79RqNbhc7icNb5IkidLSUrBYrErVwHcj9dLSUnTt2hXl5eW4efOmzgB7FyOOw+Hg1atXF/bu2XMndPLkDjW9UZSVHhoa6rNy5Uqv3NzcW02bNi27cuVKuaOjY2OBQJBUl6fmrwTjL+45WwuGhoasq1evGjx79iyBksubOnXq1vrL1AiUy8uxZs2aSVT8+l0eLIIgUFFRAQaDgblz56Jjx45YsGABOBzOO8V8qNI0FkurQvWpLHTK1c5ms+Hp6Rl06tSpX4HquSJUxq5SqcLKlSuDCIK47urigu9X/BDVpXOXWtrsDWjAu2L8+PGdY2NjN7FYrOl79+0bdO/uPVhbWcGtZUvG9RvXuYkvXuDZ8+dISkqSAECv3r3g4+ODlJQUHD50GKLSUvTs0QNBgYH89h08aQZGhqr8vPxyJovVtr1n+y4tWrTgNq+MMwcGBMDe3p7VpEkTXzMzs5aWlto4s42NDZ48eSIql8vt3dt4DPjjjz9+p5TUWEwmevTo8V7XVlFRAZFYXKRWqsFmsQsZDIYZg8EAuIChoaHQwcEB3bp1A4CpANC9e3fMnDkTADaQJAnPDh3QvHlzqU8XnxjnJs6YNWuWYvPmzb9OnTH9joWZOYxNjI8WFhUdTU1NxYoVKwBgWWhoqLB9u3b4YuZsYev2bUeOHjOaZ2Fh6ezq4jLG3d0durjtR5i3FElP+GxCDxNjk6hNGzcGPYmPf7xgwYKg/fv3R1lZWdUIoWiNg6NHjy7v26fPvdu3b0dSqpifKtSo0WhAp9PB4XDeKzyan5+P3r17o3nz5pg2bRrMzc3fa82WyWTYvGXLxP4DBjyxMDev9WuQAHg8HlatWrV93LhxrcTakFDatWvXXIKDg5lisVhJCah9CjAKCws/yYlIkgSXy0V+fr7VxYsXi2QyWXlubi7c3Ny6T58+vTVQf5nat998u7OgoOBhkyZN3vnGUK51a2trcLlclJSU6Mot3rVLGrVLpNPpn4zQVSoVVCoVGjVq1CksLCySx+PVmugEtBrUAwYMCHr69Gm0SCRCr969o7p07lKnJd+ABrwtKFkNGgjs2bNn2rGjR5ts3rJlpamp6cU7cXFY8u03qgEDB0gmTZqElT+tRGFhIYKCgmBlZYXlS5fh8qVLSM/IAIC+BIP+m7uHO8vM1AxcDod/9/49AzaHDUsLy2rnfJ02hpmZmZDD5oDD4TCMTUzqTMF716WTzWZDKDQwVWnUKJeXm1GvyxUVUCqUEIlEarVaVUbQaKARNBQUFCAnO5uem5OT/ij+yaUuPp0rli9fzouOjjY+dOBQRUlRcbmFmTlLTWowbtxY+HTpjL59+kKj0aClW0s0cW4CWxsbidDQEAOGDpYc2L9/jYmxCZq1aIYlixZv/Hre12smTpzYmYa6O0y+DyhSDwkJCczJzo66dft2UEFBQfRvv/0W9M2330Zx2Oxqd04DEhw2G6dOnYrw8fHp8ejRo4sGBgafTI4VqJK0Bt7dG0qFR0UiEfLy8qBWq9871p+UlBS/bOmy3zZt2jizPit97NixLTds2BB0//79KHNz84pLly4VOjg4WBgYGGR9DEnwtwVDLBZ/khORJAk2m828cOEC4/nz56l2dnZgMpn48ccftxMEVZpSvWyFAPDs2TPFunXrPudyuRCJRO90To1GA4lEgoCAADAYDJSWlsLOzu6Ddks0Gk2XWPcpQJ3nl19+OWJsbFyjPE0r+AEA/fv3//rcuXPRADB48ODVS5YsaSDzBnww9LWsGQwGho8Y4dfLz88vLzdX0qZtG7i6ut5p1rzZNY1aA0NDQzRq1OjEnDlzUq5evYqdf+4kS0pLpPMXzMe1q9fCr1+/EZ6bm8ef/cVs2rx58yzNzMzGjh8/niUWi+VpaWlt27Zt69uosYNWL53DFdLpdCjVKgj5At14tLLGJNRqNV2j0YBeY2NNzWyVWg0QAING1yXXlZWVQSqVSrSZ0zSUl5UhNTUViYmJBRfOnzujVqvx4kXijOjoaIsrV66o0tPTyzLTM7IePXkcO3HSpJKBgwdh5tTpyMnNgUatgYbUQKFUgsflwsLCAoMGDQIAODV2QrOmzeDl00no2aEDysvKwWKxQJKki42tjZ+1tTWHw2bD0NAQP/68Cg729lxbWztNcUlxzIvEF5cnTZrk16ZNm/y2bdsK8BFBkfq06dMD78TF7dq1a9f4J0+eRN+5fXvy2XPnthGoEqihiIvP52PVylWn+vTtY6hWqz+pZ/JjnItaP8Visa4b5rsel06nY/PmTQumTp0S6u7uzqlpdmqg1Wr4YcWK7cOHDrUzMjIiExMT82/evOlw/PhxpkwmU34qUv9kLncul4uMjAyzK1euSHg8nkYmk6FPnz6f9+vXr4nuQ3rbayqWtGTJklUajaasoqLinZqfkCQJjUYDFxcXNG7cGAkJCR9E5Gq1Gjwej2ok89ElD+uCXC4Hm83Gzp07o/v27WsHUBMO0CfzFStWRJ47d25NY8fG8PH2Gbhz5865wN9SwtmA/zOQuq02oSMEM1NTmJmaCt3c3BASEtITQE+JVIre/n5QKBRLRSKRpEPHDli7di1ZUFRwxD8gIKt5s+bqLZs2p8TdubM/MzOTtLS0lBw7duxbU1NTcLgc/P7b7/Dt0k348y9rsX7dOmz5fXO/kaNGuvQL6Y+CggKkp6cP9ff3t0tPTy8sKyuDRCwpSU5OkhgIDFBSWoLUtFRkZmTKX75IPFsqFr0cOmI4sjOz8OL5c3VObq4sLzdX9SIx8QJJkvE7d+7E6dOncfDgQWg0GpSVlaGRnT2GDx+BwOCgTZs3b8bxY8fAZDLh2LgxunTuDIdGjZCXnYNHjx6Cw+Y26tCxg19L91bGbVq35jk4ORIEjcD8efPB5XE9GzVq1MXG2hqGRkbg8fkwMDDAkydPwOfzhSwWCwSNqHQjazPEf/zpJwBAcnLygl07d3Z8lZJyZ9WqVX8cPnz4i5pCMB/+e2qX2J07d4578eLFuZs3b+47d/789q+//jpo9erVIdT59F3v/gH+BkeOHomZOGFigFgsxqdoU61SqWBkZKTryf6hoJL7RCLRO7e5rtwAlC1atGh1RETEN9VbrFatswH+/jZ9+vT9+vad2z/z+XzN9evXpWFhYWbm5uY5Mpnsg6/hbcB4V7fz+4LNZjMuXbrEKSwszGjZsiUKCgpoMz6fsRTQsyJr8O3jx4/l9+7d+8nFxQVsNvutrWKCICCXy2FoaIgOHTqgoqLind3r9R33UzQMqKyDBEmS6N+//9pRo0YFAPpkXnWrNm7ceGblTyv7mJiYwN/PP3DLli3HgQYyb8DHBeVarLLgqkMo0BqTPB4PRkZGQgcHB3hrS7QmAYBHK3cEBweDBLk3OzsHFhYWcGzcOJPD4+3OzcmRGhsb/1FUUlR4+tQp3LpxC0qVcr9IJIJAKMT+/fuwZ8/eZfn5+Uy5XK5s3bo1LCwtzuTm5Rr8uX0H9h88AI1aDYVCCYWiAja2tpg2YwY2bvgNp06d0hKzoyOaNWsGt1YtYW5liYLCAuTk5LBatmzZo1WrVi3c3d2FDg6NiMaNHdC3b180amRv7uLs6m9mbmZhbWUFQ0ND8Pl8pGdlgcfjCtksdiUx0wGSBJPFQpfO71cCTBFnkyZNsGzpskOfTZjgFB8fHymVSr8QCD6qkV4thHL27Nm9s2fPLgoPD48+ePDggE6dOkUPHDgwQF/+ltrEDQgZ4B92OmzTrl27pqtUKjCZzL+0u+XHXmM1Gg04HA7s7OzeyxhTKpW4efPminv37n7Vrl17XlWvdKpCQHtPp0ybsvje/Xsb2rVrJ79y5UrxqlWrGu3bt49VWlqq+BQtZxl/da0c1YAlJSXF/OrVqxJTU1MVSZII8Pdf2LNHT7O6vkNZ50uXLl3IYDDKHRwc3unhoXZgbdu2BUmSEIlEHyUpgXrI/urkEHWlapWnp2fwn3/+OQeoLnep/ROIiY7J//zzzwMAQACB2+zZs6Pq+mwDGvDhIKBfqgZA24tcqUSFQgmRWKRSq1TlVNwzJycHqWlpyMrKev7iRcLFDh06yL06daLdunFTmJScXFFaXCxXq9Q5ibduZ6S8epUrEYkLn5SU4El8PBo3bgz/wADY2duhoLAAw0aMwJ49e/HLL78onZyc0L59e2HzZs2VDDpD/iotBZmZmcyWLdx8WzRv4ebRrjWvebPmLAZBYMCAAXB0dDRxdnYONDMzs7S0tIS5pQV4XC5WrlyFNWvWMvk8HoeymGk0rWDUuLFjAYx9r7v0LolsVV28tPRJA2BsamKhbR1LlCj/QgIgAfD5fHzz7bdRUVFRXllZWbcHDRoUePLkyeSQkBAnalxAlat+y5Yt05KTk6OuXr0a8aGKcG8c31+QSKbRaEVqDAwMwGKx3olTaDQaysvLK/7H3lvHxXV1bcPXuAODDO4WJCEQAiSBuBJ3d5fGvWmkcWm8scbdnbi7EsEhuPsM4/79MRwYCLHe6f30eb9n9demgSN773POXnatay1csHDKzVu39n+JWDgiPMKkZcuW8y9durQUgDYuLk4qFAoFQUFBOf+Nxi3Uf9rb1Ov14HA49KdPnzLFYnFxeHg45HI5e9zECQuAL+d4b926VXzj5s3Nri4u+JHSOgLs5u7uDpVKhZ+Z9yE8ZwD/GH87iUSCTCYDiUSyPX369FUDCO5zZa5UKjF37tw+xHn79u077uPjU2M1/49A5v/kZwnxBRUUFGDv3r3XTExMXhcWFmrSU9NkOTk52R9jY26MHj1a3Kt3b0yZNMkARNJooYMeapUalhaWcPfwwLhx4wAAlpaW8PbwhK+fP+bNn4eTp06yzp45y/Ly8gq2s7NrbGVlReObmwMABAIBli5dCjKJFGLv4BAuEAhgZUCP448//sD27dtpbDaHSSGTQSJX9iVXq1G/QQMMG/ZjipleWfnyNTbFz/m965a/08hly5Ytc6RSKRo1atSJ95O989r30wNwdnLCzp07T/bo0cMVAKZNnTqgdZs2r0x4vCovHTDs0wwGAydPnrzi7u7uIZFIUi0sLKDX63/6PkjUof/sa1MoFMjlcgiFQvD5/Co++u8VDoeDW7dvH7h69eqyLl26ONb+PWH4DB8+fM6uXbvW8/l8aXl5eenKlStdr169yuRyuYp/soc8AFD/6XwIi8WCVCo1f/36tYTP52uUSiVCGjee0zSsSZ1E7IR3vnz58omUSmv/R0IVUqkUzs7OcHBwgFqt/qkgDq1WCwLpqVarf7q1ZVyitm/fvjMuLi61FDSqul716dOn66fUT48ZDAZ27959rV//fg2IY77eluL/5P/kx4TY1C9evJh18uTJ0UVFRXeKi4sRGxsLOp0OZ2dnRISHw8XFBYUFBfj44SNYLJZbSEhIW/8G9U0DGwaynF2cyTQKFQvmzwebwwlxdHQMt7KygsBKADt7OwQ3Dsb6DRsoHBabTaFQQCaRQSLan9LpCA5q9ENj/rJirv46jBXzl5U0EZmoe02+R3R6PciVwF+VUgmVWg2RSKTRaDRyEgAqjYa3b9+q1qxevV6hUOz08/VFj+49+lOp1J+Gcq89buMSte7du7ucP3f++vgJ4zvl5Oa+7t6tW+eoa1FRbJahoqaaXhews7PD4cOHT4wePTpEIpGAoIj9mUIo8Z/NQEeQ1VCpVBBj/5EUKtErfvHixeO6dOlynQwStEZpUELCwsLYEydOnHPp0qWl5eXl2mvXrlXs2bPHwt7ePlcsFv+jXvo/SgFEeOePHz9mKxSKrIYNG6KiooI1cPCg2cDnJRnEy3b8xPG4J0+enBMIBBAKhd99P41GAyaTCR6PB6VS+dNfCI1GAxMTk6oc/c8MORFWqVarxeTJk/cMHjy4GVCTXpMwTWbMmLEvKirqKgAMHDhw8/DhwzsZjiXO+D/5P/k5QniZSUlJ8n79+kW6ubnFjR49OlytVrcVCoUCNze3DhaWFla2NrYwNTUFm8NBVm4OOGx2JQDM4DFX5Zn/A6ppIpxtrJSMR1qbnaF2EVu1x/wlXvivb7RanQ5qtarqSI1Gg7Lyco1Go5GTSSTo9HoUFRYiLz8f+Xl54uTk5FtCoTCz/6ABKMwvQEJ8gjYzPUOWl5eX9TE25sboUaPEPXv1wvSp0/Dh4wdQqFRERkZi0qRJ19q2betfs6Ll50jtkiti3j179ex44+aNQ3v27Bn+4MGDaxMnTPzz0KFDk8kAtJWeJ7Gaffv2bfzm9Ztj69avG0zUi/9MT1qr1YJGoxkqGv6BKCiFQoFYLIZQKASXy/0hfBWHw8G7d+9uHDxw8MOIkSMCyLUMQcJLHzFixJydO3euNzMzkwqFwtIdO3Y4Xblyha7ValX/JOKd+k9aC2w2GyUlJebPnz+X2NjYaLRaLZo1azY3IjyiMpZU0zomRrL89+WTgWqP9XtFp9OBb2bg//0nwH4EYxuHwwGLxfqp3r9er0d5eTkaNmwYuW7durFA3bSud+7cuXPp0qUxANA8IqLzvn37pgH/55H/n/wzQnyTO3fs3KFWq+P0en3Tfv36PXZ2dv7b1/xaOLvmvWt60LUVNPkzBfylv3++x6nUKtBpdKjVGqjVKqjUKigUSjGdRkNZaRkyszJRVlYGcUWFLC8v/4ZMLsvoFNkJJcUlSElJQVxcnO5Tyqek+IT466NGjaro1asXJk+chOLiYpApFAB6qFQq+Hj7QFgmxMgRIwEYmo+4uLqgSZMmcHR0REF+Ad6+iwaLwfScO3/eoPDw8J5t27YNwHeu0c8QYlW3bt02LCcn5+zNmzevXLpwccqV3le8unbr2o6Mz0FyS5ctG/To8aPjL168iDI1Nf3peyHx5z+VEqZSqZBKpVAoFD8E8CPmuez3ZZOGjxz+tLobYE0JCQlhjx83bs7Fylx6enq65NmzZ+ZmZmYF/6SXTmUwGP/IhfV6PczNzWnPnj3jisXijPr166OiooIzYsSIygYsRscaWd1Hjh75mJiY+JDP5/8QMEKj1YCkryYj+CcWjBiPiYnJT2eLUygU4PF4rBMnTkRV582rPREySHj58iX69u3bVSgUwoRn4nfuwoWrLBarCnn8/5r8bBrM/5O/Jyq1GglJCRkAMHjw4GWEMjd+72oqXtT42dfkW3nmb3nQ1e1PNVCpVJDJ5JBIJGJ9Za25TCpFRkYGcnNz1YUFhS+TkpOiAxs21DRu3BhPnj7VZmVkyrOyslRxcXFvtFptzMbNm5RCoZDy4cMHakxMDFJTPqly8/OUANAwMBA6rRYvnr/Avbt34efvh/HjxzNDQkN5Ko1an5GZIaGSKE4NAwM71KtXj9sgoAE7MDCQptZqMPWXqWCxmBbOzi4dLK0sbaxtrGFmamZAzmdng81i8fjmfJBJ5Mq1+/5c/X8i1TlygMGg49SpU5f9ff1CM7OzXvUf0L/jrVu3NOHh4SRjJjkd9GCxmDh69OjVsLAwEyqVKmYymT9vTJV79/d0e/tP76FUKkGj0b6bXlav14PL5SIjI+PZ/n37340ePTqwtuFJGD2jx46ds3vPng0sFktSUVFRtmrVKuc2bdrQy8rKVP+YQrexsflHLsxmsyEWi20+fvyocHBw0BTkF6BRcKPJTZs2rc6dV7ZGBSoDZHo9lv++fArwY6AzMpkMpVIJComCfxJEqNPpwGazQSKRkJ+fj5/1EhN8v8eOHbtc3dvc2L8wgPGWL1/eSSgUKqysrLB79+5jlhYWVR8+8L8j2E5s4F9T0oQiV6pVYNDo+Nm1uP8nPyYatRoUMkVPo9Fga2vLAj43yI15EQj5ESNTLpcbGnHo9VV55gqRSK3RahUAoNfrkJeTh9y8HJSWln1MSUl56Orqqg4MDMSTJ0+QkZGhyMnOkSclJT3S6XXvDhw6iEuXLuHk8RPQabXQaLRgMOjQ6vVoFhGOw0eOYO/evaBSqBBYWqKsvBwKlRIDBw4Eg8HAjh07wGQy8e5NNIIbNUKziHBEXb2KN69fIzk5BRqthqfT6i47OTl5m5mZwcLcgvTi5UsbKysrsFisz2q1v8Z+Zyw1c9b/vXeeiH9wuVzs3L3r2JTJUzzT0tN0ixYt6nD79u1bNBqtxjeohx7u7u7Ys2fPxV69erWhUCj4WSV2RGrT1NT0p9Sgf0mI/LlcLv+h9CzhyP3++++TRowY8ZygLa/drKhxcDB70KBB09+8ebNCKBRqc3Jy5NbW1pbu7u55Mpnsp88HAKg/u86REBsbG/qZM2cslUploo2NDT6lfMKIESOmAzXrzo0/+n37971NSUl5zGaz8T2EN8ZsQhq1BjTmf96P91tCWFYEcc3PkpYtW04lOqQRHzLhmQPAhAkTNkVFRd0AgDmzZ1/t2bPnfzUs971Sl4f2eWj0858RHgDx85KSEly6dGkZjUYLHjJ0aGcyiQQtdN+tJD4H//wIEKrmdYyv8d/wmv5twmAwEBQUZHP9+nX8+eeff44dO/aL3dZkMhmoNEPLS71OD51eD5lMqlGr1HI2hw1xhRhZ2VnIzsxCdnZOXHxiwsMmYWGK8PBwPHr0CJnpGYqMrEx5Tk5ObkxMzI1RI0dKevXujcmTJ6G0pBRSqRTCSsbIWbNnISAgAAsWLAAAWFlYws3D0MiFRqEiNzsHeXl5FD8/v5a+9Xzr1w+oz2zQMIBRv0F9EoVEBpfLNfHw8GjDYbNd9+zeMzAmLjaqTds2h5s1baaytLTK4XK4oNNpqZ27drnYs3cvTBg7HvEJCeKmTZsiKDBIfOnSxVZ79uxhHDx4kH7rxk3ysWPHBg0fMdwpLDRU9fjJE7rAymqQh6cn38nJCaampjwajQaNVotvodf/m+/X5/cioVOnTh5z5829NmHChMiHDx/eHjJkyIpTp04tqiadqQ7T9+zZs3XHjh1/vXHjxsqftR/+k/XttYVg/gRQlar9Hu+ZTqcjKyvrxe7du99MmjQpuLZTRdT6jxs3bubDhw/XOjk5qePi4spiY2Pde/XqVVxYWPhj7DbfKVQrK6ufflE2m43i4mLHd+/eSQUCgTwjIwNNmjUZFhkZaVvX8cTybdq4aQ6FQgGbzf6uh0pYWFKp1LCQ/6WoMwEEqaRz/NvXoVAoEIlE4PF4fqdPn94C1CS+Jabz119/Pdu7d+8sAOjSpUuv6TNmdAb+3aFoY+Ws0WpRWFCgvHfvnjwuJvaUWCIpsHOwb9u+XbsGPr6+PC6HUwOsdP/+fRw5ciQyLCzs+uPHj8FgMK/179+vEwHM+ZExEEKu+uB+LJRpnA4iRmhcyvP/uuhgQAY3bdp0RNOmTX+rqKg4ERISYrd69eqFXC6XlpGeAYlYLElNT7vp6+eXGRoSiujot4iNiUF8QgKKCgrzot+/uzll8uQcN3d37ebNmyGTSiGXy6HX6qHSqGBvZwehUIiJEycCAAQWVrB3sEfz5s3h6OKMopJifPwYA4FAEGQlEJAUSuVbR0dH6xbNW0xkczhYsGABOGx2iKODY7iVjTUEVlbgcrlYv349tmzdQuVwuCxDnTmpsqRNg7Fjx9aY5+07d4ITk5Oixo0dNzQyMhJanQ6tWrXE7DmzIZVJxYWFhZg9Zw7eRUc/8vb2euPg4Ij09DThh5iPRz+lppYUFBQgKyNj55LFi7Fm7Ros+W0xNBrNb4uXLGY1b9ECEydOdLazs+szdsxYlAvLkZ+f36xx48ahPj4+MDU1JZFA4ppbmFdGOX5eY5YfFeJ9HzV6dKdHDx8OPnHy5LHTp0//Nnjw4Ihu3bq1MIYeEqHl48ePL/f29r5WXFz8ztLS8qeReP236LXJZDK0Wi2oVOp3E5gRTbo2bNgwfeLEiU9IpLqjiC1atOAHBQaNf/3m9XZ7e3tldHS0vH379vY2NjYZ/4SXTv1RGrxviV6vh5mZGSMtLc2EQqEkyuVyiMViTJo0aRHw5Vf0xMkTcfHx8fcFAsE3++8SuWwSiQSJRPKPkBB8SYjSNRaLVcUc93eEqDcHQN25c+dhKysr6I3UDFEqk5eXh/Hjxw8AoLeysmpw4sSJc4bw179TanvlL1++FJ46dWpbbl7eTqVCUXHp0iUpAHB5vKXvoqN5bDa71bix4yZ7eHq0t7Gxwb179/SLFy9uSafTH0W/eQtPby+sXLkiksvlpHTu3NnD+B51CbmG8q35TqjV6qoOe98LzCLuRzbK9ioUCjCZzP/feOt6AJGRkQ7mfP61zZs3R546ffqPIUOG/DFw4EDEfojBhw/vUVRagqHDhiE8PBw5OTkoFwqhVquRlZUFmUyG9x8+8NPS0qwLiwpLPV09nAQ2gtZ+9f3NGgU10tjZ2en10GP+/PlgM9mNHJ0cW/DN+bCwtISJiQm4XC5ycnNgZmrGu3DhAqZOnUri8/mtwsPDl5jxzRDc6EdL2uhV8yLB8F4oFYoKvV6P0rKyMgDmFDK5KmzO5XJ51gJrNKjfAL179eoMoDMANA4Ohkqt3lQuLIcJlwtXFxekZaSfzC8oiHFwcozOzsq68TY6WlxcUoLCwsJYU1PTWBabhdNnTuPcuXNo0aIFc+bMmYr7Dx7g9ImT/ecvXODTtGnTsY0aNbL7mY1ZflT0AGhUKg4cOnT0yZMnyVnZ2a8nTZrU18fHp8jT09PIBzX8l8/nk3bs2HGof//+gTKZTMvlcv+2MiZKy/4phPvX7qtWqw3fdSXfyLd0Co/HQ3p6+tPDhw+/Hz58eMPa+wFh8IwZO3bOlatXtnt6ekKv1xekp6f7de/evaC4uPinw92pV65c+akXJJFIYDKZZi9evCjOy8uTZ2RkwN3dvUXvXr09gc830dre+fcw+JBIJNDpdFRUVEAqlRpQitr/zuuv0WjA4/HAZDKhVCr/I2CcSqVCv379lg4ePDgIMPYeDeui1WkxZMiQXnq9PpvJZGLLlq2HuFxu1e//raqEDBI0Gg3mzJlz4cGDByObNm0qun79Og4fOgQHBwf4+/tDr9dj/fr14oYNG17evWf3ZS6XO3jQoEEbJk+ePKqkpORRv379Wr9++cpeJBQeiYmJwcyZM4e2bdv2OYPBqJp3XaF8AJBIJKBSqSgtKxO/i47G82fPPrq6ud3x9fUFCZjUpGlTqx9RxsR9ioqKcPv27agjhw+/6dmzV8vxE8a3wP/jSt041RDWpEmncXJ5tKWV1aUzp0/v8vPzK2QwGHjz7i0AoG2bNtizezfWrV2HMWPHYO78eVi1fAXEUgk+fvjQyM7OPnDMmDE9WrZoGWxnZ0fnm5uDVVlmymKx0Kxps2+Oh8fjGdpRgqTicrlV34thrD86N4Oo1WpodTozMpkMhUxmrlQqIZfLUS4SypRyhZbPN4NYLEF6RgbycnORmpr2WC6Tvh4xehQK8vJ5Hz98IBcXF8vLy4WSwsLC1JiPH9NFFaJ0hVKJixcvgsViITQ0FL6+vhAKhejfvz/OnTuHhw8fKtLT02FvZwdHZ6dTN2/exK1bt1YtWbLkYnBwcKf/qW+cwETQaTRs3br10LDhw31zc3OLhw4d2u3xkyeXaZX18cbvRp8+feoPGzZs5cGDB+dzudz/yMH6n1DohJculUrB4/G+q6tcJccKNmzYMHPY8OH3vvS8unXr6uTv7982MTHxjp2dnfzy5ctlnTt3thIIBNk/u4SNamFh8dMuptPpIBAIEBMTQ3v27FmJQCCAi4sLZs6cuR74fLKEx3P27NmE169fX7ezswPw7W44BLGLTCb7pjcPGF4QmUyGoqIipqOjI02tVou/F9VYW0gkEtRqtWET+JuhJRKJhIqKClhaWgbu3r17PlAdvjUOVS9fviLq/v37F0gkEiZOnLh94MABDYlj/gn5upKrBj19KdRsnP+OjIzsV1JScsbR0RFSqRRmpqbtKBRKsx49esDCwgKxMTFo2LBhdEFBweXnz59j6NChx06cOHE2KTlZ2aF9+96LFi06a2pqik2bNvW9fedOt+Tk5BczZ87c/ueff04xVuRisRg6nU6XlJwsvXHjRgKTwbheVlqKZ8+fP/plyi/3Hjx8gB07dqB3794oLCjE8uW/n0nLSH9jZ2vHrGsWxrmwKpS9Toc1q1ffiY2LW2NtbX3XxNQUT589nTxm7JgWBCDm/1WpTf/ZunXrwBYtWwYuXrJkqVwmE9erVw+urq7ysrKyYwIrQUVsbCy4XG4ag8G4IJFKoFSpUF5eLvb29r7j7Ox858D+A+svXbyEv/76C9euXcPRo0cHdu/ezaVly1aMjzExdDaLNcjH18fc1cUVfD6fR6PTodNpwePyAAA8Ho9GJpNBoZDZRLTFWHXI5DKwWWzo9DoolSqolCoIRUK5RqPWEDn9vNxcZGdmITkl5YlSpXzVvkN7ZGdlX6kQVeDE8RORT5489UpKTPyQmJz0ePz48Vo7Ozts2bIFWq0WMqkUMqkMdvb2GDR0CLZv346LFy8CAOzt7ODt7Y0u3bqiW7du5GPHjvGOHz9uGhgY2MHBwcHR0tISZDIZ1tbWWLBgASgUiqNAIOhgY2NjYm1tLT527NiSPXv27M3JyYlcu25dSvt27Tz+p4xFQlF379HDZ8KECUfWrVs39OXLl1eWLF58adWqVd2No1/Eu7F169a5d+7cOZuTk/PG0tLyb+fCdTodSkpKoFAo/rbDJJPJUF5eThaJRByZTCYmwMxfEzKZDIVCARaLBR6P913NwPh8PmJjY++fOH78w6BBgwI+b69qeD9/+eWXNePHjw/OyspCVlZW9vbt2219fHxIJSUl+p8ZXaY6ODj8tIuRSCRYWFiYnTp1imZiYqIICAgA34wfOmLEiMbAl73zQ4cObefz+fjWS1DZghV6vR4JCQlVeY+vCYVCQWFRIUxNTdv269fvuEAgYB4+fLibXC5/8D3GQG0h2IK0Wi1UKtUPk8uQSCQChEHdsmXLATMzszov8ODBA82ypUu7AEDLFi3brl+/fjLwP5O3re0J10SdG+xSYy+2abNmnVM/fbpmaWmJtLQ0q0mTJh1dvXp1ezMzM7BYLABAPR8f9O3XDydOnHj2/PnzyJs3b4qcnJyUAisru/0HDpy1ray+mDt3btcrV650f/PmzaUdO3bMHtB/QD8PTw/24cOHs8gk0pm3b95q3D3cdwhsbMqWLF6M0aNHIycnB48fP4arqyumT58OU1NT8pYtW/Tnzp3Tk8nkhK9Fc2qH1x89elRw9OjRGTdv3jxZWFAId3c3jB4zBjQq1UatUf9Xuu79W4R45hQyGQID9obn7OyMZs2a8QDM0Op0aN6yBX5bvBgyuWx7YUEhfpk6FREREQ8DAgLe2tjY6MkUsiw9Pf06h83JpNNoeiqVemLjH5tw6uQppGdkgEKhLJ44cSIrIjwcK1etcnR3des3efJk5BcWIC0tLbKkpIRWVlYGmVye8ezZM3FJcQkyMjMKY2JjroeEhJSFhoTi/r17yMjMVGdmZsrycnNjExIT7w8bPlzTo1s3TJ82DQWFRQAAuUwGBydHdO3aFWQyCRqtBvcfPrju4OBw3dPDE/3790fnrl2w96+9SE9PZ/j4+DTx9/MP8K/vz/Lz82PKJDJ06NgRjk6ONHdX9xZWVpYNLAUCWAsEsLW1xZq1a7Bq1Soml8ulVTV2gh40Gh3Nmzevvby8wMDAv+Li4kRPnz49c+HcueOtW7VabGCL+59R6oSiXrJkyZCoqKjjcXFx11evXt2jVatWFe3atePVrHQAeDweafOmTQf69O0bKBaLNSwW64e9bCLs3bt3b5iZmeHvUqWWlpQwWrVu/aqet7dreHj4mCdPnpy2s7P7LmexoqICLBYLlpaW37w/UWG1f//+zYMGDTpQ20snDKMhQ4Y02r59e4hMJnuVl5enfvHihaZx48YmSqVS9DMjEdSAgICfciG9Xg9ra2vcunXLNjMzU+jh4YHo6GjMnDFjPZvN/iIY6cWLF9LExMTDwcHB37SgKBQKtFot4uLioFarv1lqQKFQUFJSApVS1Wn9hg3X/Hx9AQCenp698vPzH/B4vB+eJ5PJRE5ODjQaDahU6g9bkATLXOfOnX8dNGhQJVK9WgjFuHbt2i7Ezxb9tujSP+EJkmtZ2bWvXwUk0+vx6PFj8ckTJ7ba2NjUW7JkSW9j5ijivxs3bryblpa2Ji839w6FQkFpaSnp9OnTr/v06fMZCwmrsuRv5MiRTdPT0xe9ePFiztOnT7FkyZLDtjY2lTluQ//r9evXH+/YsSOHRCIpf1+2zCOiRXPxmrVrEBLcGA8fPUJ4RDimTJ6Mtq1at20Y0DA8NDQUTZs2bR8cHOzv7u6Orl27KlevXu1KIpEkM2fMWGZra1tnvaHxejy4f1924uTJ9Vqtdum5c+fg7u5uNWH8hKU6vY6el58/lm9mJv1v4Tb+twiFTAa70mDjcbk8aysBGtSvjx7du3cB0KVcWI6dO3dCKpWuKy4pzvf09sKo0aNw/dr1e7du3ZpnamKa275De01AQICYzeEgPT09vqS4ZKmvvx+uXb+Gd9HvloaFhWHIkCGIiop6MmjQIBMqhQKZrJKf24wPdw8PTJ8xAwDAYbHh5u6O9u3bw8/XFwqlEinJKeBwufVDwkJbBgQEcOrVq8ekUqmYNn06Pnz4QHWwd2hhZs4PsLG2hrW1Ncz4fKxctRJ//LGBzmKxGIbGTAaAnVqtQbNm31eOVpfUBr7xeDzMnz//4ID+/c88fPAwSiqVLjY1Nf37D+QniB4GkPOhw4eighsFkwFgyZIlPVu0aHGHTqfX2NdJIKF3nz7+ffv2XXLmzJnfiAjKj4pQKETjxo0xfvx45OXl/S0vXa1SMa2srRswGQzcu3fvVLt27dgPHz486Ojo+FU9QzhcZWVlcHNzI5qyfPUcExMTvH///sTdu3c3tWnTxqz274k1nDp16pYtW7Y0qVevHlJSUlQSicSqadOmooL8ApDIP2cvocbExPyUC+n1euTl5bHi4+N1jo6ORYmJiZDL5ZaDhwyJAGpzPFVvnocOHdpgamoqYTKZ3wzRcDgcxMXFITc3t8rT+5JUKhQA6LR2zdoqZS6Ty6DT6sqpVOrfyvMQrEICgQAcDueHLFACCGdlZeW0ddvWRUB13alxCGvxb4vPPHz48CYALFi44HLr1q3ZwM8NtRPrn5aWJrawtOCZmhg2Dl2t36ekpGiOHzs+PyExYc+pU6fEABAXF9dl165dV8wrm2ckJiRg0W+/zXr27NnG5s2bIygoCDExMZg+ffp5QpnXhdolcu1JSUmZOTk5cHJyajxqzOg2NedKQkREBLtz586DhOXC469evRRzeFwMHjS4h6+vb8NWrVvb1atXb0DTpk3RvXsPnlKlgqmJSY37mJqZ8VxdXaUVYjG6de/+C4VC+QxwRMw3OSkJFy5ePLd/375xBYWFZQMGDMDQoUOX9u7Va16Lli2ZKrUaq1etGksCxP8vkvl8TYwNHolUCrlMBrFYLNbpdFV9qzMyMpCVlYWUlJTnFaKK58OGDUNuXi4SEhL0eXl58vz8fNGnlE8vdHpd2pVrV1GQX4CsrCyuvb19fr169eDi4gITExOo1WqIxWKIxWKsWrWKXt+/PmP06NHSJk2a6AICAnj379/XlpeXuzZu3LiVt7c3vV69ehwnJyeKSqXCjBkzwOVwnJ0cnTpYCqy4NkT7Uy4HGdlZYLFYPBqNVkVLq9Go0aRJEwwePPiH1oNBN5ByfQlgaYyHqRmErT6iNnRTJBKVk0ACh8Nh/6OkGt8pRCKwUVAj0qrVq68tXLAg8tWrV3fXrl17+Lfffhtm7KQZWogC27ZtWxAVFXVEIpEk/51203q9Hnv37kXbtm2hVCq/q4S5tigUCh2VThPb2tjyaDQabt68eaBL166UO7dv77O1tf3q3k+j0aBQKJCcnIzAwMBv0sNWOmnKU6dObWzTps3vtXkzCGOnY8eOYXPnzHWgUCk5dnZ25cnJyVajx4zmyLxl0p/VWY+alJT0Uy7E4XDw8eNHi+PHjwtZLJa2oqICffv2nVlNEWm8RRsW893799Jdu3atZ7FY+NY4SCQSqFQqVCrVNwldCGVOoVA6rV+//hqBzCRVXker1eo1Gs0P58BJJFJVtx6NRvNdORZjUSqVyMvLw6GDh064ubpRq3Gi1X7ukydPZMtXLO8HAIGBgV2XL1/RtfqonwPAIoOEsrJyLF/++wY6nf57cnJys+W//37Ov359tnFp2N69e9/u2LljcOtWrZOsrKwwd+5cfPjwAWfOnLlaVFg0+/ad2xvOnj376vfff59VVlb2ZNiwYXj98hWyMjJhb2fvOWnypB7A19ME6enpmkuXLu1RKpWYNGnSaEtzizqPDmrUKHzNqtXHJRKp2chRI2Pbt2tvT6VRQaPW9AKId4MIFwLA5YsXT5eWluo7tG8/MSIiwsjlqcYFFBcX4+XLl7du37694t79e49z8/IwYMCAXkOHDt0ZHh4uIM44sP9ASWxMDEaOHEn7N2y4/x2pXqe4uLiK2NjY7bt37y769OnTdQqFkrx//35ci4rCufPnqzAmCoUCAksrjBk/FkcOH8aFyjyznZ0dvLy84OPjA2FpOZ48eYLExER98+bNR9jZ2bnQ6XRoNRpYWFhgwYIFYLFYztbW1u2trKx4AoE1zC3MweVy8er1a3DY7GrFXNn8hE6joWP7Dj80O4ZRpM+4s6Hxt/alv9f1TdastKj559egeznZ2fh14a99VRo1uvXo3p3LqbN/1X9Z9FU71Pz58ztdvnSp74sXL87s2LFjeIcOHTqFhIRYEStGHG1tbU1ZtWrVkenTp4fy+fzvwjkZi0wmQ1paGoEz+luOl06nq3IQDSx4DNy8eWNvh3YdKHfu3tljZmb21fOpVCqKioqQn5+P4OBgiCq5D74kXl5eiI2N3fju3bu5gYGB3Gqy4up3w8HBAZ27dJ568uTJuXq9Xnvq1Kmy5i1bmNna2EhFFRU/xT2gtmjR4j++CIlEgqWlJWv//v1WCoUi0cPDA9bW1rxZs2ZNBT7f0ImB79yxYz8A6dfykAR5DJlMhkQiAYCvIiCJMLuFhUWn1WvWXKsus6i8HkhV9ag/Gsqh0WgQi8VIS0uDVqv94fypWCxG06ZN+w8eMripYSzGjVdIUCmVGD1qdG/i+F27d5+nkMk/tb85GSSIRCI0bdqke2Zm5uXGjRtDoVDc6Nuvn9eKFSsO9e7duw0JwM2bN+Vjx45tXr9+fVlmZibc3d3bm5ubN3Vzc3vk4eFx78XLF5tWrVpF2rNnz8a8vDydj48v3Nzclr559fq6UqV82b5p+wHWAutvjufxo0clTk5OKm9vb/Tu3bsfsS6EEIrZ3c2tl6hCNMnZ0YnXvVt3e+L3tb2j2husRqvFuXPnN1RUVGDw4MGVLXur24ECwO1bt5I2/PHHLLlMFiWwtkZAg4CW/fv1Wzh//oJ2tTej2NiYE7m5eRAIrHk/K0z2bxdilseOHbuxcOHCQU2aNClPSkqCi4sLGjZsCFNTE+TlFyA9PZ0d0KBBez9/f+fAwECmh4cHUyaXkdp36ABHJyeam6trC0srqwY2NjawsLAAj8fD2rVrsWnTJiaLxaKRK9ufAgbF3KZNm7895h8pSyR8aFLlP3roq75NUo2jSLXO+pxYhxCdXgeNWgM6nQ61Rg2VSgWptDqiQSKRIJfJkJubi+ycbJSWlF6Jioran5mV+RwAqW3btqMMkaT/ecilcaRh9+7dp4ODg2kFBQWagQMG9ItPSLjPYDCqaICJ46ZNmxZy48aNkffv3z/A5/N/6H5UKhU0Gg2PHj1Cu3btUFxc/GPjrXS8qllQ9YZvnkTGtWtRuztFRirv3r176Gv7N+FAJiYmoqCg4JtEYmQyGcXFxdItm7fsOnjo4GxD2eHn+9iMmTMnZmdnr9DpdBWPHz8uO3roiNfQYUNLy8vKFD8jl/5TmOIqFayVSqUSBwQEyDMyMtC4ceMhISEhXzQxc/Nycf369T/t7e3xtbpFEokEFouF7Oxs6PX6ryrzykWFlUDQYf369dd8fX2NPs3K6wFgVlIzfitsbyx6vR4WFhZIT08HQa7/I5Zj5ctA3bJly9HqfDjxARius279+qjklOQbAPDrr79eCGncmFobYPGfCOF9t27dul9SUtLlyMhIWFlZ9X727Nm5lJSU3Ojo6LafPn063qRJk64zZszo4ejoKPPw8ICnp+fRSRMnDrYSCJCZmYlXL1+2L2Yyb+fk5GywsbEBg8EI+GXqlE2jR41ude1qFLWouPgl34xvahhz3ULMOScn93BaWhqoVKp5YGCg2ZfG7ubmZu7m6gaRSKQsKy+DOd+8zs2uNqf4pQsXk9+8ffPa08MjuHuPHo6GdTBIXGxsxY2bN9dcvnx59YcPH8BkMvntO3Q4MHbM2O7WNgZjRFdrY1er1ZlxcXHYv3+fdkfjnT+y/P9rhQTg0aPH5UOGDOkEAD4+PpFbt25dzuVxPa0F1uDyeFi3fh22bNnMYLFYdBKZDKI3uVqtRtPQJn/73vqqP2s7BUQk6dvfxLf44omjjI83FqlMBhqNCp1OD71OB51eD3FFhUIul6u1Oi30Oj3y8vKQmZmJTykpz4VC0fPBw4YgNycXMR8/6nOysuVZ2VkVScnJt6FH6t79+3D18mWcOn0aNBoNSpUSHu4e0Ov1oNPp9hv/2HikSZMmJv+Wckjj2GqDBg2wfPnyy/Pnz49MS09/sHTp0rOrV6/uU1foffXq1XsDAwOPFBQUaH5kryWTyZDJZJg+fTosLCx+mP5VozEYUtHR0bXmAdDodNy4ceNgs2ZNJa9evT5HRGlpNNpnZDZEMy6hUAhHR0coFIqvpg/4fD6irkVty87Onu3o6Fhn9CYoMJBrY2Mz+uXLl5saNmyoZjAZGisrKzsLC4u0n8EJQ3369Ol/dAFC0cXHx+s+fvyYXVxcjIKCAvTp23cc8OVStZs3b76ytLBIcnN3/6qCplKpSE5OhlAo/GrohkQiQSgUgk6jN/pzx44bBmVefccqi9sQTQCVSv0hhW4olTHwyzs4OPzQuSQSCcnJyRg3btym4ODgqkkYjys2Nla/fPnyngDg5ura6rfFi3sAPy9vTqz7ol8XXoqOjj4DAF27do0aPnx45IEDB+5Mnjy53enTp6HRaAadOnXKhMlkVqhUKnTr1u3aiBEjOhHX8fLywvo//rjVulUrRkFBgWr27Nmm3t7e74OCgqDValFaUhJLp9Hg4+vb+WvjJ8FQh+/r51vevXt3pKSkDGez2V/cd/XQK5hMJtQqlSWZTKmaU10bPXF9tUaDX3/9dRAAzJs/fw9xzIcPH7B/375tjx4/nm9iYiKzsrLCyJEjl/bo3n12i5Ytq4zQ2l5HVlYWzp4+c6BCXAFHJ6cGxHG1qwD+p1i+/gkh5rZt29Y9ABAYGNjq8OHDUQKB4KvnEUI3AkZVe80ko5/UVM6fU2jqqwL+n3vMAPD9RrVEKq3qxaBUKqFSKiEUChU6nU5NJpNRWFiIkpISlJWVoaSkJPnTp0+PmzVrKgoKaoQ7d+4gPS0dmVmZyMrOjo/5+PHayJEjJb169sTUadNQWFQI6AGFzOAZRnbtDJCApUuXAgDsbe3g4ekBP39/mJubo7SsDAUFBZyGDRu2r1evnlPr1q05JMB87dq1UyIiIhjVq/PvEeLJzZw1q9PRo0c7x8bGRq1Zs2ZA//79VQ0bNiTXzho3bNiQPGPGjN3bt28b7eDg8EMOEI1GQ0FBAYGD+mFRqVQ0Op1ewwUniLuoVCpu375zdtiwYZ3T09OvicVi5OTkQKvVfha1pVAoVQBsb29vaDSarzqfKSkpWZcuXXoyZcqU8NqId8JL79Gj+9hTp05tsrW1hVwuzzp58qTAy8sLpaWl/3HDL+p/EtYCDAvPZrPNLl++zI6Pj1dyOBy4ubk17dmzZ0Og7lI1mUyGP7f/ObVCLEZqaupXFToAJCQkVB1TO+9NEAJUWjeko0eP3mwSFvbFkBsJhnwKk8nEj3Sao1Kp0Gg0YLFYcHNz+6G8kEwmQ7NmzRquXrNmClAzFENsmIsWLZqkUqnUXC6XfPTY0ZMMOv2nhttIAN69eydbtWp1DwAIDw+fMWHChEgAmDRpUlsmk3l39GgDII3L5VbI5XK0bdt2H6HMjcP+rVq2xPr166PmzJnTzsPDQxESGqIFQFEolWCyWDwmnQkOm+3xrTFpdTo8fviQRaPS0LZtW5uvzVYilkChUIDN5VhSvhHqJn67edOmm0nJSW8DAwP7jx49OjA3NxcPHz68de7cuQVv376NzsnJQa9evbrNmDFjZ5MmTeyI87+07lFRV18pVMqySuIJ76KiIrFcoQDPEGFi0uh0GpvNBpVCqRqF8Xv4v5VZTqFQoLSkJAsAJoyfsEIgEHz13fx8np8X8xje+9qZ5bq85M+z0DqdDupKL0ytUkGtUkEqk0EiFou1leFsiVSC9LR05OXmlXyI+XA9JCS0OCQ0BA/u3ENmdpY6KzNLlpuTnRifmHinf//+6qFDh9Jv377NePXqlSQpKUlfWFhIcFegQYMAKBQKSGVSZGdn483LV7CxsTFt1KiRu72zU4lSpdRx2JxGTZs2jfDz81N7eHgwyCCRXF1csXjxYhqLxW7h6ODQwNrGGpZWlnWmGjRaTVWtPfBvpRU2KGoalYpdu3adCQ8PZwPQzp8/f/SNGzcOGIPBCEdl7dq1o86cPv3np0+for8H+EwIofzpdDrUavUPR0NpVBqFQqHUeZIeBmT6xYsXoxYsWBB5+/bt67m5uXWywxF/T0lJqSKb0Wg0XxyPRqPB7l275owYOfL5lzAQXbt19/Hz82taVlb2LDU1VW5hYUEdN24cXy6Xl/+nXvp/DIpjsVgQCoUmDAZDEhQUhOjoaEyfPn0ur5LRrC65fv16SnR09EsGg/FFxUhQABLhky8hygnmNitLS8xfsOB2u/btLIAvg8j00KOsrIxaXl7+Q142h8NBamoq3rx5AwqF8t35c51Oh/Lychw9enSvOZ//2TYHADt37nx36dKlXQAwZMiQdU2aNBVUH/FzQHAAsGXLlvUAwONybY8cObIRqLa6R40a1ZrD4VwfMGBAZ71er2vbti134sSJo4CaFJTEhzp79uy2Bw8ebL958+ZbMTExI+7cuXOEw2ajSbOmFi9evURSclIUgO5fU2J6vR7xcfFaCpWK+g3qfxVhWF5WThVLxHB2drYgPPQvGWwAcPvObcncuXM7AoAJzwTZOTnLx40d+zQ9Pf2mp6cnWrRo0cbHx2f+rFmz2n6NDtaYYObcufM79AAsLS3xKSUl4tGjR3Id9FoWg0UdMmiQrYury8Bff13EzsnJ9mvarFnHsLAwLoFj1lX5B//7hEQmg0qjkQBAqVJqgJqgsLq2ts9/+vlRGq3WgGchkaFSqw2KWSqFWCIW63V6gEQytD9NT0dOTk5pXGzcDQqVWjhl6hQUFRTi4YOH6tTUVFlOTo40JSXllh7I2LtvLy5fvoyTJ08aWilrtBBLJKCQyOjRqyeuXbuGm7dvgc1kwd3NDV26dIGLiws2bNigSk5OVmm1WqSnp6NHjx4YNWoU1q5di27dumHr1q1gMBhIiE8Ag0FHbn5e8O49e9rn5ub2+uuvvzgW5ha2bDYb5ubmVVEAOp2OwIYNf2it/52KvFqICEuzZs1YEydO3LVz584JN2/ePLh50+bJ02dMDzbesfQwOHxz5s3bN23q1EDg26RhxkJUExERle9V6nK5HCZcnkqjUX8R9UzseyNHjrx26dKldiqV6s6XjiWcuZiYmCom0y85oTqdDtl6/YsL5y98GDp0SJ1EMxw2GyNHjlz2+++/t2vQoAEoFIr86dOnZmZmZuUymew/Ytmj/t2QBmCwXvh8PvvUqVOct2/fpnC5XKhUKtNevXpFEoM3FmJjPH3q1B4nJyc4ODh80WKjUCiQSCQoKSmpulddIhQKIZFIsHv37ms9e/ZsQ9y3NsKQEL3eEDotKioC5ztRpCQSCQwGA0lJSSCax3zveXl5eWhQv0GXvv36NkKtMZFAglQqxZIlS0YBgJmpqd/atWtn1ZxDTanuEV41o+8ay4uXLzWHDh1ax+fzMXDgwLkuLi4gxqOvvG7//v077tu379fbt28vVygU0kaNGj0MCAhoUZtXmsiRrVmz5kDXrl3tX7x4cfTx48dbIyIi+DY2NjQOh4O4+Pj7ALp/yyTRA7pyYTlycnK+sKiG+ZaVl1WIxWJwuVyTqn7JtT4WYm0+fPiAYUOGdTUxMYFWq8WLFy9OPX/2DDQaDRKJxCwsLGzf6FGjetnY2lbO59ugwxcvXihSPn0607pVK0RERODgwYOSPX/9BQ93D3xK/aRxdXXN7t6z57r9B/bj5s2bmDhxIunixYvTIyIiRnTu3LnB/+YWsAw6Hba2do4AsGXLll+7d+/+2MnJqWq9dJU82CQYjDRtJcJYJpXKlUqlhkKhQCqVIisrC9lZ2UhN/fRMJBK9GDhkMAry8hEbG6vPzMiUZ2dmipJSku8ApNR9+/fh8uXLOHXyJKCvzouKRCI4OTshNzcXmzdvBo1Gg7ubGzy8POHl7Q1zSwuUC4UoLi7mBgcHd/T19XUKDAxk29jYUPNycjBy1Cj4B9R39vb0am9lZcVzcHQEjU7HtWvXZicmJO6ZMmXK8zFjxpg5ODicYrFY4PP5KCwsvKbRaBKKioqQk5sDmUIh7tO7z92MzIy7G9f/Me9aVBR76rRp6j+3bWNxuLyhXbt1tYjs3Jl859ZtPyaL2cG/vj9sbGzB4XB49MqOa/8OBPuPi3EKavPmzeMvXry4Oz8//92Sxb8NHzlqZJypqWmtdAkJU3/5peGpEyf6JqeknHF1df3uMjahUIjQ0FBMnDgRcrn8h6qSZDKZVq3R1Hkj47SPl5cXtm/ffqVNmzYsAHU2hTF2Lq2travy6XUJiURCTm4uLl68sG/o0CFbP49NGe7cuXOXtvPnzzfLz88XVlRUFCoUCveBAwcyy8vL/yNwHNXPz+/vn0ylgkqlWlpZWWldXV015eXlGDZs2Hg/P79ql6fWHhkdHS05febMHg6HA6FQWOd1CfAb4b1/zWKRSqXo1avXip49e9YIDX9JNBoN3r9/fyMvLw8mteqVawuJRIJOp4NGowGNRoOPjw9cXV2/C6RBlO9oNBrqlm1bjtBp9FreuWFOs2bP3lxcXPweABYvWXLQxMSkTk+R8ITUGg1oVKoRSvvrioK4z5PHj09QKBSZg4MDbdKkSeOBul+0Q4cOLYmMjLxYUFAQs3Hjxl8HDhz4pAZwUk+qeqYdOna0a9euXfunT57cOnr06JmIiIhxAoFggKmJyfJbN2/ujYuP30zU/9c9NsDX15d6/8F93L5z+1Vdxh3x5MvLy2MUCgU4HI5ZXdcilPmFCxeydu3aNcrN3e1BTEwM5HI5LCwscOrUKVhZWbU/e/bs+bCwsBp5cuN1+tJ1N2/atEClVMry8/OhVCrbdu3aNXxA//7tBQKBX2p62tuu3bo9MjUxxdEjR0o6duy4Jz8/X3Xz5s1NsbGxm27evLlk3Lhx0/39/c3+tyl1Iu83derUSYcPH1qUmpr6pH///m179eo1gUql2pWVld3r2aOHVqvTIS0tDa9fvULKp0/Iy8uLf/fu3b2pU6cqO3fujIULF8rEYrFWIZejrLQMVgIrjBg9CocOH8YlgjrV1g7unh7wq+8PU3MzlJaVorCoiBUUGNjex8/XvUOHjuzo6LclS5Yu3WVhbu61YMGCuc7Ozh0tLCxMzC0sYG5uXhnOXoNNmzYyWSw2jUwig1TVZU2FBvUboP+A/p/N09bW1pxvZoY2rVuHdu/ZgwRgiVgiwelmzaBSqZaIRCIxn8+Hs7MzZDLZ5e7du3969uyZ5q9duwsSk5OOaDQatae3t/7sqdN/3r93D+/fvcPeffsQFBTEW7thPQ4cPIg9O3a1HztuXP2p06fiU8onvHzxomvTZs08XVxcwGFzWDZ2tlRKpQf7735PDKqaTqdj8eLF+ydOnBhYIZHET5kyZe2RI0fmGRuvVbXp27cfbNumzaXi4mLV99amazQaPH36FD4+PiC6gn5PFzYSiYTCwkKKja0t08XZpebvqpyA6kRY69atmX/++eeN6dOndyTC7l/SOWVlZWjUqBFoNBq+FB53cHBATk7Ooejo6JVBQUF1spfVq+eN8ePGTbl3//4KPp+vNTU11bm5udlqNJr0/6QHPDU2NvZvnajT6WBlZYXExERydnZ2DmGBR0ZGjgUqAUWkmnkyAPjrr72nAVR8jUWIYOeRy+VfDNEQm3/3bt06nzp9+lfint+S0tISmVwuf8lgML5qKBAd3HQ6Heh0OkxNTVFUVPRDbf1KS0vRu3fvhS1btDQDqi1WwLAq79+/1+zetWuhiYkJQkNDB8+YMSOYOI4Q4+NTUlJQLhIue3D/PigkSvfuPbp7OTk7sY27R9VGeRNGgEgkSmnRogVoNOpIH1/fz3INhNVqa2tLmTBhwl9LliwJ+/Tp09MHDx6Iu3TpUv1SkqrhSzQqFY1DQvrcvn371sP7D87roR/bv39/3xUrlgcJ00TRUyZN7nPn7p2zRHqiNmKZQqUgOKSx+tnz58jKzr5SVlamYdvb15mDkclk+QDANgqPEOFsYq0vX7p0fdr06V1lMpl2xIgRbQYMGLBMrVbLlyxZMkcPvP910a893FzdOMDn78qXiEEA4NixYwmnz5zZrNfr0aFjh/1Dhw4dSUQ4KqUVgFZSqRQfP35ESUnJqvfv3+ft379/dnZ29tWoqKhlZWVl5KNHjy6uTZtr/Hb/W8F0egCNGgXxdu3ceWfhwoWjANw9duzY3Q8fPgAAfP188SnlE6LfRkNgLYBcLkdhYSG0Wi0unL+AA/v2Q1ghMg8ICJjeMDDQtmPHDhQ3N3cxi8HU9x/QHwEBAXoHe/sQvqlZfXNLC/AtKhXzunXYtGkzg81i0QlQKp1Kw949e3fZ2diGrVq1avSPzINeK7VCGGtarRZ6rU6l1+shlckqAJgCqOpbzmKxYGpqynNyckJERAQADJbJZOjZqxc6d+4MobD8r4KCQjAYDKm5uXlKSkrK2Vu3br/lMFk3uFyuODkxEZnpGaBSqedkMtm5HX/uwNUrV/ApNXXp8OHD0bRpU6xZvZoXEhIydcSIEZEdO3VqanhPiNH+e6S29z1hwoSGd+/enXD27NldR48eXTZ9+vTZjRo1otSOLwYFBbFDQ0MX3rh5c+mP3vPAgQPw9fVFVlYWvpdONj09XWlv71DaJCzMxrgssa6UGgkkTJo0qUNsTMyunbt2TfiSziEiTQ8fPkRlNLpOHUImk5Gfn1+xffv2w/v3759cE+hZrQXatG074c8dO1a4uroiLy8v/+bNmwIPD4//CBxHjYyM/Fsn0mg0cDgc3o0bN2ixsbEynU4HV1fX5h07dqwBhjJupymqqEBKSvKeZs2agcfj1flgqFQqFAoFPnz4UMNLry06nQ4VIpHpnLlzrxrXan9LMtIzWK1bt6Y7ODh8FX1AIhnC4S4uLtDpdDh//jyio6O/i7/diK+dPWXKlKrmK8ZKFgCWL18+HYCcz+eztm3bdpg4zliIjaeoqEjl5eXVY96C+dffv43Gyxcvl969e9ecSqWO6T+gf6fIyMiWfD6/Rr6WuJ+ookK9cePGWzKZDHPnzHEhk2oiiY3vRQIJXbp2DV2+fLmzubl5Znx8/OEuXbpM/jwXZDi2UVBQj86dO48jATfj4+NVfr5+jDFjx+2bPm1a4IOHD861atVq9Llz5/ZZWVlVzZu4Cp1Gx/sPH6hvo98iuFEwYj58FDrY21vWNSYOh9OQy+WCz+fzjFMeRUVFePTo0cN169evlUok121tbWFqajp43ty5Rz29vAAAErHkcvSHd05CkSiNoOz94rOrlRtWq9X49ddfh+v1erRq1arXgQMHRlaFmmuF+4kUDpfL5bm4uHh/+vTp1zlz5lwFgObNm3c3PtZYysrLYc7n43+yZebXhFiP8RMmtAgMCkqK+fhxS15+fmlGevrz7j16vKmQiEl/bPgDogqR+PTp00hKSkJaWhpc3VwxoP8AHD54CAAEERERDp26dOY9f/zUWqvWRFB9fdGyRUsM7D/gu8dCZ9ClNAoV0OsrpDIpOGxOXYHAr4qxIajT6aBQKKCDnqXRaiASCZnl5eUoLSsT63TaqrRYeno6cnNz8z9+/HgjJCSkvFmzZnj0+DHyc3K1OTk5lPyC/FxhufCJpZVVYZ9+fS3fvH5TqlSpkJWVhSOHj8DX1xc7d+8Ci81G3z59ABgiEtlZWch2coSDk6P41OnTK9PS01cWFhVdGz58eKd/6/tACBG9+e2337adPXv2EAD5okWLxl6/fn0/MXaS0XEb/vhj/u07dzbQaDTJ96Yty8vL0bBhQwwePBhbt27Fu3fvYGFh8U2lLpfLFfn5eUcBzCbG8iUMCzG+9X9sGH/x0qW/8vPz335rTKampqhXrx7kcnmdx5ibmyM2NnZPeXn5ZD6fX9WdDqj+ntq2a2fv4+PTorS09GF+fr7U0dGR9ssvv5jJZDLh3wXHUcvLy//WiaampoiNjTW/fPmy1MLCAlqtFgMGDBhtHMY2DBwgPrcrly9Hp6WlvXR3d/9iuEKr1UIoFMLc3PyrirOoqAhDhgwZ1azZt1suGkZgGMPTp0+vHD9+XEaEcL4kOp0OYrEYI0aMQGhoKEHZCqVS+U2EO4lEQn5+PkaPHr3Uz8+vTuTdmTNn4s+fP/8nADQJC1vo7e39VZNMJpXKBw0adP3m9Rv48P4DbGxsIJfLy7Kys9b9tnjxurVr17afNGnSnLFjx7Yl1o0wIspKSmStWrV6+fDhQzi7uHQBvl4OZ29nh/79+48UCoVLGQxGnkqlAsHbXFv8/f1N2CwWCouLERsTK/fz9WNMmzq14dMnT9beunVrXllZ2f4VK1Zkh4WFrezYsWNjPp9fQ6F1aN9+zsP7D9ZFv4uW37l961KnyE6j62Lh8vf396pfvz7evHlzNS0tbUpCQgIyMjL23Lhx4/bjx49vOjg6QqfV8saNG3dqxvTpnciV9K5kAI5OjvaxsTEQlZUrv2X4VUc4DGV1PXv27JqZmfmaQad7Hj58+BxhMBmOMa69rf4ZCYBUJsWePXvmA4Czs3PbcePGBQBAaVkZKBSKIjkpSX3z5s10BweHC1qtDnQ6rWnffv3aMplM0r8RPEdseiEhIdSQkJBZFRViTJ06FQqlUpybm4PNmzdDWF5+2dbW9lNOTg5sbW0VJSUlZzp06FBEAglr1qxO3L59+6jgxo1x4fx5xCXEY86cOVCpVDh06FCDbt26dZ42fTojKysLHz986Nq4cWNPVzdXmJmagcvj8ciVPPF8Pp9DZ9BBp9O5HLbBgCIB0FQqX0pl7btKpYJEKoVUIhWTySTQ6HTIpFKkp6UjJycbn1JTH1SIKqJHjBiBhMQEJCclndXpdNi2dVvotq3bIJVKP+ze/xeiLl/FyZMnK6+rgVQmBZ/Ph7uHOyaMHw/AwNPt7uYGLw8vNA1vBjabXabRaMh2dnbBLi4uETY2NqbOzs4wMTGBhYUFFi5YCDaL5WprZ9vOxNSUa29vj+YRzbXHjh3bfvr06d+mT58eyePxXvfq1Sv4f0NlRIMGDagjRoxYdvDgwbk3btw4cPjw4enDhg1rUD12w/fu5+fHmDRp0upt27b9Ymtr+03Eu0qlgrOzM1q0aAErKyt069YN7u7usLCw+KZTJZPJoNPp5Dq9DmQSuU7v3FgMYDUOFixY8NeSJUuCBQKB7ksRXJ1OBxaL9VX0PYfDQVZW1sezZ8++HDt2bKjhHsb7hiECNGDAgAlr1qx5yGAwcP/+fcnr169N3N3dhRUVFV+d35eEmpKS8sMn6fV62NraMp49e2Zibm6eVunFcnv36dMT+DwvSUz59KnTBwjWnbosLCLMbWtrCwcHh6+CICoqKhit27YZCVR7fF97aMQYCgsL3wYGBuq/RR8LABkZGRCJRJDL5VXI1YKCgm82hZFKpeDz+eZLli6dA9T05EgAZHI5Zs6cOQYA3N3dndatW7+g9nHVxxtGzmKzyfPnz2f36d1HFhERMXPosKFN3717Fx0XH7dLIBCUKRSKW4sWLbr18uXLfjNnzDxUv0F9JqE48wvyyaGhobCysoKnp2d9Ys2+tl5MJpN07tw5iMViytixY0Gn0+s83tLSknzj+g1XsVSS3qBBgxP9+/efCACHDh2au27tWuurUVEjTp06dfv8+fO3z5w507lL585NNBrtiODGwSZWlpZITk5OsbW31VOoFJy/eHHHnHnzhtrY2NBrj8rLy0ut1WqZHz58eBYbG2u/e/dudVlZmUKv00EkEmHs2LFjhg8fvtHf359XPT+DPH78+K+MzEzwTExMyN9AkBJrJpfL0aVLl6H37t27CgBHjx077eDg8M2tlfDq+/Xp16esrOyhl7c3Y/KkSavPnTtXVFpauvP06dNyLy+vHQ0aNBAvXrwY3t7emDdvHh4+eghXV1dxREQE99+2fRPPnXg/ySDBxMSQhTEFeNYCAYICgwBgsFavQ6PgYEycOBFqtXplRUWFlM1mwcfXpyw3N/esvZ0dZcy4sbrlK5Y/odFod/r06YPYuLiYs2fOfORxuYiOjsbzFy+WTp85k9eubRuMHDYCJqYmvQcNHuTSoVMnbNm8RS2WiFFSWvpp3/59FbnZua+Li4ueDKokcomPjdNnZmbKszIzhckpKbdJJFL6iRMnEHUtCseOHAWZRIZCqYREIoG1QIDRY0fj7NmziI2LA41Kg1wh/+Dq5gZfX19YWwlQIRShpKTEJDS4cUdvHx/HoEZBbFcXV4pCocDMWTPBYrGdnZ2c2ltZWvIE1tYQCARgc9h4//EDmEwmj0GnA5Wd1gBD2D88PLzOdW7Xrt2ixIQE8ctXr9ZdOH/hdNfu3YJpFOq/Wp0TRvO6tWvnxMbGHnzz5k38jBkzxvbp0+dldVOuSqY2kLBgwYIp586dW6VSqfK/BUrW6XQwMzMDg8Go4iFJSkrCixcvwGKxvtqzXC6Xw8TE5NLkKVN+43+F5rW219y9e/fAXxcuZGVlZUm/VAVFJpMhFovB5nDAYjKh1X2up0ggoaSkBKdPn/5r7NixoWQQqR5U3s+wV3Tp2rXbkiVLzOh0utDMzKz06dOn7nQ6nZWfny//O2h36t9JwFOpVOTl5bHevn1bamlpKY2NjYWfr2+PRrUAAMYWybt372RXrl45wmazUVpcUn1MZUtUrUYLtVYNM1MzjBgxAmZmZl8MZwCAUChkNg5uXN/4Pt+yZIUiEa5fv35Xo9F8FeEuFovh7OwMPz+/qhIFwiqrrEH+omVGINtnzZq11bGWAiDOOHLk8KucnJznVlZWmDFjxiFHJ0fKl0ZeFf6lkFEhFcsK8wuwZMmSZYMGD+KqVKreA/r3X3Do8OEdpaWlf2g0mqLU1NTTs2bPejFu3Lj9ffr0aQMAmRmZ+hs3bqBPnz6wt3cQA+DhC8qc8MSsLK3CRSIR4uLi7hONA+o6ns3h0EKbhA0Ri8XL/f38MnQ6HchkMlgsFpYsXTrc0cnJaceOHeuFQuF1UxPTqF8XLYqSS6RLN27ZzPL388PePX+Jcwvy4Obqxs7IyIhNSEhQ2NjY0Gvfz9bWlhsXG+vr4uIS/fLlS7FIJMKLFy9AJlMwfNiwtWvXrp1LrgUoIpSzn79/5oEDB3Dw4EHV9uDtlc/iyxzcWVlZ6Nylc4/YmNhLfn5+2Ldv3/XQ0NCGtcdU2+ImQiyrV6++fO36tXN2trYoLSnRJsQlDDhz5kxqTEwMevTogStXriAoKAjdunXr/+rly4RTJ05+DApuRCWRSD/WXOC/Lt8uo6SQyFWd9JhMJpnH4/Hs7e3RuHEID8CsjMwMWFtbo02bNjOpVGr+p9RUeHl64PGDh7/9uWPHvtatW2Phr7/i7Zs34uKCQtDoNPB4vIN6PZCSnIJr16KgUquRmZn5YuH8haYKuRwCawFGjhmNI4eP4PKlSwAM4WwvT0/4+PuByWIiPS0dGZmZnMCgwPYhXt5O3t7eLE9PT6ZMIUfnLp3h6eVJd3N1b21uzve1tLKClaWhXnz1urX4Y9NGFovFohJ00XoYFHOnjp2+vBDfkLqAr4bw9eKlvXr1XPc2+u1diVgMvhn/b9/jvyOGHcpKIMDIkSP3vXnzpklZWdmr/fv3P5syZUpTgtaL+EZsbW0xfvz4PRs3buxqa2v71dC5SqVCo0aNYG5uDrVaDa1WC7lcDg8PDygUCshksi/mmul0OoRC4dsXz5+XderUyfyLpbO1fm5ja4tGjRoNysvP/+tL3Ti1Wi3odDqcHB1BoVIhrhCDTCF/ZmBotVoUFhaejn4XvTEoMMikuvaq2gUNCgxkt23Tpu/r12/+4nA4yujoaHG9evWYFApF/nfC7n+rbI3NZkMkEpkWFhaKhUIhRCIRunXrPgb4/HMnLKDLly5dZrPZIicHx6pJGzodaVBQUAAzvhl0Oj1kMikWL14MuVwOgvO4tqjVarDZbH3fvn0lAL6bu/bxo0dFnz59empqaoraIQ2CM14sFlch2SUSCSwtDSldjUYDMzMz8Pn8rzIFSSQSeHp61ps1a9ZgYj2MlUdJaSn279s/GgDYLFbw+AnjWxqv1ZdePJVSpd+1cxdJJKnQJ6cknwcwjE6nI6J5c25E8+Zz42JjJ61es2YymUw+zOfzs+7evdv248ePp3///fe+ZmZmJrm5uRAIBODxuJX3+vrWbGtjEwYAYrE47VvlIu7u7ixnZ2d4eHiwifIiwjAYNWpUqz59+7Z6/uxZYmlZ6akXr16+kUgkVy9duiTW6/WYPGUKpDIpj8PhxM+dO9csNDSUQ6wZMU4AuHrl6k0qjZbSqlUrSCQSvwEDBszUarVRL168ON+8RQsvYqOta/3USpUJAJhwuWHEM6mr3A0ADh448OTkqVNLY2Ni7wLAxAkTboSGhnYAvpzPNAZY7d27997atWu7s9lshEdEQCKRaK5EXUm1sLCAvb19eFhYWNv27du3DwwM9B86dCjvWlSUeEC/ASa379zRjBw58j+jifqHpBoHA6ByYy4uKqriJSeTSJBIpUhLS0NuTm7Rx5iPN0JCQ0pCQkNx/+49ZGZmqrMzs2R5uXkJyakpd0eNGqUeMmQIZfq0aeyKigoJh83R+/n6wbueN0ZPGAdLCwusWrkSAODo6MiwtrWll5eVQ6fV4ujx4/qZ06eTGHRGI29v7wD/BvWZ9evXZ8mlMnTq2BHOzk40d1f3llaWlvWtbaxhYWkFLo+LdevWY8uWLVXUtGQyCSSSodNas7C/3wL1S+9cbfl6yLcaHJmWkZ6t0+lBp9Jsajce+rcK4XQMHz48bPFvv4WUlpW92rlr54i+/folWwsE0KEmW+eUKVO6REVFBej1+g9fo/3WarUwbqKiryyPbNCgAcRiMdLT07/omFWWGpOePX12sVOnTqMI2utvPSu9Xo+WrVp5l5eXf7E8mUqlQqfT4fSpU6ioqICPjw9Kikug1WrBZrOr5kMik5GdnSU+c/L0haDAoOGfr1ull96t25AnT5/+JZfJUKTVigsKCvg8Hu9v1aRT/05PcEtLS+6TJ0+4FRUVBSYmJtBptTb9BvRvYRhkzQUjAZArFDhz+vQuUxOTqgGSSCSoNRpYV7JO6SoVaml5GYQiUdVi1vWwtVrtV4v7a96/uiDpzJkz5wji/9rnUigUqFQqODg4oFu3bkhPT0d8fHzV7wmFz2Qyv8psl5ubi+nTp++xsrKqETcgxrBrx47zr169igWAmbNm7aF+I6RGjJ5CJjOPHj5iS6FS8tRqdRUbEBHy8vP3527ZsuXQy5cv+y5ZsqRrZmYmLCws+slkshXW1taT6XQ6Wa/X6wiL9mubCwCUlJWmAoBAIAgjKhLq9GpJJAQGBqrS0tLw+PFjNDMKJxKgGBMeDx06dKgHYImtjS1at25tefny5dJPKSlYuWoVGgU1Itk52DlQyNW5f6Ba0R4+fPjxsmXLOopEIpiamk6cOnXqdicnJ7JIJJK9ePHifFlp2RcTTmVlZdoD+/efadggAOHNm3cl5m6sxPUAkhIThQ8fPty8ZcuWZQkJCegc2bnNyFEj1/Tu3TuYOOZLRhBxrfPnz+eOHTu2nbW1NVQqFfLz89kBAQFt27Zp08TSympct27dzHk8Xg2vwt7BgWdqZgoKmdLI2tr6X1ucTMzxxfPnKRcuXTp2YO++iyw268O+/ftx5fJlnDh5EhSSwUCXyKQwMzMz9CafPh2AgUzD3dUdLZo3h6ubK7KysrR3794TsxhM/7AmYa06dOrA8fTwZEolEpAALFy4ECwWy9XW1rYDn89n8/l8CAQC2Nra4k10NJgMRq0WqBp8L57GWIhOa7UrMGpT0H6PfIsz/luM8jk5OTh29OgQjVaDBgEN2v+MPhv/LdHDkDf+Y+PGPSNGjGgYHxefsmXT5sOrVq8aZswJoocBMDZ06NC/tm3bFmJpaVnnfqpWq2FjYwM3NzfIZDIQeopCoaC8vNzAFqhWQyaTGfA9dQOs9Xfv3j2z6LdFoxgMxnc9Sz300Ov1SqBu3QMYHNrExESkfPoEAGgQEIDARkF4+fwFMjIzK5kiDSKVyXDq9OkDC39bNLw22Rph4PTq1av5n9u2OzCZzJzMrEzZ48eP7YYPH84tLy+X/GhNOrVJkx9rnFCp0FgrVqxQCIVCpUwmQ9euXQe51izjqSEP7t8viUtIeGhpYQFjEF6FWIxmzZqCxqAjISEBbDYbapUKVlZWWL9+Pezs7CAWi+u8pkQi0csV8u+erUQqQX5+/vGwsLDPGOLIlUCa4uJimJubQ6lU1lkyR/xdLpfXCcqQSqUwNzf3GzFiRATxM0IJkEBCbm4udu3cNQUA/P38Wk2tZE/6nhfN1MyU3qVLlwEsFmujlcDKSqvTgkKmgECRAoCFhQUiIyO7ZGZm3po0aVJ7kUiEXbt2LZJKpVvr16+vp9PpXF6VBVe3ejKq+77l7eWFdu3aBVGpX+lKRCbBzc0NOTk5KCosqromofyNve1Hjx6VLV26dIC3t3epQCDoIZPJkJuXd9HZ2Vmv0qjF7m5uvNojSktL0wwfPrwrAAwdOnTH0mVLJ3I5ho0uLTU1g8fmgsNhR3xpHYuKiylp6WnROj3gXc9bA4BGjEelUuHGjRvRHz9+PJOenr7h48ePGjMzM4wdO3bJnDlzlnp6egL4uhdGKLqLFy+V9OvXL6Jbt266goICc09Pz+n9+/Wb3LxFC3NTU9Ma5xjAioZ1uXL16h0Ol4MZ02e2Y7HZ/0oPver5PXx4fenSpZEgk+Hj64v69f0hsLJCeXk5iouLTcNCQjt5+9SzCwoK4jg7O1NUcgVmzpwJNpvt7Ozk1MHKyoorsLGBmakpOBwOcvJywGLW7E2u1+sNndZatf6hMdbVAvVL8wCMDbS6Y4qkOs75XjE24JWV1LQSmRQSsUSsrwSCSWUGgF5ubm5RXFzcdRMTk1JbW9s7HC73NQDrOXPmjP7aXP5NYgxiHT58eMBfe/7q/vTZ00u7du6cOX7C+KHOzs4kouaGWJtBgwY1PnbsWFBpaWl0XV62UqkEnU6vYmYzFjKZDIVCATMzM7BYLCQkJNQZOdVqtXj3/t2NZ0+fiVu1bvV9nqseiI2N1RQWFqIuZ5dgAHzy5ElVCbNMJoOTszNSUlJQUFgAnZYCAqtDo1KRnpH+8N6du/nde3S3reuWjg4OaNO2zdCLFy+utrOzU7m5uakaNWrEU6vVkh9NiVO/pDDrnKteDw6Hg+vXr5vExMQUu7i4QKvVok2bNoOBz18+YrPbt2/fITKJDI1WC1VlXkCr1cJKYIWmzZohITGx6mEwmUyUlJTg/Pnz6Nix4xfJZ/Ly8sgODg5cTw9PfC2ATHxYJ0+cfPvp06cndnZ2kEqln81LJpOBRqOByWR+sb6Q8NKpVOpnyp5EIqG4uBgzZsz409g7N94SVq1cuTU3Py8fAJYsW/onccTXhPhQGAwG6nnXY547fw6vX726Pm7suOkG0En1FYgw98SJE9sxmay7o0aNbFOJyC8yNzfH69evSQCK+vXrJzCUchhCffoa9zIIhUIpdnF1BYfNobKYrKq1rJ1CIJFIsLK2AoPJhEwu+2zchNy8eTOjd+/e7aRS6aelS5d26tev34Ujh4/suXPnzsWwJmEkNrvayDL2dMaPH78cgKhLly69Dx08OJFor1lQUICY2NiDAUEN4eziUsXDbnwNADh58sRdKo2Gtm3adnOwd2AR89i/f39CbGzsL0lJSXfz8vIgk8ng7+/fe9zYsQs7dOwYVD2PLwvxfv/5558P5s+fP6xHjx7ZjRs37hQcHHyyTZs2NViLPm8hXBV5eSoUiaAn6evRqP9OABQJwJ07d3Jmz54dGRsbi2nTps3s06fPAgaTyeCamGDtunXYuHmzIc9cCQAj8swdOnb82/f93nB29ThJVX9+jZaWmJPxOXXeX6+HSqUCSKjqtKZUKSERS8QWFhaQyWXITM9AdnYO8gvyJelpaY/EUkni4EGDkZeXh8TERHVmRqYsMzNTnJKScotEQtZfew3UtKdOnQKZRIJGq4VGo0FoaCiuXLkCPz+/VseOHvujfoMG/zpw5JfEuNKDDBIW/rpwa+9evS6Vi4SlixcvXnfo0KF51SV4+iovvX///ju2bNkS5l6rQReJRIJCoUBgYCDMzMxQVyWWQqGAlZUV2rdvj8ePH0MikaB2j3MSyeBEXb5yeWOr1q2WfA9bo1wm01y7du38l/BbNBoNPB4PYrEYLBYLRFhcIhaDx+MhMDAI9vb2UCgUIJEqx5CTi4ePHu7v3qP7r7XHQERYW7dqNfz+/fur3dzckJqamn/79m2rli1bory8/IfC7tSvAc9qC4lEQllZmUlubi6zffv28sp664adO3cO+tI5pWVl+PTp0z7vet5VnjGJTIZIKASHw6kCOxCDJpPJYLPZuHfvHtLT06t+X1tSU1Pl9by9E1u1auXzbagOsG3btrkZGRkoLCysznFUs7nBwcEB9vb2XyXeJygAAXxG5C+VSiEQCOqPHj3ms9QDGcCn1FTtnr/++g0AWrVq1b9P7z4+tY/7kugBUMgUUKiU+pmZmbCysrr14cMHcZMmTT4zIYkXZOTIEa3t7Gyvz5o1q1NpaSlEIhGeP3suPnDggI9CobgwbNiw5oRJUntze/XqFZYsWbJHrVYjJDSEq1QqxaWlpTw7OzsQL6Tx5slkGsCCPB6P/pmhA+DZ8+fo1atXc5lMlh3QoEG38ePHX7KxsQGHw+FcvHABarWqYvv27TpirgSI5u3bt8K4uLjf/fz8aOs3bDhLIpOr5vfu3bvs/Pz80qKiIri6uakBMIjxGBsm16Ku7VIoFGjduvVQohlPXl6ebvny5X0zMjLiPDw80Llz50mtWrUa3qVLl5DaJX+EYqhdOw4A5UIhzp45c3XJ0qVd3d3d0b17905hYWHXCM/+W5uHQqHAtWvXrjOZTAQEBAw0zPzftY2TQYJWq8XDhw8PfvjwASEhIQN+//33P76XNhn4FmFOTc/NcGR1lOd7lPOXr1p5/0q2RzqdDq1OZ+i0plJCKBTJtBqNVqfTobS0DGVlpSgoKEBmVuYTgPRq5KiRiIuJxcePH5GdnY34+HjZx/cf7lhYWab069tX++z5c1lJUTHKSkuh0emg02pRz6ceclrkYOCAgQAAHo8HRwdH1KvnDS9vb1jZCCCqEKG4uNgsNDikQz0/H/uwsFCOiYkpJSkpKWjMmDFdHR0df2Cm/z6JjIx06tKly5TzFy5sP3z48IoFCxbMqFevXlUIhXjWw4YNCz19+nQjsVj81vh9ItKpTCbzi6A3osWqVquFp6cnbt++jZcvX4JOp9c4R6VS4fXr13+MHTduvq+Pzze7cZWVlcl79+4dW9nKtsbvWCwWSktLcbGS2dBYCG89JzcHUrkUbJYhl66HHhqdFnfu3NlbUFj4q421da0zDavRvmMH79OnzzQRVYieFxUVKdLS0hjBwcE8lUol/pGwO1Umk337KOJgKhVFRUWMrKwsmUajUefk5KBL5859zM3NDZMy9tyIvOK5c8/z8/MTnJ2dqyZNoVBgZmZW1W/WWDEStK8qlQppaWmwsLCok5ifwWCoCgoLTwJY9iWFTozh9OnT8R8/frxnbW1dpZAJZa7T6eDl5QUqlQq5XP5deXmtVvuZEZKZmYk5c+ZssrKyrLEWxKu1dvXqbRqNpsLM1JQ0b/78LfjCmOsSYkMbNHhQv+fPno2MiY1VHD1y5ESTJk3GfZ7Xri4R6dChQ8c7d+4cP3r06KDKnC5KS0vL5syZ0zk+Pn6xiQmPVFpapoIeWnNzc2cHB4ceNrY2pFu3bg1Qq9XlPB4Ply9emlIhqpjy/v37liNHjlzUu3fvNhyj3J4ehpxSRYUQRYVFKoK1zpiYZeaMGR1kMll2UFBQ7ydPnpxlsVhQKBSwc7BrxWazEXU1ivfn9j+ZxBUJ5bl1y9bT+fn5aN68+ah63t6Gta6875kzZ3ar1Wq0adOmv5ubG7d6PNXGRnR0tCwxMfEsALRs1bIbccyDhw/EarU6jkqlUiZNmnRlxowZnarPN2w2xBiIa2m0GshkcmjUarlQKNRkZWVlbtq0aZlSqTxrbcjtdu/Zs+dFbmWerBo5UVdaw3DNZ0+fCl+/fv3SxsamcYsWLb5eC/k/KEqVCu/fvy+k0+kYPXr0FA6HU2fO+dvGSM1wds3f1D6q7r/LZDJQqBRQyBRoK0lhRCKhQq3WqPV6gxdd3Zv80wuhUPh8yJDB+sKiIqSkpOhz8/LkGWlpytzc3NjEpKQHA/sP0A4cMhhXL1+mxycmMOLj4sXp6ekAgMLCQrRo3hwKhQK5ubkQiUSgUCj49OkTVq1eDQBBvvV8XDtFRnrZ2NgwXV1cWAGBDekkMlk8b948LYvNdra3s+tgxudzLczNYW5hDh7PBGvXrsXGjRvZLBabQiYZ1o3JqKm8jI3m/01CGNy/TJ26Ivrdu91paWmS33//ffPx48fnVpPNGOZsbm6OHj16bvnjjw3hXl5eVaH1StAzXFxc8DX9RHjyVCoVTZo0QUxMDDQaDYhqBEJUKpX4jw0btuzbt2/ut97T9Ix0np2dHdvZ2VlsHOonkUgwNzdHVFRUVTvV2kKlUiGTyUClUqFSqmqg8AsKCjLOnz33eNLkSRF1jcHUxBT16tXr++Tpk+dubm7a9PR0aVFREYtCoYh/BO1O5fO/ryxCr9fD0tIST548MauoqCgiFrNRcHAvoBoAVbUAlX/eunXrpMZAPVoVslYoFGAwGODz+V8MbZNIBs+gc+fOqF+/PkQiUY1jVCoVTE1N2V9j/iLB0NFp2bJlk4BqS534f51Oh1atWoFKpSI7O/ubyryqxE6rRVFREWg0GkgkEsRiMWg0mu2IESPa1LUWqampuiNHj/5OJpPRqnXrCR3at7c2XA9172415lB9QIP6DchsDmdUeXn5jitXrmxaumzZuOrwfs1ziPDX6tWrB96/f397TEzMMxsbm3oAklVKpWTt2rVza9/Lx7seK6xJEyqHyxGbmJiATCIjPi6hHp1GL7C0tnqwb9++B3K5/NaECRPaGZ/H5XJRWFiM02dOb++wv0OzUaNGtSVGPW7cuNHR0dG3IiIiOl27du1sJSGDaubMmX9cuHBhr0wmQ7eu3UY7ODpUedgAIBQKVdeuXdsDAAEBAT2BamUbFxeHAwcObGSz2ejSpcsQBp1e4wMh7r148eK1YrEYkR07LQ4MDKz6AnNzch/m5ubC1sbWzliZG58rlclAoZDx9s1b8auXL6+RKZTEQ4cO5cfFxZ0fO3asori4WPzk8RN07tKZ0q1bt0M9uvcYXFOZf+2ZGjatefPmdQeAKVOmbCWR/r0EIhQKpdKrVaGwoEAOVJsqxpGLH1FAMrkc7EoaT5VaBZVKDalUigqRSMxgMMBgMpGXl4esjAzk5uQWffj48XqjRkGlbdu1Q3x8PF6/fq3/8P69uLC4KC4hIeHesOHD1d179MCMX6aisKgIer0eCoUCAmtrdO7aGTqdDrNmzQJgIE7y8vJG3z59EBTcCCqlEolJSaqEuARVh3bt4e1Tj/b777/Tdu/aJQtv1gx6ANejrmHsuHHos7kvZs+chbi4OPbw4cPbW1lZmUml0kGhTcIcHRwdwTczg6mpKdasWfO31rp2Z8P/dVL5kTZv3ty0ZcuWswsKClafOHFi5ZIlS6Z7e3vTazp9wJAhg5tt27bVLTMzM41AvBP9F76nvTXByikWi+Hl5QWpVIrMzMwauoXJZOLQoUOrZs+ePd3Hx+czjgvDWAzHvnz58t66detkxgh3gv6bz+cjLy8PNBoNFAqlziYuDAYDYrEYUqkUVCoVxtzw129cP2lQ6DXNfGJf86/v33PFyhUzvby8YG5uLsnKyrJq0aJFEdGg7HuE+r39aQGAzWabPHv2jHH9+nVZYGAg6tevH9ixY0cfYljEIInFyc7Jxps3b85aWVmBxWJVWVTm5uaGrkxaLahUKnJyclBYWAhPT8+qh0B46ZcvX0ZcXBwkEkkN5S8Wi2Fubp46duzYzxS68cZy/Nix5/Hx8Q8tLS1B8EFrtVpIpVKEhobC1dUVnz59+iysT/C4E2EdoBr1qNFoIJPJql64kpISTJw4caGjo2ON0CExjjWrVm9RKpXlDAYDY8aMWWBYLYBE+r4cuvHVJkyYMOvevXs78gsLE6dMmbLp1KlTM2rzPhuzrFGpVEyaNOnI7Nmz3Rs2bNhv1KhRfW7cuNGGwWAUP3r4EJMnT+GY8c1Iu3fv1gSHNJYHNQpCQkICmjdvDh6PN2zPX38dUitV2nbt2zXPzMx8lpqaekWhVLRjMpiVowKKCgrRs0cPHDl8uGT06NHt3Nzc4lu2bOmzb9++9wcPHtzP5/N9r127do1A7ZaVlUmzMjMXAoC/vz+GDB0ynEKmVClDEkiIfveOLLAWvG3arCnCw8M7EPfS6XSYOnVqPwByJpPJ79ipU5eq9QSparVevHihjYqK+h0A1qxbO7/6GKC4uPg5AJDIpOKZM2Ysc3J0aqaDvlAsFueWl5erWrZooQ2PiMC2bdvys7Ozjx84cEA8ePBgeHl54d27d7h16xZyc3MREBDQYcqUKftDQkLsgLpC7J97r4QCnL9gwfk3b98+EggEgbNmzQqrPvrfJww6HV7eXs63b9/GmTNnlg4eMqStm5ub4XnodVCp1FXfi16ng0qtglQqFauUKlSIKiCVSVFaVoaM9PTid+/f32japElxWGgY7t2/h5zsHHVBYYEsPz9fnJKcfItBZ2QtWboU+/btQ1JCIjQ6DTQaLaQyKcwtzBEbE4O//tqLR48fQSwWo2HDhmjftj38ff2glMmRlJwMHo8XEBIS0jIgIIBZz9eHqdPrSU5OTvht0SIqk8WKcHR0DLSuJIExMTEhcuVzC/MLdnl5e8VERkY6m5nx1YWFBSetrKyKKyOFuRwu5xSVTtPbO9ojOjpaXF5evsbZ2RkrV66cf/r0aezfvx+XL17EkcOH+/bt39+zY8eO9CdPnlBNTU0H+fr6Wrq6usLMzIzHYDCg1emquOKN5d9O9/pNIVVHCAcNGjTr2rVra2QyWcWyZcs2HT9+fJ6xMtMDsLOzQ79+/RZv3LhxhKurKwBDX4ZmzZrBwsICpaWlVc6XUqn8YimzVquFUqmEj48PzMzMEBMTUyMaq9VqRdOmTVtx69at3+vKpRN7i6WF5Y1+/fppjQFxdDodSqUSR48ehVqtBo1Gg1KprPq9WCxGSUlJ1dioVGqVvjP+99WrV+fTM9L/dHVxrXFvYs/r2LGji7W1dbO8vLynTCZTnJ+fb6vRaExJJJLoe/X0d4fc6XQ6Pn36xLx3757CxMRErVar4evrO4AIt1cvTPViX750+WlJSUkeAUQj2pASqHLAwMY2ZsyYpdnZ2fozZ84sU6lUIMqkaDQa8vLyUFhYCKIVJiESiQTFxcXHioqKNjk7O3Nq35sEIDs7GytXrhzm7u5eVQan0+lApVJRUlJSVb5GWFHG9fFqtRqlpaUIDg7ubmZm1orFYs3ncDgKLpeL7OxslJeXg8PhEOQ3JtOnTx9v/HAM3guQmZmJU6dPrQSAFi1aDI2MjHQ0Pu57xYjJyG3cuHFzd+3ate7BgwezDx85Um/Y0KGdiBrhmordsA6Ng4PdWEwWnj9/vvXSpUvLRowYUTRr5sw2NBrtfrt27SSNQxqjRYsWUCgUe5KSkhJZLNYepVIpzczMfPnq5cunrVu3bjZq1KhjkydPdk1MTOQYPwcd9JBKpSS9Xo+goCA8ePAAQ4cOnRAVFXV60aJFowFg29ZtJwnvlQSASqNyKFTqQg93d8X6DRsiw8LCGhLs84TEx8dnUSgU9OzZk2Rra1tJhgPMnDnz8r17984AwMKFC8+6ubrW2CDIAJRKFYYPH94BAGZMn364fv36NcoaLC0tw5hMJmztbBU7duxYqlSpaqz11cuXEdm5C96/f4feffrA29sbr169wrJly3q8fPFCkZKScsPD0zPg5KlTN5wq853GOfe6nh1gjIi/eP3G9eu9OWw2Dhw4cJrJZBoZJP8utU5EeiaMGz95z67dfwqsrZ8ePny4uVar7SiVSCnz5s1VJCYm4sHDhygqKkJGWrr86fNntykUSsrlK5chEopw+PBhPHn8WExnMCCXyeBgbw9PL09MmzYNAMDjcOHq6opGwcFo1qwZGCwm7t2/BwAmISEhHev5+Dg0CgriBAcHUy6cP18RdS1qownPxOfPP/+85uDgYCEQCGBaiZzPysoCm83mEcBVA0BPDzqNjsDAwC/Ok8flmtEZdFhbW9fz8vKiehn6AEzS6nSIaB6BWbNmQalSbiwqKtZPnDARzcKavXR1c31q7+DAHDVylP758+dHra2ts9w8PPRWNtZnDhzYj+dPn+Hh40cAsGT27NnsXr16ITIy0t7e3n7AlClTUFpSio8fPzSJ7Ny5ibe3N6hUKs/BwQEEYLVuFP7/HmnTpo1F8+bNp128eHHz6VOn1qxYsWK2m5tbVeMWYk+bPHny8O3bt8/My8srY7FYkEgkYLFYcHZ2rqp8sLCw6FJYWBhcUFCwlMvlfu7EVTqLdDodI0aMwJo1ayASiQwMlyQSaDQabt++vers2bMD+/TpUyfuSqVWo6ioyLxhw4Y1QuomJiaIi4szACSB2kynJHd3987t27cP2bhx41GRSJRsYmICqVQKNptdZWiQyWSIRKKCi+cvPpoxc0bzusoiTU1N0bFDh36HDh9+SqVStfn5+cq8vDwWmUwWfS/anWpn9xlAuE6xsbHBhQsXTPPy8oq8vLygBxAcHNwHqAvBa5Dbt26foNFo0Gg0VXWDRJgaAHJzc+Ht7X1t7NixnQDg5cuXbyoqKqKMrSORSIQ2bdqgQ4cOKCsrq/q5Xq9HWVmZrrCwUOvs7FxjcYiNc/CgQTOSk5M/EY1giJC7k5MTGAxGVQ7duDYeMFiIGRkZZqNGjdq7ePHi3hcvXkRycvJ8Z2dn0Ol0SKVScDgc0Gg0SKVS9OnTZ46XlxfNMPfKvHrlOP/a89d5sURSSiaTMXny5JWGcf69zZvYXBctWrR67969NxQKxccH9+9Hxnz8uG5A//5zGgUHV5F/GI+FxWarTUx4SExKEqalp8HN1Q31fHx2nDt/vmF+Qf7KxMRES3Nz8/FBQUHjOnTogPj4+EW/TJkyMiYm5vKatWvCo9++XfT4yROZj48PGgY0JNW2kFUqlf7s2bMQCoU9w8LC1BkZGVdPnz7tbG5urhzQv/+cwUMG1696bgAszC3oJ06eXKlWq2Fayf1PmCDEs3v29OnxmJgYSKVSnpu7O0+pUuLXhb+ePnv2bH8AaN68+cAZM2a0rvncDTJo0MD1ycnJd5s1a9Zx9dq1Qw1rh6qVmTRpUneVSrXy/PnzhW4e7rFyqSxJoVAooAeZzqCTaDS6+7bt20gAnrVr357Ut2/fPi4uLnMHDhwYHBsTc3nV6tU3/P39uxgr868JMaeKigrs37//6uPHj7vGx8dj0a+/Xo6MjPTQw9gE+/eJHoB//fqsk6dO3dm5c+cEkUh0RygUPj548CCSk5MR3DgYfD4fjx8/RnxcPDQaDbRaLa5fu463b97ixs0b4JuYhnXp2nVcaGgoOyAggGJjZ1OxYcMGsUajcXF2cu5obW1N4pvzlXw+HxQqFZnZWWCz2FXIeRKZDCqFgqzMLFhaWGys7+ffeNKkSS5/Zy515vDJZJ2eBGi0NV0hCpkMNsvgDHA4HK453xz1vL3RqWOntgDaZmVlYfbcOaBQKFPLystEZqamCAsJRdyHmN8ePn60LyAgACNHjtQWFhaKt27dioqKikQzM7OlZWVlOHnqJO7cuYOrV6PQsGFDlJeVhXTt1u23iRMndmGymP8rSta+JMReNXr06F9v3769uby8XLh127YjmzdtGkHsToS4ubmhX99+s48eO7rQxMQELBYLIpEIWVlZKCoqgkKhgEKh6Dtp0qRhNBot4tSpU6s+fPhwt169ejVy5UQ6lwDVkUikKqKXymZb2lkzZw5v27btKzMzsxr4DwBQKVU4e+bM24KCApiYmFZdt0JcgaCgIGzYsIHgiK/6XUlJCWfw4MFXwsLCYGlpOXfIkCE2KpVKyGazq+rkQTKAmplMJm7cvHHcoNBrfu3EevXs3atXYlLSNFNTU6SkpJRmZmVadencBd8bdqempaV9++EYFoj3/v17Kp/Pl1lYWMDUxCSodZs2bsbHGSNS0zMy8OLli3OmpqZgMBjQ6XSwsbGpyisUFRUhODh4FqHM1RoN3FxdA/Py82sodCaDCRaLBblcXqOhC4lEglwup8nlchJxd2OFcO7cueuPnzzZDBjQxIRFRRgUtRU5iURCaWkpSktL4eHhMWTPnj1bIiIizAHg5MmTo6RSqaK4uBharRbW1tZwd3eHSqVCTk4OZ8aMGTOIh0LkrykgobCwEFejri6l0+nw9/eP7NatW5V3brxePyJ6ANbW1uSjR4+e7NOnT9iTJ08qOBzO3ISEhONenl79w5qEjWvevDmNw+HwaDQayGQyEhMTqQwmg8rlcLWjRowaHxcfdywgIEDau1cv5OTkLDp67Cg4bM78X3755Xjnzp07BQQEmF+4ePFS165dxyQnp+zz9PBcoVAoDAyBFSIFg16d26JSKEhPS694/vw5fv311/OhoaGYOXNmx2fPnt3s0KEDwsPDvY3HTmypbBYLqKx6qL0COp0OoaGhcp1Oh+TkZOWhAwfWXb5yJTojI+MUjUZDy5Ytu967d+84iVSNuCe2h9+XLbt6/vz5uXw+P/DkyZPXGZWsddUWsSHnv2jRooVTp02DXq+DAeisU+v1Or2JiSmzuKgI3bt36/Hu3XukpKSwW7dufahNmzassrIylaenpzuNRsPTR4/PqNWaFTRatadgnMWvjc399OmTeM2aNVNTU1MPyhUKdOnSZduy33/vWr0i/1Z1XoMAw93b2/t2RnrGGaVSGadWq/XHjh2LolApyV26dMGb1681oooK+YGDBxAXE4uVK1fCy9MTLSKa42PMR0VpaSnNylpAefcuGjGHYzvPnDXT2snRyfhW3wQGMpgMiVarhUwmF8vl8s84Jb4lxHsik8vAZrGhq+wFIBKJlEKhEEVFhWnlZeX2ogoR8vPzkZGRgdycnIT4hIR7jRo1UgYHN8LDh4+QmZmpzMvJlaempj4nUygv9x86wCwuKaFt3bpVL6mQSGxsbRHq6oJevXph1KhR6N+/Py5dugQOhwOlUsm7du0aQkNDsW7dOvnSJUs0MR8/omfvXq/2HdjXNepa1Nw7d+6s/Z4yq3+7tG/f3rJhQMCgp8+eHb986dLKObNnj7C3t68ysImo2i/Tfpn6Mebjant7ezGNRkNBQQF++eWXqlbaNBptTZs2bYaOHTu2datWrVrPmzt3VUxs7Lry8nKRcf9yAntF0MQaK18Gg4Gs7OzXnTp2HPT8xYvjBHscISq1CqUlpU/Kysqh1VRHIUvLy2BjbYPw8HDk5ubWmJ9QKCSb8fkqAPROnToxFi5ceHrLli3tHR0dQaFQIJFIUJCfDzLZkHN/8fzFuZSUlF2enp516oGWLVs5HDxwsIlEInluYmIiUSvV9mlpaWbFRcVCMvnbEV3q+/fvv30QlYoPHz7Q7969q2Gz2eqioiJ4e3l1sLSwqHGccdD0wvnzj0pLSwvs7OwgqmR+I5PJVSxvcrmcOnv27CXEuRKJBKmpadeKKsPrhBTm5yMkpDF8fH1RkJ9f9XMSiQQWi1UjNEJs2sePH3+wfPnySIIPnjAiiDII47I1wNAOLyUlBX5+fh3HjR07Z9Dgwa2J/EtUVFT2zZs3D3t4eFTVn6vVahQWFiI3NxehoaEDmzZtWiPkTxgVN2/efJGamhqjUqkwYcKE3w1rVHO9flSIzb93794+vy5cuHrlqlWTPT094efn9/7IkSPvi0tLlr948YJy5MiRtlOnTg0QCAQ4ePDgA2trG42VlQAikWhPjx49+vXt29c+JTkZj5882Z6Zkan29fUVbt++PTI1NfXm1KlT21tYWODZs2d7V69ZM5xOp89v3br1xwMHDtDr1avXk0KhVFmUJJDwKfUTVywWg0QiyZydndnr16+/0b5du/bR0dG3X71+fTQiImK0obtddY7/azPXaLVo06atvmvXrti4aZNy1apV81RqNQIDAzFkyJDdgwYOGmcAkVWvdV5uLmbNnv3b+fPnV5DJZNbJkyfvOzg41NgQjdmqyCDBpNpwJKOy7A0AHj562I/JYF6ys7WDWq2WPn78mJ+RkUFv36EDnj17xq5ksUp++fIFwsPDa5W0VaPiNWoN3r17J9q3b9/u5OTkFTk5OWJ7e3uMHT364ogRI7qTjdr+/tu3beJ5+/n5wc/Pr69EKu3bMbIjtm3fvkwkFIpzc3Oxfv16VVl5+TFXF5fygrwC2FgKckaMGnmqRYuWmDN7zvuzZ88O5ZuZwd3TA1u2bMGe3buxbPlylJWWYt/evV3HjR/fKDQ0FO/evaNZWFgM8vHxsXBxdYGZGZ/HZDCIXCZXDxKYHBaXUOYEyZJSpYRKpUZFhUin0+ulSoUSykrO7/SMdOTm5H6KiY29GxQUJA1uHIzHjx8jOzNLmZiQUP7h/YddwUGNQKFQfOLi4zB9+nQUFxVBV0k3KpPJIBAI4OPrg3nz5gEAzM34cHVzhb+/P9JT0xQcDlfx9OlTmJqaNm/RokUTb29vFgC8e/cOPXv2hE89H66Ts1M7MzMzVzMzM9jZ2cHBwQGHjxwhFxTkIzMr6/71G9e73r17d92mjZs6zZg5o+W/MQ3zvULsVaNGj557/8GD43m5uZ8uXrz4cPLkyS1IMICCiWBfSOMQjpen16hnz59tcXJyglqtBpVKhVKpBI1GQ35+fsLq1asPbtq0aaSHhwfOnT+/8NGjRxPv3rmzLiMzc3N5eblCrVZXeezE3l67vBgAXrx8eWLWrFl9/vjjj14kVIOYqRQKWBy2M5vNLmAZgeI4KiVKSkvw9OnTz3hRCgsL9a6ursp63t50ABgzZky7y5cvB6vV6jdMJhN8Ph8FefmoEIlAo9EgFleUnDt37v78+fNbEUZ8jbC7iQlsbGw63r179zmHzdEePnxY1SavDZld2d3tW0L19vb+5kEsFgt5eXkmXC63QK1WIz09HY2CgyOJh2YshFJ7+vTpeUtLSzAYDHA4HFCpVEilUlAoFGRnZyM0NHRc8+bNq3ZUnU4LpUJRplQqawAOGEwm3r9/D6lcDrlRvr8SDakMDw+vHILBi4iNjcXgwYO7AobcB5vNhkajAY1GA41Gq9HyTigUIicnh2xra9tn0KBBY4cOHdaW4DonZM/uPX9wOBwtEaJPTU2tKqXQarUYMmTIFGIdiLUgwxAV2LFjxwyJRAI+nx8yYsSIRobjfvzjrKsGNz4+vuLmrVt3AcDb2xseHh6wtLQECZBlZWaipKTkwsmTJy/06NEDYrEY1tbWHB8fn+ER4eFjIzt3bggAzZs3R4OAgGmFhYUTb968ed3U1BR3797tIJVKb4eFhYW6u7szZs6YEZGVlfVUqVTiypUrIBQpIXKFAkePHLlcWlICuVyuBgwhtL/27r3Vvn17xvNnzx4MGzas18WLF88zGIzv8jioFAqePHnELi8X4vmzZ2CyWOw+ffuObte+/bTWrVq5A0Y5az30V69eib1///7s+/fv32IwGE5Hjx6Nat++vSmxdnVJXSRIao0aw4cNH5SQkHAmMy0dwY0b97YSCPyTEhOX2draKl88fw4ymSL29vZGSFgoDh482Ob9+/ftNRrNcFdXVw6JREJ5WZlKVFFxysLcovje3bt5DBZzz5kzZyCXy+Hv799+7ty5y7p27RpmGMP/LjGm5OVW1g2zWWzwzcx4Li4uBPXqVAAIj2iOOfPmQqFUbBRXiFl/bNhAvXf33hsHZ8enXl5eWLt6jXzPnj33iouKYi0tLTmlZWVXEhMTr9jb22PJkiWgUCiLp0+fzg5pEobhQ4baBAcHD9y0aRNZIpFI9XodXjx/8XrUyJErR48Zo8nIyEB8fLw2IyNDlpOTW/Dhw/sbQ4cPK502bRpWrVqFqKgo0Gl0aLVaqNQqWFlawsfPF3NnzwEAmPJM0DCgIbV5i+YsOwd7sbBChPj4eHA4nCZhYWEh3l5edO969VhOTk5kMoWCefPmgc1i13dycmxjJRCQBQIB2Gw2zM3NkZGRSWaxmBwKlQoSmQRyJR1uWFjYV9fW1NQU3t71utT3r7865mPMgstXLp+Y8suUljQa7X+pOjcqtx00KGDh/AVNsnNznu/atWv+yJEjn7PZbOhJ1cY9GST0799/4tlzZ7eUlpaCSqWCTqfD0tISdDodVCoVZ8+eXTNnzpyRRJq4efPm/PDw8NVPnz795fjx4zvu3r37Z1ZWlpBCoXyWRjUOzXM4HJw5c6Z3o+Dga4MGDuxE7BA0Oh3e3t5trK2tXxrT7srlcggEAohEItTmV5fJZFBr1FXzNTU1Rffu3bdt2rSpCQHy5hvhzKysBHj65Mk5AK1qG2uEARQUFNTh2LFjS/hmfOj0+kInR0craxubMvl34N2o39L6Op0OlpaW1OzsbL1er9fq9XqYmZlZd+nSJZyYRG3Jz89HamrqZVtbW3C5XKjValRUVEAqlUKj0aC4uBhjx45daDwJKpUKNofjymaxM4xLBiwtLPHhwwe8fvOmruHx9u3bRwcML4RCoUC/fv26AJAwGAyoVCrodDowKq17Y/733NxceLi7R06cMGFbi5Yt3QggHmExkUHCo0ePxG+j3+4hcjVERECr1UIsFsPMzCy8V69eAcbrUM1QdvLdy5cvX5jweFj066/bDR/mj32atclMcnJy8Pjx46dpaWmX8/LydiUlJVW4u7tDp9MhLS2Nx2azxZcvXISlwAq+fn6C4qKixlKptPG8efO4JiYmY7p162Zq/DIymUxEREQ4nz179tq4seNWnr9wfhEALF++vN0vU6fy+vfrhz/++IOZl5c3acqUKW7Pnz8f1rRpU5CM5rnjzz9fp3z69L5li5Z0BwcHCrGGrVq1wq5du6LGjBnT7saNGxc2btx4Z8GCBW2/x+Mgk8nw8/efevbMWW2PHj0ojRs3ntKxY0cz4vfV7XmBGzdviLt169agc+fO6NWrV9uePXteadeuXVVv3Lrqm2u2s60+YteuXY9OnDhxAgB69ui5Yf+B/bMqSY76JSclnakQixHUKAgSqSSutLT0DJfLvbds2bJ7Go1mfkREBE+r1eL2zVtqtVaj2LptKzIyM6GHHl27du0XHBw8ZvTo0e2IdBJRr1s7o/tvD7HWRbBTW3TQg1K5gXJYbB6NQoVVY0uENQkLzs7NCc7JyoZXPW9MmfrL3NjY2KsXL178qNPpdty9czf/6bOncHBwgKenp5bNZotVCgV+mfqL+O3rt7/Pnj0b5ubm8PPzg1gsTnzz5s2iKdOm4uyZM7h46RIoJDKcXV0QFhYGvqkZ9FodGDQaRCKRXXjTZu39/PwsAxsFsV1cXchkAHPnzAWbzfZ3dnZqbWUloJqZmcHc0hw8ExNkZGaQmUwWh+isSCaToNcDdDoNLZu3+KE1M+aLNwbD1tVtbfSo0fPPnz+/IDMz85lYIoH5d5YV/1tFD8P3vPDXX7cuXbq0cWxs7IvDRw6/mTB+QrCBpbJ6P+jWvZt3RERERFlZ2WMTE5OqvbasrAzm5uZISkpK3r17941ly5Z1rNqnyWRERETYNWvWbEWf3r3nnj13bktmZuZiY7A34aUzGIwqwHVBQQGGDB7cOaBBA52fnx8AQzo2pHFjRoVYXCPyq9PpQKPRPmvORSKRQKFQQFT8ELps8JAhYTt37mqYmpr6nsPhgEKhgMPhgMViQSwWIzEx8WJ2TvZ2R4eaBELEu9GpU6fQ9WvX2dNotFyVWq1OS0vXu7q7MURCoZJErp3MqylUTy/Prx5AZzCgkCtM8vLyWFwuVxYTE4OQkJDeLl/hbr9542Z0dlZ2upubG8iV7USzsrJApVKh0WhQr169ll27drU3ngSNSoObq2szvpnZfa5RDl2rVsPbpx5M+WbQGiH9JBIJ6HT6UHNz86rNe+2atVcSEhKiiLA6UaNuzAes0WiQkpKCYcOGbd74xx/TLCq7qQHVoRdi0zpx4sQfVlZWcj6fX5X3J5PJYDAYyMvNxeTJk5cQCGVCiDDKvn371tHpdLi4uvqPGj26MfD9YVXjTbOiogIPHjwov379+l8NGjSIunTp0qPc3FxQqVR4enrC29u7W79+/eZZCQT1E+Lje718+fJOj149V23ctGkGnUFnarW6KuCZYY41DQ/AwAF/9vzZX8Obhb+Ki4u77Ovri6SERPGDBw9QUVEhzszMXDZ37lyUlJTM7NChw9Lx48eP8PDwIEVFRSXNnj17YFhYGHbt3s3x8HDnEmsAACNHjmy7efPm1rGxsfd27NgxYOjQoSVf6ylOzLusrAwR4REmEeERS4x/r6sD0uTr68twdHAMk8vl7JUrV94meBVkcjlu37olfvXq1V0ymUxp1KhRy6ZNm/IEAgGMc5OE8fbp0yesWrmqL51Oh089n8iTp07OIj7qjh07+nbo2HGJopLDf+jQoXj96tWnPX/9dcjPz28Pk8ksUqlU4ndvo6HWahAWEtqHSqX6z5o725oM0uCOHTt+xuhHfJZSmQw0KhVanQ4sJhP/5rwp8XyKiopQXFws1ul0KC4uQX5+HnJycj7Gxcc/DGoYqA5uHIynT57oMjMyFZlZmcqk5OSHer3+/Y6dO5CXn4+NG/4wIJBpdNAZdJiZmWHF78vx4OFD3Ll7B2ZmZpCIxbykpCRQKVQsWbIEy5ctx9p1a+0bNmzYoXHjxvygoCC9s7MzSGQSqWv37nBxczX1dPfoYGll5WBjY1PV5njt+vXYsHEjj8lkGhQzxbA30Oh0tGrZ6m+vBVFNUpdy/lJUqPZTrcs4un/v3mOFQgE3NzcfRh3kJf/bhPhihwwbGnz+7NnQJ89EL3fv2r1s/PjxV4hqIOJPOp2OQYMGrdy0aVNzgnhMJpNVVTi5u7vj4sWLCydNntTRWmANPUhVUS4ymYw2bduatGnb9rfjx4413rZtWycymVxVRqbRaMBkMmFiYgKdTkdQjOunT5s2+PadO8cAA1WxqKJCvXnzZtT20C0sLLBixQqYmprWaOtNpVKV5ubmOqD6uVsLBGjduvWEAwf2T3BwcIBKpQKbzQZNQwONTkNuZl7u9WvXX4wbNy6sLgfHwcEBnt5ePZ89e7bd1sZWkZWVReNyuOwGDRsqlQrFV9ebWlhY9NUDGEwGNGq16Y1r18toDDpYLBZatmzZkXhYxkK8oNHR0dctzM3B4bCh1xsWWyAQVJWLjRw5cnXt0C2FSoF3PW+aqKKiBqEAjUZDUVERsjIzq6wrwBDqaNGiJYteeWxiYqJy5cqVvdlMJliVqFSNRgM6k1EFgiOTyZBKpejQocOMQ4cOTQPq8ogMc3gbHS15//79BldXVzAYDJSWliIvLw+AgRREIpHwIyMj2xrWoeY1nj97Jk5OTj6nUqkQEhIymeAYNgYN1j7P+ONWq9V49OiRTCQSRT1+/PjE69evb0mlUimdTodGo0FhYSHCw8O79e3Td3av3j0jGJUW4lE7u1Z8Pv9Op8jIX4wNnbrmWTvUQwYJS5cuPdqlSxeT7IxMPH/+HG/fvuEFNWqExMREmVgs1oaGhpbeunXrFwcHh1/v379PKSoqKqfT6eBwOFi1aqWsYcOG10eNGtWJaEZCJpOxaNGiHQMGDKiXk5NTunfv3ktLly7tXtc6kGFg7luzevUlsUz6vlmTpmHdunfrQKr8aImoQG3ueicnJ0ZqetpzsaS6d/SZM2eeLl269HcWi3Xr/fv30Gq1GDx4MN6+fRtGpVJnTZ06tQ+fz6+xIhcuXDin1+uLgoOD2Tt27owiWsAaPx9jAFbzFi08mjZrtjwvL+/XFStWXL5y5Up/M3M+JDKp+fyFC85ERESAKOlUazSQSCVikVCElORkZGdlaxISEy41CGiQGRgUhPfR75CZmQn/+v5tOnWKDCeiOXVt+MZlif+N/Go1xa/BU7l48eKtXbt2rWnatOn9SxcvIS8/z1BCpDfgBkLDwnDo4EHs3bcPgMFYdHZ2RoMGDSARS2BtbY3MrCySCc+kRf0G9Rv6+/szGjRoQG/eojnFq543ghoF8VxcXNqb8c2czc3NYWFugeKiYkybMR1z5s3lsZhMkCo3ajKZDI1ajcAGDf/2/GpHaz4HKhnDFav/35jzAPi+yEVtdDcAaCrz/9Dr8eTpU/HOnTsnAUCTsCbtjBn5/jeLHgCXw4Fvff9fbt+7+zIlOfnqg/sPRK1atTKtzbTRoUOHiFmzZllnZ2cXMhiGvdvf3x8eHh5QqVRITU19d+vmrZdDhw4NNS7rq1LsIGHQ4MEdQSJfGztuTBedVqcjuAZIJFJVLTuZTIaZmRnu3L17/M8//5w9efLkQADw9vIe6OXltcbT01NDlOeyWCykp6dj1qxZNfYAsVgMc745r3fv3nRUjaWSL2Ti+EExMR/n2djYiJgsFooKC1FWWgomjQULCwu8fvnqqkGhf46rIoGEiIiI7s+fP/9TILDSWwsE5SKRyLKktLRc941W1tSPHz98+UHoAUtLSzy4f5+sVKtUjk5OYLJY6NqtW1UbytoiFImQmZV5xT+gPtgsNuRyOVRqVRXNK4/Hcx46dGhY7fMZdAaksv+PvfeOi+re1oef6X0Ghl6lK4JIFUSkKIKgqNh7iS3GFo0pGo0x0USjJkZNNKbYe28gNsDeUBEQqQJDh6FM7/P+MWxEBE/O755777n3vevziQFm9t7ftldfz1Io9+/f/1ZPWb3BAKG5OSwtLdvrACkUCl6XlVHjhw4dTLj2Pvv0001anVZLp9HasxtNLjSL9oz2srIyBAcFDbx48eKPpkPw7viJ1+2nH3/c9eDBA7mFhQU0Gg08PT0xcOBAaLVaiEQihIeHL2mrVW0n4qW+efPmLxQKRQuAv3DhwmnEswhsamLuHZmATqdDYWGh6v79+7cuXbqU/uTJkx+Dg4M1Op0ORqMRcrkcO7ZvR//w8CHbtm1bN2bMmP4dFR+lSgVxY2M9mUyG3mCgdje/rsk0jpCQEB6Pw3WprKkumzhh4sejRo38hsPjIikpqfHChQs7L168+KOVlRUoFIpEKpXC1tYWTk5OcHV1xeHDh9VHjx5NTL+ZHv/xso+X+/j4xNnY2GDEiBE9+/XrF9/S0pKWl5v70GAwjCSad5jW4c26LV2yJPXM2bOjps2Yjj/++ANnzpw5sH///mnkDuvXmQwwgkalQtgmzHfv3n1lwYIFCV5eXmgD/aBLJRLj6TNntGKx+EF+fv44AMOnTp160d3dHYAJ2vT27dsXqFQq+vTps6Cvn1+Xz+lMVCoVzs7OzB07dow3Nzc3MBiMSefOnWv65JNPem7ZsmVyaGgovv/uO+zYufPF2DFjrs2YMUO/d+9exZNHT1BRJULyqFHo49sH5eXlyEhPx1dfffVLZXV1lZ2NTXtHuJbWFlDI1Lbe0IK3epL/VxCRhQwA8+bOPVghEk0noDkb6upBJpMHBgUFBfr5+TECAgJYPn18SRQSCWwuh+XSwyVUKBQGWlpawtraGlwOF2ZCcxSXFFOYTCabSqGCTCaBTKJAp9Ni3LhxGDdu3D81PnqnUFl31BUsdWfh3TGUhLd+fjfpEZ2+C7xBv9Pp9dBoNFAqFJDJZVIyidyOdFldVY2K8nJVQVHhNalUWjR79my0Slpx7uw59ZEjR7a4ubpp44bGJ8ydN3dGxzH+z6U3Ym7uvLljduzY8RGLxZKkpqZuj4mJWdPZI+Xq6oqhQ4cuOXv27Jd0Ot2ETlhX156DJZfL8dvu3cvGjRt3r7N3FHiTvDl58qSEc2fPfnvy1MkveTxeeyWTXC5v76RJhB+/WvPV/Nlz5jxiMhiIGBjR+/z580Yajdbea53BYIDL5SIoKAgCgaAdD0WpVIJGpU0RmAnamz4RAjnAP4BnaWk5+erVq7ssLCxgMBrQo4cL7GxtIbQQ4nXZ60vipqb1Fp1wXAgVMikpKfb69etkrU6nv33vrq62vs44YMAANDU1vbdZCzUgoNu+KgAJEAqFFjU1NaSa2trm8rIymJmZjejdu3e3l9y5fbuxubn5oZ2dXXtmuYuLCygUCiorKzFkyJD5dnZvd5EjJuHv7z+BxWRuJOrKAZOgs7CwgKWlZXuWX5sLQ58wdOhgAHjx4oXs4qVLPxCfmSBmTfgFLS0t7TXwOq2W9v3GjcdoNFqbRtd1sVCFSITU1NTtRBwHAKqrq9HY2AitVova2lps2LBhCfAuoy8pKcFvu3dv1+v1mDZt2kf+/v5vZcATDJIEU6clUUWF9sH9B/evXb92rez16+3lFRUSoVCIPn36wNXVNSw3N3dwcUHRlnpxg5pCodj++NOPV0P7hbbfi7gfjUqFubk5VywW41V+/ikAU//ZUigul4uwsLBhGRkZv4wdO2bjmLFjCY2BN2fOnK0BAQGvS0pKzv71118ICAiASqXCixcveH379sWQIUNw4sQJqahSlLZ58+Y0V1fXCdu2bTvGYrEwZcqUgb/++mva8+zsWx2TUzoqNYcOHUp99PhxYkhICA7uPwCtVoumpqZZS5cuHRsYGMgivv8+2rRpU2pBQUHikCFDEBcX92VYWNiSXr16sQwGA9gcjrSysvLXU6dObcjIyLjU1NSU+NNPP6WQyWS8Ln0tuXXr1mG1SoX+/fv/7baVxHcYDAY2bdo08caNG1a///77BLFYXJibk/P1ldQrkEgl+GT5cpw6dQqnTp+GhdACri4uCA4NYfYLDqYVFhTg7NmzstycHKOZmVmjuZmAZjAYcPTo0boXL178XllZqczKyirzcHe3HxwbaxUaGrosPDycRvqbY/yPk+ntPHjo4L0///prupWVFb766qtTMTExcfPmzSOTKRRTnLk9AUyLDz/88J9+Cp3evWDuKDjfFsLEFXjn+13Wmnf6a9fCuy0MQqPB2IZQ1taNUadWq5UqlQoKpQJSqRRlr8tQKarMfZn/MiMwKEgTFByE25m3UF5Wpq6oqFAUFBRkGI3I3vXbLlSKKvHD95vQKG6E0WiEWqOBvb0dFi9ejE2bNuH06dPw8PBAz149kzd+//0ZJ2fn//GivDP59PZhLlq0aNnFixfX/b7n959nz569pmNSNiGMFy1atPj69etfmpubg06nQ6FQ4NatWx2rpO6fPXs2d9KkSb5deamI++zdt3fV3Xt3T1dXVz8lsEgoFEp7bJ4Q8k3NTY93/frr42XLloW4e3gYq6qqhtfW1Z4n3O5anQ58Hg/e3t7tniESiYTm5mZExEaYEx5S4hQR8mzkyJEzHzx4sIuQXeS2kjoGg4GqxsbszIyM6tGjR3cJBOPp5YWWlpbk2traU3Q6vdnKykoYFBRk0dLSIn4fRDnVzd2t2w85HA4aGxoMly9cJGn1OjQ1NWHo0KHRRGynK0jLzIyM40+ePIFQKIRGo4FGowGXy4VarUZjYyM+/fTTOcSiv7mHaQHi4uL8N2zYYCuTyWqJxaTRaGhqakJtbW17pqJEKoWdrW1iH18TXslPW7ceBCA3awMDIJPIUKpVqK2re2s+o0eP/io2NrZ9ATsLPOKlvnTxwh2hUFjp4eHR7qaRyWQwGo2QSCRwdXUdHBUd/ZZqRVx7//79u+KmphqlUomxY8d+iA7P6BgBfvL4ScFfe/86WlZWtksqldbX19dDqVSid+/e5t7e3ovi4uLGhIWF9WUwGBg3dqwiJTX1J0srK/uQkJD2e3V0VhkB+AcEGCMiIlBcXJzbeX/eT6aRaTQaY3l5ebZcqUBVdfUzAO2puY+fPAGDTq90d3fH8+fP4evrGz86OXnYqFGjZrq7u6OpqQkRAyKu3rh545jBYDj14sWL45s2bZKsWbMmRSAQDC0oKFgN4O7OnTuvLFq0aGhHpnv58uUraWlpiaNHj4ZAIBjB4XACjx8//jWbzdbv3r17w549e9Z3F1smwxRO+ezTT/dt/fHHWeHh4di1a1eKp6dnQkf3WGJiIg/AeoVCMWDPnj2Jt2/fTp00adL448ePn5BIWumjRo3Se3t7IygoyPtvLFg7dTy/gwcPHrx6zerURQsXha1fv96g1mjY69at+3j58uX0sPD+uHkz3dzXxyfRytLKxtLaClaWlqBSKBAIBGuGDR/+c2hoqNXhQ4eLX7169dPBgwd3BwUGGuwdHFBQUICkpCQcPHgQGzdu/G39+vUH586dG/5fUbtOhglBMe1K2ikACPD3X7Vo0aIx3X3/3b7kxC6/69p+N/REeie00tmV3RkNsmuYGBPp2iwpKqWtpE2tgUQi0el0OiXakCFrqqtRXlGBJrH4ZVlZWUZIvxCVp4cnnj9/DrFYjGfPniE3J6cyJzf36sqVK5s//fRTrFu3DimXU6RarQYGnQESuRQ2trbo7dMbK1euBGBqtuHu6QEfn95okUpga2+Hquoq8AX8iH6hocH+/v5sb29vukIhR1xcHHr06GEXHR09aejQoTwis/1/vnX+diIqGSQkDU9asn379nUUMkWckZGR0bNnz+jOfGpgZCQvtF+/+Kbm5jSBQAAqlYoePXqgqakJNBoNlZWVOHzo8C+TJk3a9c47YCQBJNPfOBwOPvvssz8+/vjjQI1GAyL7ncBiJ6DHVSoVfvrpp6VLliy5x6DTSQMHDozbs2fPeYNeDyMAg14PnUaLoqIi0yPaBGpJSQmmTZs2jNLmcewIuU0CCcnJyf2OHj0aQqfTH/P5fFRWVuLmzZug0+mQSCTIzMw8M3r06EVd8TY6jYaQkJCBe/bsORUSEgK9Xm9gs9lGW1tbqN4TR6fevnW72w/ZLBZqa2usWltbazg8LpycnRA7JHY4sUGEC5nYDK1OZ3yenf3E3d0dXC4XZDIZ1dXV0Gg00Ol08PTwHBwTE2PVcbM7vsyurq7o37//tDt37mxu3x+jESwWExwOp911LpVISLGxsSMpVAokEgleFRbu8vf3B4/LBaXNNVNYWAgKldKu1cnlcs6Xq1d/QowdHQ5CR5ebXC7HH7//8ZlWq0VlZWW7RkdA79XX1+ODDz5YYmoI8oZIAFQqNf7666+VfD4f7u7uEXFxcT2AdxNmTp48VTB9+rS+vXr1UkskEsTGxlJ69eo1v3fv3iMSEhNiPDw86dS2OngAGD1mzKyHDx/+FDUw8nlpSanMw8OD2xk6lkaloqSkhJudnY2Kiopj1dXVG4nyjvcJ9o6fVYgqSLX1dXdcXFzA4/Hb3STp6enSYcOGDYmPj3/s5uYWPWzYsFVLliwZYm1t3fl2Y2bMnDEmMzMzZcSIEcMePnyYyuPxPg0LC9s8duxYemZmpmbx4sUJfn5+zZGRkWYAsGfPnvT58+cnzJo1Cy4uLgnDhw07v3DhQpSVleU+ffr01PHjx78fPXr0vKFDhzp3FgTE7CdPnrz9+PHjSwFg5IgRqX5+fkM77jNBZJDw8ccfJwQFBqYMjo0d9uzZs5Nz584ttra29hA3NSE0NBQEzOz7LMCuiMhanzNnTsi6NV87NjQ1VowdM+bDL774YoNOp8PYMWMxdszYLq/98MMP3cRiMZ4+fdpy4cIFTz8/P3h5eSEyKoork8n4PXv2tPX09Cw6cOCAVK/Xl86bNy8xIiKiytvbm/NfwfRVahVEFRV6AJgydepwYr7odAY7C+nuLODOv3dlT3f8m06vB4lkQtvS6rTQaXVQq9VoaWmR6vV6kCkUKBRylJeVo7JCJCssKrzW2tr6evykiaipqsbLly/15eXliqrKStGLnJy0OXPmtI4ePRofLfgI9fX10Ot1qG9oAAC4urhi796/UFFRgfT0dMhkMqAtB+fWrVuorKzE/v37QSVTvOPi45b39OpJHxIfx/br21cslUlV325YDz6H52Nvbx9sbiGkmJmZgcliQmhujpKy1yQWk8mlUIlQAxk6rQ4hIf3emvu/a1Lk/wt1Pp8DowYKw8PDB5ZXlN/+888/V0+bPv0Om8V6y+ihUihIGjFixcaNG9OYTGZ7YyBHR0fQaDTY2dlBJBIdfPz48aaQkBD+Ww8gvXlrSSBh8eLFAT/9+GNYeUXFAyKWbjAYYGFhASaTaSpl1GhQKaq8fynlcu3IpBG2MYNiku/du7fQwcEBgElJra6pQXNLM5hMkzUuk8nQs2fPPqNGJYd0fF7H+QqFQvj5+Y1LS0t7bGdnBzabDU9PT6jVavD5fGRlZd3SarWLOuaGvbkXEDMoJvnmzZtL7ezswOFwmm/cuGHH5/Ob3gcDS3V368ZCNxphZ29POX78uMpMaG5saWmBTquzi4qMak+L77xZpaUlJDabfcrX1xdCoRDZ2dnQ6/Xg8XjQaDSIHxo/oWNJWlc1eH5+fl4nTpwAh8Npb3FKIZPB55kyHfVGA1qbW4yRkZGjAeD8+fN5IpEox8vLq11zsnewh7Ozc3vyQ1VVFYKDgz4NDAjoElaq4zhSU1MLnj1/fp9Op6Ourg4kEqm9x65Go4FcLjdPSEjosgb/xvXr9enp6bdJJBJWfrFy9bsZ8CYm9ejhg0yVSqUuLS21XL9+/ebg4OAxoWFhPHLHNrLt1wAuLi59RowcCQd7B4NIJDJ4eHi0j7ujhRgWFjbz2rVrq3Jycso3btz4+/bt2+d2Tt5539yfPnn6ksDa79HDWQCY8PCnT58+RKlUPqRSqcPWrFlziUjyA95NKuLz+UhKSkrct2/ftVmzZsUvW7Zsy6FDh2Z/9913N6KioqIAGDZv3vxtZGTk1vPnzz+eP3/+IHt7e/Tq1SshLi4uhd+WULd3796TvXv3Zmq1WvWyZctmxMXFpZM7aMLkNjV83Pix36deubLKy8sLixcvTlm0aFGbMH+XCCthYGRkQlJS0g9nzpz59Oeff55OJpE/yHmeDSqVymBzONQ36/+PGaux0w6TSWRY2Viz5CoFhicNn0Gn09vDNp2TXwjrk8/nNxuNRlhZWWnkcjm4XO6QKZOnzOrZq+dwf39/xhdffEEvKyuTDRw48OfTp0+vBtC6+Ycf9v61d2+X2v2/mkgkMtzc3PQPHz1CTk6OCED/rkru/pGQBt4gtBEY1wqlEjKZVAoj2rKa5Xj9ugxVlZWKgoKCq1KJtHT8pAmorqzGq4JXmrq6OqO4oZH24sWLGwDu7juwH+fPn8fRo0dh1Jsaw2i1Wtjb2eOjxYvw685fcO7cOdAoVLi5uiIifACcHJ1QVV2N7BfZEPD47kGBQZHFJcVnKqurWhvr6zmvy8rIrwoKkJGRIU1KSsKyZcuwdetWXL58GQWvChAZMRB5L18yhRYWnOEjkmiNjY3Y/vPPc5KTkylffP4FOirj/4jonUra/jeTEaZcqblz5nz/8bJlEY8rH99NuXy5fOzYsT3eRKBNPG3w4MGxy5YtEyoUiiaiDr25uRkqlQokU+WU/Pfffz8WEhIyr7syQCNMiblffLHylwUfLQiSSqWmv5ua8cDe3r7dYjczN8Pli5fOjkwasWBIfJzd7l27AnU67VMG3dRdk8/noWevnu2op3K5HNbW1pMsLE3gap1PO8Fr+vfvP/rixYufEYnZ1tbWYLFY0Gg0kEql5woLC0GUzREKQXtiXMRAJy6X2yM3N7e8sbFRPXHiRGl8fDyturpa210cnfrw4cMuP2iLLwgbGhp4PXv2rGhLgppg18Hq60ypKamZjx8/Vri4uLR3UGttbUVLSwukUini4+NHEZPtvAmEULKysgqg0WgghBaFQoFRb+p7TCaTodZoYCG0GBAzaJAFAJSUlKQ6OTnBzMwMFAoFcrkc+S/z2xMadDod6uvr6T/+uHUF8eyuiGCuqampf7q7u8PZ2RkkEgmNjY1obm4GlUqFWCzGiBEjpvTp04f65si8ufZJVtafzs7OEIlE5rFDYuM6zo/4mQQS4uLixm/ZunU+n8/vsXjx4pkdx9FVWRmbzZYJhUJkv8hGcEjwWwvfMaYYFx9vt2/fvkCRSPR0x44dy2bMmDE3KCjore90xTSI8T969PAvqVSK+vr6wNDQUKpOp8OkSZOSKisrH4aEhAzbvn17uzDvah07gkTMmDEj9vbt2+v379+/6rfffvtiypQp5yIiIjampaV9RqVSD2/ZsmX6+m/XJwKAm5tb/KRJk1IsLS3bz4a3tzc+++yz3T/99NOsV69eZWzduvXpp59+GtjRVb9s2bILp06dXuXg4IDt27enxMfHJ7xvj4nPyCBh165dK8rLyve/Liu7n5ebe9/G0gppaWkM5x49WM5OTv901ytiTOXl5caCwoICGpVG6h8+wK+78RCzyM/PV02aNOkPAPDx8cGwxGG7p0+fNt+rE+CTj48P9+ixY18OS0y8//Lly8t37t69KJVKF3WESf7PICMAJoMBH1/fAWQy+ZeUlJT1Q4YMGRobG8s3GA3QaU1Jm3qDASqlUqPRaNRKpRINjQ1oEjejuUkMiVT6oqCwILOnV0+tn58fbt26ZRRViFQVFeWqwsLCOwaDIWvv/n04f+48jh87BoPO0NZSVQM7ezvMX/QRdm7fgXPnz4MMEswEZtDpdZgxcwacXJxRX1+P6upqeh8f3xhvn969/QMC2N69etFoZCqSRyfD1c3VwtPdI97KytrW1tYWfIEAHA4boqpKmPEFPJ1Wi1mzZlnKpLLNa79emz106FAbGxsbY29v76JevXpdNBqNsLW1BZPJvD57zuzs6OhozJs379mhQ4cmz5s/Dw8fPMCPP/2E8+fOY+mypdi181e2mZnZB/PmzbPs6d0Ld2/f9rGwsorv7eMDe3s7mGCZ6dDrdeByuG3noWuchP9NRPC/8AEDBuh0OqGjo2PTwwcP/ho7duy6zu9b7969MX78+OlXrlzZZmlp2d4O19nZGXQ6HTY2Nnj16tVfEknrPD5f0C0/IoGEadOnBW7ZuiVKIpFkEhY2gHbvLRFLv3Xr1jm9Xr+Ax+HCy6vnyCtXrjy1s7OFSqWGwEyAsLCw9h4gGo0GHDbHoNPp2hMzu6LY2Fj3P/74I5BMoTxls1jQ6kzgZEajEVVVVfrLly9f9/Hxie1KGbazs4NQKBwjEol+DA4OVra2tgrPnz+vNhqNDd3F0btFimMymZDL5bpjx47VNzc3Qy6Xk9asWeNLZJV3VXJVVlZ2w9zc3AAAarW6PSGurdtMVGRkpBUx5HddciZqbGzMJTLJtVotOBwOIiIiwGAwoNPpUFNTg/j4uGQ2iwWVWo1jx45dMhgMkMlk7X1rCescMNVxh4aGjukXGsbpbtGJcbzMz8eBAwf+4PP5kEgkYLFYsLe3b2/DJ5PJMHLkyCnAu4K3obER586d/V0sFmPKlCkf+Pj4dBvcCw0LE7i6uPo3ihuz7t27pwoPD2d2V1ZGAgn19fWcwlev0C80DBYd4HY7KkVGAHweD8HBwZtu3bo1hMFgyL/99tthp06fvkxtg2p9nwXw8uVLw549e/7QaLWYO3fubA6HQz916tTju3fvXgLAOXH8+CU7O7u3XK1d3Y+EN73Y582b93F6evoqg8FwXiwW4+eff/50wIABn6lUqrqTJ0/6t0pMmb/r1q1LedN69o3HYdWqVTNzc3N3ZGRkPP3uu+/mLlq8KIvFNDlZTp48mfrnX3+OBIDY2Ni9nYX5+8IMRgDW1taYO2/un1u2bAnt6+cHR0dH7Nq9S/LgwYMvN2/evNrX15fVuaNTVyvYOcb75aovf9br9RiWOGypl2f3GA/EVV9//fWu5ubmyrZ5pKxdu7a9PztRrkdY8zQqFf4B/kOvXbt2mU6nX21ubpbzeLxuz/W/goj3dOKkSZMKXr06+DI/P3Xs2LEWs2fP/szb25uek5OD+vp65OTk5Obn599btmyZdNWqVdizZw9yc3PxurgU+YWvpADw2WefoV9oKFatWgXAtAeuriboVBqVBpFIhMqqKkofH99BvXp7+wYEBLA9e3rRyCQSRiUno5e3t3t1VTXp+PFjUz08PAdOnznzMp1Kw8ZNm7Bl6xYam81mksmUti5rJGi1Ovj28cX0adP/4TxpVJoRMMLG1sbJ1taWnpCQgISEhEAAgQqlEgMjB2L7jh1r5XK5VCqRYOfOnZTGhsZ0M4FZsW+fPhidnFxfVFS0z9vbWzokPk731+9/7Ny7bx+mTJ2C5Z98goCAQN5PP/+EjRs3YvvP2yOSR40KnT1vLmAw4tmzZ4nRMTG9nJydmD2cnGn/zlgE/wry8vLCnDlzFl64cOHbs+fO/b502bJ1jm3u7Y78Y9iwYdMzMzO3CQSCdqGr1WrbjbuCgoKHR44eu/fh/Pnh3b3vRCx9woQJH/z++++ZJghqU2mwWq1ut7hJJBJqa2uvZmRktA4ePFgQGBKUdOTokbVmQnPo9Dq0SFpRXFwMc3NzUwWDUgkzgYDR0e/W1fPNzc3Rq2evkVeuXHnq6OgIZVtCZRtYjeH5s2fXAcR2TnIleGBISEjg9evXSVlZWUY+n1+5YsUKcls/gC7XlpqVldXlBzQaDS0tLS7Ozs5V/v7+kMtkpD5+fcYBXWuQzS0t+vPnz9/UarUgmib4+PiASqWiqqoKQ4YMGf4Go52wyt8wX4LBNTU1lVpYWIBEIoHJZEImk6G8vBxsDhs6rQ6lpaWYO3fucAC4ceOGuLCwMJOwzgn3vkAgaE+ga2howJgxY4ZSOpRKdSbi2Tdv3LhpbW3d7NYWhiASKQhMeCcnJ3cCtpMYN0HHjh69U1ZW9trOzg4jRoyY9WaW7xKfzyeNnzB+0aZNm+asX7/++5SUlHXve4lfl75+cu36dVDpdMqkyZPe+szYYS1JIGHFihWx169fH/L8+fNr58+fT4mMjJx88cKFI4Qi0Dn2SYKpvnjVypXzlCpVKwB8+tmnswAYt2zd+gkAjB07dpVLW6/iznv3PvL19WVxOdzI16Wlt27cuFEyfvx4d6FQOKa4uPg0oXCtXr36/KBBg8idXY5GkAgYxd8KCgpCqqurn65ZvebI999/P/nChQtPPv/880Qmk4mgoKCRe/bsmWma2/tfLtN83yiTw5OS+q38/Atnpr1DhbNzDzaPz1dkZWV9N2PGjN8D/P3n9QsNjYqKigpzcXXh0eh00Km0Lh3JLS0tKCoqku7du/f369evfcJisfDxso+Xvlmtzs83UXNLCwoLC3cDQERExHhCmL99Dt7O2e4X0k8XFBSE0uISdwaT+Z+OPEKM19HBAevWrUtZ+/XX41+/fn1y27Zt323YsAFSqRQXLlxAnz59MHr0aJSXl2P37t3o27cvzM3NoZDJUfq6FE5OTrFmZmb9pRJJr2+++YZBoVDCIqMiHaytbcCg00GmULDn998Ne/fuVdNoNJbBYFJBTb0TdPD36wsAuHXrNi6nXJ4qMDfrERwU9F73BJ32LkJbd1o2mUKhwIQGR+38GbstuZJGpYHNYvGsLC3RxiOGFRUVoV9oP4SFhUGhUCzPycvRtDQ3QyqTrbqZfnPfwMiB+GD2bGRkZEhTU1JRV1MHn94+qe6enqk0KhVzP5iNisrKr4ODguDZ08tCwOOvW79hw0ILC4v/lUKdEFQDBw6c9/PPP3/LZrNrThw/fmf58uURnYVyQmJCwO+//96HSqXmMJlMGI1GlJaWQiwWg0KhoLW1FefOnD1gEugmntH5jetQ1520cePG9kQ4wGSh29vbt4c9tFotMjMzTw8ePPiDYYmJAVs2b3ZSKpUiHo8LrUaL69evg+geKpVKYW9vX/HxJ8vbn9V5/MRc/f37jti/f99aDosNOoOOPr6+AJkEmVSGpubmq83Nzd+Zm5uTO46ZuN+wYcNGi8XiqRKJBKWlpbT79+/bCwSCxu4QXqn9+/fv8gNHR0fKvn37Kh4+fChlMplwdHLqERIc0u0L9Pz5c71UKr1r2Ya8RqVSIRKJYDAYUFxcjA8++CAReL87SafXQyaT0aKiosBiscBms1FZWYn6+noYDUYoFArY2dm5D01M6AkAt25lnrG1syVZW9sYAUDXpkzU1NTAYDBAo9GgqakJwcHByR0XqivSaLQ4dfLkenNz8/ZSFQqFAp1OB51Oh+rqaiQkJE4iNLzOiVmnT53aL5FIEBgYGJKQkODT3fMI7XPatGkTN23aNCc1NfWbx48frwsJCXnnQBDWX3Nzc4pGp8PZs2ctDx06zCM+e9eqN5WerV+//mpCQoJtz5496+7fu3d03rx5iuPHj5+jUqlvuZKJsW/bti31/IULfwLAd999l+Lm6sZ69vyZTKfR3A4ICMCsmTMX/qO960jE2rDZbCQOSxy/cePGW08eP/5r/PjxGwYOHJiYn59/Oi0tDQ4ODmFr164d0dVaES/imDFjgk+cOBEikUge792794OgoKCiBQsW/MpkMjFy5EjBokWLznUGgfnH4zORvb09EhITku/fu/+zh4d7GYVK/a6qqmqbRqNpqKqu3vDbb79teP36Nf3Zs2exY0aP7qfXG2xZLOYEG1tbCoVCwatXr+p69Ohx+NChQ42ZmZn7+/btK1Vp1Pjggw+OxMTEuHQ1r47Pv3TxYn5FRUVhXz8/8sqVK7d3t8YdvVl37955ajQa4eHpmWBhYdG9r+9fRB2TVu0dHPDbb7+dOHv2bEtWVtY+Hx+fVolEAhKJlBsZGZk2YcIEjB07FmfOnJFeu3atPeeFRCGjpaUl65cdO9XXrl4VfjB7tkNoaOjVmzdvkqVO0skh/YJpPL4ADDqdDOCdPBdCMANAU5NYodfrodVq5BqN5i2Izu6oozsbQHsbZ61eB51Gi5bWFtTW1cqbmptRIap4VlNT4/X8+XNUVlYqiwoKrrVIJMWTJk5CZXUVXuXn68vLyhQiUWVNcXHxNQaD3nD05Alcu5KGEydOUBkMho7DZCO4XwgCAgIwe95crFu7FiUlJdi4cSP69OnDGxI3BH5+fmgSN0Hc0AgHO/seapW6+f7de1Vl5eWL7j94kH779u1TPB7vf6VQB4AhcXGOLi4ukVVVVbdOnzq92yTQgY7RaKG5EIGBgZPv3r27ks/ng0QioVevXiCS23Q6HWpra4+9ePFit5+fH7orYQSA/uHh5j29vKL1BkMGoRxQqdT2BjBEs69bt25dAfCBjbUNvDy9ku/eubtd0toKKoUCcVMTmExT90+JRAK1Wn2gSSz+0d7O/h0lEHjz3g4eMsSfzWRZlZWXNQAAh8tFaFgYpFIJRCLRs2fPnqkGDRrE7uoePj4+9MrKSu/y8vJ8kUgk9vLy0o0aNYpeVVWl6SqOTn3x4sW7i0AiITc310qlUtnGxcU91+v1sLCwGC8QCN65AyF00m/ePCeRSEhcLtdIJpNhMBjQ5qoHk8m0iYmJ6bZ4nZi4pLUVz58/PySTySAQCKBSqVBXVwcajYaGhgYolUpERkYmWQpN1ubtzNuXGTSG0aDTgwRTqj+BGU+0rrO2to7t37//Pww03rt3t/VFTk66UCiEVqtFW5JSe5N6AIiOiZ5kGq+JiDapjx490mfeunWCLxDAzs5uBlFy9z63r4+PD2fBggVbd+3a9cnChQtH3r5z53znzHnAlAMgk8m0vby8UFNbW7dj546LEydMSOrRo8c7Qp1Yx+joaOzdu/dORkbGvOjo6PTs7Ozzs2bNih04cOBXc+fOjSR3QOm7d+9+akpKSiIAREZGzly5cmUCADx6+EjP5XIxa/Zs+Pj6dnnYuqLOoZTamlopAKjVGi0APHz48DJx5tavX7+bSqV26yY3woQ0NmjQoI03btwY7OXlpdbr9V/z+XxwOBzk5uaqqqqq6vv27WvdXWJM1/SGdQQGBfGOHj0KHp9fOXfu3J969Ogx/vz581ednZ0PeHt7SzZu3NisVCpTRJWVKd9//z2sLC0/GRARQdbpdMZLly7JQkNDERUVhXv37kEsFmP+vPk/rl+/fhLQvXAm3pni4uIrCQkJWPnFFxwXF9d3SgaIMRJz27RpU+q2bT8fBICNGzcmUymU/zJ2T6TqkMlkjBkzxmzMmDEf6w16DBkyBF+uXg2pVCqtranF+vXrIRaL05hMZp5arYaZmRk8PT3PrlixIvf+3Xu3f//999vpGRnYvmM7fv5xG0pel87sHxqG+R99SP5lx85gB0fHxFmzZkGhUKCosGhIHz/fPr19fGBpYQUajcpTKpVsrVYLnU7HUbcJdL1eD3U7kItcSiFT0NLaAqPRCHFDI6qrqlBZVZWX+zI3PSAgQBMSEoJ7d+4ay16XqysqK5SlpaW36mprn02YMB4XL1wMPnjwIJoaxVBr1FCrNXBwsMeCBQvw8/afcf78eVDIZPRwcUEfvz7o06cPeHw+SkpKkJOTYxUa0i/Ow9PDLCgkmGPv4EBvbGhARMRAWFlZCXo494gzNzd3EgqFsLCwgJm5OV6VFMNMIOABwM6dO1NWrlyZlJ2dffrMmTPpM2bMeKeBx/8W4vN4GDVq1Ix9+/ff0mg157KePlUGBQayCKu2Q6LvxJ9++mllO08lkdCnTx84OztDrVajobGx9datW9f8/PyGvK+MU8DnY8rUqUnXrl3LsLW1BYVCQUtLC5qamuDu4QGdTgutVouW5pZzuS9fwrd3bwSHhMRnZGRstxHYQKPRwM3NDb169WpHHq2qqlJmPX4isR8xQvi+JFoHBwdExsRMqK2p2WljbY38V/nYvPkHUCgUqNVqUs9evU4OGjRoRld7LRAIKAaDYWRra2t+aGioTq1W97hy5UqV0Wis69galiBqQEDAO39kMpmQSqXKc+fOVdXX10MmlZJWf7XGjUqldrtgIpEo28Pd3UhtSxCwtbVtr7eztbWdQJQAvI/uP3jQyGQyC9zc3EAoBTqdDiqVynSv1lZSUGBgPAC8ePECOq32gqenJ+htqD5Pnz1FfX09CA1MoVBgUMygJCJBrisimGVaWtpZBoMBgUDQXjtva2MLg9EAtVoN7169guLj43sDb4QGwZizsrIuUqlUiVwmwwcffDDZ9J3uhQthpW/ZsmX5ieMn9j5+/PjCb7t2pSxZujSxs5BWqVTYv2/fX+LmJvTq2QuPHz8acf/evR6uLi7ffrJixbTOLUKJ8qmJEyd6xETH3Lxw8cLnKSkpPzx48ODG7du3b7x8+TJp+rTpvwQGBTpNnjx5/7Nnz2a2NrcgKip60qVLF/d2GKaxDX0OOp2ORqzW3838JoEEmVyOoqLCPRw2B4FBgaM0Oi1UavUZrUYDDw+PQTNnzuzbcR+6s9InTZo0aOvWrdYkEqme2F+pVIqCggL16tWrZyQmJqZ2jkG9b2zE8wDA3NycbARQXFR8DUDAqFGj+o8aNaq/RqNZu2fPnvqXL19OiYiIuJ6XlwcPDw/4+vrKe/fujcuXLwMAyl6/Zg0fPpwaGxubMDBi4IfzP5wfQ+xx1/RG2Tly5MiNWbNmQalSUTQ6LYmDd2PyGq0WxYVFqKyqPJeRkZEMAK4urkOWfrx0UMf5/GfSm70xwgCiVtxURkZUrfC4XJ69nR0CAwMAYKzBaBwb0q8f5syZAwBrFQoFwsLCED80Xt7YKD4c1j9M7+zkzD1x7HhFenr6yU3fb6osLSl5ZC4UPnJzc8Nnn36K1CtXvg4ODOJ9vHwZ0tPTcfvO7Yk9nHuAx+VCp9beuXDu/LqW1ha8zMtTlVdUKAsKCu4Yjcas3377DSKRCBs3boSktRUUChUkkmkt+4f3x959+/DXHyZoWktLS7i6uiJ2yhTa4qVLmKtWfSm9c/cOxce7d5R3b28/P39/dm9vbzqJRMKokSPh6ubK9/TwHGppaeloY2MDSysrcJgsfL9xI7b+uJXHZDBAIpFBopjAR3RaLQL6+v+tdf7iiy8SX79+ve3YsWNLbt68uX/8+AkxLNa7aGj/k6ldMQQwZsyYMQf2759dXFwsv5WZeS4oMHASkTMCmM5dfHy8i52dXXhLS8s9JpMJg8GAuro6MBgMqFQqGA0GXLxw4acPP1wwhEqldMlDiLfd2dk58eXLl58Q4GM0Og1kEhkv8/Jg0JsgeKtqqrVnT5+54tu799CEhITEE8ePw9zMHCw2C0qlEnfv3gWNRgOJREJ9fb3mwYMHJ5NGjJj/viRaCpkMX18fn7S0K6QeTs7GJnETLC0tie6fxpd5efmm+XauhDEpMP7+/t5XrlwhKRQKo4WFRenQoUPB4XC6rEfv0kKnUqlobW1169mzZ6Wfnx8qyyvI3r28J75ZoLdJ3NSkT7tyJVWj0YDFZIHNYaNCVAG9To+GhgZER0d7Ut5TykEwsRvXr597+PBhOwa2UqmEp6cnhEIhFAoFHBwdjUMTEoYCwNmz5y4XFBUa7e3toW8rT7OysYZXz57tExWJRBgcO/i9rn4STLjw586dO9CGTgZ12zy0ajVUGjVqqmuQkJAwvnPnIxJMvZhv3bp13M3NDWw2e8iAAQPMu1unjmSEySW9Y8eOI/Pmz/PbvGXLMHOh8Pq0adMGd2TqR48de6VSq2v6h/WP+/TTFb9k3Lq1JjMj49jjx4+n5+blnbx27doFcluc8w3TNa2pja0N5syZs6m1pSXqxMmTyWKxWNPU1PSKw+WwAcDVxZV/9OhRkq21TeiN69eOUNqsZTJI6OPnR9Vqtdi0aRNYLNbzBQsW+Hd0if0dQXLm9Ol8iVT62tPTA4nDhoUfP3I0q0XcBBcXVyiUCmVraysEAsF7IpsmcnV1xZw5cxafO3duzcGDB1FcXIxhw4Zh3Lhx2LZt25X5H86/+Nvu35JMyhCxun+PCO+LvgNI8osXL9Q//PDDrsLCwp2BgYElCQkJuHHjBshksimvQypljR49es2YsWM9He0dovr07cP84osveERs7h9VUgDAz9u33ykuLr78+++/Iy8vT+nm5nY80N8/kcvjo7W1BSKRSEYmU043NTeJ8/LyLrq7u2cRHaQOHjp4lsn4r2P0xk5sxnTKuiPTHMkkEhh0OrRaLbRarVEmk5HodDp8/fw44sbGebdu3UJTU9NDvplAPzJ5VPzzp89ySECqXqfDN998g8rKSixevAiOTk7SpYuXQNzcBDtb29/VajUmT5kCJyenMoVS8fWiRYsAmGp+3T3c4ePri2ZJC2zsbVFTW0vmcjhRQcFBfn379qX7+/uzff36kIwGI1gLmejRo0ewtbV1pLW1NaysrEACCT//vA07d+6ksNlsNoVMBplCaYvja+Hv7/9Prx2D1hFoB+9dOTJImDhx4uLff/99SVralSyVWgUWi9nt9/+nEvEWhIWFCfz9/RNev36devXq1ROLFy+e1NloFAgESBiaMPGvvX/do1JNEMgikQhMJrO9Jjzv5csrDx89lA4ID+/SE0sYBoMGDerF4/Gcy8vLK4guaK2traBRaSAaejGZTOS8yL4OYGibsTu8oKDgEodrwkGxtbVtb8nN5XKRlZV1R2/Qz6eQKV0aJQQ/DQgImOjv7/8RUY/e2tKCJnETlCoVJK2t5xrF4u8sLSzIXY07fujQsZUVopkkChl1dXXMx48fO5qZmT3pKo5O7dfvbVADo9EIR0dH0sGDB6uvXr2qYNLpsLS0su/Xrx/3navbKCc722AwGJ7Z2dtDr9PD0tICdg720Kg1qKyspPgH+Ldbrd1tr0ajQXp6+gkLCwvweDzodDo4OTm1o8zp9XoIBIIkwqOQl5d7m/gMMCV2VZRLIWmVQK/XQ6FQgE6nO0dHR3u8eVLX7qvMzExxYWFhuqWlJZGRDy6HA41WC6PBCJVSiZB+/cYSG9SRnj/P1j1//vxMfX09li9fPr0jvvr7iNAcJ02e1CfvZd6JDRs2jJ8+fXqcwWC4NXLUSL+mpiZkZT1tXLNmzWQXlx6YMmXyoOTRoz0GDR58dN++fVPu3r2blJ+ff3HKlCnj/9r71wkGnfHWyNp7V5NIGD1mTCKbw9FVVFRgRNKIwp49e8IIYMN3G5KZLObub775ZtHy5cs/3rhp008sFosEAMFBQZzKysqohoaGzF9++eXj+fPnZ5DJ5G4bpXRcY0LL3vzDDx/k5uVh/Pjxi7kcDnbv3v2Rg5MjrK2t8fDhw/uBgYHDX7x4cYnD4XQrBNsRppKSlspksu/v3bunMBqN4PP5k3r16kXy8fE5knI5ZcTatWsvrlu3bjhRH/13Y4+tra16APDy9OoFAHv37r22/ttv5zY1N5f7+/vDz8+PbmZmtmTmzJnCsrIyXLp06Y8nT57U/PrrryuHDBnSaU+7VnQ6CvLs7GykpKT8uWH9hsV9+/ZFs7gJRQUF6lcv8yemX79J5gv4TJlMRsl/ma9plUnUc+bMgZ2dHW7cuIGsrCyvAwcO3B8wYAAH3Tzrv5uImWq1WmRnZ9+YNGnS3sjIyAtffPEFzp49ixcvXiAvLw/l5eXS5uZmAEB8fDxcXVyR8yIHjx8/gUQqQWhoKKbPnMnTaLX4cetPcHHu4ebv7z/EzcOd6+XlhYCAAHC5XHy9bh24XE6wk5NTZLvFzOFAaC5ETU01hcFgsonKHMC0R54LPN4d+D+g95Um/V3qqna/M924ceM0mUxGcHBIHwbjf363ta6I4H1UKhUjRoyYu379htS83LxzT548UYaFhbXnUBDv/shRI8fk5uUuISqOVCoVqqqqQKPRwGAw0NLSYrx6Ne3sgPDw6e8LUdjZ2yMpKWlsTU3Nj1wuFxSyCUFQJBKZ+ocAkMtkaBSLU2Qy2RYul4vw8PBBe/fuvaTWqGE0GlFfXw9/f/92L3BlVdXJ58+e7w4KCuK8720MDQ0za21pca2qqiqlUqno4ewML6+eUGtUqKqqLnj86JEyISGhS1eyX58+zNLSUo8KkahIKpM2u7m765OSkiiVlZX6znF0an5+/js3KCoqsuVyuVbTpk2rKy4qhrlQOFloIXynESthWd24fuNUc3MziU6jGykUCsRioKa2FjKZDGw22yo0NNTszUZ2JtPmpqenN+Xm5l6zsLCATC6DXCaHtbU1vL29IZPJUFdXh9jY2CjAVD7W2tqa5u3tDS6X295mz87ODjQaDUQZm52d3ThrG+sOT3r7+R1qz88KhUIQ8XMOh9Peck+hUMDS2sozOib6LQQeYu737969KG5s1BgBREZGjnwzo38c+yK2Yv369ePu3bu3ID09fde1q9ciWlpaeC2tLbh+/YaUQadDIpWiuaWFZzQYIRAIsHTp0uGOjo4ps2bNSszNzT05atSoZ+PGjQvo7pnV1dWSwsJCQ8e2f8SzxWKxXqfTaYuKi39uaGj4xtnZmW8EQKfTSRs3btw6e/bs4Ly8vMxvvvkm5euvv04ko3sbg1hPsViM2CGxk4tLSx8EBgZiy9Yt23/88ccT9+7ffxQTE0NxcXVZGhMT8+OyZcsuDxo0aN7Dhw/3dJXk11EQCi2EvMGDB1MrKyuRnZ0NHo83Ijk5eeKRI0eaHRwcUlNTUpJu3ry5ePv27dsDAgLar31fDTgANDc3sxztHdAkFgd/9dVXu8Vi8QIOl4uq6moEBwdPHz169CYfHx9bokKjvLycfvfu3RVX065+O2TIkDXosB7vE+alpaU4ceLE4bS0tO+5XG7e4MGDkTAsER99+CEqKkWwt7GlyRVybatUqhg7dizWrvsas2fPBolEgpubGw4dOgRnZ2eSpaXlmdTU1H4xMTF+TCbz3y5pisgR2LNnT+ovv/ySSCSoEhjWQqEQRPiNw+GgpqYGjY2NgBGwdbCDWqWCSqOiBgYGptMo1Ag+j4f79++Bw+WC3gbZSQBGMRgMrP3qq39qfIY2pDCj0Qij0WQzk0kkGAymv1OpVBiMhg5n5N06hTf//j2l6n3gTqS2f0gg4fTp09m7du1a0NbRcjybxf43291/HRHWZ2ho2DAOhw2JVIrMjIxzYWFhkzrzscjISPvt27f3USgUOWw2G2QyGVQqFS0tLe3fSU1JPbpy5arpTAajWylDJpHg7u4ekJaWBqKxlkKhAJPJhFAohFqtBpfDQXV1dX56ero4KSnJIiIiYlhaWtpyZ2fndk+NUqls794mFovV58+duxAUFDSpq4Bke2hPaIb+4eHj6+rqNgoEAsikUjx58hgA8LrsNSn/5ctjCQkJs7vi4XwBn+zn5zfOydnpOxKZrFapVE43btygGQyG6s716NTOVgaPx0N1dbUkLi6OplKpQKPRsGLFCisq5d1EPuJQ19bVFfTy9jZSSGSQyGRYWVuBSqUSSWlTbaxtu+3KTjC8X3/9dadOp4NSoYRUIgWDaULouXfvHoxGI4qLizFm7JhEAMjMzGzWarXP7e3tAaOpvV2NtgZlZWXgcrnE90nh4eG+ZFL35WrEhqakpBxVq9WQSEzWPY1GQ2OTGDqdDs1NzYiOjh5BZLd3nLtOp8O169ePM1ks2Jmbx4f2D+MBHUtk3t2czjHSlpYWpKenZ8JoFBPKyIP796UqtRoWQiGEZuajx40bu3j8hAnRIL+p0R4zZkzC2bNntx0/fvzj7zZs+GDs2LHPSKSuC3NcXV0pf/zxh6VcLm+k0+jDeXzeAUtLS9qDBw9u/fzzz8sBoLa2lkehUKgdx//BBx8E3crM3LP/wIF5z58/H/bXX39dHDVq1HAiJNL5WXq9HgUFBa2LFy+env8y/0JiQiK+XP1l3qtXrwq/+uqrCQAQFBR0Yt26daMLCwvjQ0ND4+/evfv7jh07xi5evDiuY0kZceeSkhJdVlZW7qlTp9acOnVK6u3tDV9fXxQUFLy0trbGjh07UrZt25bAZrOvXLp0accnn3zycOrUqd9ERkbFu7q5mFpTdkNKlRInT5y4rtVosXXr1pjGJnHJ6NGj4efnF5KcnLzh66+/HtJZA5ZJpeT+/ftj8ZLFcq1OB1qbm/19wvyXX37JvH///oaKioprhYWFGDNmDItCoUxks1k91q/fQOXz+UlcLqeHTC4veV1Wdsffv28zhUKBnZ2dmslk7nv+/LksPDxc6uHhUbBv3765T58+xYDw8LHbt2/fzxcI2P9OQp3Yubr6Om1+fj4SExNRVlaGefPmwdDW7ITAi7Czs4Otra2pz0NTI5ydnaFQKCCXK3TPnz7beuTIkXSlUkko6Vq9TifTGwwMPp/PlMvlRqlUKiWTSEajwUgywvhGk8abpCrToNp+amPCJh5oynI2Aka9Xk/icDgcNptNbmpqUsNoVIJEonS+zf8rdcU7Ow7NYDCQGExmY1ZW1j5fX18MGzYsYdq0aaNMo/z32dt/FXVUcAKDg+iurm4jXr9+feHKlbQTy5Yvn0RvSw4mFt7MzAxubm4jrl27lmNtbQ0ajQaZTAYGg9Huem9oaLjy7OlTQ//+/buUNQRf8fb2HlMpqpwmlUpBpVJBp9PR3NwMGo0GNpsNg8GAhoYGPHz48FhSUtLCQYMHe3326WfWeXl59VwuF1qNBiq1GlwuF3q9HiqVCkeOHNn16WefTeLxeN0qExQyBU6OTk7Hjx+HtbU1mEwmYqKjwWAw0NrSapRIpOX6tla6nePoVAoVTs7ONr//9SesLa3Qw7VH1dQpU2SWlpYgwnAEUU+ePPn2YpNIYLPZzn379q3icDjQarUMr5493wJT6UjNLS3aq9eu3lDI5RAIzEAik1BeUd5u3S5dutSCSn0/FGJZWRluZWTusBRagMVmAwYjmltbUFpa2q4YMBgMi9jYWG8AyMrKOvr06VNSTXWNkUwmm5iAQg4ulwudTge9Xo/m5majt7f3OGIzOxPBeB48eChramq6SRwUwgKQyWQmDaxJjP79+49+e/6ma4uKi1BTU3O2pbUF06ZOncDs4PZ+95mk9jaUTU1NuHr1atOzZ8/2WFtbp9y+ffu2WCxGb29v3Ll7B1ZWVtYRERHzRo4YOW/gwIFOtLZOVB2fTwKwf//+pXfv3v3jeXb28+82fHfp088+HU4im2xokkntB5lEBp/P5/j7+096+fLljlZJ6+WzZ8861dTUkIVCoWzSpEkoKyuDhYXFchsb2/ZsdsLd9duePXOZLJYyNzd36ZYtW5JOnDgxcv78+Sv7hYb6cLgchkGn15aUlOhFFaLcl/l5lw4dOrRRJpMb4uPjse3nbTkVFRW9k0clcw0GAxKGJoz45ptvRrNYLPj7+8eFhYWdvnv37pilS5bER0REaAICAmjE3MrKyvDpp59ulMvkv9jY2lRWVlbCaDTiq6++wu7du1FYWHh++/btkUuWLIndsWNH6qRJk8YNHTr0lI+Pz6Nnz54NvXjxYvDQxITh5gKzUd69e7s5OTqyGQwGpS0RBWVl5fLVq7/cVlRcnMFjccDksEsAoLm5OXHnzp2XiY6ABiMAUodWtySSoq6uDjdv3lRNmz69y70mFJKqqirs3r37hz/++OPz6OhoWFpamvfs2XP11ClT5/bt25dHZzI6w4QGtv0HmVyO6zeuQ6VUrU1PT9fo9fpj+fn5N2/evHm8qanJuP/AgVMKhSLgxIkTq8ikfx8gEoJxLvpo4YiK8or5DQ0Nhx8+fKg2GAwGOp1OolAoRhPwy5ue5oSQNyUqmWCWn7/IPvciL/ccjMZ2SGcanQ6lXAEnR0e0tLSgVSoBh8OBXqeH3qiHQW8goLz/FpEAkKgmF67QzBzmQiHKy8rAZDKh1WhAIpFhMOqh6yKb+J+h97W7JNpKMxgMTJgwgdynT58Vc+bM2WRmZvZvsqP/enqDnUECnUZDXHzc+M0/bL5QV1d3Lj8/H337ErmybwyYfiEhI48dO7aBx+NBLpeDwWDA1tYWZmZm0Ov1KCoqwtOnT8/3798/+X3e0X79+jEcHBxi1Bp1OofDgV6vh6OjI6ysrNq8NkbY2NggLzc3FwDs7ewwaNCgKXX1dT9x2GwI+AJkPc1C3suX7fdsaWm5ffTI0bvz5s8b8L7kXq9eXlNcXV1XuLq6KjUaDfbu24fW1lYYDAZwudxLi5csXm1hYUHv6lp3D/ep0VFRX/Tt21cpEAh0t27d8hKLxc86g19RO0NHmpub4+rVq3SxWMxhMBgSPp+vDgoMtOxuc4qLi2gWQuEdJycnkMlk8Hg8mJubE1Yy3dfXdzxAoF69PVlCqB49evRmq1TSaG9vD41WAzaLjYGRA9tddQqFAjY2NlN6OPcAALzKf1UYGBho5HI4IJPIAAkoLi2FUqEAi8WCXC6Hra3tgH79+nVbbkW8Yk+ePD5tbm4ONzc3UKlU1NXVoaysDFQqFW3WgdXQxKHhXV17/ty562VlZRoyyIiOiemy1p2YMxnA69evdX/88ce2p0+fXmxsbHyS9SRLQSGTseyT5VRHBwerCpFo9ty58/oPjBw4yMfXl/kGle9tImJQFAoFn3766YGFCxcG/vnHH0lm5mZfODs7MzkcDmxsbMBkMsFms/HLL79onz17dnD+/Pnw9fXF3r17Fffu3cPYsWPJsbGxnJKSkqjRyclfUqmUThnzRjAYDOzevXvJ2rVr+3z//feDmEzm+ZTU1PMnTpzgHzt2jP/Z55/L44fE6ZYsWSw1ArCxsUZwcEji119/fVihUJiNHTvWUy6Xy/39/QcfOnzoPIvFalcWNmzYMDolJWVofn7+lS2bt6w6fOTwZhKA3JwcrPj002FisTjldWkp5s6ZC1sbG6uy0tcsDofTrNFopC0tLS9Wrlw5JCcnZ9XOnTs3nD179uSBAweutrS0bL579+51KpX6ZM9vvz0x6A1fT506FYcOHrTgsDnTPLw8eYUFBY00Gm23XKk0mgkEMBqB5tYWREZGDjl27NhlounMm25hph2vra1Fdnb2ntLSUrx48SK+O7AiEoCy8nIcPHBg+Pr16y/zeDz09fNbPnLkyHXevXu/lYvSOe5OKAPctsoMDpvDGGtqYztXIpHM7dOnz7cffvhhrLW1dfmrgoI8qVwOHpfbpWfmv4OMMCVlWtvYYN++fbsvXLiwOTExsZVOp+tIJsn2XjlF4D8QdcbAm/eNQqOZ3b937+aff/45xtba1u+nbdtOMxgMrtFg0BiNRoPRaNT9cyatkQQSiarT6dS/7Nz54auCgozJkyYfjomJidXptK0AiWyEQa83GLWEOvePxt/1mnRPJBJIep1eZwQEYaGhFqGhoVzimv+N1nlHIoRVRETEqF9++QU1tTU4f+5cSt++fRM7yoo2WOsQi+++s5XJZLV8Ph8KhQKtra0wNzeHWq2GhYUFHty/f2XBggXJJlCxrpN3+Xw+eeTIkVHXrl9L5/P57X3WHz16BCaTCRKJBKVSiYKCguMVoopdzk7OcHNzdbqcchlCcyFIRpNnLyAgACw2C0aDKa5+6/atsyaB3jlT/c1vgQGBrOLiYt3Lly8JIY7IyEgoFAq0tLY8f/XqFX3AgAFdrlVQcBD36tWrmjt37uDRo0fk2NhYxciRI03hqg5EHTx48JuHG43w9PRk5ubmlp49e1aq0+nAZrNHOjk7U4iF7Qg0AQBPHj/JkkildGsbGw2RdadSqUzQeGZm2pCQEOfuNpR4Ue/fu3/WysoKVBoNTCYT4iYxHj161A7LJ5PJMH/+fFsAqKmpMdy6deuoWqUCh8MBmUyGRCKBUw9nCGxt23uwR0ZGxpiZmb2Xy+n1ety/fz+T0M6USiWsra3h4eEBvQnkBvb29uNdXFy6HHdm5q1zSqUSjvYOcQMGRph1P0/TFffu3ZN/9913nzo5OcG3tw/8fPsExSXEr4mLixvk4+PDEFpY0N9tP/k2upkRQEef0kcffRRw6dKlGUqlcn9+fv7GHj16QCQS4cihw6BQqejt0xsqlQoKhQIjRozg1dXV6e/cuaOwt7cfvHDhwotGo1E3ctRInrWVdbcxbLVKhUePHp3XarWYNGkSGhoacOH8eUlCQoKEzWajvKIcJBIJVVVVFlu3bm1MTk7GtWvX8qZOnerb2tpaRSKRhD///PNVoVDYwYNh6iN+4MCBszHRMaxraWlbrl699lnfvn7srT/+OC4tLS21X79+WLZs2TeBAYGLBkZFslZ+uYra2NCoXLhwYdbmzZs3ymSytAcPHny3atWq51u3br08a9asuNra2jhHR8cHRUVFaY8fPbo6bfr0+zdv3jQ+z84WA9h29/49AIC5mRkCg4PZVBpNYTAaoZNoMXr06I1vC3O8ZZ0vWrToh5ycnApbW1uLj5ctSzDN4901e/78OXbs2JHQ2Nh4hc1mu6xcuXLPFytXtse23pft3Ble9o1CaGp8M2bMGI8rqVdmnTl75msWi8VitDf3MP5bCHVy2+kklLYRI0bwAPzLAOc93N1Hnz93Dp49PfsuWrjwn89u64YePXw4qL6+PmPSpImThyclAUCXuAD/FfTv4m35r6J+/fpx7O3tEwsLC1Ou37hx8au1axM7C0ZnZ2f07Nlz7IMHD3bKZDJQqVRUVlYiNzcXdDrdVMJmNJ766qu1v3l6dQ25TKjntra20TU1NTQGk6lVKpUgUyjw9/dv9+4CQEVFRfONGzcKZ82c5dXbx2eSvZ39CmcnJ4PBaACLxYbBaJJLZDIZNjY2KCoqulBXX7fFxtrmnecS76W1jTU9KChogkqlOmRmZgYWiwWRSASNRoO62jrag/sP7gwYMOAdxDwAsLezp7148WKswWA4Hh8f35CQkGAYNGgQr76+XtrRA0TdunXrmwebCuYtm5qanKOiou5JpVKEBAeHcNjsdzgFIVRyc/MuVFRUaGpqakChUEChUKDVaiGXy2Fubh5q7+BgBAjVtouErZpqvC57fcHGxgYEeADR9lOr0QIkoLy8nOzj6zMGADIyMup5PG6jT+/ebUKBDrlCgYaGBkgkEpDJZIhEIoqDg0MEsYndUVFRES5fvnyaSqW2o8IFBARAIBAQ5RGkYcOGRRBx+I4LLRKJUFBQcEqtVmNgVORwNrPLRm5vaZnDhw9nOzg4RIhEojt9+/bFkKFx43/44YeRb3//3Vrpjp8R697a2oqnT59KMzMzLygUCnltbS3i4uJQX1+PRYsWQalUWvT19fuWSqPKY2Nj5V5eXmH29vbhZmZm2qioqLj6+vqGfv36sTo2KyCoY5w/IyND8uD+/YlXrlxJ9fDwiO3h7BwhFovh6en5YN26dXfT0tJw6NAhKBQKKYDmmzdvflpbV2tx4viJla2trQBAO3LkyNXIyEhyx/UgXq7g4GDmgPD+X6Vdu/ZNYkKCx/SZMyj19fXNADBlypSrS5YseSvJg8/j89zc3KIHDxocvW//vlOZmZnjfvzxx5TMzMwZT5482W9ra4tx48aFGQyGsI8++mhtbW2ttLdPbwwbNqy6paXljlqtlrI5HDtLC4soc3NzzsKFC+MbGhruh4SEID09/dvBgwYf8O3jy+uc63D27NnU06dPfw4AM2fO/M25DXu+87ppdVps3Lgxsby8/Iq5ufmQixcvnBs0aDAbeLcz3d+1wDri2z958kR/7NjRHVqdDiNHjJxA7wKM6L+TOs7p7RDVf3yUZJBQW1sr1RsMUKvVMplcDi6H8xbm/f/LPZVKJWRyeZPBYEB9Q0M9AOvO9/yPAbwQ83+zDh3f7c4q3P/fiMFgICIiIun58+cpBa8KTrx+/XqXaxvUdMezHx4ePuTRo0c7LS0t21ug6nQ6KJVKCAQCiESippQrqbeXenkOJOFdxYhQemPjYqPOnDmjYzAYYNDp4HA4eJHzAnUdMEzkcjlyc3JPAVgVFR1ltWL5J8LHdbWNPC4PWp0O5ubmcHRyhEajAZPJhEgkKrp582bppImTumlfasJ3CQ4O9nz48CE0Gg1aWlpgZ2cHJpMJGxsbjQGGNIPBEEHu4PkjzgmTxSJFR0f3Jsq6r1275pWSklLOZDKlHRPjqHPnzm3/hcPhoKGhoXHlypXSmuoa1DfUk2Kiou1IHZDFOh5srVaLiopyRWBgIBgMBlgsFry8vEClUqFQKGBubj6Cy+HQiMVEh3sQlJGe8VqpVFYQLnsy2VTo39LSAhJI0Oi0oFKpzKioKC8AyM/PP1xTW2tQazQgkUiQy2Rgczhwd3dv75trb2+vjx0SG9/5uW+eb6LU1NRMnU4ntbW1bXf1icVi1NbWEkh3Rh8fn1EdDwMx9pSUlMdNTU11zj2cMWjQoH8IawsAAoGAdvXq1eshISHWly5dkly6dOk7R0dHv6VLlw4lvtNZcXgbCtak5Dx6/Ojq1q1bf6pvaLhx984drYODA75YuRKjx4zG3dt34OLSA7W1ddTBcbGuSUlJQ6Ojo98aR7/gkGmbt275eODAgRMfPnx4jChH6yjEHj161LJ58+ZfSkpK1lRXVxtjYmIS9+3bd9nOzg4jR42CVqeFWCyWRkVHo3///qTS0pLC9IyMcJFItMVgMMDBwQFMJtPlwP79Z8eNH+9PzO0NvamX37x166o0P7/f9AZ9XerlFEgkrZRt27ZdJIR5V+tqY2uDzz//fKxGo0lJTU1NzMrKOvDXX399/MEHHwQYYcJpNjMzg5mZGa9Xr14A0LPtv7dIr9fvXrlyZV97e3toNJpz367/1oEEfDp+woSPoqOjmTQqFTt/+SXj6NGjw+3t7SHgCxJXr149pvN8yCDBoDdg+tRpY65dvZbq6+s7dOfOnalEX4COHQYJ+jtCojOI0RdffDFPJpeLAwMDvRcuWjik43f+felfNz7CGjGiY3rvf2wFSCQSoUl3uFVX1fd/836d3MUA2t/mru735vtvKz7dhSjfeOv+3ff9HxPhyYmMjByZmZG5oKCwoOnixYt3lyxZMqDj2pEAxA+NH37gwIH2UGJLSwt0Oh169+4NjUYDc3NzlL1+fR3AwPc9093d3ajT6UZJJZKzXB4PTc3NcHJygruHB7RarUmuyOUoKysTA4CdrR0lNDR0al1D/TYOmw0ajY7m5ibcvXcPMJr6DSgUCmSkZ1yYNHHSx10heAKm1spUKtU1IyODRKFQjEwmE/Hx8aBSqWAwGHjw4EGrRqsFs630mZi/AUaQTdC03rdv3yZxOByjUCjM3rp1q5HAaCGIev78+fZfdDodhEJh7/Hjx4tqamrwIvsFc2BU5GRiUJ0ZUmNjo+pVfv4BqUwGoVAIsViM+/fvg8FgQCqV4uOPP1Z3DtoTRNzpwYMHp6urq9Ha2gpdW9ZwaFhYO+SqSqUChUKZ6OZqYow1NTXiqKgosNlskEimWsaCggJUVlYSDWXA4/Lienr11AHvNlrouFCVlZU3g4KCjERzl9bWVjQ0NIBKpUKlUsHCwiIyIDCw3QfeEbazSdx0ncvlwqA3OEZFRbl3vndn17gRQHlZmfzy5cuFIJHoSUlJqKmpaV2/fn3C06dPv/jyyy+/9/LyessqeFuYk1BdVYUpU6fOIJPJBwoLC1FZWYnx48czp02bRgvqF4y62jqw2WxYWFgaJBJp3bNnzxKqqqr6ymSyzcOHD2+3dP0DA+JtrG3w5MmT4z/99NP0Tz75JJHYj4yMjPwzp0//8jw7+5eWlhZERERAo1av/fHHn77mC/jt42EwGOByuDwir0GlUtnzuDxypagSDQ0NcHNzG3z69OmTiYmJ5sD7lZ0+ffowjh09urC4pOSr1atXg0FnOCxduvS9rVAJRrB69eqE+/fvzywrK9t348aN2ePHj3/K5XL/YbkacZ7HjRvn5+bq+mTzli0X2CzW768KCmqePXv2laOT0/d3796ll5eXo6CgoJVEImFYYmLc/AUfXn67bv5Nzu5PP/109djx42e8PD2HpF1NS32rVeNbjP2fc5ET3/rtt99e3Lhx4y8Gg4HExMQfBALB/wKW/r+LOu5pRwX5H+31m8+7UvpM9Caj43+PFU8Iu4EDB9qRKWQvoVBYWFNTcx1Ah3i06Tvevb2NdDp9iEQiuabT6cBgMMBgMFBcXAy9Xg+lUomzZ89eX/v12jVmAjNqd34hFotFihkc43/n9p2zLCYTVCoNMrkM2dkvwOGaclekUikqKioO1NbWbrK1taW6ubvZXbx0Cby2KioajQabtvCc0WiETCbDgwcPbqnUqqVMBpPUGYqaeN/DB4SPj42N/dDd3V1BoVBw48YN1NbWQq1WQyAQHGior//BycmpSzShgQMHjh45ciTd3t5eTafTBffu3evR1NT0oKOMpRIlSIAJBvHs2bOKW7dukahUKpgMhqF3724h2JGfn88IDApqdnJyApPJRHFxMfLz88Fms1FSUsJwdXV9D6CMycJ/+fJlgaenZ3vJAIls6rJGbsv+1Wq1iBkU4wQAra2tuidPnhyVSqXgcrmgUChoaGiAjY0NLC0t0RbzR3Bw8EAej9d9rQgAiUSiPXPmzE21Wt2u6ZmZmcHR0RF6vR4SiQRDYodEm5uZvVMGIZFI9AcPHbxuNBrR06vnaCIj+s3L90bwNze34OzZM7dev359kcFgbFmzZg2mTJmCDRs2oKyiHN9+8w3OnTu3saCg4PGmTZsuRUVFMYGOMXPTveQyOTZu3JiYmZmZajQa0bdv3/gvv/xyqbe3d4SLiwtgABzsHcDn8vDhhx8a8vLy/pBKpftqa2uzP/roo7irV68e2r59+xQAGBI3pJejo4OLQqko27x587AePXpkjx071i8zM1MRExMTEh4eLq+srGT+uHXrGncPj4/8/f3NgDdWZkfF5vnz59i6deu3ly9f/pZEImm5XC4cHBzGfv311ycFAgGI6/4ROTo5sZqam2FyIRuVtbW1sLW1fe81hOa6bdu2PxcuXHj89u3bzw4ePHhnwYIFXcahuss+DQoODjpy5EjQ69evvzx9+vStqqqqb+/du3dLIpEoRSIRkpKSyEFBQSvHjRu3vjPULsFgi4uLdWu+WpPIoNPh4+s79cDBgxdEFRXPhEJhvG+fPj6BgYE8C6EQhCvw71pY7YqA0Yj169d/QKFQEBYW5rd4yZLhXc3p/+i/mkz705lJEAxdbzTAoNdDqVBCJpNBKpVK7eztwefxoNZoTPCfOi1aW1qIHts8BoMBEtl0shgMBshtXol3xfj/fCudWCcLCwu4u7sPr6qq+vHo0aPXP//889VmZmaUjoovn8unjBkzJvLKlSvXzMzMwGazkZOTAzqDDjMzM6jVajQ1Nd3Ly3tJGhAe3uXKEB5QDosTkpWVRXFx7qHXG/QwGAymcKuZoB1ptLKysuX27dvScePGmffx8xsfHBz8pbu7u85g0MOUlEyGoa0UUq1WQ6VSXXj9+jXJu5d3u/LVmby8vIyPHj1S3blzBzQaDX5+fhiVnIzWlhaUl5UrX77Mozg5Ob3jjQEAb29vzePHjxnNzc1qlUql6t+/f/WoUaPeSoxrT4ozGo2wtrZmGwyGKgqFIpVIJGAymRNtbG2ZHRe+48+3bt26cOLECR2Px4NMJsP48ePxxRdfoKG+Ho1iMQKDgtot17cX1TRIUaVIk52dfVyr1YLFYkGj0cDZ2RlN4iYolApQKBQUFhbShyYMjQOAp0+fGXr27Fnh6OgIEsnUXvPmzZtIT08HnU4nFpYUExPjTDynO3pV8IpGo9HuWFhYgNaGAmUwGKBQKEAmk1FfX0+1d7CPJg7BW9e+ekVWKpU35XI5QsNCBxPfeSPoSNCoNfjjzz+u7d+/f0tjY+PVpqYmeHt7IzExMWbwoEFRLc3N0Gl18OntU1RSXHL44cOHN+bNmzfkxo0btx0dHds9gARDT0hI+OD2ndupdDodgwcPXr53796tNjbvJmB0aO34SXVV1SdTp01LFIlEqXv/+muqo6Oj8LPPPkuwsrTCmLFj969atSpKKpVi8eLF0x0dHe+kpqbuGDhwoDw6OhqlpaVLxowdu+rNnr35P3ES/vjjj5vffvvtxzKZLCc4OBhNTU3mycnJBz78cMHwN8L8zZnprib/1193ZaxY8cm2KVOmYN68edi5c2fDuLFj596+c+f3v9Mb2svLi8zlcueIRKIdpaWlGUajMaJjmOh9ZGj7EplMhru7O/2zzz6L7Rfab3BMdIwFgGZfX9/BCxYsODxgwIC3FvtNoqKJVq9evUmpVOqdHZ2Ql5s39+zZsxoAYDKZX8fGxvKMRmP4Rx8tWB4XHx9HpVDbGcs/wikAgMrKSqxdu3ZXZWVlFgAsWrRor7WV1f9wVv4/nzrvVXNzC3Q6rVosFmuOHj0qdnJ0POTk5Ky5nHJZWlRUpKqurr4qqqwstbW1waBBgyGXyyGVSREREcEdMmQIaVhCIurr63v06dNniJeXl6B///7w8fHBkydPepibm4/x9vZGjx49wOFyeRwOG1QK9R1r/X9aQl3HGHlAQEBCRkbGjyqV6k5OTo5+4MCB7TWdxHdsbGyi6+rqqFwuV9fS0gJPT09UikSor6sHjUZDU1MT6Vpa2vkB4eGj35e5MSh2UMK+/fv0LK4JRIxOo6GouAh6vR5cHg9GgwHVNTW6goKCQwAWRwwc6Hzh4gWoNWrQGaZy01aJBKo2nAQSiYSSkhLS7Vu3c7x7effpTvrY2dox3dzcksVi8WkzMzPU1dZh208/AUYj1BqNNiAg4ER8/NApXY3Z0tKSFRISMk2pVP5iMBiaBw0aRB00aJCgvr6+lQhFUXft2mVaWBIJKpXKkkqlurq4uGQWFBSgj5+fF+HP7+z+bUNrehQXF2fkcDhQKBTITM/Ak0ePIZFKYWlhYb548WIdAEp3gjU7O1vl5uamcXV1bY+NNTU1QaPRgM3hQKvRoIdLD01kVFQ4AFy/eeP08ePHjWw2G0ajEWq1GjExMfjqq68gkUgAmBLohgwZMoE4BJ2JOP7Xrl27XFdXR6bT6QaZTAYajQZHR8d2aEEPDw99XFxcTMe5Ey/PlbQrl5qbm2FhYYFhw4YlAW86rwFAdXU11qxZM/7AgQMnLS0t4ejoaBYWFrZi3NhxC4YmDBWSyOS20hwDIgYMgJeX17RFixYNLSoqurNy5cpFBw8e3NmRWfzwww/Pbt+5vdfHxwfW1tYRR44e2WomMGtXIroiMkztLg8dOpQSEBAQVF9f//Tzzz8fNmzYMLWPjw9t2fLlkefOnRv56NGj8+bm5tmLFi2yr62tVSQnJ1NtbW1Zf/755w9JSUnNhw4d2kMIZ2L9SCDh0uVLz+fNmzdYIBAgIiICBoMheefOnX+GhYWZA4C+Xbl5O3xArCExuzt37qTu3LkjUalUwtXVlcflco3R0dGyjIyMPyZOnBh47NixBQRWfcf7oP13070SEhKmP3v2bMfFCxeur1y5cpVQKCT/LSu4rXCZUDzIICE6Kpo0evTouefOnfth2PBhYwhh3plZEnMpKy/D8ePHf7CxsYGFhQUmT5msycvPx769e0Ehk2FhaSF9mfcy7dKly2mHDh/54+D+A7MpVMpbChtBBoMBcrkcNTU10tQrqTWtLa1HLS0t7+Xm5l4dOHAg+Hz+1LFjxwYSa2hs//dtl/7/0f8Dkd7+hfi1Y2VPR0tco9WitaXFePHixXq5XP7nrczMRg6Hs6uhsVH16NEjTJo0CSs+/RQkEgmjR4/GB7NnU62trHgzZsyw+WXnTjczgZmgpbWl+PTJU8/6+PqipqYGXC43V61W52rarPfm5masWLECVCp1yS+//oo9u3fjZnr65A3ffWdXW1vr4O7uPiEsLIzGZLGY5mZmb52nrvjDv1vsvaMFOmz48NiTJ07gZX4+rqSlnR04cOCEd8rX4uIiUlJSSBQKBVwuF01NTWhpaYGVtTWMBiOcnZ2N5eXlWQBGdz1XE8fo1auXtqmpqV9JSckjLpcLtUoNgZkA48aPA5PFglajhUIuh0whbwQAN1dXUk11zTiZTHZUIBC0lzW/evUKWq0WFAoFCqVCV1RUdAJAn7f7a7whOoOB8ePH929paTnN5XLR0tKCF9nZMBqMMMBo1Bv0hQajyfPY2V1Pp9PRp08fq8ePH8PKygq3b9/ulZmZ+ZrJZLYSndeoS5YsAWBKiBOLxQ3Lli2T5+TkQK1Ww9/fn9UdKIJao0F2draSRqOBRqPB0tISwSEhUCjkUCiVEJoLZ/B4vC6BzYlDd/vW7f2PHj1SP3r0yLRhJBKsra2hUqlAIpEgkUhgaWk5wMfHRwuAJm1tLe7Xr5+RyErXaDQoKipCXV1de3kbl8u18/Hx6aLMDu2HAjCitqb2sZubm6Fjb1y5XN6e4chgMEa5ubm95TkhfigpLrkrFAohEAgSvb29jQBIxJwOHz784Ntvv13k7Oyc1bdvX054ePhXkydNWhLWv38XcREKQAUWLlwYT6PRrsyfP3/o0aNHf5kyZcrOqKgoPHr0SHr37t2UtWvXfg2YQiKDBw8eayYw63JPOhLh1rW3t8eqVav2rF+/Pripqcl46dKloz4+PtOZDAb27dt3LigoiK3T6ZQSiURaVVUFEom0LiYmZtmuXbu8L1269PvgwYObHjx4cIpomkACIJPJNEnDk+YCAI1GE0yaNOnI0Pj4RKGFRfuzyW0r/b5432+//Za5YcOGxJaWFowcOXJFZOTAr6hUmlEsFk/IyMi4cvz48Y/kcnn9H3/8sZbwRrz7erbFpsLDg9tgRTNbW1vlQqHwP1QqZWNt7ezm4oqw0LBajVb7DpY34Y1RqlRIGJowxsbGRmJtYwO5Qm5NoVDmjx8/jubs5ORkZWXVIhaLxdeuXvuVQqE05efnz/njzz/tp02bmkB0KpMrFCgsKJA+efLkBYvFun748OGnoaGh6Zs2bZI6ODhgwYIFYLFYaG5uhsFgyF++fPnm0aNHL46IiGASXZ46I+z9H/3z1LZ+XVT0vPmTVqdDzosXiqdPnz68c+fOLYFA8NujR49qxI1i6HRaREZGobCw0GPZsmVjJ0+ebBMcHOze2tqaZG9vr7SxtW3Jz89Hv379Ts+cObO5uLiI+uJFjib/5ctnpaWv8fHHyzBocAyoFCrYbDa4XC6kUimWL18OBoMhNTMzA18ggI2t7W/nzp3D6dOnMW/O3OUnjh1jGozG2WMnjOPV19bPGj16tIWFpSWdTqO9dSK6a1P830kdx+fm5gqBmdloRwfHM08ePX5iNBondPa0OfdwNqpUqtEajea4qq102cPTE2VlZe0e1rS0tDSxWLzOwsLinbArwcP4PD5tyeLFwxoaGx+x2ez20rf9+/ZBLG4Cg06HSqMGl8s9t2b1mi85bDY9LCysd1ZWFgBTvhmLxcLEiRPftPA19VVnEwiSXa0xzdT4TLxjx452pDv/AH8wGUy0tLQg+/nzWrVKBRaL1a6sE+Mmk8nQaDT2aWlpoNPpcHFxefrTTz/pLCwsIJfLAQDUnJwc0wVGI+h0utWixYsbSoqLcfXqVWZIv37TgK61/uamJsWjR4/2N7fFPWk0Gj77/HNYWFigtbUFPB6fTekmIQ4wWSIMBqMpNja2HS2KSqWid+/eYDAY7Qlx5ubmw5l0Bs1oNBjT09Oz5G290nU6HXh8PgICAtoBKBQKBaytrKcJu9jIjiSRynRpaWl35HI5+Hw+tFotHBwcYG1tDY1GAzKZjLi4uEBWF+V64iax4fKly2k8Pg/Dhw8P5XK5ZLQdkiNHjmROnTo1GgCCg4NHHzx48KiNjU17Up2+XRt911qdNWtW/JHDRxKfZD1JWbNmzQRPT08yk8m8vHfvXqmDgwPEYjEyMzPh4+MjJe73dzKkSSBh9pw5Qbt37w60tLR8Wlpa+kLT1kfa29sb27dvvzB37twhvXv3hpWVFSMoOHi6t7c3Lzk5+Ze8vLxRWVlZp79Zt+7CN99+O4IY76NHj5SBgYFPJk+ejKCgoJXR0dGJHZ/bkQEajIa2zNE2kByjEUaDAddv3Cj48MMPhwHAyJEj1507d64dlNvBwSH17NmzY1paWs7cv3//65kzZ2YdPHjwgqWlZZc94AESOByOqqSkhJyYmGiQSCTGv7M+XRHRftbLyyvhyeMnkMllWjK5c6KSae/UajWiIiMnvHr16szUqVNhZma2fuqUKct69/Zh8/g8JAxNAGB6+aOioj4ZP378MAqFcu/p06xEgYC/ytnJmV5UXIRTp07l9+nTJ+Xy5ctSDw8PUCgU3Lp1CyqVCk5OTrzbt28jMzNT7ubmZhg+fHjWpUuXss6dO7d97dq1+2bMmDH474Ql/o/+MRlgspKAt2Piao0GRYWFyrt3796+ePFiektz8xa5QqFzdXVFZWUV3Fzd+IEBgR9HRAwYEh0TE2FnZ4fa2lqUl5eDxWK9rKur2378+PG9QqGw5OCBg9KRI0fiwf0HSLuaBmtra4SGhXHDwsJIvr4+kMvksLKyAo1KIxKCMX/+fNTU1ODZs2egMxiwt7fH5cuXdQCUKrVaGhQcLD137vzGD2Z+AD8/vy+zs7O51dXVy2JiYvolJSVFWVlZ8czNzTtZ7+9zSP/XEsGn2Cw24uPi/Hft2nWmob7+XHNz8w9CofCtl4/BYJCGDx/ud/ny5eMWFhbgcrkoLS0Fl8tFG7IpGhsbs/Ly8siRkZHdPA+gUChgsljCY8eOwd7eHmQyGXK5HBYWlvDz6wuNRg290QBJS2tOTk4OPSw0FBQKxTYzM5NEoVCMRG+CFy9etNejt5XPnV+1atUKMzOzd7r5EIaOg4PDOJVKtdXe3l4DAE+znrZjxAsEgkONjY0/Ojk5cd4es2mN+vXrN3no0KHLgoKD5UJzc3pZWVmPwsLCl+0udyLLnQRAr9d7ACSqWq0qZTKZOi9Pz247rIlEIsbkyZMVVlZWsLSywplTp7Bm9WrYWFujrqEBq1aupNHe0z9drVHj5cuXzSQSCTweDzQaDa2trTh06BD0en171vny5ct1AFBcWqp183A7TwIJ9La+5bczbyHryRNwuFwYDAYoFUosXLSQ+T58bQAoLCyk8nn8G9ZWVqDTGSCRAKVKhYqKCpDJZBQXFdGTk5MHdXXknz97riaR8Fwhk4PFYIZ2/Ozw4cOX/Pz8UFNTg/Ly8l5CofAtGL/3ZTrTaDRERUUOu3P3TopEIjkhFovh5OQENzc3ODs7Y/DgwSguLoaXl5d5d3vSHXHYbHzwwQcTtm3b9nTPnj0XNmzY8L2lpSUNAObMmRP7559/zqitrd2/cuVKRkhwsAsALFiwYOTJkyd7i0Sil9+uXz9m3Pjx0j59+jAB08uQPGoU22AwKB49etQaHBzc5oJSGcrLy+TZz7MN+fkvz8nl8rLxEyaAzWajqqoKTU1NaG1pRWFRYdnLly/3eXl5YcmSJYLZs2d/BbS5vY1GODk54f69e6e/+ebbv2rrameXl5dfnDJlSsyQ2CFrV3y6Irpj4xUCyMTM3JzZs2fP4Fu3bj8aOHAg6Q185D9HBPdoaWkpbWhoQF1tnY7A4u7sHp86derPjx8/PiEUmpPj4uIuTZs2LYH4jHC3kWCqxIiOjjbbuXPnsQkTJjifP38eIf1Cvjt67ChgBHg8PqpratCzZ09UV1dburq6zk4elcyKjY2N8/Pz86VQKBg0aFBDfX39QQsLi7v9+/e/lp2dXXnz5s3YvLy88z/88MOIzmfr/+ifJoPRaISVlZUZAEhlUhS8KpBlZGSk37179051dfVWrVarLygoQHBwMCZMmNCXSqUm+/n5jY+MHOjNbMOhuHv3Li5fvvxrbm7uNYVCcS4zMxNt3QEhlUjB5XCGTpgwPqiuvoHm69fHxrtXr5G2trZcAmiEy+WCyWSCSqOaWnoajNDpdXBwcICZmRlaJa1oEjdhxIgRqtelpSkuLi5ljk5OSLt6VctgMA4kJSWJ1q1bJ3N0dPy2qKgIjx8/hpOjY6Jaown28fGZOXHSJFcel4uOaGr/ncpgZ1wKEkhRbflcxQ8ePJAlJia2e9oIgchgMOJf5uev84ZRU1NbAydnZ5SXl6O2thY0Gg0NDQ2k9PT085GRkV3CwBLvpZub2zRHR8fPnJyclETmukGvR2trK6g0GugkEqpkVbQnjx9nhYWGBkVHR095+vTpYldXVxVgspibmpqg1WpBJpOhVqthMBgeVlVWaboS6AT5+fkFfPPNN0wnJycNUSotFotBpVJRX1+P8opyjpOTE7p6m728vEgUMllx7+5dSCVSPp1Os+DxeO2AONSvv/4aAODp6YnFixZn7d23Vw0AZJB6OPdwfgsMpCM9z37+et++fUZ3d3fTZhiM8PbsCQOMaBY3M2ysbaZ2dy0AtLa2KrNfZB9oEje1t0j18PDA4MGD263k4qIiuoeHx1QAePb0mVyr1rK8evVUGgwG0Gg0hPUPg6e7B0AyLW5RURHd29t7DLH5nak9mS8z815paSm9p5eXRqqSgEajgcagt4PL2NrZacL6h4V3de21q9dOSCQSeHl4Ij5haFutu+kwrl69evXz589fnTp16tLNmze/S05Ofv7NN98sYbFY8d7e3h1icm/cXh2Fulwml+v1ejQ2NkIoFKKyqgoUCqWXlZVVpEKh2CMSiXDhwoWUBR8tWEin/f3WinqDAbGxsRqDwYCXL1+Wkcjktw7bwYMH9+3evfvg69evpSqlUg6AY2dnhzGjx6zd8N2GCQB0X3zxxdbLly9/CQCRUVGC6dOmmVWIRAoAP0gkEr1er2c3NjYeCAgMrNq6ebO69PVrAMDwpCQ8e/YMcpkMQksLSKQSlJWVoaSkBIkJifDw8FAdPnz4anx8fJyjoyPQhkvO4XKx6YdNHxw+fNjB1ELWJWPf/n0ZRcVF33z44YdriI5qxC5TqRTweLxeMpnskUaj+dtr83Yp2xuBrtZo0ptbW/DTtm1/cDicPmwWaxSHwwWVRoVWq0VhUdHp7Ozsj9lsNoKCQ74mhHlXYBbEU8aPH++0b9++CSKR6PjTrKe4eOECBg6M5PUfEO5dVVWZGDEgYlhwSIgPl8tlEdCvBCUkJPAArH39+jXS09OvXrt6bYZEIqkVN4pH2tjYpHzyyScJQBf+4v+jv0ck0Oh0Oh48eFDj6elZ/P133529e+/er/b29tBqtdBoNPD09IwZOXLk4MDAwEVJSUntiSV37941Pn/2bOujx4+vXLly5Yavry/c3NwglUoxduzYifZ2dn05XO6cmJgYhtDCgmc0GsHn/YfB83gAZgCAVCbDuYEDoVarv64UiZQUCqXO2tr6cEZGhlylUu18mZ+fkpKSkhIfH//Ns2fPnKytracPHDhwbt++fXtYW1u3K6p6GPDfFbQh+ODwkUmRJ06dxNVrVxEXH3c0MTFxXuf8kP7h4UGuLi4ag94AHoeLhsYGyKVSeHl5QavVwtra2tja2vrCYDAkk7uAZybuFxAYyCp7XaYvLCwEva2HgFQiBZNON6GUGo1QqJSa16WlZwAE9fHzIz1//hz37t4Dk8WEXC7HgAEDMGTIELS2toJMJqOgoIBbWFRI8fH16Xau9vb2kry8PGleXh74fD7Ky8vx+vVrsFgslJSU6Hr16vUsYkBEl90znZycaFevXPXXGnTP+Dx+5QezP6hfunQpqVIkMgIANTcvFzACNTU1Zja2NqyhQ4e2Ojk6gcPhTOfxeO9IDWLzK8rKD7W2tqqLioogk8kwY8YMTJgwAY0NDaiurmb6+Pa262oyHWrAjR/M+kAhFApBIpHAYDLw+NFjvH79GnQ6HVqtFnyBQBsSEuIIAA/v3z+YmpqqTE1Nbb+Xu5s7/AP8IZPLoFVqYS4UaoODg7utsyPB5Oo36A0pwSHBGnMzM3A4XOTm5uDhnUfgcDiQyWQwNzfv39OrpwYAveO1RqMRdXV1pY6OTtDp9UM8PD10AKiEWO7fv7/Aw8PjYkV5xdEHDx7MamlpSfnrr79Smpqa+js7O08eOXLk/P79+9O6s6YkUoksPDwcEomEq1arhw2OGRT8zbp1n/j5+ZFOnjw589SpU+EikShl7597c+Z/OL/P34+FGUGhUAxCcyHq6upI+/7ae3np0qXDVGoVqFSqSiQStSoUCvquXbtUeXl5P964cWMNACxdtnT8jz/9+LlSqSy7cf36t6dPnw5wcXEZWFRUVF0hEsn4fD5mzZqlb2ho+KG0tBT+/v74Zt06CIVCrPhkBdOrV0+as7Mz47fdu41nz50Tz5o1CxQyBb6+vkhJSYFWq0FLa6v6008/jd+6dWvs+m+//Wb0mDH9CRcyGSRMmTIlXmhhUXzzxo2pz58/T3n+/PlXS5cuTZ03b97XQ4YMiSNi6xQKBTK5rITD5oCo//77wC2dEsuMRpibm1kMS0zEy/z85gsXLkzPevyE4+jgYGBxOHqFUkGn0WgyPp8PmVSGDevXrwD+saWj1ekwaNCgQLG48Xh9fQNr1gcf/DkoZtD4yOhICpnUdUPCjnFPEgBXV1e4urrGOTo65sfHx/sDKF+xYsWwyMjI5pCQEMH/Wej/PBlM1hnPzs4Oe/bscc3OzsaDBw8wfvx4ODg4zPT09OxvaWk5c/Dgwe38IC0tTZ2Tk7Ot4FXBzbt3715tbm6ChbkQQqGQ5Obm9snMmTMjtVptdGBQEK874f2+pNa/S2SQwGtD2OSw2VShuTnPz8+PB2DtiJEjodVo1l++nKIYM2bMH8XFxbeznjy5IBKJNly5cmUDgLDJkydPDAoKmhceHs6itJUK/3da7E5OTgalUjkqZtCgc0qVqlKn14NKobylbLu7u+saGxpiZVLZdb5AABIJcHFxaTfItFotHj9+nKdSq8FmvYvgSSgPDg4OdO/e3hObmpoOEI29mEwmevfuDRqN1l7brtFqWQDg5OjIDA4OnqxUKv/i8XhgMBioqanBqlWrOt5e5unpeTw5OXlGd/zH0tKSdfr0aT+tVpsNmIxRc3NzGAwGaLVaTVlZ2QkAAV15iNlsNu2Tz1ZMMBoMz4QWFnoej+eUlpbWrNVqG0gkEqinT50myr3MLCws3B0dHWuqa2vQLyRYQ6N27TXQ6rQQmJmxPvnkE7DZbKjVapSWlOLA/gPQaDUgAdJhScMVAPidryU2prio2HDh/Hmqh4enmkwhA0bg1u1bqK+rA41Oh0KhgJmZWZCnp6cRAPQGgzRi4EBQSKYMcb1eh8dPnqDkdElbS0QjeFxukKurqw5At+4OrVaLx08ea7hcLqg0GuQKOULDQhE/dOib/ueWlgl8gaCDMDcdpZbWFm3qldTrbDYbQxMTBvJ5/A6xetMxsbKywvcbv580cuSIwdt37Jj/yy+/nBs2bNj9Fy9e3L9w4cIP8XFxn0+fMWNhx57dAJD/8iUup6TsSEhIQFJS0qvIyEgHc/M33vVp06b1v3LlyqdHjhzZ/M2338xOHp38yNraGqS/ET+lUCi4d++e4N69e7hx44ZG0ioZfufunU+ePHmiYLNYpwYNGiS7eu2aytraGhnp6d9kZGZ+EB0V5WBlaYUvv/zy8M8//zzIzs5OfeXKlWEAyOfOnTPExsbizp076N27N6+srIz/Mi9vVlJSEtXS0rK3o5PTUB/v3nD39GCrVSpKeXn5x3Z2dj8XFBTA3t4+LDg4aOh3G77j9fX30+blvVSYmZntaGpquv7rrl3Xs7Ozf507d94CRyfHdqGeMHSouU/v3pcPHTr0U0ZGxnIOh3P/4MGD8T/++OPQ7zZ8983g2MEhrwoKkPMi5+70adNA4LF3pI4JY8R6ve1Cf/Oz3mDAnj2/X6qpqcHo0aNBIZNR39ggr29sAADQaDRNYGAg6uvrYW1jnewf4N817u9bJ4NEhLU0N2+ko76hXvfZZ58FRsdEUyRSCS5dvJSRk5ubKSovx5AhQyh9+vgtCAwKtOiYLUvY+iQAcXFxZrt37Trx4YIFoQCMx44d+zMkJGQ5wZT/j/45MhqNoFEo0Ov0JDaHveyrr76KGTVqVGyPHj3ak1nv37+vfvLkyS9ZWVmXb9++fVOpVMLJyQlCoTnZ1cXlk8RhiTGRUVFRzj16sAX8t1mfoYPi+K+kzpgGHXEizM3MAIA+a9ZMOoAVrRLJiqdPs6RlpWUnMjLSDz96/Dh92bJlDywsLD5euHDh6jFjxizv06ePOVH3/q9QOP5Z4nA45IkTJwbs2rXrXGZ6xuUFCxasFgqFdMIxTwIJfB6POmjw4KgnT55cp5DJYLHZyM/PR0tLK5gsJlQqFeh0+pnqqiqNh4dHt65MGpWKSZMm9Wxubm5vwyqXy/HTjz+iUSwGjUqFVqcDm8U+tnHjxs84HA7dz8/P5cmTJ1Cr1e3Z7WPHjgWTyYRer4dOp4ONtXVuWxVYl6vHYrNpU6dOHdfa2ppN9He3sbEBhUKBUqkEl8u10Gq17eXUHYlKpcLS0rLp9p07EDc2Qi6X2/L5fCWVSjUld69duxZ8Ph81NTW1EREREuJC7169HLsbkEajxamTJ/MaxeL29nW5L3LaGSWNSvPZvnNnl53OCLb57OnTY1lPn8qznj4FADBpdEycMhkcouesSgWhUDiGyWTSAOBFdnahVq0Gk8+HTqsDh8PBF198ARqdBp1WB41GA6PROJbFZncrzAGgpbVV/fzps4NisRh8Ph9qtRp0Bh3CNlzgyspKfPbZZ+ZvOp29sdwqRZU0V1fXew8ePACLxepp+vxtS5B4bcP697cODAo66+Hhce3169db9AbDVW8WS3Tv/v1Fjx4/3jlixIjvJkycmGxjbY3ysjLDpEmTEqurq5vr6uoGjxw50oEY75uCGWD58uXrjxw5soVEIj3eu3dv4uzZs1O6ShTrTCqVGt9///3ZiooK9O7dmyGqFKmdejhtDQgIgETSisGxsbCytsbFCxfBYDB0v+78ZXfEgAHfUqlUzJ49O3zAgHBWbm6e+vLlyyguLjZYWFj0jIuLmzQiKcnXw9Mzbvz48YyVK1fSORxT9yCC9HodRiQlzS4oKPhr3vz54HC5v06eNGmBp6cnCHSjiIiBGDxo0Kr0jIyfnz59+vk333770ZW0tNTLly9fsLS0bGdYzs7OWLVq1TIHe/vIFzk5q54+fXpVpVJdWfPV6isyhfyznBcvWng8HqZMncp2d3dnEHvXUWirNWow6Iy3/iZuEuNp1lNpXl7eK61GWyoQCKJFVZVXSkpK0gFAoVDETZ06NcLW3o7J43DN6QyGMD09/WZpaemvM2fONFpZW0W/rz0mQQaYKinmzJnzcc6LnBePHj86+fPPP/faunVr/9DQUFlNdXVOVFQUbO3s8KqgAJm3bm0eO3bs8cTExKEdxQDhDSIDmP/hh/0OHT48uqmp6Ux5eXmVVqcH7R+0Kv4/epdIJBJ0Ol1rUXExvvvu+9JFixe5EJ/dvnNH+fzZsz/z8/NT79+/n1JTUwNLS0tYWlpSXVxcPo2LixvUv3//cA8PDzb9rcZKQEevz39mZnnH+xI/d9VoScDnIyY6hodozB4/Yfzs9JvpTUeOHN75JCvr+8zMzPV1dXXrHR0dlw8ePPjL/v37C4nkz/8qi71dYSWRQjVqDfr06fO0pKSEToCftdesk0gwNzO3y8rKIjHpDKNao4GZQICkEUntGeevX7+m5+TmKDsL9I7ueyqVCrlCzt64cSPs7e1BIpEglUphaWWF8AEDoFQqoTcYIJfJ818VFJCCAgNhBKzS09Pf3I9EwtatW2EmEEChVEKlUkGv11t1hHDtTBQKBREREfq2qizI5XL88ccfaGkDF7K0tLy7YsWKFZ0FOpHpLm4U+58/dw5sFgtOzs6PNm/e3J7pTq2vr0drayukUikvOTm5RaPRoL6unhMSEjLFdJN3N7NJLJaLKkQnWqUStDa3gEqlIjk5GSw2G60tLRCYCcazWexuYFdNbm+nHs5Fk6dMBo1Gg7mZOdLT03H06FEwmEzAaIRWq8W8ufNaAEBUKZK/yM45JlfKwWIw23snc3k88Pl8aDQatLa2YvDgwU20bqFmTRtZWFjIiBkU02RrawsKhQq9Xo8XOS+gUCgIjYjl6uY6DXjT8pWg27dvZ8tkMowfNw5Dhw5N7rw+HYU6ANDpdHzzzTdDRCLRkCNHjlzIyclZ7+Dg8BjAq4cPH45ubm4enJWVNZBKpR7m8nhFc+fOjU9OTk7peI+ONbBBQUH0M2fOpBw4cCDh9OnTqWVlZbHRUVHbJkyc6NsxUawzmtuff/zxrKKiIpNEJrM/+uijfC6XW2lnZ3etUSwGmUyCra0tysrKNCDjF5VS1XrxwoXttXV1Xzo6ODClUimysp7qioqK4ODgMHh0cvL60WPGhPEFAnS11oRCI1fIERYaNiI3N/ciAERERKSOHj26HbOeGCefz0dgUBAjMCjos5MnTgxrbm5eyGazL27atClxyZIlKU5OTjB0EGIzZs4Mqq2tTfvtt99OnDl95uOS4pKakydP/lBTXQ1vb288ffqUamtrS/f09Gyff319PY4fO3ZzxMiRt+89uI/ysrJES6FFL3Nz88OpV66cEYlE1zLSM6DRaiDgCxg+vj5qNpsNFos1cPPmzWlubm5ITk5un+OMGTNGnz59ei+TxVJYCIXNxr/J7wwALCwsuIcOHzrRKmn9UKFQ/CaVSu9bWlqCTqcjNCyMl5eXp3/y5Ini/v37kvPnz4968PChytPD462T+CZMAOz6bXf0urVfn7lw7vw1lUoJGrfbPNb/o26ojSfpyRQKbO1sXUpKSgyvXr06d+vWrbNFxcWHXmRnoy15lxQQEPDJ8GHDYqOioyN79uzJ6sh0uxJ8/y7lYR3HRgYJHA4Hw5OGC4cnDf/q8ePHX1w4f/7Aq4KCzSUlJT+WlZX9ePjw4bUjR478bMiQIezuaqr/1UQYT5GRkfH79u1Dg7gRt2/fehASEhJG6vydqMjJj588XuTi4qKi0+hQqVU4ceJEe/kWAOWd23cOJI9KXtwRda0zNn6PHj1mhIeHf+nu7q7Q6/Xtrvam5mZwqabERLFYTH3+7FltUGCgU3h4+LQxY8Z86uXlJSOTyVCpVDh+9BjUajWoVCokEgns7OxEHy1a1O08aVQqiouLldu3b2/PzJfL5GCzWFBp1FAplBfqG+plXC63U6tl09xDw0LHJo8aNa9faKjMwsKCJhaLbZubm8uMRiOoX331FVQqFezt7f19fHxKrK2tS2lUmt7T07Pb0q8KUQVjwuRJNGsrKzWJRIJerweLxWqHwOPzeCQypeuYIGBye7PZbO7QoUNBpzNgZW0FrU6L+vp68Pl8kEgklJeX01xcXZIA4NWrAs7gIYOp9g4OGhIALpeLnJwcpKWlgcVigUwmo7q6mtq/f9iw7rwKBN25fTv9tz17DLa2tu1sUaFQEPEL0Ol0TWBgEItYwo6M9NWrV2dyc3OhVCod3geJSxDhMnZycsLnn38+Ijc3d8Tly5dPl5aWbrxx88aTysrKG2ZmZjcsLCwwc+bM2/Hx8RFmZgRgDAC8rSyQQEJycvJQiUSS+uGHHya9fv36hkgk6lPf0LClf//+ywMCAkiEy5UE0748f/5cufartbMBIDAwcPzChQudATgbjMZwlVoFCpkCKoWCwMBApKenK4sKi34yGA1sJoNBAoB7d+89WLFihZzP5/uVlpRct7C07DCmd19yMkjQGwwYEjtkem5u7kXnHj3wyfLlKYQw71xyZuxw3bjx432iYmIy9u/bl5CWlpb6/fffJ27evCWFw2G3C3USAFtbW6xdu3Z8fFzc8J+3b99y7Nixn9hsdkvfvn3x8ccfS37dtWvkgf3799rZ2dFOnTz5jEQmb9i9a9fV23fuIOtJFkpfl34NAIsWLiTKXECmkMEkM2Fja6MGAAGfL/zrr70X3jRXIbJwATKZpFq1apXar48flq9Yzv87FrppjibKzMzMlslkxSKRCP7+/qRhw4atgRELPXt6saysrLQvX76cBiClqalJffnCxRcfL1/mR+pwBgjSGwywtrCSm5uZg8ag23Qur/s/+vtEp9P5LBYLS5cujbezs3scGhraLBKJwOfzERcX96GDvf3wpBEjYnr16tXJEv/3ENj/DHUW7iEhIfSQkJA5L/Py5ly6fPnMpUuXPsrKylr39OnTLdnZ2admzJgx1MrKqt1a/8+uY/f29tYWFxd7Ozg45JubCy8bjIYwMon81rh79+5Nzs7OJt+9excEsJmFhQXCw8NNlrWpLlxCuL672yf/vv4sJpOpqK2tBZ1OB4/Hw6NHjyASicDj8WA0GtHc3KypqKjYD2B1b29vskajUeTn57cL44ePH711z8LiomOtEskWNov1jolOyBxLC8vhcrl8s0Ag0CsUCiQkJiA8PBytra2ora3lVFRUcIj+JZ3JxcVVrVAq1Xfu3AGHw7ESiURudXV1ZQwGA9S4uDhYW1vj+PHjRVu2bGllsVhwcnRiTJo0sdsFz83JrTp6+LDW3d0dDAYT9fX1qKyqNDFzGDDngzmSzkAcHclgMOLa1Wv0xoZGcLgcqFVqODk7Yd78+dC2ZShXV1cz/P39BwDAo4cPb5w4cUJtZWHZjqQVnzAUn3/xOSStEhiNRtTW1DJCQ8MiTYvWVYa76blcDufKyJEjdTweD0wmE+Xl5RCJRGCxWJBKpbCwsBjvYG//VkMWEkjQaDUQiUS6xMRE2NnZzeTyeO917bfPtUO81tfXF76+vmPKy8vH5OTkfHL//v0fIyIiUFtby1Kr1X3MTDGv9id3dS8ySJgxY8ZQe3v7vLlz5y4xMzNLu3r16oqDBw/+Om/evOkcDmeo0WjsTQIpv1HcmPrbb7/9bmVtVWVrZ4slixbPIe5MJpHQseWrTC5HcXHRGQAYPjzpY0tLS4ZKpcLu33YvEpgJjB9/vGwPIcy709YJYbNzx47U+/fvHwSAL1etSpk3b163jVY6usBIAKytrDB9+vTUixcvxu3atSuVTCJv3vnLzk/fVAWgfT3D+vdnh/Xv/9X06dOXHjhwYEd+fv5Ob2/vuurq6gunT592mjFjBuWPP/+U2tnZgUql4uTJk32dHZ2YDnb2r6xtbQY5OTv7+Pr6esTHx4+urKycffLUqZNPHj8me3l5jdq2bdv2kJAQs47PJMQplUZnspmsuGdPn6bu+nVXTtLwpPeegY5C+NTpU8/nz5sfQKFQ0KtXr0Hjx43fFhcX14f43NXFBaNHj75cXl7OpdPpcolEctxoNPqZlIa3GSmFTMb3G79XVFVXYdLEif27aoX7f/SPyWgwgkqlMhwcHJCVlXW1b9++IJFI40aMGJHg4eExdmBkJI8IwQH/efHw/w4ijAcygN4+Pujt4zM6LCws+e7du9/V19evXr16dcLx48djd+7ceTQ0NNTyvwLzQCAQ0FZ9uWqyqEK05sqVK6pJkye/4762sbFh+Pr6Tmlubv6dw+GY6sqZzHY8E6VSiRcvXuQrVSpw2gCculJEHBwcKLdv3eovlcnuE7lYZmZm+Oyzz8DhcKBSqaBWq2FmZkYBgB49elCvXbvmp1KpnhP3CA4OQUhIMCQSCXR6PXQ6raS1pVllZ2PThUA3cRFPL8/wESNGsHv06CFty27H3r/+AoPBRElJsTogIOBldFS0T1fnzM7Olp6WlmYJoAZAbWBgYMvcuXNRX18P6pw5c2BtbU0TCoUiW1tb/ePHj8HmsKfyBWbvJPoQjKm+ru6QVCpVV4mqoNPrIJVKTb3UYYRUJoVQKPTHO8N4Qzq9Di/zXt6qqa6GQCAAmUxGTk4O5HKZCXpVrQaLxVJ+++23MgBcc6Hwythx4/Q8Lhd0Oh2tLS24fDkFt2/fAplMgUIuB4/P136z/ls5AE43j4VOp4WoslLg5elpgvfTauHq6goBXwCdXte2cYK+NPq7slomkWqePXt2yGAwID4+XtdVwkJX1FFgEW7wHj16IDIy0uHly5eIiYlBS8v/x953x0Vxre8/M9sbu/QOIqCi2FAQFRURUBB7770be4maRI0mGjVq7L232DuKvYtdUSwgKr237W3m98cyy4JgzL2593tv7u/JZ6Puzpw5551zzvuetxarJ0+e7MHhcI6Eh4dHWkrDlcEw9YiIiFrx8fEXLl68GPfo0aOlsbGx1w4fPrwgLy9vAUVREi6XK2/ZsiVevXoFNzc3u507duwPj4hoaelgxfSPAHDm9OlHWZnZn9QqNYYNHzYaAO7fv69/8+bNY3cXN/Tt3buZ6fmm0VReHEw7t27dyli9enW0g4MDwsPDx40aNSqKGX9VoCu0ZaKVo6Mjvvvu+4vt20eSh34/NGvsuLHj/f39ReVuPxUFpaioKGlUVNR3169dn3rr9q2Vv//++w9HjhxRebi7w2g04urVqxg6dOjv12/c6C0UCqHWaHQ8Ho8LmoakzAP58ZPHLQ8ePHikZcuWC48ePfodz5zy2HIjMP1LKBRi4qRvAm7fvh379u3bfYmJiRv9/f2rNJhZmj+UShXGjRk3orCwEF5eXsGbN2++4ufnZ36vzHjKEi2xGjVqBInUSlvOPiwpALx580azevXqDSRJYuHChbYskgUjRVXVjf9qWPo8uLi4SEiCBEX9hQMlAa1Wq8rNzUW3bt2+nTx58pzGjRtbWVVybLMUZP8e7NzS5m5CWSlTonXr1vPi78ePuHHjRv+UlJTLvXr1cpg0adKZ6dNndCSJf60KnsVmwa+2n3Lnjp1QqVR7iouLFzk5OlaQVtkcNkaOHOlRXFwMPo8HZxcXbNq0CRcuXDAzYj6ffzg7O3uzd82a1fIEgVDAmTFzZjeCIO7xeDxwOKaEPmfPnkVJSYm5cqitrW3KlClTwOfzOSNHjuplMOifiUQiKJVK+Deobw5TJEkSOTk5vMLCwupV1ADc3N0VISEhtEwmg7OLM5LfvcOHDx9hI7OGwWjU5WRnHwKwqKp5JpVKuR2jOw7KzMpc5urqqurYsSPRrVs3QV5enpr922+/Qa/X23l5eTl37dr1SXhkBIxGY42qVOYETKE3NWvW1Kxctcoc5nXu3DkwuYeTk5JF3j7eXYAvxKAXF6teJLy4CgB5BaZKMRw2G+6ubtCYqtbAWmYd7erqKgaA0pISp8DAQHC5XHC5HKjVGnz6lIrSkhJwuVwTwe1s+9rZ2VX54pgNUK6Q61atWnWQySwHAPa2dpBKpdDr9cgryMfcOXNpJpFI+aiBj58+cbt06ZK6bt065OTktGV9QY1TPUxtpaSkGHbt2rXUaDTCxcVlVtu2bYUXLlxYMG3atPYBAQFRM2bMWNE2tG1dxtu0soMNs5gcHR0xePDgyDZt2kRyOJyeRUVFx4xGI3Jzc+W2tragKMqrW7duI8ePH/9NeHi4pKp3wmyVObk5l11cXaDT6Vq3Dm1jDQDHjx8/XFxcDHsb2yAXNzcjAFa5MaAic2FMF/369RuUkZGBNq1bt1q1atUGRtBjrq1qTtBVtBkZGUEMGDBg2f79+2etWbNmyZYtWxYzpwPLFiwZYWjbUFFo29Dv7ezsWo4fP777N5Mmldjb2aO2b60269et7y0UmSR1kUhUwVFGr9dj5syZmc+ePcOWLVv8eTxehQ2rsp8El8OBra1t4OvXr5GZmamfM2fO6jNnzsy2PL1U9jwGgJ07dzwQioRPZEYZb+nSpfsZZl5+SjJdl5GZeezu3btyrVYLe1t79/JqWxULwsydO3cFgILAwEBhRETEMMDkn/LfhvJxVaSZpQFBIZcj5eNH+fLly08UFxVBLKz3FzoLEKAoSlmYm49hQ4cuadOmjfmX6tb4f4pt/K+G5XpqFtzMKS4u7ur6deuOL1u+vMfWrVtjLl68OHzrlq3ba3jVAOOk9lfSwqQ9JPHp08cuRUVFSwcMGJCb8v4936ksPJV5JpvFRlZmpmT+ggVwdXEBZaRgMBgwYsQIiEQi6HQ6pKenc94nJwu9y8xmVfWTzWbD1sYm7/qNGxCJRGZ+kpiYCIIgTOGwpip5B3Jzc1c7ODiIbGxslI8ePQSLxWJiz+Hi5AyhyFTyOyMjk3Bzca3SO5WZ1bY2NsSKFSs0SqUSLBYLbDYbi39aDGtra5SUlEAikbD1Bj04bM7nvSYI9OvXz4bFZiE/Px+ZmZkBs2bN+sRms1PZz549A03TvIcPH8pomoZXTS+0btW6oDrnMspoxO07d6RyuRxcLhc8Pg99+/YFh8sBZaSQlZ3NcnN3I8qJ/zkRVSqVoU+fPiRTIc1gMMDRyRGeHjWg1WqgVqsBoA1BmIrAbNmy5UpWVhasrKyg0Wggk8kwbOhQCIUiaHVa6LQ6SKVW9Tmc6sz+pjNORnqGIaxt21ccrimJDIvFApfLNZVtJQgkJyfzXFxdBgPlTlsMrl69+mD37t3o168foqOj21fzoCqeXL5BMSLSpG8mLc3JycnjcrmitmFhv9Ty9cXkyZNb79q167uHDx/GTp48ObZbt24zOnbsODMoKMiBLGuBGUn55mf61tPTE+PGjevy8ePHY4sWLQKAuv369Tsa3i68tqubq1kyq25zKpWXGvbu3nODzWYjKiqqnZXYdGr19vZ+EhoaCi/PGn34fP4fuk+vWLHiUkZGxjUA6NS58wQHB4d/aKkz6VcXLFgw49ixY/P279v30/Tp0xfXrl37C/eUb0Tjxo0Lk8lkl+fMmRMSFBiodXJ06skw86q8f3V6PaQSK7atrS2ePX2aCVR/AmNoHhYW1uX77763pygq7+XLl/MOHjxYv2fPntGWmhvL+VNSUoIjhw+PKy4uRpfOnSf07t27Zvl1MOe+B4Ab168fb9GiBa1UKBAeGT7I8jrmqvj4eOrq1as/AUBQUNDMZs2aWTHX/LfB0jegctrgx48eK1M/pZ57/uL5iZSUlEOnT5+GlcQKLJIl+UrXhT9EGV1JLp+H/Pz8XAAOf092/fVg1omdnR3mL1jQvW69eok7duwYdeHChR3TZ0z/OH369EstWrQgmQwOf5W+gpkLUdHRwQWFhfjtt9/g7Ox8tUWLFmGVBT4nZ+fBgU2bzvX28VEBJhNUbGwssrKyIBAIUFJSomnUsFFcZGRke0vHuPJnmYSHwsKitkePHl3B4XBomqZhMBjQrVs3dOzY0VyaND8/HykpKaSDgwMUCrnj+fPnK/Q7tHUb8Hg8GAwGpCS/N5QUl3yRIDKZTMTlclsUFhbeZELmHj58aNJAl5RAKpWyBg0ahKpCxzmm5FaFcZficOfOHajVap2zs7OBxWKBvW3bNmRmZmaEhITkAUB8fDwc7R3sqnMu02g01JnTp89lZWebUxWWFJtOyjqdDjqdTt8xOloPQFCd5KZQKoiuXbuy7O3tzfaOI0eO4Mb7a+Dx+dAb9GgeHJwLAGnpaYr8/PwLAKBWq0GSJLKysvDb6t/MzFipVmHSN5MKqoubZ7aL5ORkCEUiYa1atZQkSUKhUCApOQkUZZqSAoGAqt+ggV35feWe4pkZmcdKSkpwKS5OsmzZMhWAKsPyqoLlxr5z587zly9fXmhtbU307dt3Tu1atQAAEyZMaBsdFX1n7ry5P9+6dWv+8+fPV7x69WqFn5/f1Nq1a3cPCwtrLhKJWFKptNLZBUh8/RrDhg7dmp2djdTUVGzfsWP/kCFD/JjfKwsnlZH68ROkUumF+AcP0LlzZ18AMFBGNGvWTCQvLcWb12/ZdDWu3JY0Kioq2mFvb4+8vDw8e/o02TT2cqn6z0ryPj4+xODBg0ft2L5jw5nTZ+7Wnlm7xR855DAmiX79+jV99OjRtCOHDy9p1LBRjkqlAlMMpTK4HA7c3d1pUx2CkhPZ2dnjnZycqgwHZMbi4+OD777/7sixY8dCg4ODjZs2ber4+PHjWe3C2o10dHJysnewB9skebMJgqB//fXXc+9TUp5QFMVt3br1jMp9YN7O7t27M/ft23coMDAQdevWjenWrZuN5XVyuRy5ubn0kiVLOhoMBg0BsIcPHz6H+f2/kRFVLH6ix8uEl+oTJ05c02g051M+fFif9PYdnF2d4VPT2zUyMrLj++TkLWq1WvFX94OmadBlk+vvegL/s2DWU69evfyaNm16e+DAgX1v3rjxe/z9+NrzF8zfNWrUqJZMgaC/Eh4eHpr9+/e7uLq6Znp7e8caKSqMVYknNWzYUMDj8TU5OTkQCoUoKSmBg4MDOnXqBKVSCaVSSdk72MdRFNW+Kn7GCA+BzYI6TPzmG5FXjRoKiqYgFAjxLukdjh07BqFQCIIgkJSUhMYBAfrg4GBB06ZNBzZo0OBbX19fNUmS0Ov1eP0q0RyX/ik9VVVYVHgbwGcHP+aZXC6XaNmyZYe8vLyb1tbWUKlUOHz4sPk6Fot15LfffvuWz+ezK95vEkJevnrpvWfPHnC5XLi7uz9cunQpYWtrC3ZRUREMBoNg+IgRyg/vU/DsyRNew0aN+jMPr4zi4mKlRqu9wefzzRWgDh48aHkJa+3adV80MBcWFOLixYtwdHQEn89HaWkpdu7YUeFpvj4+tQDg48ePnAEDBogdHBzkACCVSnHv7l1cvXLVvEHnFxZwXFxcegLVOV6ZcO/evYMnT55UfnZBOVw8PTw++1Kn10MkEtqGhYVBrVIPtraxFpra/WNvT0uV9Js3b+TDhw/vWLNmTdjZ2Ql79OjxranPphOpV00vHDx4cO79+/cn3L59e/mJ48d/Onny5KoOHTqsOnPmjFOdOnXGRkRECG7dujW4cePGIh6fh4QXCQ9fvXr1M0VRt1JTU9Gta9d+AwcObMTQoirJtDISEl7mAwSGDh2K0NDQngDAJlnYtWuXbvPmzQgMaHIDND2puvuZU2t0dPTII0eOXLK3syv4lJr63aRvJmVNnDhhea3atQVfK8OXO7+Zel67Tp0BdvZ2G0gWeZyiqRYk8eUoBkvNRfPmzcdu3LBxSVZWViL1hdgyDoeDOn5+ndeuW/dLrVq1Lu/evbtD48aN90ZGRtpbhgMyY0VZ+xMnTmgjEorOnzp9qrNAIDBoNJplC39cuCwmJkbSv39/zPn+e+w/cID7448/0mw2u1Cj0UChUBivXrs2Ta3RNE5NSyVYJIsGTdN6g4FuFdJKf+jQwbMSiYTS6/X49PEj96fFP63SarWa/IJ8KrRtW4NCLsfZs2ePCYXCBKVSieXLl59t1KgRjxnzf8sJvXKZz+ysLFy/fv3myZMnz6Wlpf36/v17I03TqFOnDtuvrt/UTjExMTGdOrW+fPkyxo4Zs8XWxlb+teGC/x//OEy+PKZ55eXlhWvXrh36bt68rhcvXuw3evTokLy8vAtz585tb3KIpv/p+cfsV2KxmB8SEjJYLBIt/fTxk71BrwerzK+FucbVzY11/cZ1P51O94q5v1evXoiJiUFWVhb0ej30er2z3mAAj8utdg+sUaOGIisjQ5ubkwMWyYJMJsX9+/F4+uyp5WWqZ0+fHujfr99YH19fUefOnVm2trZmZ+rLcZegUCnNuorMzMx4AO2r4xEEQSA4ONioNfmLwWg0wtvbG1qtFgaDASwW66VcIVfZ2NhUcORg1nnjRo36SKXSKSNGjFCHh4fzKIqSFBQU5LLPnTkLNpvtERHWLpcOC8t98+Yt37NGDfvqCF5YVIiZM2eKZDKZwtbWFufOnUNsbCzs7OxQXFwMFxeXGCsryRczZylVSmRlZYEkSTBq9X79+oGpA5uUnCxq1LhxXwBIS01T3rhxw+Dr6wsAkJfK0bhpANZsXFfmhMBCauongX8D/ybVPY8AYKSMcLB3eNujRw+wWCxQFAWJRGIOTZDL5eDxeIOtrKw+yyyk1WqxefOWmwFNAjB22lhndjWagD+Cg4MDx9nZuUFKSsoLhUKhuXLlyt527doNNUm45Srj4OBgaXBw8GJ/f/8ZmzZt2iiRSH67fv16No/HWzBy5EhkZGTM7t27NwiCwKlTp1C7dm2kp6ez+vfrv2D3nt3flZc6rXoyVS4ycujQoQ3xD+Lh4uqC2rVr61CWac/Pz6+PTCb7hc3lHE9JSaH9/PyqXK+MQ1tERES7PXv2fIiNjV159ty5BRcvXlx/5crlk8NHjNgzffr0MIbZMm55JMhKbZSDeRCPx+PpdDokvHopry49anVo1Lixm5EyIjM76wWY3Z8uU+1ajCQxMZHevXv3DpIkaY1Gg3v37l1MSUnxunPnzrcRERGzQ0JCKqTrpUCBAgGSIDF8xPAoewf7hAcPHmxzcnLatn79+hJnZ2d5r169wOZw4OPjgytXrqAsrh2urq5GhUJxaMbMGYd02oo55x8+eIhatWtBIpEgJycHb968OX79xo3jzO8lxcXo1KUzMjMzIZPJEBMTs2zGjBntGfr9X+Xh/hIqC5SWcy8rKwsvE16mPnr8aMfjx4935Ofnp5WWlqJOnTqI6hA1Xiq16hbatm2IX9265oJLbDZbXVaI4s9Nhv+PfwiWuTVomHJrLFu+vG+Lli2l8+bNi/790O8d+vbte75mzZpRrDLmz4i9/0h4GzOPOVwugoKCOFs2b8HBQ4diJ0+dMoPH45GW14hEIs7EiRP7G43GeUKhECKRCM+ePcOIESPMjNbF2fn1kGFDwUP1tS9sbW15x44fdwaQynxHAOjZsyc4XC4Mej2MRiNsbW0/AIC7u7th+7Zt2lK5HGKhCHqDHkbKCKlUCpqmQVEUDGWOWtUdZFhsNmrXqqVTKJWmojAUBVPUGA8EQSA3N1eUl5fH8vTw/IxCAIEaXl78JUuWcEiCUN+9ddtGbzC40jSdy96zew+cnJzcpVKphiboXLFEounTr2+VaVsBIPVTqujWrVuEp6enmSGHhISAxWJBqVTCzs4u4I/ST6qUKjIrK4tgcraLRCK0DAkBl8OBwWiAj68vUdO7JgkAz549O/D69Wv169evzffLFQrQRsqcWQcEofQY4lFaVZ+ZDUVvMIAgCafmzZtDKBSabRaJiYngcrmgaRoBAQFEVd7r+QX5CpVGff7ixYtoGxpK/lE1t4rkL7d329jY8H9d8evhAQMH1AVArV69epinp6fzmDFj2jPqXSYkhgTQoUMHWYcOHea8fv16Vmib0Gs3bt64k5+Xd/i3335L1Ol0OHPmDPLz85Gfn49GjRpF7T+w/zugcv7vqrd5pVIJLoeDzVu2xJ4+c3qZQCDAvXv3Qq2srMzepJ06d2r8/fffC968e6c+fvz4yXnz5lVZvchynGFhYZKwsLD5Tk5OrXft2jUrLy/v0YwZM9r5+vpmd+7c2bHc5lauubB8T8zfKYpCXl4eLl+6tK2wsBC7duw8PGPa9M316tWrcN2X+mJvZw8elyvNy8t7z3itM4ycoijE349XHz52ZOvzZ883lZaWvh45ciRevHgBlUrFt7GxUe7evfv7U6dO7ezYseP3PXr0GBIQEEAQAFhlvIRRR3bq1KlOx5iYFe/evl3w808/f3JwdDj68eNHhIaGIjg4GHv27DmRn5//3GR/U0Cv10v69ulLFRcXQ6vVQqfTQaVSEQWFBXj48CGRmZkpr127NurXr4+HDx5Ap9ezFy9e7CSRSIo/fvhIEATRvFevntMGDx5iLg70nwqTs1/5+zUajbhy+Yrqw4eU/edjY/drtdobiYmJIEkSYWFhYa1atRpYq1atXsHBweKq9hGJRCLQ6w0gCOI/edh/WzBzvmvXrlECgeD8tavXonv27Bk9cMCA2GnTp3f4K9TvNEz28LS0NMeUDykYMHDAdYVcrpJJpRUcITlsNmxsbJQPH5oc1CQSCV69eoXS0lJQFAWFQoG8/PxDxUVFa0QCYbWe7lYSCbdn9x4DCosKl0gkVjAaDODyeGjWrJnZLl6WAc4BABwdHURSmayLUqU6yuFyUVhchDFjxmDwkCHIzsqCwWCASCRi6Y0GcFgV/bqYdcBmsXDv3n3jqtWrIJFIUFpaCh8fHzRs2BBKpRIpKSn0nDlzeE2bNK2yz46OjpoHDx6oszKzUFpczFMoFJKcnFywp0yfirNnziZeuXa1RKPVAIBg9W+/VSHOmDqSnJR879y5c0oXFxfk5eWhW7du6NmzJ/Lz802hAjy+miAreuVWhkaj0eTn5+usrKzA5XKRnp6Oy5cugc1iQ63VQCwUqceMHWMEACcnp/RevXqZPAE5HBj0epw+cQqPHj00t8fncOusXbOmSgMps7kb9Qbs2rXrEXO6AYAPZRXBGNTy9RVVZWtJ/5Qm6tWzJ33r9i1IpVKz09zXoOIJhUC//v1q165T58348ePmxcfHHxk7dmwHGxub2F69enWwVO9ahpH4+fmx/Pz8wgcNGRxeWlIyX61Wy4uLi+Hm5maoVbv2qMuXLx1LTU19lZ+fDyYVrCX0BgMUCjneJ7+Xx126lONfr95+iqLw+++/v7hz585xwKSq8vX17SgWS8y7aE2vmggMDJxz9erVH3bu3Dl76NCh3VxdXVE5HpqBpTAyffr0tu3C2z0cNnRYRF5e3uUlS5b0atSo0U1XV1ewWKwKPVQoFSAJEjq9nnr75o0y8dWrJ1KZ7PqQIUPu1q5dO+6nn37C4sWLi4cMGdLx4cOHZ0iCIKuzyVcIpSMAykjx9Xp9ybFjx9707NmzDkVRePbsWd7hw4fXbdy4cX2bNm0KmNrwjRs3bmMtk/UOCWnV++Chg1ObNm26z9PTM+XZs2fDHjx48JOtre3wXr16jYmIiLCxsrKqQGeSIFCnTh3xnLlz6gGoZ6QosEgSRqMRBQUF7BcvXjw/e/YsBg0atDIqKmqknZ0dNBoNDAaDOQc0U9UrKysr4cOHD5eePHmyxcfXN/PJkydcFot1OSYmplZOTo5i6LBhEsbr11J4M43/PweW9MnLy8OlS5eunzhxIvbe3bsr3NzcKBpAkyZNvGxsbEb17NlzTLt27WykUmm17d26dat0zZo1P0skYrBYrP+fEu//CAxTb9++fRRJkuePHD0SPX3GjCgrqfTGyJEjW/+zmeUYtXLLli0HPXr0aKKTvROSk5LEbm5uFa4hSRLFxcUuTAlwwKRBWLp0KSQSCdRqNYqKiuiszCzC1cX1s+cwIEkSrdu2kZSWysHhcsDjcqFWq7F9+3YUFhaCz+ejpKQELi4uj+fMmQOCINCvf7/mRiN1VCQSQqlUwdPTA4UFBaBpGkajESqVCjRFA5Vk0vKKDIBYLApRKBQQCAQQiUTIzMzEp0+fmLKsiuTk5FgAnario1KpVLhr1y5HAOkAMpsEBOTN/HYW2BMmTCBz83I/Xbl6BR4eHvDwcO8uLTulVfQqNKG4pOicUCikmJO1o6MjatasCS6Xy0gm1B+d0NVqdUZxUZGmtLQUbA4bapUabBbblN9bRUEsEYc7ODiKAYAgCJvmzZuDz+eDw+FArVajuLAIarUaHA4HCrkcDk6OPQQCQbWZ7QCgqKhIWVhYeEyj0Zjq3bLZiIiIMCfVT0pK4gU0aTKonOjleBAf/+rc6TMYOmI4gpo1+7zyxxdgqQpl/h4Q0NhXLpeL+Hw+goKCcOXKlai7d+/+OmrUqGl169ZFRfVu+YbN5XBgZ0ruInF3d0f9+vWRlZNd+/mzZ3iZ8PJD27Ztu50+dfqEs6sLQNNIT0+Xx54/fz0pKfnJjZs3Tnbt2vXZjz/+iICAAIwZMwbnzp2Dp6enQK1Wq8+dO4c5c+fymEgBxq6/bNmyaU2bNv35/fv3STExMb2ePHlypKokJwwIi3sbNWyEFStWHI+IiLAnCOLW9u3b2/jWrhWmKJXXMBqNwR8/frzbokWLVDdXV8z+9lu8fv16b79+/T4c2L+f8qtbFw3qN0Dt2rUxYdw4yfVr1+SvEhPPjxw58tuNGzf+wuVyier6wCAzK5MMCwtTfkpLxbhx41rb29tPePPmje7x48fL5HK5oawQD9/NzW2kj49Pj6gOHUKdXVwAAEHBQXsvX7o86MWLF8vDwsIuP336NPns2bNzk5KSFp05c6adn59fU7FIPDCsXZiDk5OTgMvjsUmSKAt1YYPFYoGmaVy6dAkHDhxYJeDz0aJ5i16bNm2a+hXTpgWAFpcvX56++KfFvTgczoXFixd3Cw8PTyyrpGV6R2U7X0Xtxv8tLDVCFEXh6tVrqsuXL+2wkkj2P37y5P61a9cQGhoKDw/P0bVr+faO6dSpnan2c9XIzs7Gw4cPnz9+9PjA+5T3y06dOoUanjXAYrG+2in1/+Ovh0U+jKiVK1eeHzBgQPSoUaMi/Or4aVuGtPyn2mbmT0BAAKdLly74bu48WNvI7oS2bduy3MfGtJc2adJkQKNGjWb5+vqqaJoGQRB4+PAhmOyNycnJZJ06dcimTas+6QImH5rUT6nFmzZvApfNAQGiTPMLSKRW5kIspaWlJ/IK8pUOdvYiAkTR8+fPQBIkiLKyq6BMhxOtVms25X4+tvIQTVc3t7Y+Pj4ib29vpUAgQPL7ZHxI+QAujweRWISi4qLbADpZqu3NPgYSMScsLKx3TnbOyrr+9TRdu3ahevTqyWHv27dP7OPtI1m7dm3GrVu3IBaL65BVMGQmBr1x4wD2xo0bIRQKwWazsWzZMuzatQt8vqnKzYQJE/QdO3as5kWZOqNRaz6o1GooFQoo5UrUb9QA/g0bmP6tVMLKyiqcXdaHs2fPZjAha1qtFmKxGOPGjYNEIjGrK/V6PY8gv2xSy8nNoSdOnMiWyWQ6Jr6wsLAQBoMBJEnC19eXV9Pb287yHoaxlsrlv+cVFmDvrj3cyZMn6wBwvsbZjAHzAplY7SVLlnQsKio6361bN4waNQrnzp3D7t27p+fl5Z0ODQ39NiQkpEOdOnVgGaZUztzLw982bNhwZ8KECUsAk9e1gM8/uWLFigh7B/uQ3NzcpLS0tEMXL140Dh8+HC9evECbNm0wYvhw4u69exP5fL7tzp072128ePHTjh07BhqNRpw8fvzT9GnTzL2GacGIhg0dtmjnrp0znz17djQ6OnrCnj171jPJb6p+z+UIDAyU8Hg88atXr7SlpaU3GzZqdPNSXBxKS0qg1elQo0YN9OzZE/Xq1cOjh4+watUqjBo1inX9+vXQpUuXtnJ1cR0uVyhkzZs3v/rh48euuXm5y5NT3v9Qt45ftSc0pl+XLsbdz8nL1bi6uuLjhw95cXFxCzw9PVFSUoKSkhLfCRMmjOjSpcvodu3aWZMVMoEBDvYO6N+/f2RQUFDkp0+f4uLj49e2DQu72LRJE/X9+/fPbt269WxhYeGPLDZLtH79eplAIOjesGFDa2dnZ1NOBjYbJaWlSE5OvmUwGArevn2Lb+fMaVn+jC/PGxIEwsPDxWKJOLZTTCf73Nzc11FRUVGJiYmxQqEpFS5RKcHHv8OGXnneWzp9MsjLy8OTJ0+eHz169NDp06eX2draUjY2NoiMjAz0qlGjb5cuXUa2DAmxsqQ5XamNR48eGj98+Hhq9+7d616/fn2tUaNG8PHxEYSEhDRLeJFw3cPdXftXha39N6Cq/aZyGNe/2zOfYepdunSJmjp16qnFixd3GTVqVNtHjx9dEwqF+EfD2Zj90sbGBts2b5FSoEuKS0tOA2hZuUVvb29+p06dSFtbW/D5fCgUCixcuBByuZy5RPn06dOjvXv3HlgVjZh5Z29n31YhVyy3t7WjAUCuVGDQwEHo268vcnJyAAAlJSVkbnaO0cHOHtnZ2eSpk+WagRbBLeBf3x9yuRwajear9GVSmZSqW7cuy8XFBWq1Gr179Ya3tzdUahX0ej0kYomAiUX/LJEXQSAwMNDRaDSidevWUCgUHutWry1k37t3z4rNZrtLpdKMPn36AIDKMje1ZUNGoxGvX7/mq9VqyGQyFBUVITExkYkbh1wuh0Ag8GaGUt0E0+q02QCgVqlRWFQAa2trBAYFIj83DzqdDlZWVioAKC4p1l6/fv1A5fv9/PzA4/Gg0+mg1WrRsmXLkupC1hh8+vRJcPXqVbJmzZoQCAT48OEDbty4AQAwGAzg8XiKSZMmaVCp9Kper0ejgMas9h064NGDBzFSqbRaW8yXwFA0Ojp65I0bN863a9cOjRs3nkoShJTH48HNzW1fenr6jZSUlBsPHz4McXBw6N62bdsRQc2CrMQicQXmDgA6nQ579+7dBYCOjIwc0qlTp2YvX74cX1BYcBkELl+7dg1v3rxBeLvwkWFhYW5169at6+Xl1aFZs2aEWCwWMxECu3btOiiRSFCvXj0oFIotL1++XOHv7w+gfMEuX7FihmcNz6vnzp2LvXDhwoY+ffp8mjBhwo+tWrXyJVkkYTAYWGw2h0UQYAGgjUajwWikjAaDnjqw/8B1Pz8/+Zs3b/Dq1Suxi4uLlUwqzTTo9Yho3x7Pnj51vXDhwtAffviB06xZM7x+ndi+Z89e9Vb8+qtEIpGYRzxg0KAuazesJ1qHtqFJgjRWR2dGCEtOSsL27dvH6g0Gg0gkgo2tLc6ePYtvvvkmolWrVmNbtWrVvUmTcj/KysucKmvLx8cHPj4+ke3atYtMz8jA9WvXjh/+/fBWpVJ5oXnz5pREIpFnZGTIhULhb0zFJn9/f3z8+BHv37/H+/fvYW1tjfz8fK6Tk1PHz59VNZgIheBmwZj0zTebFy1e3OPTp08X1q1bd2XWrFnt/i82cEtUTnIDAImJicjNyY3buWvHyhcvEi6+TkxEQJMmaNKkybDatWoN6Na9ezuTycYESybO/HnxwoXCnTt3bvn06dMqJ2fnXGdnZ6Snp9s2adJkWr9+/WY0btyYO3nSJEKr0/3PeLlXd3ionPDo/5KpL1q0qPOtW7fG3LhxY/PgwYO7HThw4ASXy/2n7OlCkUhAAb0j27ffWq9ePauqSoo6Ojoat2zZolEoFBAKhVCpVKhduzZCQ0PNPlaenp4vqitnytCtVu1aEe0j24u8vGooaJi0S3w+H9euXTPnKUlPS2P7+PiKylJ4dxNweT/7+tYyFJcUw9nFGTnZ2VAqlVCrTRrnqmD5fmxtbI1BgUG0vYM9OBwOcnNz8ejRI3DLyoeLRCKB0WgsSy5TseckyULjxo1VeXl5OH7sODRajQebzTawT506xfX08LBisdn48OED2rRpo6ucoMU8oWgaD+Lj9Tm5uWaVQt26dcGoOt69e8d1c3OLNnW8ehj0BhVgYpZSmQxXLl1G3IWLAEHASFMYNXKkEgDycvM0PXr0KOVwOCBJEhKJBI8fP8b27dsrtOfq6lqHJIkqn8n0/d3bdxevXLmifPbsGQjCpFIhSRIkSUKpVMLGxiakqkxzRsqIY0eP8rgcDgYPGdKc/ZUpXys/HwDWr19/5caNG9sBYMjgIdf69O0TSpAkgps3R+/evX84efLkLwaDYb5Sqby9atWq28+fP58plUp7hoSEtPbw8BgUGhoqMRqNOHLkyOVDhw6d0+l0u52cnDBu3LitXbt25axbt67G1KlTY1xdXSmJRNL+8OHDi6Ojo5vyBXywyIpal+TkZO1vv/02+ezZs5vdy1KkpqWnyy9dupTo7+9ft9yeD9ja2mDq1KnnL1++3MnFxeWss7PzuU2bNp3z8PQQbNm0hbNt+zYuAB6LIDlGmqJFQpFGqVJqx40bZ3R2cZGzWCwIhUIs/mnxmf79+rfo37fft0nJyateJSTwt23b9jwkJMTWSFNgEtpYglHfOzg46JSlCu53c+Zpe/Xo9Zk6xtJe++DhA/2mDRu76PT652KxGJ8+fUItX9+o3n36TO/cqXM7ewd7i/bLk84ybVRICCMvBU3RePvmjT49Pf1BcXExxeVyWMyJQK/Xw87OzuyEIxAIJI0aNcKbN2+QlJRkTEpKUgUEBKBVq1YiJycnnz8zd5jNZsiwod1/mD/fUSQS5SQmJl42Go3tWCzW/xk7r+yxnpaWhu3bth998+b1j+7uHgl5efnQaLSSqKioWePGjx8fHh5uU1EDQldIpJOTk4OrV67ce/b8+b63b99uePDgAaysrGBtbR3WuXPnaRMnTmzvX78+m2VKEa3T6/X/Wc4C/yJUdmj9Gg3Mv5sslmGicXFxm9q3b5907Nixk4sWLTq8aNGi3v+IkGHpODZj5gzfu3fv4sjvR3R9+/YFp+J5CzY2NiIrK6topUJxms1mw2gwoGnTpujcuTNycnJMGlydTqo36MHjfp6dmaGou4eHunWb1rC2tmbaRdzFOJw8dgI2tqZUEEnv3qlCQ9u+AVDPzc2tQevQUKG7m1upkTJCKBShsLAQRqMRGo0GGoEG1Qmc5mxxdrZw93CnxWIx7O3tkZCQgDNnzsDB3h6lcjkcHR3zaYr+7D7AlDsj/n68dtv2bfDy8gJJkroPHz4Y2YMHD87ZvGWLurioCLdu3YK1tbUVEx5UORRGq9VSDx89Os9k4hEIBGjbti0EZXnRCYLgS62k1gyhqnuNRqPRUPYn829QRgogTKoOqVRaDwBycnI4LVq04Ds5OemYpPlWVlYgSdLs2JacnCz09/fvyfS3uhdWWFBwQyQS0RRFQafToU6dOmjQoAGUSiUUSiUc7O07MmERllAqVYb9+/cf79ChAzp37SJnsaoPtaoOBIB3SUm6WbNmtQeAn3/+OW7Q4EGh5gvYbDRs2JBo2LDht/Hx8aO3b9++tmbNmmsTExMLunXr9vvdu3d/P3bs2KyffvqpR3h4uObChQuHHRwc4F+vHooKCx0dHBzYADBx4sSoM2fO/BwXF/ftkCFDxD179WxaeRMoKirCvr17454nJIwtLiz60L5DB4hFIpw8eRJGoxFrflszVGJltTC4WbM2tWvXFjISsZWVFQ4cOHBmx44dJx0dHFdfu37tVssWLdWzZs5S9+rVCzRFgSRZ8PT0wMaNG8top0Tqp09ITU2Fo6NjvZEjRoZaWVmhXUS42607t5Gfly9tE9rGls8rT9NcWYXM9F6n1ehYLFIHgvCztrYWWdKfYSyJiYk4e/bskZ07d05nsVhpFEXB3d29y7hx46b07t07VCQql9fKzRcV6VNcUoKS4mLlnTt3KFdX172PHj3K27J1y/EG9Rt8uHb1mnzS5EmQymQoLSvo8+nTJwwePBh6vR6XLl0Cn88f36hRo6U0TStatmypX79+/cjk5OTjubm5qp69eqUDcMOfhLu7B6ZPmzbmyrWrP969e/dBaWkpbW1t/X+icLZMJGQ0GvHjwh/jnjx5/DOLzb7h6OgInU4bEtwsePj333/fv3nz5hV2UIaRM/e/SEig83JzL65evXp5cnLy1fT0dHTo0AGTJk2a6enp2S0sLKy5Y5nzHwONRqM1aRD/nhy98nw0UhQ05rrcCrlQKARF01AqFTAaKYjFYomAz4eRoiARiz+7/99VDY6CySHt559/vtKuXTti7dq1fZo3bx4YHR3t9Ue+LtWBzeGAzWYXPXr0CO/evTtUWir/jm/Pr8DRORwOIiIiWhcUFJxmirQUFRXhx4ULweXxoFAo4ODgQPXt3/+Lz7K1tcGqX1eq1VoNeByuqVa6UgmlWoW0zHTmMsOrVy+PA6jn4empGjVmFG1nZw+RSIiEFwm4ffs2BAIBDAYDDHoDqpqjlvsxj8ejZ8yYYVSpVBCKhFApVdDrdMhMy4BKq0ZWRuYJlUq1RCAQsCs7VxMArKwk7nK5HC9evACARxMnTtSzp06dqt65a5dSaiWF0WBg1atbtzMA822Wm2tpaYnKaDQ+FQqF5rSprq6u5ty5bDabllhJdAB4X4qDtvxOrVajpndN1KxZE2q1GklJSQKvml7dACAtLY29fft2I1PCsqSkBC1atMC8efNQUlICgiCQnZ3N9nD34OALz9Pr9ajn7y/45ZdfwGazQVEUrK2tYWVlBaPRCJ1WC51er0UVRjmtVqPq37//kwMHDqBJkyaG0NZtvmhO+PwFmrBz+46jKpXK6Ovr23LOnDkRQNVpSJs1a2bTtGnT+a8SX816+ODho9atW8fv2LGDunfv3mySJPfEx8eDpmk0atTIms/njxo+fMT4Fi1aEIyUvGfPntkNGjTY8/Dhw2Pz5s6L/vnnn88DJuei+Pv3n6xbv36+tbX1WXt7e9y9ewfTp09HUVERIsLDMXLMaKxc8evD5cuWRWvUGlk9/3pjxowZ0z4oKKits7Mz3N3dMX/+/K7FxcVdHZ0c5U5OToe6d++W6e7hgaKiIhAEAW8fb7Ro0YJ4+OgR4uLi9nt5eb3Lzc1FSEjISCsrK1A0hfGTJspzc3Oxd/ceP71eDz6P/8Va0iYnFb2oc5cudEFBQTSPxyUZegFAZmYmYmNj4y5evPgdTdMPXV1dkZWV1eGHH36Y3aNHj1DLQiuVhQCaBjKzMhUnjh3PlMtLD966fTvP09Nz/dOnT1FSXIzuPXuiuLAYnp6eJj+FsvhWd3d3NGzYEGlpaahbty7atWuHo0ePYt++fTvDwsJ6DRo0qAkA1KtX71hMTAyRkZGhTXr37iyAseWhe0yvvgwjZcSU6dMEySkpOHXy5E2lUqFihJp/FyrbyjMzM/HTokUDNm3ZcqBho0aIjIgIbdq06ZzGjRtHent7m+9jNCCsMkZOURSuXLmiOHXy5KY3b9+udnBwyBCLxbC2tnZo2rTp1KFDh45r165dBVd3qvI7A0AR/70K9y/F5ut0Oqg1Gty8cUP+MvHVycaNGqbs3rkHly7FPROJxbFr1qyh3N3c+FweDxHtwqHV62oEBQV1HtC/P4fFZhO5ubmDO3fubGtrZyeRVorEsMRfxegrqv0JNG/eHOvXrb80fMTwiMmTJ/cMDQ19bLKn/9k2CbBIEk+fPJG+e/cOfXr3fqdWqVQAKoZBEAQi2kcqeTwe2BwOPDzcsWrlKhw5cgRM8RQHB4cTWo1mrqCK9NXMvmljbSPiCfjNikqK73I4HCjVKoitJOjStYvZ4dtAUahZ01sLALa2ttSaNWv0AA2BQIDMzCzIpFKw2WxoNBpUezy3gEgoEur1ejulUplWVrobIrEYNEUBLAJGmkorKSlV2draWjF0sRQIPGt4dhMIBFNbtGiha9y4sXbSpElc9t27d2137tihuHfvnvrw4cMiWzs7s1qwsl1GpVJRS5cu5UokEj1gUsGrVCqzyt3ZxQUya1mF11IVWGVedyRJQq/Tw9nZGUHNm6G4sBiOTk5cR0dHDgB8+vTpWmJiojI3N5d5PhMGBKVSCZqmodPq9B1jOuoA8Kt7nsFoxNMnT1hyhQIikcjcb4PBYA4zCAoK0lSVvz4/L59s3aoVjv5+GAI+vwszCf4MCosKdQcPHljl5OiI0WPGrKiOOsypkcVioUH9BoIG9Ru0ysjIaPXmzZv5aWlpiIqKglardW7fvv3STjExPZoGBooYfwemNUdHRwwdOnTO7t27B23evDn29u3b/SMiIprKZLKzd+7cucbkJj565Cho0CwrqbS2Uqks4PF4qnYR4XiflIz58+fLHRwdink83i/zf5j/S0RkRFBpaWmPHj16jI6MjJTJZDJ069ZN0q1bt1EUTUOv18PaxqSq0mi06NqtG7p264bmzZvPPnPmTGhg08C0qdOmjWU6eunCRSo+Ph4kQSoo49dZ2Y4dO/Y2PS0N48aN43ItVGcnT558snDhwjl6vT7O29sb/v7+oc2bN5/TpEmTSGdn5wq0ASqe+s+dO/fyypUr26xtbH774fvvEdysGZ6/eIGpU6cipGVL4teVK3lnz57V2NvbIzU1FRwuBwVloSl16tQBj8eDWq3Gx48fhenp6azw8HB5QUFB7uDBg5v6+vqqgoODBQ0aNACbzQ4VSyTX4y5ePDZ37tyxJgHj62cRAQK2NrZaocCUoJAg/m8KnzMPXbZ82bUtm7eMq1O79tt27do5tu/QYUPXzl26e/tUZOSWGhCDwYAXz19k/3749w3r16//2cXFxahUKqHVattMmDBhgre3d/fAwEBW+f3A3/UUDlTWdFBITk7S3r9//87Va1dvcdicfWKxOPm3335DTEwMWrZsiafPnuLt27eYNXMm1Cq1vk3rNsjOzQGAhKysrASNVovDe/fi2rVrP1pZWQnv37/ft169evVdXV2HtmrdGiRBgMfjSQiSgEQs+SxTn2W//pkxESAwbPiw8POx5wcePXp03+TJk5dt3bp11p9VvTNtNWzQsK+jncO3AU2aELm5uRxPT88K13E4bORkZavv3LsLLpsDa2trPIo35UQHTFoDpULxIj8/XyWTyT6z6TG7QVkq1o65ubl3xRIx9Do9hEIhOsbEQCgSQq/Tm7K46fVcABCJRbwd27fzAWiYtiZOnAiBQACNRgMWm40/ijkRCARsvzp+4dk52TuZWuyjR482O3wXFxdzlUoFwdDDki4AYGNra+vv7y/o0aOHrlWrVpKbN29asV+/eW0rtZLSYrFY3apVK9rOzk4LgFMV8QvyC4iPHz+SDg4OMBgMEAqFsLc32SNpmgZJkrCWWf/hy2KzWTzTn2wYaCPqN2iAkcNHIi0tDQUFBZS7m7seAF+pVN4Ui8XmqjbW1ta4e/cu7t69a9kcuXY9k2q26glD0xRevnqlzcnJMWfzqdQG7OzsxFU5Tbx5/Uawa/tOKqpjRzRq1CjwS8+pDi8TXlJ6g+GRg6MDoqOigk0tEGVmiercNIDNWzbf371rd/+GDRt+aNasGTgcTu8ffvhhR6NGjUTlV1u+bNN9vfv06XnixIlBLBYLt27dOpiXl3dw0qRJcHZ2Rk5ODpKSkuDl5YWUDymsB/HxMydNnjxk6vRpBE3D0KZNG/VPP/9c6l+v3p6XL1/KTp48OVGv0z0g2awHSUlJP16/fn1QgwYNBrRt2zbE0dHRtFFwy9MWsAVMljogJiaGV6tW7XtKpULfuHFjDmAS4o4dPaaOj49HXT+/d1qt1lzytqpFz2w8qamp5719fODq5mZnNBrx4uVLrFq1av7Hjx9/fP36Ndzc3BxCQ0O3d+/ePYZZ9JanEMbWR8JkCli8ePHGS5cujadpGjKpDI0aNmrYu3fvbn3792/cqGHDtsHBwSz/+vXl27Zt83JyclInJSVBZi1Dfn4+2Gw2RCIRBAIBGjdu3K1Zs2Y7bGxsWO3bt79x7dq1rjk5OcaRI0b2evLs6Vkuh4Pp06cvmzRpUtD9+PjLW7ZsOf/NN99E/5m60iySxN07d2wBGjVq1AgXicX/tpCtyifz3bt3xx48cDD6/fv3CGnVqvf877/f7VWzptlmUvk0DQAXL15MPHny5E+PHj06YGdnh2bNmsHd3b1Pq1atxkZHR4cygpfpfoCZyX9Pdm6iKJM86e7duzknTpzYdO/evQ2FhYW5vrVq4c3r16hbty6GDBkiePLkyeSff/65voeHB/bt26dJTkpKT8tIn7/v4H50jI4GyWbBxdkFN27cQHx8PHr16mU0Go3yRo0abT179iwMBsOkevXqYeOGDdi9Z0/3b2fPbuDu4cGWy+XDoqOjbZycnfmW6/efpTljVlmzZs3eCxcuHN+zZ8/s0aNHTwgMDBT9I6r32nXquHXsFIM9O3fRLk7OZGBgYIW+kgSJ5OQkt72795i/FwtFWLt2rbmYV1FRkUCpUn3xwQRBoHnz5lRZ2VWwWCzodDqcPXsWOp3OMnEab+iwYZBJZbzAwMDo7KysA4KyLJDcsqJfpqqg3CrZuSVDJlgk3N3dffkCU3EWLpeL3NxclBSXwGA0ICcnh8jLz/usGaYNB3sHbc8ePajS0lLs2LFDwOVybdlv37y1KyosUkVFR2H0qFEQiIQWA6/YVm5uLufWrdukm5srhEIhPnz4gPv37wMw2dN4PB716PGjP3xJHC7XBgD4Aj5srW2Q8OIFVq1chcLiQhA0jPMXLqQBoEWLFqyGDRuCzWaDz+ejuLgYv/zyC0pLS83B/s4uzh2lUukXU83SNKBSqtKUCiVYJAmKptGgQQMw8fJJSUmcevXq9WCIZRq5aeyv37y+ef/RA8yfP5/t6VVDAeBzz60/wKcPH3MUppA8JydnJwMAtuWzqoNYKHYQCYVUQUGB07Chw3Z36twp0sbG5KDB+EoQhCUjNLHSun5+fINe31WpVJ709fVF06ZNRS9evCAVCgU+fviAoqIi+bJly7Bzx05dTnbOsM2bNh9t3br1d2FhYcHNmjWTNGvWTAJgTmlJSSqAmVwuVxncojlu3b6lPHjw4KZNmzZtioqKihw9avRkqUwa3ahRI3OfmQ2ZMbnUquULlEUOMIu9YcOGEWfOnFnerVt3RX5BgcjBwcHirs+hUCmRmZF5Jj0jHQsWLNi1ZMkS+eLFi0/ExsY+b9++PcaNG7ewR48es0NCQsxHdyb/tKXph4TJGbJdu3b9UlJSDrm4uKBBgwYDhg0d+ktdf39XW1ubCt6pNWvWFGo0GpZcLodOp8Onj5/g5uoGlUoFR0dHJCUlQS6XB4wfP14GAF5eXjGHDx/+KSEhYc6rxFfndu7YcW/MmDHNx44dG7h1y5bohJcvz0+aNKmjWq2OnTVrVofq1KGVodVqMWPGjLiSkhJEREQEMDXc/x2wPElOnTr17JMnTzr5+/ujf//+p4cNG9apLC+C+URuGVaZmJioOHfu3JKLFy/+/PTpUxQWFhKTJ0+e269fv3GNGzd25VowEsar/+9rHbc089C4cOHCq7Nnz25UqVTrORwOEhIS0DYsjFW3bt2hQwYNbmQltZoYFBSEGzduICkp6d69e/feWltbr5fJrNNdXVzh4uKC3n37IDsrGyUlJcjLy4NcLofRaJSkp6XDv74/+vTpYywqKlLt2bMHF+PiUFpaelwskRxfsWIFSktLv7t7544wv6BgWqdOnVq2bt06zN/fn1u5dsE/AhqAs7Mzfvzxx9PTpk0LHzVqVMyzZ8+u/SPv1tOrhrJ+g/qcHTt36BPfvD4HoEflWPS6dev1dLSzn+Zbq5ZOq9VCJBKBzWaDIAhTNlOA0Ol0VS42pg0WiwVfX1+9UqkEm81mqrXh4MGDZn4jNzmqvQVt2nfr1KnT0M7O7oBAIACHw4FYLDancRUKhajKhGsJgiDh7uGuF0vEEIvFMBqNeP70GYxGI0iSxKfUT0SL5s0/88I2n9BtbOBbqxb99OlTPHv2TCyVSh3YH96nWKnVau6pk6fw/NkzauasWTRzE12pgeLiYmViQoJGp9VAJBQh8XUiSktLTfGwNA0jRXEEAiHH8p6qQisEfL4Hh8WGWCSG1EqKy1eu4PKVK8xl5JJflnIA4OPHjyydTgcej2e2TdStWxcajcbstGBnZ9eU/IMYdLVarX/48ME1g7E82ql///4Qi8XQarWwsbERODo61rS8x/wqaPoyAKz6dSVr0OBBf3I+lnkBp6fFl5aWonWr1m2EIhGboUZ1oMuoNmDggJrNWzT/mJObq2seHMwFLBYaUX0rHA4XAwcNqvXhw4eGbdq02ebt7V2b8exvF94OpSWlx4VC4cdatWs9VyqVZ69eu3ru+o3r59asXRO1cePGXfb29qJXr15de/jwUSc3V1fojQZIpVJfW2ubASKh6Dqfz79+4vjxOA6HEyeRSFo6OTmNie4YPahxo8ZgSr1SMAlSNPF5OE1wcHBYh/btsWnTRsre3i6+rp9fs8rJdyyxaePGR3GX4q6r1Wq4urom7Nq1K0GhUGDKlCkRgU2b/tqvf//6zLVUhfkGgC7zwi1bXLNmzfo9Pj7+kKurKwYOHHhm7NixMWKxuMI9BACNRoPp06d3ffz4sQIAAgMDg7/99tuhb9++zb1/7946lUqVm5CQgAsXLnzPYrGKxo0bN8/Pz89m1KhRs1Uq1U95eXny5OTkYwajsTmHw8G27dtPNWvWjA/AuG7duiixWDw/KDBoko+Ptw2/zCeFWf80jbLKXxT0Oj22bt165tmzZ2cAoGnTppGsP5jvfx3KmfPGjRtj9+8/0MnHxxuhoaHnR4wYEcXQyzLPAmDyddm9e/eFTZs29fXy8irx9fVl+fn5fR8VFTUlKipKyryLymr1ynvF3wkMo3z18qXm8uXLi0+dPv2Tl5cXbG1tUVxc3PKbb77pERMTM7JFixYSAHj37l3h8WPHtqampa0oLCzMVyqV+PjxIxwcHOBdsyYIgsCFCxcldWrX9lYoFF27dumKwKDATvX96/va29tDJBJBKBBCo9UgMzMTderUgU6ni/Py8nopkUhKvby8ViuUShVFUYtXrlyJuLg4Wy6HM3X8hAkTQ0NDpZZRLn+WDTPzYfz48e3Wr18f8Pz58+u//PLLk9mzZwf8mfwdAMDlcsmfFi0mCNNB7AGAHpUFA0dHR5sWrUIELi4uOsb8++bNG/Oaz8rKIv3r1/+iVovNZiM+Pt6wevVqiEQiU40RmkJRYREMej2IsqyPeXl550qVcr2VWMLx8/PTlJSUgM/ngyAIWFlZgSAIsNlsfEnoNgsRBAF3N3daKpXCSmIFpUqJBw8eQKVUgsPlIuldkrKwsCgVgG9V7XC4XHrY0GEUj8uFj4+P4dn7FB37ZcLL9/b29kUPTKlUiXnff8+u+OjyyVhQUHApJz9Py+PzQVMUOFwOGAeYkpISODk5NRAIBfzyO6sGXyDwkslkbIlEYjAajahZsyYomoKiVA4nZ+dAqVQmAICEhAROYWEhhEIhDEYjeFwumjZtCi6Xaw4P4PP5avIPJCGlQqEZOnRYLkUZQbJY4HG5aNCwIXg8HoxGI/Lz8mknRyc1Kp2+DUYjunTvxnr85AnOnDnjYGX1ZU3A5zCxB3sHh/oisQgvEl7cUiqUer4Nj/PlOIBy1KxZEzVr1qzIzP8AJEnA19c3kcvlNhw5cmRVKZKGGCkjunfvjjt37sgvX7q048bNm8sePXoUO2XKFM9u3brxXrx4UbJ3715EREa2bRoQMGfM2LHh33//PQFg/vXr1wsXL1q0+OChQ6t6dO9+JzMz807cxbhfW7RoPrJX794TAwICTIyAACgL5swsZn9/fyolJcVLbzR+ePnq1e8AmhH4vDocCQIKhYJe8tOSUYVFhXBycgKLxcKRI0fEU6ZM2T1p0qTuTLRDdSViCaKcSb9IeKH+7bff+gJAdHT0phkzZsRUpisz13v27DX30aNHp2qWbZ4//PDDqZiYGAeKohATEzMzJyfn8ocPHzY1bNjwXGJi4srFixevbNq06XQej2eTkZGh8fHxQXFRsUin1YItFCIoKIi9devW21u3bBnqX7/+28ePHy+8fevWkoQXCW36DujXMjoqGra2tjAajSgqKkJGRgZSU1Nx7dq1RJIkD5MkCXd39zZDhw5tberzvxrl1NyyZculHxctii7Iz8fkyZMqMPPyq02Ql5Zi6tSpQ2/cuLHb1dUVzs7OY8aOHbu0YcOGMubaf5fn9X8CGEHHoNdj69atcRcvxo3m8rifWCwWHBwcIhs0aDA9ICAgsnbt2gCA+/fvf9i0edPk3w8eOiMQClGnTh1zRI5QIMSnTx9JNofdsUXLlu2dnJ0Ht2vXTkJRFGRfSJnr52eupNyDoqkezZo1Q05Ozo/v3r3Levfu3f6EhIR98fHxya9evfpOp9cvSk1NnePv7z8tICBAYpmb/Wvs4OWnZ4DH42HNmjVHO3bsWHP16tUDJ02alCgQCP7U3JWIxaLSkpKATtEd73eMjhYYDAZTRlELuLi4aAYOHEjZ2tmCzzNpbpcuXWo+WScnJ2vCwsIyAHxeShPl+4NQKAyWy+Vm+ztBEBCLxaBpk75Pq9OCz+fL5aWlaiuxhBMcHEwLBALweDzo9Xq8ffuWyZYKkUgE8g9cXQiSgLd3TRiMRshkMqYgE+RyOZOozZiRmXERgG9VtBeLxXyDXi8sKS1RFRYV5oaGti1l+9TyfRf/IB5SiRXc3d3rikUisyRTuZHkpKREAEhNTwMAWMtkaBoYaO6Ag4NDsz9K8AIAfD7fys7WViCTyuQ0aIitJKBBQyFXwNHRMZTJEpeSkqLOyckxOwlIJBKEhYVBJBKZy8yJReI/TDWbmpoq8fT05Hp4emgZdYaNjQ1IkgRFURAJhZSdvd1nM9VoNOLliwQWSZJo0KBBV5FQ+A+VWavhWcOLQ7Lh7u6emZ2VxbG1scHXMPOvLX9aGSRJQiAQBK9etWqBWCzpNGXK5J60uQWTIMEiWRCJRIiMjJRERkZOfvH8+fgRI0f2u3r16jGlUql58OABgoKCJq757be1NWrUqNB+x44dbTp27LgyMDAw6eDBg2dDQ0PRMqTl8ydPnnxzMS5uXefOnb/t0aPH0Pr161uUxCpPeWjvYM+pXadOj5zc3BWXL18+mpaWtpJJ/1nZ87dHjx4/FRYVPhszZgySk5ORkZHR4dSpUztbtWrlBAsqfimigmlr7py5KwCgXr16TTZt2jSmMo0ZHDp06PG5c2eXMGmBFy1adD4mJsaBLqNtcHAwH0BMixYtYp49e/b21q1bW1+/fv3r+/fvf9VqtdBqtSgtLYWzs7OVUFAuA44cOTI4JKTlyxMnTs6Nuxi3USwRK5oENr104fyFS08fPYZYIgGXywVFUSgtLUVaWhrkCgXkcjkIgmBv3bZ1F5fLBeMx8a9A5TSyb16/xpgxY6IBoHu3bkvnzZsXZaJbRZMGANy5cwdHjxyJ0mg0F2iadpo+ffruiIiISCaJ0f8SIwcq+H+ge/fuAwsLCvYHBTVDeka6XVhY2KYhQ4b0YA5E6WnpmDZ92tzc3Nwl2TnZMj6fH1lUVHQ5Pj6e8vf3R05OjtTdw2Ncx44dRwc2C/Kys7X97Hlfir4xm50IkqkyKfLx8fHp0KHD/MzMzPmHDx+OO3Xq1MpLly5ddHZ2XrBv376Vwc2Cd44dN7a7S1k65D/z/pi1Hh0d7RUVFTXiwoUL23fu3Hl//PjxwYxXxtfsaXw+n2jVqnUUm8O+n5CQQAQFBX3G0CVWVvSpU6eMZfseNBoNbt68aQ6LBqB9+fLlfgBzqs4WZ+qru7t7uLe3t9Db21sFAEUFhWgf3QGRHdqjsKAQAKBQKFjaMvX9+/fvjffv3wdFUxCLxGaHNqVSCZND/pcZOkmQsLKyopUqFQDA1dUVDRs2xLNnz8xaab1enwNUPP4x/RXyBdx6deu2eJ+ScrpUIVe3iwhXs9t3aM9+/uK53tXVFS7Ozq0rJ05hukRRFAKaNCGGDR8ONosFNpcDpVwBlUoFpkC7ra2tlLnhS9KcSCiEk7MTYWtnC4IgwBOYVBZKlRI21jYswJRmNu1T6rXs7GxIpVKQJIm01DRMmDABjIpdr9dj3Nix+k6dO1X5HGajuXvnzoXvf/heKZVYgaZocHhccHgc0BQNhUIBa5nMeC8+/vOQBprG/Xv3WUajEc2aNXMlWf+YqrNxQGPSysqqgUqpenHz5s2H9erVCyw3aXx5Uv+jqR2PHDmSVFBYaMjJyS7rNDMlTG1UPpU2aNiQc+XKlaNhYWEh8fHxd2xsbILu3ru3lqzkRW+pXp02bdri/v37n01JSek8c9Ys0cW4iwfFIvHbhw8fDnv18uXmwKCgWf379+/m5uZW4ekECERERPQ8fPjwCoFAkHbl8uVHQ4cNa8o4ijEb4caNG2KfPn36g0Qiwbt379C7d+99HTt2HMAwf+pP0ObF8xfqc+fOLQaACRMnbLd0gLQUIoqKirBr164RQqEQEokkYN68eSsGDRrU1kwDGqAJk3Odvb09IiIiaoeHh69IeJEw78bNG6vXrVv3Y61atWBnZ4fc3NyPxaUlkElloGhTpbc6dfzY335bZ1m9evV+MBgN+xRyRc7LFwmlsedjrxAkSUqlUi+ZTObC43JZrxITd7E57BKVKS3kgojwiBqW7+JfAcv3q9Fo0LNXr44ADAEBATH7DxyYzTzf0keaAIH4+HiMHj06zMvL61qtWrU67N+//yQTh16d9uTvDGYOX7t2LX/RokX9jEbjZZFYDKVK2Wvjxo3b69evb9YGrly58tratWu/4XK5ryIjI3+2s7NrV1pc8p1KpaZ8fX1Qp06dOS1btpwVFBQks8ziWdnpsypUPhB8FipLknBzc8O0adMix44dG/nb6t+uZmZlLtVoNJeWLF3S4/iJ41E7duzYFxQUZPM1jpyW65BJCjVlypRl169d275nz55BvXr1SrK3t//62ukEgcDgINabN2/w4MEDzvDhwz+7RCAQcPbs2VNhc65Rowbq1KkDpVJpCjkzGFgmenwe9cL8287Ojg5sGsh2cnYCAGg0akgkEmRlZplC0QAUFBQQhYWFqFnDC0+fPmVZJjlTKpSwspJArlCgeXBzKsAiE2VVYLFYuBgXx1qzZo1ZbT9kyBBs3rwZqampZQdWEctgNILNYn32Lkk2C1KprEm9evVOz5wzGzY2NmJ2SEiIpH79+oU7d+6EUCg057SumDPYdFqtW68e2aRpE3A4HNjamGqhnz1zFnb2JscYoVAoYH1FzWqhUEQ7ODnTtvZ2IEkStra2YLFYUKvVkEgkBgBQKBTqpPfJz/V6PQqLiwCYkggw6nYTwTXg8flO1T2HmTDpGRk3/fz8KJFQCC6Xh5ycbGRmZZlCGky542szmgnLhUFTFN6+eQMrqRWaNGmiIf5kPW4GdnZ23AnfTFz1w/fft9u+ffuQsLCwxNq1a8OkZq6qx58Xe65qIZknI12xvvfGjRtvHz58eDdJksTw4cO7my6pfiEyTNTKygqtWrbsrVQq70yZMmUrWSlXOANmQ3d3d28YERmB/gMGtImMiJj24vnz4R8/flyen58f5+zicv/JkyfdU1JSIiMiItb36NHDxzKrVJ++fZstX748UKPRPDxx4sSYzl27PraxtjZvhAcPHIxduXJVdFBQEBwdHVvWr19/6dixY0OqowVDj8pjZdqbM2fOCgA6VxeXpmNGj2lYHU327Nlz/9KlS88pisKWLVuODBgwoKblM8vKqVd4byRBoEHDBtb1GzZYKJVKO928efPbR48eXXn27Nm61q1bd5g0aVJHkig/QZEEgc6dO4sBjJUrFOjRsye0Oi0IAOyywi4URSE3N9du3bp13+/YscN3+Yrl335p7P8KzJwxc9+rV6/OC/h8Yv+B/Wf4fH6F+UDAFJam1+sxf/786OTk5GtNmzbtMHXq1NjKQtdfZRMnCMJkG/0PPuwzc27Pnj13p06d2rewsDCtTWgoxo4ZczI0NLSLk5Npy9LpdFi9evXve/fu7VtaWspevHjxi7S0tMInT560zM7JMfTp0yeiXbt284YPH96G2Zere//V0feP6G4pFAuFQsyZOycsKysrbOPGjb/funVrsIODQ+yYMWN85s2bd6hnz56RJqZe3vqXYVrtkZGRNmFhYcMuX7my8/z58w+GDBkSRFaxVqsCQRBo0bKlIS0tDYmvXqko+nMhXiIWCxo2aNAyKzv7opWVFWiaBofDQVZWFmiahlwuR1xc3IXS0tJZVlblFbYrHgQI2NjYGAODAmnbMu0Hj89HWmoqbt24CT7fFMiRnZ0Ffz9TCWcfH59GAFDLxxc6nQ47du4wt81hs+kRI0dUPSaLfT4vL49QKBRQKBQAgFevXpnLter1euj1eoKiKIDF+oxWBEHAxd2VVKvVpnLihUUSdmFhoZim6UI3NzcIhUIDUY09mgaNVwkJkCsU4PF4sLW1xa1bt3Dv/j1YW1ujtLQULi4uDynK0s+5akhlUjRq1BB2dnYgCAK2trYgSZJJTgMAUKlUBrFETOu0OnA4HKbAPBwcHEyVcAC8e/eO5eLiYs6PXdVJrbi4GM+fP7/o7u4OkUgEiqZAsEjY2pmECblcDicnp0hT9a6KMBiNeP78eXz3Ht3Rvn17VEebL4GRUsdPmBB2KS4uKik5KfbgwYNRAwcOjPXx8ak28QNgerl29vZwdKhY4M1SqmRs1QBw7eq1ki1bt6w+fvz4AgAYMGDASl9fX/M9wJffi0arxaPHj2+VFdJoUP31JmqzWSz5kqVLUat2rQ9sNhvffvtteEZGRvjOnTv3Z2dnD3z9+jW4XG7crl27Ir28vF4GBAQIGd9UiViMWbNmbRg5cmRgamrqk3Vr1/4+d+7cPkWFRViydMneoqKiwWlpaajpVbPzL7/8cqqiN3XVJ5Ly02XFsd6/f191Pvb8IgCYOWvWpqrCE0kQMJU8ZR1r2LAhbGxs+lRm5tXBMlRr8ODBTaOioi43btQ4SCAQPHz+7NkVjVbbkc/jfXZKIsvoAJi0VpWxf/9+/osXLzBgwIDBHh4eX7Yr/YUgADx9+lS9bv26QQCw9JdfYuvUrgO60mxg3sCoUaOWXbx4MVYilvjPnTs31t3dvUpB8K8ASZL/0Dr8d4FZz5s2bboybty4cCsrKxCAVa+ePU/17ds3lLkuLTUN3bp365+bm3tw1qxZMY0bNz6zf//+6Xv37l0ZFRWFAQMGLFjy85L5bu6mxIL/akGOebckCMZDvU/Lli3bXrhwYdCaNWvifj90qP27d+9OzZkzpzMj6H+N2pwR4EeNHr303PnzO3/99dchPXv1fC0Sir7Kls5ikajp5UUbDAa8ffv2kl6nWwyBwLzWAZNDm7uHR0sen39RLBaDz+fj48ePePPmDfh8PgwGA5RK5bUbN27kdurUycHSS94SErGEtrKyogVlZjKpVIo3r1/j3bt3YMr6pqWmEsUlxWwAkEllLR3tHLiOjo46y6ynaRnp8PbxqQ9U7evC9J2iKdSvX5/o378/mPTmNjY2uHLlChjTnUQiQXVJakiCgKenp1EulyMpKQksFkvEfv/+vYimaTg4OMDKyoquvFjMmyNNIzsnB4xXn0ajQUFBAQwGAxQKBdRqNXJyck7k5+fr3d3dv2hrtraxoV2cnSmRWAySJMHj80GWhRiIRaYNjqIpbNu+nWTSdcpkMty6eRO3btyCVCYFQRCQSqUiGxsbNxORyjcYy81+586djxMTE58w+baZ/PMSiQR6vZ4xFcgqVmsztaZUKrV5Bfl37t2/j8dPnlAenlX6VHwRjIpHLBJhwcKF53/++ecOr169ujBlypQWw4cPX+Dt7d3cx8dHwuFyAdAw6E30vH37dtz69esnvnv3zrBv//7ENq1b8xnVpaVdGAAePnhY8PjJ4zXHjh377fLlyyX169eHj7fPN2vXrp3CjKb6/pUvysLCAty7f/+oTCYLcXZ2rqhZ/WxUgIenJ/HjwoWo6e1tnDFjBkiShKurK7777rsBJ06csF2/fn1U2Q0fdu7cuSYgIOBbRm1HgEDv3r2bzp07t3Vubu7N+/fu9U1KSnqzaNGiF0+fPj3euXNnDBkyZOvCBQtHWjJzAhVZeVUObcz3zL+PHDmyAoBeLBY3GT9+fBMTTT6nisFggLu7u/Cbb76BXq8Pq8rj/ktgnmlvb49Jkyetmj17dsjp06cv/Lpq1Qo+j0dWFjgrmwwsY+WzsrP1Y8eO3QoArVu1lpj6/K8HQ7N169b9BACenp7Nx48f377i88upsnPnzme7d++e7ezsjC1bthyqXbv2v4yZV8Z/Gl9nqHLk6NEH48aNCycIAvb29oEHDx48GB0d7W157aRJk6IeP358YfTo0b26d+9++Pr16yNiY2N3KBQKtGvX7hzjtwBUf1j5V8BS2Gzfvr2Dn5/fxYcPHw6/dfv2zucvXnR5/fr1rr179w75syFoXbp0cXB3cw9ISEh4cvLEyecDBgxo+DUtsFlsHDpwkDp+/Dj0ev2rktJSlVQqrSj9kgQ83N1JkUgEoVAIgiDg6OgIHx8fc+haekYGLl26tL5Tp04Lq+s7l8clpkyZotDpTIdIg8EAdzd31PTyQlZGJgAg9eMnrUKhUAMQiMQiUY0aNfhOTk46iqLMWUgNegPP1tY23NRq1ZpVwGTGzszMhIuLi7nfOp0OKSkpZo21TCYDVQ1DJ0jTOHk8HvLy8mA0GsXs7OxsAZvNhpubG2RS6WeLxCxNUDTy8vLAeJ3n5+fD3t4eMTExpio2NI3MzEwyMTFR5e7uLv3SSxIIBOTMWbN0crkcQqEQNGWSlgwGA8aOGUuHtg01CQkaDXg8nimzm1oFV1c3NA1sCkaCcnFxUbq5u2kAcCtvIYyZ4LfVq8cUFBSgoKDA9NK4XMTExJhD1sqIprcUZBhOplartY529toXL14g9tw5skf37l8aVpWgUc4XW7ZsiY0bN13o1atnV1tb21N37txpv3TpUhgMhuFdunTxqFOnDi5dugS1Wn2idevWzzkcDqysrEJ8fLzNnSNQPiGePnlSdD42dvmDBw+W8Pl8aLVaDBgwAC2at/h1/ITx05ixWL7HqsB8f+r4yRf+9ephwsSJ0WwO+wvbpWlMWq1WvHnLFqJLTCcROWtWuUoZBLp169Zh1apVF0+fPt3Z399fa2NjU6LRacG3yPImkUiw/8CBvf369vXkcLm4cOHCgitXrsDHxwedOnU6HxISUuaAVeFUTj9+/EhBUTQCAwPFhFnoIPAqMVH7+PEjnX9df17jJgFcAHj27Jnyzp07i9zc3DB9+vTNHA6n2m2ERZIAAfX9+/eRn5f/fvTo0dWToBoYQYMFAm3ahLZs2LAhCgsLX7PK9KXVPbfiuymbLzStmjVr1rtly5ZBb9D/WxXM129czz9x/PjPALD4p5+2s9lsM1NhQMCk/ZoyZUp/AJg5c+bpmJiYesx4/lWoqsb0fwoIAA8ePEDvXr3aA4C1tXWtnTt33mvVqpVZu6JQKLB169aok6dOXggPDx+xcOHCbdu3bx+wYsWKA8XFxezt27ZfHj5ieBugYsjYv88HwfQkRnj28PDA7du3d4wdNzbm+rXrPWJjY4cOHDhQu2/fvtFfy9SZHXDqlMmbZn/7bdDevXuXDxgwYN8f2eSZ+zRajZVer8eQIUMoFotlKP/d1EeSIODu7m6wkkrB5/MZZzKkp6dDq9WCx+NBamWF8+fPL43uGD27Q/sOFQQChrI2NjYiFxeXdiqV6opZNU/TSE1NNV+bnZurlZfKnwAIl0gkBs8anrSLi4sp9lwkBGWkwGFz+LI/yI0CmObClStX9hcVFZmd6RwcHODj4wONRgOlUgmdTkeYvOyrAgFra2vQNI2UlBTodDohOy8nV8jn81G3bl1Y29igsp3YPJFoGvn5+UReXh7EYjG4XC7y8vLw9u1bc9Wy9PR0TePGjc+0b99+IAGizIHo8xdmZWUlZJFkI41a85DDYkOukFswHooNAPKSUrxNfG22r5Mkibi4OLx//x5CoRBKpRIkSbp+M2kSv3JfmRfUt2/fpenp6Y/d3d1BkiQyMzMRGhqKgIAAcwpPRq1R7vxV3l8+j0f8smK5cdiwYXBzd/cE/tFwofJEKx4e7jh16vTJN29exx05fHiDk5PTqTNnzuyIiopCeno6ioqKTBV3HBzg7e0NHx+fjvb29jyg/PR0+/Zt4/lz537Oyc1d/OjRI52Xlxfq1q07Pz8//+aLFy+u6fX6e+MnjK/wZMuxVTwRlp9klyxZMt/b1weNGjeuuvafmc4mHD9+PBYA3ad/v+Gm9k1gzAyjx4yJ9Pf359+9e1dLEASfmQokCOgMehA0EN6uncesmTMP7D9wYMyWLVtgbW3dfMqUKXNCQkJCTW1V9OUoKSlRPnr02PVlQgIEAkGmv7+/OYh81Ypff9u1Z/fi9RvWzwloEjAHAJYvX76yIC/f0DqkVcC4L5zOaZhUd2/fvvXat28fVCrVxpcvXy7w9/cXVBz1H9j8yq4rKioy2NnZcbhcrn7btm03pk6d2oaJ0WdaoWmAID5/PwCYkwUPgFZT5pHzZ09FfxbMPNi/d/+aouJi2tfHp9XAAQP8mL5VXl9z585dWlpa+rpevXrtx40b1wn416uGCZPUCKBaTeS/FZY0UcjlmD17dgcAxQBY+/fvv2TJzI1GI8LDw3vEx8dfiIyM7H/x4sVt69atG/Dd998dAA3eoUOHbvbp0ycI+JyO/764/PInWarhN23c1H3+/Pnn161dG71///4x9evXd589e3aUJVOuzoOcodLAwYMDf1u71vH9+/f7Hz9+vKFJkyZW+AKYOWdnbxckEAgwYMAAHU1RFoebMtoTJJycnSGWSMDUbZDJZEhJSUFcXByYxFUlJSW6X1f82iWgccAlBwcHi56a/mZlZUU2bdo0+MWLF1cYf62srCyUFBWbbegUTaG0tDQBQLhYIoGLmytsbW0hEAjQxL4pSIJEdk42ZWtvpwdQXnWqCsTHPygSiUSvfXx8QJbHuSM1NRUEQTB2dcqy4polyDJzNUVRTDp0ITs/P18oFoshlUphLZNVKwfSoFFcVKwtLCyEXq8HRVHgcrmoX7++WWr28PCgnz59ulWlVg0UCoSgqmmMz+OSQUFBMfn5+Q95fD6S3r6DXq9Hdm4ObG1s7QCT9JKZmQnKaASnrD7smzdvYDQazfncmzRp0s3ZyYlb3sdyZ7JRo0btPHXq1Bx7R0ezkxGHw0GLFi3g7OxsjjXU6XQQCYWoKj12qbwUKrVaK5PJYC2zbl7+lH8MzMR3cnKEk5NjZECTJpEvnj+Xh4WFXatdu/bThIQEODs5wc3N7fqzZ8+us9lspKWlLX/y+Mm3wcHBkJfKcfLUybg1a9ZMTExMTOLxeOjcuXOfCeMnrGoc0Ni5jp9fSd8+fWQJCQlHa3p5nV+ydGl0ufNJ5cVWkZkvX748Ni0j/aSdgz327tkjD2xaVfg6c6fpntjY2D0sFgtNmjTxM33PUMe0iHNzc+XFxcXmdIrM5CopKdEtW7ZsCZfHxbffzpkzc9asfp41asQQBIEOUR0kkrIyqlUxB5VKRbm7u8vT09NRWFhYQb6Sy+XyGp415P7165cAQPL798bff/99kUwqRVh4u608c8jX52A2j3r+/oMJEOMByGfOnLkyNjZ2XkVHoC+DmX+PHz86d/PmTSOLIPHuzduw7OzsJS1bthwTGhoqFZcJkCYZsvKGaILBYOAuXbqUC0DL43Krrf/+V+Pps2fYtn3bMltbW0yfPn0VULWW5927d6q9e/fOAYBt27adYxzm/tdgued06tRpwvUbNy5KJBL8+uuvFzt06FDBRjfxm2/2xMfHHx83blzUhg0b9o8ePXr+1q1bDwDAnj17rlbHzP+vwYicCxcujPr48ePuPXv2DNm0aVN0s2bNLoeGhrb7I/8cZme1t7dHixYtpp86dWrW8WPHjjZp0mT415gSZDLrBo6Ojrhz547RwcEBbm4VCxYSBODp6Wne42mahkgkwpAhQ5Camors7GwIhUJYW1uDy+Ve3rFjR3S/fv3OMymiacbURZLw9vYOPHjwIGQyGWiaBpvNhlqtRqlCbn5efkG+HADEYjGcnZ3h6OiI0tJSxMXFmYrrqNW6DlFR1Q6Kocf6tevWXL9+3ZyYjcViISAgAGw2G0ajEWUa7JJqCUMAjg4O4HA4KC0tRVFREUkWFBTQJSUlcHZygr2Dw2eGKTOxaUClURWpVCqoVCrTIEtLQVEUeDweOBwOZDIZMjMyb65fuz4W+NxTu7wjJNpFRLCGjhyO3n37wMHBAQKBACySBaFIVAcwFWLJzc1FfkEBCgsLkZ2djU+fPiE5ORlv3rxBbm4uYmJiehBE+YQgYZKC+/Xtt/bYsWPD69SpA5Iw5UzOyspCv379MGfOHNSpUwfBzYMR3DwYLVq0gG+tWhZkLid5SUkp3icnw97eHhIriWu1hP2TYN60lUSCkJAQyZQpUzpHtm8//5tvvpm//Ndf59+5fftaz549z+Tl5ZEajaZwx44dNy5cuJAzbfq0wceOHWtPEERSSEhIxKxZsy7t3LnzUGBQoDObzUaf3r2lkZHt+4pEIty5e7fj999/vyUnJ8c8IqZ0JVFGKxIEsrOzsXv37rPXrl2PnjJlCiQSCdauXfvbrVu35Ja0qIynT58arl69eqxx48YBbu7utGlcFecw45FMUZSpglAZUlNT1Ww2e4G1tfWC7OwsNQD07t1b0qtXry8ycwAoKioiRw4fgYL8fEgkkgqdI1gkh8flwqg38AHg4cOHmRKJRK/RaNlt27YNqKqPlRERES7y9PSIBoAHDx4s2Lx58zmY6fVlMMLRo0ePsGPHjkX+9epRffr0QdOgQOrq1auzZ8yYYde2TWi7o0eOLDx58uSbT6mfKIPRWOG9MLPD1tZWEBgY2AEA1GrNvzyPjDmW/Pbtc1IrqbaGp6dPrz59zBoNwvyfCevWrVuqUCjQo0ePn4ODg1nMdf9rYESwdevW3rl+48YGABg/YcLhUaNGtQPKabJt27b4TRs3DnF0dKy/YcOG88eOHbu9devWHzkcDn4/9HvsoEGDWgD/ecycATMBd+3aNTgoKKjHx48f0aNHjy5v3779Ks0R8/uQIUNGqVQqHD16bJ1arf4qQ4KVlRXXwcEBOdnZKC0ttWizbN8nSLNp1mg0gqIoyOVyuLq6IigoCEqlEqBpUBTFhEDHbli/ITo5ORkAcxChmf51YbPZVhRFmVO5CkRCWEtlkFpJUVailQJMjqyODg6oV7ceHj58iP379+PIkSM4e/Ys39bauko/MmYFXb16lTpz9swvBEGUZYkkzMKDWq2GWqOGRqOBSqXKp8x75+f+bQRJQqPRQC6XQy6Xy9nFxcVFLBYLCqUSMpl1tY4mFEVBrVLnqtVqsyc6i8VCUlISSkpKzLlzNRoNZn87O9qvrt+HmJiYGlXZSbgcDnQ6nfze/XvQqNXQarVwcHCAXC5nCQVCbwBmpzuhUAgbGxvcvXsXGo0GQqEQKpUK9nb2QcOHD29lHhiArKxsDBw4YOjNmzd3BwcHo6SkxFwJjsvlISM9A4t+/BG5uXnmLD4GoxHNg4Ppev7+FoQyQSGXIz/P5CsgFov/MiNWRTW46f+ssqQIACBwccGECRNiLl64OPv58+dLLl++HJqbm8tNSUnR6fV69OvXb9mgQYNmenl5md4Nyp3F1q9fd7Bnz555XjVqXLl27dqYvLy8Y3Vq1549YODAUJFIRLLYLMbxTnf1ytX7y5YvWyqRSGLL1D6SyMhI+c2bN0tHjBjROyEhIZbH41UM0Srr99gxY6fSNK0fMXz4YqFAYDasWErcJEmCzWaDLltM5pMeTZO1fH3h6OQE2kiTlmP4YxDIzc2FQqkERVXkcxlp6XRmVraZjh/epxwsLi6GRCSWubm5fsHJrxxcDhfde/bskrho0XmSIAyHfz8cc+PGje9mz569qGHDhl+MSgCAU6dO5S9cuHCAq6vr4zev36Bu3Xo9XV1dbRs2arRv9cpVSjc3t6uxsbFXSYJYcPToUS8HB4chzZs37xAcHBzk7OJCMEmVBAIBGjZs2P7hw4dHikuK/w0MHTAYDbhz585xqUyKBg0a9Laxti77reKYXzx/oTp06NAiAKxly5bPAv5zGdG/GgQIZGVlGSZ9M7kfAPjX8++wYMGCXgBjeiKQkZFBjxo1qicAxMXFxSqVSvTs2bMVAAwaOGhV7z69O5iu/8+kYXl0hknNe+XKlaONGzdukZycfG/QwIFdbt+5e4rL5XyVFqtNmzYyrxo1Gr1Levf02tWrBdEdO36eIacSxGKx0cHBAbll+eorg8Vi4eTJk9i4cSM4FnlUTNU8dXBydgaXxwNK5WamXlpaGvvdd99Fz5g+/XzTwEDzuvbx8UGP7t1n/n748PcGgwEqlQrjxo/HvHnzkPAyATCd/gnAtEY9anjC2dUFNby8YGdnB7FYDBcXlz5SmewzGzqzR+fl5eHnn3/uCEDNeLcDJjOBQW8AI+golUoolco0iwQ5n41779492LhxExwcHECSZC4bQFZGRgZ69uyJ8ePGY9nyZVXebKCM0Ko1eTq1BjoO10wwFmHKtqbRaMqT4RMEevbs2Xrf/v3HevboEUiiPJ6ZUW1kpKe7Hdx/AADgWaMGPDw9kJWTzeNwOBIA0Gg0RFFREWQymbnmtFQqRWJiIgBg3fp1Wxm7BgDk5eZi6NChna5evXqWKRbCmAJYLBYkYhEuXLyACxcvfDY2o8FIDh8xwkx05kSiVKlQWFQIW1tbCIXCv3RTrXyaqbiYTTm0p06b+t2Zs2d+7dWrl+7OnTs6kiDCp0+fvmDkyJEtK9/HCAk+Pj7YtGnT5e3btsUolcpzT548iUtNTY17/uJFzaysrMFdunTB/v379R7uHjuNlDGTxWJBpVJBJBJFxsTEHP306VM8gIikpKQL+/fvvzt8+PAWlW3tv674NfbBwwfr+Dy+X68+faKY51fe+NksFjgcjinMiKjon65UqaDX68Fil0djfc0Jj81hQyqVQq/TQ6/Xl9OPptG/f3+8fvcGuWUVithctreVlRU8PTxK3759p65fv77Q8v1W90zKYMwFgFK53K5uvbr5V69eXTxv3rwLrVu3ntg8OLh7ULNmEoqmQbJYAG2KK3/27Jn8wIEDWw8cOPBdRESEWiaTQSIWT/vu++9+9fT0REJCwnJfH59rjx8/fpz6KXWbSCzKLC4u/pCRkbEgNTV1wdkzZ31qeNUY2KBBg+j27dsHFhcX4969e0cdHR3h6+NDf5U08k8iKSnZeCH2wn6pTIrmzZvHmOhjcRIq68GC+fNX5OXlYciQIT/WrOnF+s9kQ/86VF4P48aN+5kGnQaAvXXb1lN8Hq9ClEW/Pn2nAUifO2fu2gYNGri2bNmyBwA0Dw4O2bJlyxTgPzqsvgJomFTNGzZs3N+zZw/vh48enV69etXVWbNmhVV3Urf03eHz+ejWtdv4TZs3jT537tyR6I4dx/6Rc5xIJIKNjQ3S0tLKMrB9DqPByGZiuSuDz+dDJpOZzaoURcHGxgY8Hi925KhRYdOmTVs+ePBgcxaYX5Yv//b3w4c3qFSqLMCULfHx48eoUbMGCvILzF7nHC4Hao0G2TlZcHR0xNgxYyGVSaHT6bzKKoRX2PMIACkpKTh69Gg0j8e7AKCsZoMpbp7L5kBVVhYcALRqDbQaTZ6xWqc4QKfVs5VKJdRKFVgsViFbrVYXKxQKKFVKaLSaarWKlNEIjVZbqNFqwdVqzd+zWCyIhEIo1WqwyrzdbWxsQFFUWq+ePYO3bdt+bcSI4a2Zl81sTE2aNOlXo0aNb+rVq2dWNzg7O7NAmCqRqdVqVUFBgY7P50MqlaJDhw5ITEzE48ePMXDgwFW9e/duwPRh586drx49ejSZIGCu8MIQhSRJU3iaUgWJSPxZDGupQg5nZ2ezWGe52WvUapSUlMDT09N86vv3wNSLtm3bCi9cuHD3xvXrZ1u0aMEdOHDgnAYNTMOuagEwfQ8ODoarq+vZn3/+ef37lPdLSktLMxwcHFJUKtWCM6fPwGg0gsvnIfXTJ/j4+Hi5urrOnzZ16hBXNzeoVKrwOXPmNMvOzo5fvnz54IiIiLfu7u4sAgSKi4tx4MCBs9euX+vk6uqKBQsXHLC1sSl77udMnSTJcomZsLCwU6aIhn8kppjFIgkWmw2dTgcjVS65UpQRffr2wbvkZLx6bRL6mjYNjCEIAmnp6brv5s1bcer06R8sN53qBAipVEoDwOQpU9Z26dy51ps3b4arVKpH58+fH/rp46eh02fMCK9Xr15IWFgYkpOSkJSc/FYsFh+8ePEigoKCIBKK2oSEhMxdt25dJNNmUFCQJCgoqLNWp+uckZ4+7/79+w9v37oV9yk1dbtSqcxIS0tLfv3m9YKkpKQFL1++bLN27Vp+QUHBRUdHRzg5ORWVedD9KVp9CVWN/d7du9kCgUBbp3ZthLZt27yq69LS03H23LlFAIipU6dOr66tvzMsx/v4yWPVqVOnlgLA8GHDfgouK6Jk4Wfy7tad26ttbWz9fvr5p4mxsbGv7t69e5wgCPbCHxcdYrFZ5tb+XaFp/wyYNR4REe41aNCgX9evXz9txYoVPfv06ZPv6elJfk0Cq7Dwdt1Xrl41+vSZM5uXr1gxVlhFDgZLCAQCyGQyvHz5EhqN5jOnOACwklrxAMDW2uaz+zVqDeSlcrA55b6+RqMRDg4OYLPZ14YMGdJUp9Od7d+/f0ehUAhPDw/2ps2bf/9p8eLWfn5+yMvLw/59+zBx0jcgWSS0GhP/0+l0dO8eveRqjRpcNgd9+vfFp9RPaNy4cQmz71n6WCQmJuLXX1dG+/nViZVa5N6naQo8rile3vI0rtVqodVo5TRFGwGwqhKXrKys2My1AFRshUKhYTZVsVj8mXdzeRw6aINOrypLo1dOGIMBBAgzMwdMEpCDgwNKS0upkSNHtHFwsL/QqVOn9sxJHQBCWrWypSjKJj09vXDy5MnYt28fnjx5IndwcDCankcTNE3ratSogZYtW0Kn0+HmzZto2LBh3z179kwBgJycHKxcuXLPsmXLho0bN45i6ipXCG0hCOh1erBIEmQ1Od+5ZR5ylZ1/tFot5HI5mGQF/w5YWlIJAO3bt2/SJjS0CZ9XHu71JWmWUV27u7tj48aNExISEkbdvn37ntRKev3qtat0wvMXVJMmTVhh4e1QVFQU1qpVq5Z16tQxh1UJhUIsWbJk87Bhwxq9efPm/bRp01bs2bNndm5urnLx4sWTLly4sCM8PByLFy8+P3To0EblQtrn8jlJsiCTycBisWDQ680/UzQFiqLKs379CbBIFkGSJKnVaSmjwVIVRSAtLR2ZmRnm+uytQlpxnZ2cO755++bc6TNnfjx+7HiP7j2617N0PqsMrV6PBw8fFJAkiUYNGwa3bNmyxi+//PLszOnTO61tbHadOXPmZk5OzuUB/ftfLiwshN5owMGDB9GiRQs0adIksn///uNq1arVtTrBi8flombNmtyaNWu27N27T8tPHz/Oi4+/H3/u3LkLp8+c2RwUFFRw+/btGwUFBQgICIBarUZWdnY3gqi+z/8IKgheMDu67c4vyEd2dnZXF1eXCkoB5voD+/ff1Bv0hu7duo9o2LAhD/+TsKhCt37DcqFQqJZIJB6LfvrJbH4gYXJ0mjF9+iAAWLlq5TEA2LRp00AA6Nix4/yIiHCzX85/OiNnQKA8PfP3338/9fbt25ufP3/+dvbs2csPHTo0+2vSw4a0CrH1rlmz/sdPn55dv369ODo6WvYljRmXx4NYLIZSqYRWqzUfVy096HlcrhTAZ/u02TatUoFb6TeDwQCpVAovLy8cP3485vnz59+MHz9+uZ+fH2/M6NGtxCLR+ezs7Oi4uDhwORy8ePYMR44dR/NmzfIjwyMglcoEBoO+LkEQiUOHDUVaejrOnTuHsLCw/iySNEf7AMDt27exZMmSKA8PjwvW1tZmcyFN06bskKSp/rol7zIYDNAb9Hqj0WgAUCXzYnNMKk61Wg2SJPVsjUZjZFz92SxWteFKNE0Z9EaDrjJDZ4jGIlkwUAbzpm00Gs3hbU+ePOmgVCrP9+3bN4rZ9j09PPDLL78c+fHHH9ulp6fDy8sLpaWl0cHBwQIAiIyMFG3fvp12dnaGQqFAcnKyaOjQoZunTp06AAA2b95849WrVz8nJCTE2draQiqVfmZfIQgClNEI0DR4X2DIbA6nwvGbmVx6vZ7WaDQQCoTgcP+huix/Gpa5tBnmzDDzr7WxWYab1K9fn1u/fv02FE216dy1M0jCVA9eKBTCskqdZctDhw5teODAgcGXLl3a8+HDhx9XrlxZePr06b3Ozs5Zep1eFBwcfGzo0KHtLftr+WwGBEGgsLAQKpUKllI4c7LmVKgbwIgEXx4jySIJFoskdVpdJYYOcwQEYKoFwOGwiS3btvzeulVrMQDj9BnTh0a2j3xQ7g/x+YlIXlJC37x+Y19gk0AIBAJnAAgICEBAQMAwhUIxTCwSldo7OOy0t7MvfvrsKZo2aYr5P8x3bRTQqE9om1AJU/3NkqaWmxVl8S2bzYK3jzfX28e7Ve8+fVrdu3dvXmpq6uHHjx8fIQjilqura4dly5aN8fX1DbVUff8roNPrUKd2HeXkyZMgs7Zuy+PxKjoclv157dq1HVZWVujUqdN4yzH+b8HESB4+fFiyfceOpQAwZsyY71zKDhQMrQ4dOvQy8fXrBw72Dn6DBw/2u3Xr1qsrV648A8BftmzZTKC8yM1/F0zCpaOjI8aOHbtjypQpLX///fcfvvvuuwmWYaTVQWolReeuXbpt2rgp4emzZ79HR0eP+ZJjHZfDMRddMej12qquYXM4MgDmsLUK93O5MBoM0GrUqFzIi/GMt7W1hU6nW7t48eKz/v7+G0eMGNF+wIABUVeuXLm1Y8eO8RRFJZAEiRvXriGgUaMupnFYcbr36DEzJSVl2KjRo7Fu3ToEBgZOGjJkSH2gnJmfPn36w8SJE/sFBATE29nZVTiF06DNfkaVcyxQFAXKSFEUZfyMNIy0zWazTBohgoBWq6XYzEkJAEjW59VHLBLLUEaDwWC5aVaGSXqzyPRL0+ByuXBzc8PVq1ej7927d2zlypXdGaL27ds3jMfj3X/8+PGFLl26sNevWzePVxb+UqNGDcH3339/7e7duzdkMhlmz549xd/fX/r06dOiffv2fXfkyJENkZGRqFmzJhITEz9zkDL3gaLBZrEAkqw2cJXNIitwe2bMRr3BoNNoweFywCL/bZk3K2zcnyco/HpUyKJGlGfhq+r38ueZBIElS5bsuHTp0u+5ubmqvLy8ZS9fvoStrW378+fPHw5oEmBleX8FJm7BJBVKOdG9e3d4e9XEqDGjzVexSBZNURT0ej1IkqTLn/3HI2WRLJLFYrO0Oq3BQJULljRo6A160LRJ1c+01SqklWjx4sWx3333XdTHjx8fjR49esmBAwfmMgJTOUxrIDMzk3Zydi4gSQKenp56ADzmRCIWizF8xAgrAJOVSiUaNm4ELoeD7pUSDn1dDDFdwYmIzWajVatWQgBD24WHD1Vr1HKplVTCOKb91Q5Tn/eJwJOnTyQHDx5Er169stgVZHsTbdLS03H37t0DBoOBHxYe9lVRA383WHqC7N69+xiPx9PwOFzr8RPGDwfKHeFomsbmzZvnWFtbY826NccAYObMmQOVSiU6d+78nZ+fXxnn+e+iIG1e8yZa9O3bt8WhQ4ea3rhx49GWLVuOrVmzZsiXTunMqdW7pneUg4PDj0nv3j02Go2fMVpLsNlscLlc6PV6GI1GTeX+ECDAYrNFAMDiVHMmJQlo1OoqExMxjtMymQxisfjDkSNHOmzcuDFy4cKFM4cNGxZ+8uTJFwcOHFhmMBrVsedjg5u3bB7OPHf1b6uHnjpxUvDw4cM30dHRwStXrmxvqXVctXLl5WnTp/fw8/MrdXBw+Ix3koQpvqXyIdlEKxoGg8FAVcfcTPfzAJNfQ2FhIUg2m22Wakjiixmt6DKgqg/oqr2UGWL5+Pjg+PHjPSIjIydkZWWZf+/WrVuzBQsXzo/u2HEec4ouY2JETExM6E8//TR/8uTJ862traVTpkz5cfPmze7p6ekbPD09IRaLqxUuygdMgMVmg0WSYLFYn30AgCRJruU9FicqGjBNqH+00tp/Cqiy06Hlp2qYpO8mTZqwRowY8XNaWhqePn2K0NBQcuTIkacqM/OqWyibBzSgUqkItUZTgX5CoZA8ceKEZOOGjRLCnMno67zcSRaLxWazuXqdDpVP6Myi4HA4FdqaN29eh25du/YBgIMHD/5w6NChJ6Z+lveV6d3RI0c2J71Phkaj6erv7y9i2qhMN5FIBAGfDxbLZAP9Y7p+GZb3Ojk6wsuzhsTG2trc9r8aRqMRd+/dfZefnw9nJ2cfoHzTZih5MTY2xdHRUT9y5MgB7m7u//I+/SeCeRNyhQJHjhzZwefzMWHihCk+3j4syyvu3LlT+vz587Pe3t51+vTu43f+/PkP8fHxz+rXr89etGjRVOA/16v9a0HD5JkdFha2EACOHTu2rqiskNYfIToqOlgul+PQoUM7s7KyaFN7VdODIAlzWlUaqMD5zOuXIHissgRnVX04HA4MRiMIgjDHqlcGc1p3c3NDYWFh3Jw5cyL69u3bRa/XZ82fP3/WiBEj5neI6tBeaiU1r0sHeweMGj26T6/evef37NmzvaWG7syZM+e2bN0aAaDU0dGxSl5FEqQ5CqjyBzBllflSAiWSZTqhi8ViiMXiPwyt/WqY3ggNgq6aqQOAl5cX7t27t2H9+vUxCQkJ5t/ZLBZMNofPN0SCIHDmzNkXzZs3b3Ht2rX5Pj4+SoZo1Y2UIdB/RCqp/zqU6wTWr18/rUaNGoE3b97Eu3fv+K1atTKXw/walPksEFwuB5SxXMj0rOEpGj9+fEbvPr0yrGRSUbkl7CvaJEk2h8MRanXaz6RarVYHY9miLR+NCTt37TokEAh8ABjHjR07sLi42PxM5uozZ868Wr9+/XiNWk0s+WXpr1wul6hKNK4sGP2VZyyqrDXa/Pd/zRyuTG+lUkEXFRadF3B58Kzh2Qko93Bnrnz06NGej58+oXbt2s3/apv+fw9Moz5/7lxabm7uHU9PT7QLDx8HlJ/OASD2/PnfVSoVmjdvPhkALl2+tLesqNWgBg0afNkL7L8EzNzs3r17ey6Xy83MzHx04viJ50D165n51sbOhvL19W3j4OBguHnzZsbXPO+fLcrDVGADYC5XWpmHMAdUa2tr1KxZE8nJyad/+eUXzzNnzsQyZsOqEkExmjTA5NvVq1ev5XFxcTH169c3+RBVcQIHTAfOv3KNk0ajkfGQA03TRlNHqwRRBnzxU82DGCbr5eUFgUBwbkD//o02bNhwm/ndMg7ZspXLV67oO3fu1FwkEt2rVasWjEZjlYycxWKZv+dwONDrdSguLAZBEGbbalUfAKAoSlehr8wLKxuvwWCowJD+zmDSh9Aw2aNWrly5y9bWVuLp4THE2kL6rO5NV7ShkwQAgqZNXu3MHXwen+jVq5ekX7/+EiFfQDCM4+tU7gTYbLZQp9XDYLRYJDRgMKnkyr9AuXgilUqxcePG/RwOhyguKXk9fPjwgUyfCJjqoA8bNqxfYVERRo8ctax9+/Y1Ldv5d+PfrYhVqzUapVKZ4+rqCrFYLGV6wUCv18NIUQWNGzWCi6tr34q//u/AzLBjY086OjqiVq1aQUFBQfYAzATRaDT08RMntul0OgweMmQEALx49mIPn89Hhw4dRlhc+reAv78/q0mTJkN4PB5SU1PPA3/sFyC1kpKBTQPbpaWlISEh4XcA1eZ4YKJiyvhLBZ26OUaepnXGKk65lh8+n493b9/h8ePHZs0xaeHMXaHdsu8kEgkCAgL0N2/ejN63b1+saWwVHfgolL/PN2/eYP369Z3u3bs3q3JGO0sQBAGSMGkPCFTNSwGAJMgvyjGU0agDTJlVFQqF6YTOdN74Ba5FkgTJZrPZVamtq1JjVwej0Qh7e3sIRaLnEyZMaPXb6tUXGSKV5xc3TQilUolZM2dGkSSpkslkMBqNVapLCIJAaWkpOBwOJBIJeHw+vGp4oaio6IvM3FzyjqI0lfsJACw2h8PhcaHT6Soyj78x6Ar/Ad26dat7+tTpjPUbNmxgczhfVd+a+Y3FIgiURaBbvrPPVf9fv72RJAtsFouv1Wo+U7kbjQZTeVzTYz/rz5AhQ4JGjx79GwCcOHFi/48//nhWp9MhPz8fffv27VZQUJAQERHRfu2GdTOYfv5f4N/BzD/Lg0AZaZqiIZFJwePxdEBFoa2wsEi3bdu2w69evUKDBg3Ypt//N6FWq+l7d+5eIwA4Ojq2l0hM2Q1Rll7p5cuXRF5e3gNvb+8GTZs04dy/f1+e+DrxfUlJCbp06dIS+G+znFcPZhQdO3bsIRaLsXfP3oN5+fnVbpaWYrtYLK7LJlnIycpOr+4EC5giqZgKaCwWq4LXGzNHjQaDAgCMekO1H9AAi2Rh544dOHv2LNLT000Oc0ZjlVFMTLTW69evkZKSghUrVkTfu3cvnzA/u/xPAsDTp08xY8aMaJFIdLZmzZrVHj4JggBBmjLEkV/goyQIsNgsNklWkZecoSdNmxk6AJA8Ho8pBgWDvnqqEiZ+zmWz2fjSh8vhgM1if9H5gMPhgAkxmzJ1aofz586lV2XPnDt37vanT59e8fT0xMuXL5GdnQ2tVmvOVAeU10fW6/Xg8/nw8fGBWqWCo5MThGIhSktLodPpqv0AgF6nqzJbAZvNMpeKNej/Nxi6JZil16JlC0nt2rX/dGEakiBBgiD/yvhpkiDB4XCsNZVU7gRMnu2UkapSNccw51WrVn0TEhISCQCXLl3qdObMmYUTJkzoERcXdxIAb/HixRe4nOpzvv9dwWFz2Dwul1N2mvmMgCqVUu3h4ZErFAqDnRwdecDfhyn9WaSmphrr+dc7weXxUMPTsyzFa/n+dfr06XNsNht9+vSJBoBjR49tpCkKg4cMHlrTu7yK6teamf6TwcyBTjEx7SUSCXJycxJevXxZ7cAsnWY7de7UtXGTANy8eWN7bm6urrp7dHo91Go1eDwe2BxOJYZugkGnKwJgriNe1UejVsNg1ENvMGVjk8vlMBoMcHZyRnp6uinyp+zETtM0JBIJcnNzcfToUcTGxuL58+cYM2bMUIPBUKZNYA6hQEFBAfXtt99Gq9XqWBaLxTj8VjkeNoeDgrx8GAx6cNjsau3+pMnviySrcOBixq03mE7oZQ7oJCkWi3nMBmiofORB+aQjCBBsDkfwRwydxWZDwNgnyjzohUIh+Hw+uFwuaJpGSUkJEzcHAJg6bVpfuVxOW4YtZWdnIzY29ocaNWrAysoKHh4eyMvLQ3x8PJycnMDhcExOACQJiUQCd3d3cLlck3q8zKHAxdWlLDhfA71eX+UHALRlnL3yLOTz+ZBIJJDL5SgrePU/B8amS1nYUr8WBEmyOGw2y7xI/oL+kCwSHA7HyqA3VDih06Bh0OvLBEZ2lcyGgikj06JFi84CpnoBt27dWmA0Go/XrVsXmzdvPhcUFGS+8++w4X4t+AIBVyaT1S4oKIBareYAFRl2RkYGq0Xz5ujerVs4uzpP4v8RxMfHF6Smp0FmLUPLkJA2QEVfA41GcyUnJwcymawlACgVCq2Pry+CmwXX5LBNoZp/t7nl6VXDKODzQ5RKJS5dunQGqHqMlmGu9g4OuoKCArRq3UaekZFRZTgaAGi1GigUCiYMmlVV21q9Xg6YUoZX9WEYul6vB5fLBYfDMRdB8fD0wM2bt5Cenm7mKQaDAdnZ2Xj79i10Oh3EYjFsbGyQkJBw7sTJk5+YsTBmgoEDB86Li4uLffDgAb7//ntzQjKJRFLBGY7H5yM3JxeJiYmQiMRf5KVsNhscNofDYpHVLji9XqcHAAGfDz6fz2HLZDLrvLw8FQBkZ2V9QeVOgsflWvN4XHOlsupgYuY0UFaYo6CgAMXFxQCAwsJC/PTTTyAIAky2nHfv3t0ZP3780r17985hXtTvv//+OCkpKbN27dqm3LZlDgyvXr3C69evodVqYW9vj1evXpmlKoqizFoAU354Rzg75yM988s+F9lZ2eajnqWjA5/Ph5WVlVkA+V9EdTHmXwOSJAgWm836Cw/oYJEscLlcsUajgcFoMOd+pVF2QqeMZba26mz8QGhoKGfTxk0Xtm7bOmjbtm3yZkHN+KtXrz4QERFhcdr63zqBCvh8ODo6tn799s3LkpKSTABeQPn7T3yVyFKq1ejZq5ecCUz4b8hs9leCoUVmRsbex48eA4Czt4+PDoB5Q1QoFMjKyiocO3YsoqOjY/R6Pfbt3XdQrlKga7du7QiiYgKrvwvEYglrwIABPW/fuXPb2tr6lpGiurJI8osjdHRyFMik0vY3b968GNUxmhsYGFjldWq1GsXFxZBKpRAIBOYmLdd4aUmpBgAKigqrbINFkBBLxOCzK8apMz5W1jbW2LdvH8LCwmBvbw9vb2/4+fkxp2TQNG0uwf32zZu9RqPxO8a8fOTIkRcXLlxYymazYTAYoNVqUVJSgmPHjuHdu3eQyWTm9LPOzs64dDEOBfkFsLOz+yJNeTweeHy+FUlWHzMtLy01ACZBgcViCdkEi3R2dXfL6NKtK9qGhoIqy03NwBznR7LAF/AdeAIBeIIvZ01jKmxxOByUlJRg9uzZAEz2cya9HaN6Z7Bv377F06dP/6ZRo0ZiI0WBx+Mf6dGjh7mWLQOj0Qgu12TXPn36NORyOTw8KlQpBFBWTEajgV+9uojqGA0BXwC9XofK53CD0YDg4GDactzMFSKRCDbW1kj58AFqlfq/O27tH8Q/s+kQBEmy2WwOTdNl2pB/fgMrC0GR6rRa6A3lydwJGmbnxaoiLRgw83nM2DHtg5oFpd64fqPEx9dHEBERUSm2/u+NygIPj89DDa8aToarV/Dp06dzACZa+rV8+vgxUyaVIrx9BItZJ38nhvQ1YMw6gYGBBcOHD8f75PfDZFJphdNNbm6udt++fQc7d+4MX19f5OXlISom+nWNGp5o3jy4BfD3pBuLJPEuKSkzPT0ddvZ29jq9DgJe1XyCmVNikRitWrVq9duaNRc/fvx4C0A4I0pbQqlUo6ioCDbWNhAJRVW2yeawDUx1tM9+K0sVzThtV+XZLhQKoNPpEHcpDiHNW8LNxRVGvQEai3oRAMAh2Xjx7HmxRquFSCiEwWDAjBkzxgOm0DGm+mhRURGOHTsGwFQ2NiUlBQqFAo8fP0ZGRgYcnZ0qmI6rAk+vA1/AtyeJ6lkPl8s1ikQiCERCkCRpw+bxedb2dvaYPXs2BAIBKKMRZBUPIkkSQpHIUSAQ/GFec+Y0bWdnB4PBYC7cwmazzaXiLIlKEATS09NVBw4cON6oUaPBAFC3rh83KOhziY2mabi7u2Pbtm0oKSmBlZVVtY4HRoMBhUolBg0ahN59eiMnO+ez65iKOsaycVuqhMQiMezs7XE/Ph5yhfzvtwr/1SAIFpvN5hBE1Z6k/wgomoJery/5f+xddXwU19p+ZnfWfeMeIhBICA4BkuAhwd0LpUKFtkAV+pUqdS+lpS3QFne3BAKEBIiQAMETIEpc121mvj82s2wEqdx7Kzz3Vy7s7pw558yZ857Xnpfk8cDlcJu9vTabrVmZ1ru20WQq69atm7Bbt25C58//TXAeLcMAkyZPpnLOnUNxcXEZwB5s7X9yudyMzMxMJCUlCSeOn/hf7+tfBRRFITsnR+ji4oIO7dvLWn7P4/FMvn5+lr1797qSJImGxgYEtmuH2yUlUClUWgCtrvm7g7VoBQUF9Vi7di22bdlaOWXylPtexyEIdO/RwwYAFWVlZwAMbYsxTqfVcKuqqtC1a1dIZSw51h3iVxtFYdy4cRg2bFibQdkBAQH45JNP8NNPP93VuuyopQ4GuZcuIqipvkmr2h8aLTw9PavpJrbLffv23S4uLj7l6dm2gOZwOI7a5lVVVQAAPz+/B+JQsdlsEIvFPncLNKcoCo/Mno3BQ4bgrbffQkN9gzvp5urGSKVSXLx4EW5ubvDxabvsN0EQEAlFKrFYjPuR6TMMA4FAABtFoaqy0jGJbPpSW20LBALs3Llz/fvLls3i8fkcjUbDraysbHbiYhgGUqkUBQUFWLNmDaRS6X0ZhgiCwNq1ax2+dtZ8z8JisUAsFqNDWIc794F9gSqVSoSEhhI1NTWMVqstA9D+ngN/iGbgEgTB5/MlpFNK4R+FwWCgCwoKTnl7eUGlUjneTgZN1K/3EejsYc1ZeP/bTMdtg0HBrQJd165dEd2vv8JqtTZ79xRKZfn169ex9ue15OQJk/6H/fzfgqZpnD51iggODkbffv3MLQOfDAYDp3u3bvDwcB/L4XBQV1Nn/OTjjwEAH3z00T/Lcd4EVgkKDw8fBQDnz53fbraYPxeLxfe1avr5+TEAcOPGDUfKdCuBrtNZKysr4eHpAZlc1nRPp/QxhobZZHaYx50hk8lQUFCAY8eO3VcRZRgGIpEIRpMJGp0WMpkMFqulmTWLx+eBy+OayaZ34+DBg9tUKhX4fH6bbKUsE6tAIACfz4dSqYRSqWxWKfJusNlsEIlEbncLrmPAOPosk8pgs9qkpKurq0koFDrSvtrQde1/2n3eAovVHiDwIAiQSBDQhjm8LVitVhgMhiN5+fnG8PBwCUVRsFFUs0hBVqBv374dxcXF8PX1vWewGjvYhoYGpKamonfv3q343s1mM2RSKWi69cilchlEQiG/vr7e3NDQkAGgfdtL7iHahN0qIyC4f94+Vl9fb5BIJOUTJk2Ej4+P04NgHC8J7z4xHsBDIe4cxMXAHpuQl583eM2aNZ/zONzaGY/MavZ7rVZjI7kkOoT9u8+0DMOgqLjYEhwSAn9//1Ya3O2y22hsbERwULAaAKqrq7UA4OnuoZJKpf/Nko3/FTi/RwqlkhAKhKiqrCw1mcwmAPcl0Nm4YQMREhKCp599FjRDo7l52T63dfX1F6uqqhDdP5rr6uLa7DvA/kyKi4ug0+tbaeCenp5Yt24d8vPzW7lv7z4moKG+3m7ep5tzrDM2GgxFW4VN7oTz58+flcvlkEjadgU4g6ZpsL+9V5qeM6QSifyuXzJ2EpuamhrI5XJwuVyGdHNzM5IkicbGRjtrTavaq036KkHA1c2V4XA599XQ2c7zeXzweTzQ96jnyoLD4eLWzZuSa1evITw8HDaaAsXQYGvBOrTzokIcS06GM8Uea8I3Go3QaDSQSCSOgwDTVIgkPz8fEokEQqGw2WSaTCYoFIoWGqR9zGaTmVn86mschmFQUlpaANhT6v4dFDO/D83q/9pJYIRgiPualx4UHC6XeWTObORkZ0M4dVqzR8FyQnPvnrbZphD/Nwt24I6GNXXatPikxCT8sOqnn95e9t4yTw8Px+5YdrtMMHDgQLzyyisMRVP/1doGfzWYTWYzCAJCcWv5bLXaKzvKJFIrAJgtZgMAKOQKNw5B/EMnzf6+8Xk8G5/Hg8lsgs1me6BtsrKykgwNCcGIhAS7Auc0Q+xbXFtdk2EwGLBh/Qb+sg/eb3pZ75jcGYZBeXkFGjWNzfLJhUIhioqKkJKSAplM1szVyzAM9Ho9dDodJE2R7Sx4PB70BgM0WrsssTZlzwCwyySaNhMANBoNVVhYuEOn08HBRXAPaLVaSCQS+Pn54W61250hFovh6uLCJe6moTMM6uvq0dDQALVaDYlEYiA9PT0NYICGhgbQFH1XtlQOQcDdzQ18Pv+epguapsHn8+Hu7o601FSkppyEwkn43gt5eXn6MWPH3gDQBU2T73gAAORyOXbv3o3ikhL4+PiAYRhwuVzodDrU19eLlUrlIi9PT0ttXd0KrVZrYM0vfD4fZrMZ169fh0KhcETDA/bUJRcXFx57kHE+cYpEQkFldZUoMjLSOGJEAtX6BPkQ9wJBEODz+XI2kvTPQH1tnXTld9+j5Hap+NtvVzRbiHdoX/+Rls0/FW1lAXi4uxv9/P0gEPAbbt8u5Xh6eDi+k0qlwQKBADarzcrQDP480ui/HwRCgQAMA7OxtXWQR/JAUTR0Oh0PAPgCgQgAtDptHWPfZP5RM3fnMEzAYrOSVqsVHHDAvZuduAUiIiKITz/9DC8tepH5/Msvmn3HrlCBUNBIkiR+Xfsr8e5775J3vm9ynzEMSkqKubV1dc2UTalUiszMTNTV1YEtWcrlcmE2m1FRUYEuXbpMEAmFkQRB/HL79u1CB2U47HtJfX19K4pYxmHoBnR6HfXxxx8TDyLMeTwejEYjzpw5A5qmH0ijNxgMUKlUzN2yhBgwqK2zZ5C5ubmBoigDGRwcrAeAEydOQKfXEXfzdRIcjp2sRSJps0QdAEcyvtFodHRYbzBAeB/fBQuKoWG1mO0CnWHAOAleoVCIgoICnDyRArWLiyO4rrGxES4uLv2mTJmyr3v37mqKopCbm7v4ww8/nG2z2Q6w2jdr5igqKmrG963T6WA0GBrbGrdEIhG4ql369u3b90C3Hj04NhsFPu8f9T7+6XDQ5oJgAyFFD/huPxBOppzMLbldipEJIx5VqpXN7GsUZbsrmcNDtEbLFa9QKsV5eXkDaIZJuX71elGP7j2C2XgST2/PbufOnUN2drY5PiH+f9DbvwY4BAE/X18+AJSUlMDb27vZ994+PlAqFbh161YDALi6usoBoKyivEan0xlUKtWD+Sv/hmisb2BMZhM8PTy9hKL7pEI1oaa21majbKCotllKbZQN02fM4OTfuIGDBw6EKxSK1uZhmkFxSQmqqqoc7mCSJGEymZCXlweJROIQ1AaDAQKBQLhgwYJ9jz766FAGDEqKS5bMnDlzcnZ29l5WDnC5XJiMJgehjaNYCkWDpmgTAcBmtXG4XC4pEAjuGyPE8rF06dIFVqsVJEnCbDajob6erXnRCmazGXKZDHdLE2VoBpWVldBqtfDx8QGXy9WTahe1vrFRY2fKEYm5d+0YAUREREAoFLaZGsDhcKDT6XD79m0cO3YMe/bsAUEQEArsTGsPGhRlMpsr2fY4XK5jg3Z1c8POHTsdeX3Gpsh0nU6HFd99t75v375qto2oqCj1s88+u3/atGlStVqtZ7lx2Yh7Z/rYxsZGmMzmRIvZ8pFYJCaco9xJkkSXyMg+VVVVB5ISEzFnzqMPNIaHsINDcECSpLCtIgi/FewzuXEjf3tU7z54fN6T/s00cQagbBRIkvkzien+0Wg5TUqlknjuuecGv/F/b6SknDhxYMbMGS+wxyNvLx8Xo8mI9PR0Ydzw4f/trv5lwOFw0LdfP6ahoQHp6emClrnTYpGIzjl3DiUlJXtohvnRRa0Wvvzyy6isqIROp/tH+nbYd/PqlSsHGQBdunSZIhQIHuhk3aVLpAUA1C5qP6D1IZOmaBQWFhI8Hg8dOnQY2lZ8jM1GoaSk5HR5ebmD24TlI1Gr1c3iHAoKCoglS5Z898wzzwxlP+vQoQN/3759ewYMGNDbZDJltXQps20BYHnWSQCwmC1MeXn5A5GOsbzx+fn5MDURnXl7e6NzZCRomrJXXWsxeqvF6gjsts9NC7pmhkFhYSHXZrNh0uTJsFgsOjI1NVXz2aefIbhdEHx8fDQt034cwo3LxeXLl+mMjIxWkYSs2btz587w8PBAfX293UfQRDBj45IP5EcHAL3R2AjcoXR1TCQAggDYtDmGYaDVahEcHNxv8qRJ7QA2cpkAB0Dv3r1tDQ0NJEtocy9otdo8rVZrUCqVEnbiCBAAh0CHTh2J4uJinMvOEc6ePfuBxvAQdnDsXAPi+/H7PwgI2F/c0WPHwGqz4tLFi9qxY8Y4vmeavhcA4HJbHzgf4t5gAIBhwOORQS6uLrh2/VqizWZ7gU3FaRfUjrJYrTh06NCtpW8u/Z/29X8JDpeLHj16mrdu2YKz2dn6555/vtn3FqtVWFJSwh8/fnwVRVFQyBVEcVERQkJD0dDY+I9LWQPuHAwLCgrORkREYPLUKZ4PWm46ODjEoFaooFSqRgFtC620tDRSq9WiU6dwaVscKTq9znj+/PlTgD1IjEW7wEDExQ9HQ32DQ6FQqVSyfv37zQXssVCsg87LywtLly6dWldXl8X64V1cXXBg3wEc3H8ALq4uAOwENRyCwwMAk9mE2tra+1oF2fiv27dvIzExERwOB3qdDv4BAYiJjYHJbG4zQp5LciERSxm2/VaBvAyDmqpqqrq6Gt9//z369OmjI48kHqFMJhNxu/Q2QxBEyt3o3DkEBzk5OczPP/98144vXboUfD7fYZIX8PmgaApWixnmBwjTB4DysjIrYPc58Hk8hzWAJEkIhUJQFOXwk1itVigUCre28v+MJiM5ZcoU8Pn8ZvmBzrVmWVjMZo7BaGjl5OUQBPr06UPdvn0bGekZ5Q+S4/wQzcEjeXwCxANHdd4LXJKLCxcuCFavWYNZM2fxWr5INsrWdJr+w7f614GBnVipd+8+0yQSySPnc3MPnjx5Uj948GAJAISGhtI0TePChQtb6+vqfxZ5P6Af7R8EBgCPJJGZmSFfvWY1APyi1WiWClxd+axYc3d3E8yYPn2q2sVl3Y38fAQHB2PXzl1BVsp2y8fPN71vVFTUPzHDgqIphLZv711hj7qu5vPun2liMpuRnp4unDx1CsLCwtqkTWMYGhkZGbRcLkfv3r2sbb3cRoPBOueR2VaCywHZpDyIpRLkX8/DsWPHIBbd0bjz8/PNlRWV1wF0YPOV2BZDQ0Mler3eIXO8vb2RlZEFG2VzKLFckguSyxUB9iI9tbW19yWIIQgCRqMRFy9ehEgkcgRnSyQSaDVaLFq0CLdv324VbG42mzH/ufm2wYMGtdkuRVHQaDTnL168iKzss3BRq7Xkjbz8kLDQ9rXX8vNqG640XtHrdEaFXC5yXnTsoENCQsIAe2K8M8rKyjBnzhzMnj0be/bsad4pixlSiRTPzJ9vL8F4j+AoK2VDv/79GIqiIBIIQVltjsnlcUkoFXbqPLXabl2XyWTQabWHUk6erBsQG6t2Lr+3fdv2rPLycqO3t7eDJaihoQH9+vXD0KFDUV9f7/htdXU1R9OoabVSuFwSnSMjqe3bt+P8hfO7jAbDZ2KR+N9NZP0bQfJIPsMwf0pQnNVqQWZGhpZDcBAdEz0FuEMSAzCOw9pDef770bt3b1KlUk26du3a9s8///yzwYMHvwUAeoOem5+fj169ejF1dXW8lr7jfwNYjdDX1/eRbt27LwHDlN68eZNvp/C075JymRxeXl6un3/xBQIDAw+/9NJL8U89/dTsVatWvX0+51wSgKh/UuIr+67pdXpqw4YNuy5fvowukZH9OZzWJuSWsFqtOLB//y2RWIwXAhaY4EShy8JsNjOpqamH4uPj0blLJNOWtU+r1RJjx48jXV1dQTdp4h7u7ti0aROuXL0KpULp+K2bm5v5VFraT3PmzPnMOXy2rKyMWrhw4Z76+nqHYGUYBmAYBAYEOEbC4/HA5/PlAGA0Gumampr7UqHz+XzU1dWBbZsN9rZYLPD09MTIkSPx9ddfg7JRcLZs2N3DfM+7tWswGq3nz507Y7KYoVQoRDfybwjI8IjwYKPBSI9ISKht164dbbZYrABEd0qZ3glycnFxGebq4iLw9fV1EOnbrDZ4e3nB09MTdXV1rcwPLJPP0LihiBsej9LSkrsWqrfZbLCYLazmDYlE4jgZ8Xg8zJgxA4WFhY7oQy6Xi8qKCssH77//8YDY2I8BQKfVYv+BA5lLliyZaDAYWlXwMZvNqKura5aPXlpaypk/f34rjYPkcrFr9y7b/v37IZfJKxobNQYXF9e75wU+RDMQIECSJJ+i/5wI94b6RionO2d73959EBwU1KHl91QTrfA/ZbP8b4M9uD/xxBOLz5w5s/3cuXPL8vPzF4eGhgoUCqWkU6dO0SaTKe3ipYulERERgf9ETfNB0Ceqj6ffzp24cPEiTp06ldqnT58Y4I7AFwqFAz09PL/U6/UnAcSLpVKB2WxGZXlFmY2iHFrkPwE0AC6AkpISrtlsPiEUCjEsLm4scPdDC+vGNZlMhitXrmwxGI2+7m7ubVp8dFqdXilXnD1w4AA6dupkio2JbfWbsrIywcb1GzjOh0yGYcDj8zB8+HAHUykAdOrUCSWlpd+tWLFi4KhRo0YFBAQAAD799NPlGRkZh9kMLoZhYKMohAQFw8PdDWazXZRYLBYIhEIFYC/vXVFRQdxLoHM4HNAUjfqG+lYsqawCEh4eDn9/f7i6ujqIaAAgLy+P6+PjM5yd55ZSU6/XGbk8UuMmdkVISIj7pYsXA8nAoHa6uro6y6hRo9CzV0+O0WhwXNdSqKtUKnnniM5CXz+7QKcoGhKJGDw+H1abzVGE3hl8Ph8GvR7/t+T/wAEHJpPJUba0JaxWK2QyGYLbBYEBoNFpQXLtCrGrmytOppzAwYMHYTabwePx7AcAiwWLFi1qBwAHDhxIXrdu3fKCgoI9bFvsAcNqtUKtVoOiKKSmpjbrZ35+vmHSpElFABy1DdnNjQAxmGGYD1988UXaYDQ+VP5+AxgC4JJcDm37czb9yqpKA5dH3nps3hNoFxSkRzMaTfvB0TmA5SF+G9j3ffacOT0++OCDATdv3kx57733lqxdu/YLtUqFkJCQmM2bN6edSj11cPq06c/+kzTN34IA/wDOpQsXR1sspn319fXJAGI4IBwVCUePGTPmxx9+wOZNmxLffPPND0aOGPnUpo0blxw8dPCHWzdvrmzfvj1YsfZ3PxCxVtH9+/cfq29ogIeHR6eIiIi7Dso5XbK0pEQ8eMgQuLi4jFcqFG0GvlgsFvr/lr6BhQsXgkMQ3YDWa66yslJz+tQpU0hoqOMzVgtWqdWQymWgmlx+NE1DrVYbb968Ofrjjz/uajKZnvj+++/njxkzJmbVqlWQSCQOqzBFUXBzc4NIIgHB5YIAAYqmIBQJJQCg1+vNlWUVFvFdvE8cwi7vxGIxuCTX0S/HXDTtU42NjaBpGsFNpXVZ9ySHw5GoVaomZjanvPumGbBYLMQvv/7KzcnJwcmTJ7ldu3cTkGFhYdUKhcKg1Wqx6qdVmDZtGoGObT8MNzc3S//YGNrD3d2RS1deXo6bN2+Cz+e3uZGyA9Dr9aiqqoLJZILRYATRBvmHyWSCUqmEQCDA7l278OWXX0LQ5Ivh8/moqKp0cMIbDPYS5v379x/9xRdfPL1u3brk/Pz8oVwuF66urpBKpbBYLI66sgzDoLS0FKWlpW0NzXrp0qXtAF5jJ4zd3DqFdRzYq3sP5J4/b+vVq6c0Ijy87cl5iFYgAPAFfJJuMl39UfB4JDN37lycPn0aAwYMaNGg3eTO4XDAI8mHqei/Ewzslqnvvvvul+HDhwetW7fuy6FDh86ZPXt2l8jIyIGbN2/+8OjRoxv0Bv2zdyuU8U+HWCwmYgbGDt23b/++Xbt3J73yyitvy+V3DHeRkZG0QqnsefXatbPnL1ygY2NjVP6+fj56nf72vn37Tr/00kv9/inLkx3HoYMHt9XW1OCJxx+f5u7u/kBuyZMpKSkHDhzACy+8ILmbH7qwsFByMfeitWP7MHTs2HE00Dw1FgCuXLmyrayywlxWWdFmG6NGjoTKxQXmpmwrmqbh7u4Oo9F4/r333nvuwoULR7Kzs3e/8847u1966aVxXC4XfD7fUeI7OjraXueEpsEluZDL5TwA0Ov1N6qqqkwKpaL1vDQFhGu1Gvi3C4RKLrOTt7URQMflcu08MDSNmJgYh2zz8/NjXF1drQAEbTGU1tXWIT8/n5BKpejWrZuez+dXkWFhYXUCgcCQmZmJtLQ0YujQoc2SzJ3TuFxdXZnAgABGJpOBJEkwDIPExEQwDAM3N7e7PDY7vL29weFwcOTIEQQHB9tNES2CzEwmk6NMKcMwHL1eDz30ju9JLgm+wH5wsFqt4HK53mlpaXuPHTuW8/LLLw/t3r07ZDKZIwqehdFohEKhwJQpU8CWuHOGzWZDSEiIhhUIztPWMayjee5jj3EWLVpE9+jVM3vEyJE97znQh2gGPo/PsVissNmoPyzTKRtFbFi3Htfz87D0zaVNOwDL58yAsjVp6A9z0X832Pc9Li4uMC4ubnFSUtKHL7300qOTJ08+98KCF+LefudtzvW866dTjqdUjxg54t4v/T8QrOVu5KiRY35du3ZBXX3dmVOnTtUkJCS4sqWXRSIRZ/yECU8uX7787Nq1a3/u+vnnj0d2iXwk82zWR0lJST+zAv2fUgzowoULyMzM/DXA3x9hYWEjgHtbbhwMcLW1B1xdXRHZpcsTQNvzkXftetmBffuxYNFChHUII1q2QzM0QkNDi2c/Oseh/LGgaRoyuRw2qwVFRSUQOzH7sQRoXbt2RU5Ozp7XXntty8cffzw1JSVl7N69e/ew9dL1ej24XC7c3d1hsVggFAqhVqsZAKivr083Wc2orq5uNT6L1Qqj0YiEkSMA2BXae4EkSdy4cQPx8fFwc3ODxWKBSCRi3FzdHMx49j/vhPFVV1cLduzYwZkzZw7i4+ONubm5NWT//v1rIiMjabM9dF5fU1NzE0CYvWPNtVWxWEwsWbLErNfrIRAIQFEUgoKC0Ldv3wdKrK+trYXeYKfbq62ttZcrddLqm6j4+ADg5ubmCgBeHp4ODbtBYzdNNFWhwaFDh440NjZiyJAhQwDg8OHDGD58OFxcXBxtMgwDk8mE0aNH46mnnkJ9fX3rKHeLBRaLRWi12SBo4Q9xcXOhUlNTGbPVAoPJuBtAz3+r7/D3gMfjgyAMsFF/PMq9qLiYe/v2bfh4evkrFEox4KyIE6BpyvFs/yka0P8C7Jbx8y8/vxcaGrqzpqbm/JgxY144cuTINy+/9PKb33/3/dvbtm79esTIEctYU/O/B/bZGRYXFxjg59+nqKQ446efflqZkJDwBiukCRCIT4if+uOPPz6Vk539FYDHh8XFzf5+5cqP6urq1l6+fPnr8PDw+/Nn/8XBKnr79u07bjSZjP6+fl0mTJzYA7i7K4GVJSaTidmydWtaQ0MDEd2/f3DL37FtX8jN3VxRXYmcnBxi6vSpFgDN7Ns2mw3unp6iGTNmgOQ11/IJgoBEIkFWZhaKi0paKXIURTkCpn/44Ydp48aN89qzZ89ud3f3LtXV1bmenp6oqamB2WxG927dUVlVCbPZDLVKBQC4dfNWJQBUVLWu4gkAErEEKpUKGo2mzbQ0Z4jFYlitVrz33nuora0FwzDg8/nmMWPGtDGR9jVYW1tbd/nSJePOnTtx8+ZN7QsvvGAhv/rqK6HVapVpNJpKmqapK1eu7AUQ1hY1pFwul3C53C4Gg+Esh8OBVCqFXC6HTqeDVqvlGwwGQW1tLaXX6w2tutAU6RwZGYmKsgqcOXUagYGBzWhYdTodTAZ7HrpKqYwS8PhwcXEBn89HdU21vd51k0D/5JNPdsXGxnaaNGnSaAAN7MNja7GzsFqtcHNzA4/Hww8//NAsQIKFTqeDm5ubcPz48a3GLBQJxZu2bO4WHx+fM3z4cI7VZgOPJP9VW9jvBmEPZuRwOH/I2cquxaqKShPN0AhuHzqA3+TncrYgOXzof7jj/26wWoC3lzf3xx9/XP/IrEd6HT16dPnhw4enPjt//lvfLF/+9i9rf33/qWeefjMqKur++Un/IDgqMSqUGDl61GPfffddxoEDB74uKip6wx5gZV99AwcOVIR36jT8yuXLibt27bo6fvz4jt27d++Wk5Nz7t133/12y5Ytr/69D0P2t65R04gz6emvAkBgu3bz5TLZA40o59w5NDY2nomPj58SHBLiaJF9nwnYtehuPbrXt2/fHtu2bwv6dsWK1s5qGjiSlCipq61rs8YIW/lT7aKGwWBwCHU+n4/KykpcvXoVCoUCNpsNAwYMGHD16lXm8OHDh4YOHerDyory8nJ4eXmCxyNhMpmhVCphs9nQpWsXzpxH5zSjAycIAhKpPR3t0uVLqKqqgkAgaCZzuFyuo+6I0WiU1dbW0uXl5Xq1Wg2LxQLKZoPJbAafx/OVK+Ri57lxRlFh0W6dXm85evQojh49yjebzRby119/9Wrfvn0wSZJJgYGBiIyMbGQ5y9nFxm6YAqGA07Nnz5HV1dVnRSIRqqqqUF5RjsjOneNGjxnzS/sOHaQSicRSWFj4JIBdZrMjGB5GoxFcLhcWswV8IR8SiQRXrlyBUCh0+BUaGxpgMpmOAPhIqVR19fHxkXh5eelJkkRRSbG9PKa99u34RYsWjZsxY8ZrO3bs2C+Xy0HTNIxGI8rLyx1VdVh2HoIgkJaWBq1W26afX6PRwMvL66DZbH5ZIBA0+4FYIiGnTZs2QafT5ezdvUfeq1dvu4/2IR4ABHh8u+nKubrXb22D3UQb6uryGAbw9PLyIVpx6tsPjAzDAA/59v8w2I115oyZPc+cPrNmxYoVj82dOzf6u+++K377rbd+evnll5/87NNPF2/fseOLv7dg+u1g1+Pcx+ZOOXfu3As5OTk1y5cv3/LZZ59NZT2dHIKDefPmffTo3LmJC15YMGX8+PEXly1btnbMmDGdt23btmzZsmWLQkND/7YMSOy7vHfP3oxTqWlnAfAXvfzSVODegX7sdZcuXjzAFwjQp0+fAdwWbk4WFqsVVqtF1aNHD7Rr126aXCFvdXi0WC04knQkraysDM5xDCzYeh/e3t7o2LEjDAYDaJqGQCCATCZzRJVzOBxYrVbMmjVr6JkzZ45++OGHh59++ul4hUKBjMwMTJkyBdOmT0NJcQkoioLJZEK7du2IoKAg8AX2bhEEB1aLBVKZFNeuXUdmZiYYxl4F0mQyOQR7Y2MjZFLZ0EfnPvpuSEhIhEAgoK5evfppYmLiB76+vo4qoh4e7hMkYkkr7np2DrVaTZFUJkO7wEAQBNFz7dq1xeTYsWPNXC5Xp1AoEBUVBQB8m9XWZm4dQXDQq1cvPofDwdWrV3Ht2jUoFIq+zz3/fGKHDvYsIj9fX/gH+O/MvZA7XKfXJfH5fOj1egQHB8NoNMJiscBF7YI+fftiy6ZNqKmrbXaPxnztNZqh4erqSoSGhHLDOoahoLAAer0eFEXBxcUlYteuXTv3799/YtOmTZ8Ad2rOstW2WO5eiqJAkiQ0Gg2qq6shk8nAbaM2N5/Ph06nO1lTU6OXy+XNuJa5XC4mTJpoW/3TKvz6yy/pb73zNiAQtHlieojWYDX0P0L9yi7ghsbGfC6HA3c3N7Kt04HNaieW4ZH/nLSg/yXYHP+vvvpq7unTp/ecO3duz5w5czq/8cYbReHh4Rt27d795c8///zY3LlzI/5N7wN72OnZo6eyW9dur1dVVb21devWN15++eWpnp6eDrP7I7Nnd132wQc9buTnZ2/ZtPna1OnTIgYMGBCZnJycu2TJko+3b9/+xt/1MEQAqKmpwYrl3z7eqGnEmDFjlnbr2vW+Kb32SHEa+/bt/ZimKMTGxj4KNLe0sWBoGj+u/OGWl7c3Jk2eLOK2ERtTX1+v12g0B1jB6QxWmauqqsLt27chlUoRFBQEs9mMsrIyZGRkQCQSOQKnlUol8vLykp988smZP/3004aMjIxZmzZtWs/lcLFhwwaUl5ejpqYGAwcNorp3744zp09zauvqIGpiluPx+SgpKQFN04iKinLEa3l6ekImk+HUqVMQiUTQ6/WSNWvWHBk0yE4Y4+Pjgx07drw/ZMiQm8eOHduSkJCA7t27w2azubHxQC0DAa02K6L69hUEh4QgIyMDJpNJGBERQZJRUVFamqZLjEYjtmzZAqlUKho6bJjjYmcfOpfLRcdOnUxGowFBwcGIj4+HQq6YzApzdgPw9vLG4CGDY1atWpXk4eGBiIgItG/fHnq93hHQVldXi9AOoQgMCISPny+sFisouxAm9AYD5HI5+vTpw3Ts1BGXr16ByWSCWq3GoUOHDly4cKFg/vz5gxQKhUNoA4BEIkFtbS2uXLkCHo8Hk8mE4OBg8Hg8CIVCDB8+HGKxuJmZn0V1dbW0oqKCHxQU1OxzPsnDhXPnLYmJifBy99ivadTopRLpvzO89zeCAMDn8eyHrT8hF91sNjc2uVbaEOcEKJYp7h7lUx/it4GBPWAnMTFx9yuvvDIiPT390MoffpgkEgja0zR94s0335w9c9asHLsL5N8k1O3r+8l5T760Y+eODyorK2+89957K1asWDGfAAEadoHywfvvr50yZUr4ktdfnzh1+rTLzz7z7Mbk5OSI/fv3v5OVlfV8r169FH+vw9Adsfv555//kJGVeVkmkYq/+OKLxcCDBfpdzM017N9/IM3Pz69vTExMM5Oy8//XNzSYci9e3Jp78SK6dOmiaauGSEVlBefpp58WqFQqa0vrKyvQt2zZgpMnT+LkyZMAgB49eqCmpgapqalQKBQOCzFJktDpdFi1atXGjh07zlizZs26EydOXCsoKDh76dIlZGVlAQBUajUxa+ZMXLl8hc8WhKFpGgaDAb7+fg7iM/aQoVarIRaLkZeXB4ZhEBAQMIsV5ux8cUDgmWee+ezKlSu7Q0NDzeHh4bBZbcaWFLrs3NAUjXPnzokoisKEiROg1WqLy8vKNZzZs2frbt26VbJgwQKkpaXhypUrN+/G6sUjSZw/f9721FNPIzc3F1OmTEFE5wiHw5qN8gQADw+P3jqdDjGxsVCr1airq2vGAW+1WmG12pAwYgSen/88Hpk5C3NmPYKxo0ZxaiqroXJRI6hDCG2yWXDx4kUAwGeffXa4V69e/v379x9cXFwMPp8PsVgMXhNFrFQqRU1NDa5cuQKFQoF27drBpakym1qtRklJCQ4dOoS0tDScOnWq2X8HDhww37p1q/7OWO7UPVfKFVNdVGrMnvuouaqqiu88sQ9xb/D4fAe5wu/ZslpudAxbp6BVawwox0HNmQPqIf4IGDCgYc9iefPNNw9GREQkBAQGHi0pKf0RACoqKs5NnzZtAhu7cMcsSPxH3g/mL/Jo2XXZtWtXSffu3ZcAwHfffbfobHY249y9yZMnd3pk1iPPFRQWXHnrrbd+mDBxQnj37t1Hm81m27SpUycYjcYWhtS/Fgin/9n/bf8vLTWt6qeffnoaAF58+cWtwcHB5P2IZNic9c8//exTAHj++ec/Bexv8h1W0jv7alVlJRMbE1sHAGqVqs3o+Vs3b9n27dvHnDlzptl+npmZiS1btiAlJcURJE0QBE6cOIEbN26Az+dDqVQ2i7eiaRoikQhSqRTffffdqLy8vPM7duw45O3tDbFYDFZxDevQYTgAXLpyOeXCxVxcvHwJFy9fwrkL50HTtIMNjr2n0WiEXq/HhAkT0KNHD/Tp3bsD1UaQnEwm8+3cubPwzJkzePLJJ3Eh94KBTzY/xDiXjM3Kyqo9ePAgNmzYCBBE0fOLFmjIb775hkpPT/chCEJbWFioKSws3KbVaL6WiMVC582ULeSrUirjTUbjx2mpqfSiRYvA5/HLv/r6K8fv2O108eLFcRRFbdTpdR+fSjt1gRWqzlVrOBwOjEYjvv12OYoKChEQEIiiokLiDV9f9OjZE8/Nn6/ncknodTrMnj17+uzZs4cPGjRoql6vL+TxeGhsbGw1KeypyNXVFR4eHjA0VWVjGAY2mw25ubmora1tdR0Ac3Z29vpZs2a9dOfEbB9Nr969O48YNRI7d+5Eu3btqrt27er9b9JGfjfsxVnsB7nfOVXOfMsCoUAOhoFer292iETTbyiKum806UP8PjAAgoKCsHjx4oNrVq9J8HRzO5yeng4QBHbu3Llr3pNP7vxp1aoJ7PP6Tx54/yrvHWuR/Prrr1+/mJv7Xent21VPzXtq4pkzp3fy+XzHnvn+B+8vP3DwwIaPP/746cmTJ09LTEzc6+bmRtwqKDj24qJFP3+/cuVcDu4oEH8lNCuH3PRETSYTnn/h+Sm1tbXo1KnTiNcWLx7p/Nu227CvhfLycuzcufMzhUyufOzxx/u3dR3767y8PEoml2HhwoXo2atXbMv+AEBOTs6G7OxsfXZ2drM2+Hw+LBYL4uLiHBXYRCIRTCYTjhw5Ag8Pj1ZFxgC7XGLjw7p37x5TU1Oj/eKLL1KmTZs2wNvbG2PGjBEHBgb2YxgGubm5xwGguroaYWFh6N69O/R6fTNhTtM0rFYrm2fuFRUV9dLs2bMXOd+TPeicOXNmc3JyssbV1RV6vR5qtbo/Ox8todPprEePHt0CAJcuXRLczL/BKy8r15FfffUVPD09IwYNGnSD4BAahVxhqG9oMHt6eraoZ2uf5pCQkOgxY8ZIhEKh9vvvvweXy13h4+sz7JVXXhnOnt5qa2tx6NChirCwsOkeXp7jgoOCG61W6683btz4sry8vNLLy8vh9+ZyuTBbLKipq8Oly5dRXVWtnzx16oWoqKguri6ugwsLC48FBQV1+/XXXzcePnz40okTJ7aq1WpHHnyzieFwwAbiSSQSOAflscxBAoEAXbt2RXBwcLOyd0213BvbykX3C/DX79ixgzAYDExjY+M6AK/9VV/Avxr4TT50Gn+cY53H40vBAGaL2fF4HIKDsVdbc6ZOfIg/DmehzADo2bMn3FxdD/34008jDx0+fHDSpEk4fPgwtm3fPtHH1/fg22+/ncD6hf8TgpemaTAUAxDEX6IIDwMgNDSU9+mnn26bPmPGgJyc7F2ffPzx7jeWLh3HgX19+vn5Yd36dXtHjhgZM2LEiGHFxcWZv/zyS+qjjz4as3bdusdGjhrlM2rUqLi/sj+dAeMQPMPihj16/vz5FLFIzN2yZcsBkVDkELN3O7mzj2rr1q3HDSajbsroUctc1Op7/jYtLW39gQMHMH3GDLRv314HJ2ZINgpeqVQWjx071uF2ZRgGKpUKWVlZyM3NhXOtcoZhIBQKYTabUVFRgYCAAAfRTLP7N5XaLioq0i1cuHDZypUr3zh9+vTMHTt2bKAoyhAREYHa2lqMHTuWI5PJUFZWBovFAqlUCoqiHBwrxcXF4PF4Und390mxsbELaJruajAYsHr16tpevXq5REZGOuY0JycHmzdv/tjX15fp2LEjqqurpSEhIa0OSux+19jYaHjsscfKb5feRn1tnY/eoA/69MOPjpJz5swBSZJl7dq10wIEbt64IaysqBB3DAtrM/DL39/PEB0dDTc3N1y6dAlXrlwxLVmyJJ5hmE/lcvlTBEGc3LNnz7dJiYnHhifEc3x9/fy7d+v2WseOHV8LDAx8jabpI9nZ2RvOnj27rbi42GA0GuHi6ooJEydg08aNKCoppm7dupUBoMvChQtffuutt0Tr169fAQBLly59ys/Pr81oRhZisRh8Pt+R3ua8uVMUBaFQCD8/PwQEBDTzpWu1WtTW1nKsVqujWhwLNzc3qUgkio+NjT0UGhpqtdmsIEnew8C4+4AAQDpp6L9vpuzlcAGAaSp35/xMnQUO3ZTr/meUa30IO5w1bfbvAYGBmDdv3oGss2dfuHr16vLAwEAolUps27ZthE6v3/bhBx9MYv2d/xEBRQBE6zSH/wnYOZk2fXrs1998Myc9Pf3Xr7/5ZnxgULsTs2bOGsDO3YiEEdGPzHrkx3Xr182Lj48fe/jw4T1Hjx6dv379+hXjxo0bvmH9+vNTp03r8lcV6qzgeeGFF3anpab9GhgYiK+++vpARESE3SLDdrnNQ5Z9FjQaDVatWvUkALz62msvAq3XB2sFoGgafv7+t9u1a4ctmzZFf/fdd61y0qw2G+rr62XBQUEQS+xhTRwOBxKJBGfPnm1zHAzDgMfjwWAwQCaToU+fPvZS322Aoihcvnx5WUlJyRtff/31+vPnzxcVFhYqPDw8cPnyJeOkSZMMbm5uyM7OxvHjx1Ffb+drLysrg7u7e/yLL744PSIiYjaXy8W5c+f2BQUFvZOUlHR03bp15gkTJvTp0b3HNIFAMLumtubIyZMnvzMajefj4+Mxc+ZMFBUWEYHtAs0A2kypqqysFERFRYlomrYWFRRabDablmEYkCNHjoROpyteu3atvqiwEBfOnzf5+fvVAvBsS1ipXVyYDz/8sNkMtGvXDnv37n3l/Pnz74rFYm1AQAA6duyIwMBA1NTU5KWnpz+elpb2nEKhGD9jxow3YmNjf4mMjPwlMzNzFcMw669cvpzSp08fdOvRHfk3bmBY3LCpAPDcC88nzJr9SIKLSo2ss2dhMBhOBwQEgC8QtKIS5XK5MBgMqK2thUKhaJPTmzWnFBUV4cyZM6ipqWk5vLXvvPPO6wKBoFmIv0AgwLwnnxyYnpFx6LPPPquIT4gHSfIeCvMHAL/Jh/57q605m9zBITgMw4CxUm2cDu5UdLM/94fP5s9Cc9eb/e8BAQFISkz85r333hu+Y8eOWZ6eng0uLi5Ys3r15MRDh6bu3r1nc3BIMJwFVHNt/489H4ah6T+QOPGngjW9Hzx06Je4YcNunz179ugjsx5JCPALaIiJjXHsJWt+XvMkA2bf+vXr9w4cOPDxEydOrA4NDa395ZdfNk+bPn0AweVmT5k8OZjTFFT3v1zDzq4s9uT06aefHtqxY8d4AJg2deq+sWPHDLf/hrlnCAD71Xfffbf70qVLN+Pj45f06NGjTQJ09oBksViQlZlJR0dHY+bMmaNEQiHXuV8AoDford8s/2aL2XTHEutM23rX/hAEhEIhbt26BaPegPr6elAU1UpecAgOSspKzT/++OPO9957b8KePXtS2YODXKbAzz//PLBHjx4nampqkJeXh+DgYI/+/fu/PGTIkGdcXV0lRUVF9aWlpcsyMjK+OXbsWPW7774LDw8PhIeHw8PLK23f3r1p6enpS/RGg3bIkCFQKpW4efMmtm/fDp1Wp48dENvGpmnvY2FBoXXx4sW2uXPnYtDAQbVckmvlcDggVSoVTCaT/ueff+YBsAEwXzh/fiOAF9vSQFVKlVggFPStKK84zfoh7DlzHggJCdEKhUKIRCIYm3zXAoEACoUCRqPRWFlZufHw4cMbk5OTgx599NEFkydPfkEgEDzRtWvXirq6unV1dXWGlStX9o+OjlYwsBeTd1HZzTInU1KyKisrSaVcYTNYmp+o7LmGHEhlcodf/m5F5ymKAo/Hg6enJyIiIhxmEpqmodfrS0pKShh7OcQ74PN4MBiNtcePH4eHh8f6+rr6T0Teor8909N/HARxJ8rdZsMf3aB4PJ4EAKzWO9VeWhLL2F/MP3Sbh7gH2D2B9Q8vXbp05KBBg26uWbPmqaSkpO0CgQAlpaVbnnnm6ZoxY8cunj9//lCO0wP5K2qffxTsnKiUSnz55ZeJMTExIgDGOY/OGbp169aTPXva2aJJksS6dev2duvWLf6ll15aM2nSJNn333+/Sa/XE0lJSZumTpkS0/jjj9uffPLJfnZz/f/OAsgeotlddPHixfsOHTw4pqysDOPGjXvvgw8/HAU82PMkAJSUlNAfffTRIwDw6Wefvn2/aw16vTk1NXUtj8fDW2+/XeMc4c72raz0tm3QwEEXSZJ0ZDLV19fj8OHDzaqatQWSJNHQ0ABNYyOio2NAkiSoNtgsA4ICYbFYzlAUNUGpVDru7+fvJ3rn3XcTT6akfKhUKgXDhw9PCAsL61JdXY3z589vFolEG3fv3r1PpVLBw8MDvr6+DlM8W+LZ3d0dISEhWq1e56ArT05ORnJyMggCYZ99/lmrQw/7Jl24cH5bXV2dYfny5di5c6dx5cqVZhcXF5BPPPEEGIbx7d27dzsAx4OCg9E+LKy6LV8yAAgEAu6YUaPHNmo0p1UqFaqrq5GXlwebzXbXCWQYBhwOBwKBAJ6enqAo6tbZs2cXJCcnv6RUKifOmzdviaen5yszZsxwTNid2jJ2VFZU7mxsbLRduXKlVfscjr2qjae3F7yaOONbfm+xWGAwGBw+Ey6XCw8PD4hEIhgMBnC5XNTX1ZEXLlyo79atm6MGLbt4vL19xslksk/i4uIaCwsLxf/GetC/B1yS57SOfp+kZYU2j8dXggDMFnOb4QsOYpm/aMTwPwXNhTqB6Ohoda9evbf16NHjyJo1az7n8/mJeoMheeHChck3btx4atKkSW907drVVyqVOky3/xTB3lLpiY6O5qxdu/bI7NmzBxQUFKQ+NvexwSu+W3GgScgDAB5//PHDjY2Nw999992vNRpN7TvvvLMxODhYmJWV9fO8efP6i8XiQzNnzoxn48r/F0Kd3UHLy8vx9NNPv1pRUfFpQ2MjEhIS3ty1c+cbIIgH6hX7vF966aV3GxsbdU888cQHEeER92AXtP++pKREMHPmzNIvvvgCBbduDW9LFl2/ft3K5/FEoe3b65tioHDq1Cl7K00C3Wg0Oix3d/YH59sRUKqU8PPzg9FkQkulw6g3oLq6WmG2mCEWiZvJpuj+/fnR/fu/VVdXh6tXr94+derU+5mZmZ+dOXOm4bXXXnMIcQD3PFxQNA0Ol4vIyEh06NABBoMBCoViqkgsbpWnR8DOXx8eHn599uzZSEtLg9Fo7LlkyZJSDodTQXbt2hU2m83Srl07jZubG0wWMyiKUrfFaw7YTzbRMTFarVYLPp8PhUKBI0eO4Ny5c3fVip3BkuI35ZDbGhsbt+zZs2fLtWvXekVHR781efLkkZ6eniBAgLbHvsBqs6Fr166871asAEm2zkVUKZVIOpKE4ydOwGa1NjOdcDgcNvJwqFqtjrZare/J5XKKJElcvXoVmsZG0JT98FJVU20qv132K4DXOCCaResOHjKob0lxEb77/nv4+/sn9evXL+6hYff+EAj4TT70Pz5TQqFQSdMMtFqtqXVzhIMa+GE64X8edzgq7O+AQMDH/Pnzh82YMWNYcnJyxqFDh/bV1NR8UVZW9sO77777Q9euXWcOjxs+VSwRD+vVu7fQuSb4P0G4O+dPP/LII7ENjQ2HX3j+hfjredePT5gwocf777//w7x582IAQKFQ4KmnnkrcvXv3hCNHjqwfOnSoNjg4eHdcXJzsxIkT3+zZsychKyvr41defeVVH28f+174X5oj52TDxMTEusTExFlnzpw5NGjQIAwcOHDbBx98MOlBhTnb0pEjRwq2bdv2Do/HC/3ss8+WAHcPKGbvfez48cyff/4ZM2fOREJCwlDgTnkStt0zZ878unffvjarnrAyQCQSTZdKpSSAdSwHifNvzBYLThw/DoVcYSemaWHe02o0cPf0SLZarG9A1LSNEXf6uWXLlhNr1qz5pKCg4FBcXBxUKhV8fX0dEe73k4kEQUCv10OpUGDgwIHQarX2ALsmErS2YLXawOPxVSNHjkSPHj1QUVEhLioqEpAkCfKFF16Am5tbza5du6p3796Nc+fOQaVSlcx5ZE6rhliSiYKCAsFHH30EF5UaJI8Hg14Ps8WCjp3uUne1DbTU2mtqarJ++OGHUatWrRq1e9fufe2C2jnmlqZp1NbVcs0mEwSC5sH3JI/E7fIy5N+4AZFI1MoPYrVaUV9fz//yyy+TYmJiiFGjRpVkZ2evZkkERo8ejYkTJ6K6uhpmsxlKhZKx2ijwSG6zk3FgQKB567Ztvh4eHqVeXt7HKZqOs1MW/v03o/8UCMCRtmazWvFHjz9CgUDJ4RAwGI26Vm0x9mfNMAxIHhcPtfT/DFqnGNn/TcO+gatUKkyaNKnPmLFj++Tn5b1y5syZL48cOfJ+Xl7ehrq6ug2HDh0SjB49+uWxY8ZM6NmzZ3c3d3eHFmdv5w65CNBaA/6rwTl/GrjjT3/+ueeHcwlu8nMvPDcewNV9+/bFenp47OsfHT3KxcUF3t7eOHXq1M4vv/xy5UcfffSMUCh0+eKLL44NHz585IkTJ4bv3bv3NbPZnDxkyJAPx48f353d3O+WEvh75qhlBgMreioqKrBu7dr9q9esmR4bG6uzWq2SAQMGbH/22Wfj2TE+SNsE7FrxkiVLJgHAJ598skmhUDhmrO3r7Ci4dWtXXV0dkpOT3T797DMjABEca8IuE4RCYX1cXBw4HA6EIhFu5OWh4NYtSKUy6PV6iESioBXfrtgok8tQUVFxQ6/Xn2nJ984lSZhNJly6kGuv4NmC1luj04LkkTkms8msgEIAwm51KCsrwwcffLAsNTV1qV6vR0hICORyOYxG429mxeQSBLZt3oIjiUmgaRqNWg1efPFFM78NIh371DHYvGlT4+2y2/D19UVsbGzOjBkzqLq6OpCrV6+Gu7u7ZevWrQGnTp1qFIvFDQKBYL1G0/ixSCRsZsNnF5K7h/ssiViyzNfP10zTNEjSG0KhEFySi5qaGshksvv6MJxB07TDr11VVbX/hRdeGPDCgheODxs2jMPe12q1wmK1gtPi1MLj81BZWYmLly7BYjY3o6wlCAIajQa9e/eePGzYMAIA+vfr3zc5OXk1+5sTJ06grKwMZosZOq0OarX68vRZM8Ajm7svZDKZYPTo0Y8YjcYPz2ZlkbYnHweX3zwa/iFagLALdDtT3O9L8nPOYRWKhGKCIKDVaKpopmV7zEOT+/8YzolqfB4P4eHhivDw8LcjIiJevXr16o6dO3f+EhAQcKykpOT9b5Yvf3/woEF9LuTmjp0wYcJTw4cPV0skEodw/+uK8HuD1aY5IPDs/GcHe3h6XEhMTHzCaDQmz3/uudHjx49/4tlnnvk2rGNHgVQqxdKlS582m82h6enpj2RlZXU1Go2/+nj7nCwrK3t93bp1SdevXUuqr69/K7Jz5MJevXspORyOQxDbU0F/e7A/SwDmnIpGwM6dvm3r1uNvvPHGRw0NDUmBgYFQKZXDf/nll1/Gjh3rab/nvZ8M2zb7Bj7//PPfZGdn5yQkJExZuHDhPSuxsbDZbLBardJRo0ZBJpPNViqVrXzJZosFubm5FQzDQCwWg6IoDBw4EDNnzYLZZIbRZATJJef4+fsBAAYOHLhk+fLlY8LCwppp6VyKgtVqhY2iQDMM0EbwLmWjKJq2U11yYDd5T58+fXRmZub+KVOm4OrVq4606PuBVWTFYjHQtC926NABjY2NsNnsKW8anZbv6eExBWh7vjWNGsu+/fvWA0BOTo7Izc2NfP7553X5+fkgjxw5ApPJBG8vr/aLFi266eXl1SAUCo0VFeWMh4dHm52KiIjwnTZjGs/d3b0pvJAAh2M3MaSlpaGmyh49TpLkA5ta2YGq1Wro9LqT8+fPH56amnrIw8ODbKrsZgXsAsIZcrkcZ86cgdlkchwknGGxWDBmzJhnHX2PjJgQHx//fIcOHYx8Ph/FxcU4cOCAg3imvKxsS3lZ2ergoOBm/gYej4cBAwaQixcvBhjmV61W95bARfCwSss9QfzhKHc77FuETCojeCQPdXW1t1qWQmQAJ5P7Q/wv0VJgREVFiaOioh4ZOWLEI/k3btw+dOjQ6uvXry/ft39/Rm5ubsbNGzdeP3bs2NgRCQmzFUplQu/evUUtg6D+TnAW6hMnTgwcOHDg0blz507k8Xg7y8rKVr3y6qtH4+Pjf5g2bVqci4sLli1bNqSmpqbs+++/f/7kyZNzKJryEYvEnevr64nz588zCSNGvPPY4499PWzYsAUzZsx4rn379q5KpRKcZsL8wSwZzgIcsAuU+ro6HD506Nj6DRu+Pnv27N7Q0FBwuVzRwIEDv16wYOGT3j72eKEH0cydhfnmzZuzvv/++wUAhCtXrtzyoG00NjZaf/jhxy0BAf5YsmSJsC1NtaaqypyZmbmusbERMpldIw8NDUVMbCwaGxug1WgxePBgA1vfY9y4ccP37t0r4/P5WtJJC+dyuaAoCjK5DDqtDmQLDd1kNEEkEvnx+Xe0txEJI+afPHly/+DBgyGRSFqVZb3r3DSlzAFASXExpDIpomOioVQq7QeCprkrLy8XRHTuHHm3dioqKiwJ8fGVhJ2D3quioiJoypQpRwGAfPvtt8EXCKDX6XJ/XrOmIT8/HzU1NVxPLy+mS5eubTbo5+9v3rJps1mr10PSpMQzYMDj8WE2mdCgaQSHIBATGwuegH/PkwubXiYSieDm5oaNGzeyk3z0ySeffH/v3r1v8Ukebty4QXz++ecO1h8WlM0GqUwGLy+vVm3rdDqoVCrPsePG9mM/69Sxk4jD4Zhu3rwJPp8PkiQxdOhQByFJcXExeS7nnNlZoNOwHzaqKivH8vn896L79y+5duUqomOi7zquh7CDz+M7ojv/KOQKOUPyeKisqiqw2WxWAI43nTXv0TTdyg/2EP87OKcnu3t4wN3Dwyeqb983S4qLX9+7Z09Kv3799ubl5X1z9uzZPdXV1XtOnjwpiImJeWnqlKnDo/pGxfr4+DQzyf+RIj//LbQ0v7u4uODXX37ZsWr16kObNm2aHRYWVpiZmTn81q1bcTKZ7KUFCxbEubq6YunSpcsHDhw4b+UPK5+6XXr7cFhYGJQKJaqqquDp6dlw+/btdzZv3vyJyWQa1b1b96Fe3l7TBw4cKKMZGjKp7IFjRxo1jdDr9LYbN27cPn/+/C+XL1/elZOTc0Gr1SI2NpYXHx+/JCoq6sXIyEiFfTy/xaRvt+Lm5+dj+vTpEwHg66+/Pujv7//ALVy7do3Xvn3oRa1OB41GE28npmrufrl85QrTpUsXa2BgIEiShNVqxfHjx7Fu7VoIhUJUVlaSvXr3Gs66KjpHRvLDO4VPLr1dukYkuqPwMwwDkiSRkDACEomkleJh0OtBkuQEqUTKBYDVq1fnJCYmfgcA+fn5sNlscHFxue/+xtLK8vl8ZGZmIjMzEzKJFEKh0FGTHQBMFjOEfIFu6ZtL9QCkbbVVUFggkkqlgu49elhVKlW1QCBwtEG6eXpALpejvLyiYfeePUIAZgD6s1lZGydPmvRkWz4sV7WLxM/ff0ptbe0GmcxB3tNU6YoHLsmFVquFwWCA1WaFu4sbDEZjm4NmJ7ygoAA6nQ7BwcEOc/358+c/OXfu3MJu3bop/P39p0uEok8C/QMszi81SZKob2hAXV1dq5fdYrGgb1TfSUHt7hRc8fX1JdPT0/vV1dWdEovFIAgCAQEBEIvFsNlsKCkpMRYUFKwD8GzLsQ8ZNqzHlq1bsX7DBgQEBO6Kjome/Ff38f0vYfehk07BHX9M0LqoXWCzWaHT640Wi9UCJ4HepKHTDMOA81Cg/0/RktnK/v93wOVwEBgYSL6wYMEQhmGGHD9+fFlmRuaaAwcP7Pbz8ztRXV39waefffrBoEGDwouLi2eyJnmpVAp3d3cZTdEg/qKRdC33ArabKrUar7zySsLAgQNv7dq1a2l6evrXaWlpSWazOcnb2zvObDbPGDhw4OSYmJjOMTExp0+fPn01JydnQ15e3jdXr17VduzYEQKBABkZGUZ/f/9tmWezthUXFr388Ucf9545a2aMl5eXqKCg4JHIyEiph4cHVEoluDwSZrMFZbdvQ6vV4uzZs1fkctnhrMws8AWCb0pLSuoUCoVdodPr5ZMmTnpx2rSpz4dHRKhZAfNbppn1m1utVrz77rsJAEoSEhIWv/DCC4Psc3P/6wEgJSUlsaG+Hu7u7oiNjXVoTc6xA6knT25OSkqysHSuLi4uePrppyESiWA2m1FZUYHYmFjHfQkAffr2GZf7Y+4aV1fX5sFxIFDfUI/autpWnbRSVkT1iYJAIIDVasXixYufAexyp6SkBCUlJYiMjESTVaMZKx2HwwGXy3WY2PUGPfLz8uDl4QmFQtFmkTCtRgO1q+soDw+PVsKcHXtGRsaObdu36w8cOAAfX1/zt99+W+zi4gK9Xg9y2dvvACBAUZTnmNFjgjgEcdxK2yCXywvvlrrGF/AxefLkyMbGxg0tWdXu3N3O430kKQlqpQpGkwk8nr02Niuw2YGaTCYcO34Mcpkc7u7uztqyYeOmTT9369ZtYe/evTs8+fRTcHdzg7NgUKqUOH78OE6fOQ2xU2o4h8NBeXk5+vbrO9y5W2KJhJw3b97w2traUyKRCBRFgc/nOyrmGI1G2Gy2OhtFgeRy4Zw85x/gb7l48WIfLy+vDLPZdBW4F9nhQwBOTHF/Rlskif79++P0mTMwGg121jintWC1WCg7J8FDT8hfGc5EMwRBYPDgwbLBgwcvmPPonAX5eXmFR44c+SUjM3P53r17L5eUlLx+48aN1/ft3TvisccffzTtVFqMTCYFl8Ph/Z3Obay23qtXL1mPnj2/2r9376xffv31M41GsyU7OzspMTEx6eLFi08GBATM69WrV2+lUjl77ty5y44cObIsODj4WE1NTYaPj8/qdevWVZ47d04X3qkTQtu31xZmFSQHBAQkr1+/Hhs2bHjz//7v//gBAQFwdXEBT8Cn9QaDvq6mFqtXr0Z2djYee/xx5F3Pw9WrV9ExvBPB4/EWLVy0aNC8efOGRvWNEnKaCPhoPBgXv/Nv2L8Nj4t7/PiJE4fHjRuXsHXr1g+d27vXXum0l2ZwSRKXLl+OCAkJsQDgsy4CAnZh2djYeLtXr14Ml8uFQCBARUUFNm3aBIlEgsbGRsjlcq9ly5ZZAPDZg0C3rt1G1tbWIjc3t1mslUgkwq2bt1BdU91mv7p0juwAAPv276utqanJ9PT0dMQGGY1G1NTUQC6Xw9fXF1wu16GNEwQBs9kMHo9nd0enpkEilWLmI7MAtG1tMpvNUCqVAwRtxGfZGfQouLm5ZY8fP56prKiEwWjovWzZskIej1dK0zTI8RMnAmBA8ngaMEx+fX0Drl29isqKSqHN1nZddB7Jg6axUffll1/CWUNvdvMmoW02m5Geng6RSIRHH30UNTU1oGkarq6uIO3V20DZbIgfHt8qkM7b2xtajaYGAMIjImwHHpntVldbe9v5npTNBplCDm9vHzBOpy6r1QqVSoVhw4aNANgoXHvFOLFILF+5bSU8PT0d/O+1tbVgGAZarRaurq5Jzzz77GtKhYLnnI6ikMn5H37wwfDde/ZkbNu27fTSN9+0yeXyh9LjbiDu+NDtJ+I/dvShaRqLlyyBzqhvfUhgGNgoirKb3P/QbR7ivwS2MDNgDzby8vKCl5dXYP+YmLfz8/L+b+fOncnV1dV7i4qKvs+9ePHgxx9/fLCiooIrFAjB4XLlfwPrezM4SmUSBMaMHdtz5KhRm0+cOPHexg0bf1WpVCsOHjzY0LFjxxXr169fERcXN8dqtQZcu3Zt4YEDBzxTUlLcV61atVWlUp2qrq5+IevsWRSXlAAMg6NHj6Jbt24oKSkxX7lyxezu7o7de/bgypUrkEgkWLFiBc6cPoOb+TeGhXfs1D/CXppz/NjxY4M8PDykCrmiWR9/S6U8xvF7OxYsWLD7+IkTawB4vvP2Owd5PF6rzIV7waDXM1u3br0QFhaGefPmjVUola0EkFansyUnJ6fq9HrI5XLQNA1fX1+H+Voul8PV1W1Gy2sjI7sQ7u7uo/R6/X5ns7tOp8OwuGHoHNkZOt2dLDgul4O8vDxx3/79pwDA+XPn13h7ecHD09Oh4buoXWCjbLh27Rp8fX0RFhbmoA4vKSmBRqOBh7s7ci/k4sTxE5BKJeDcg7XYaDHj2WeeqW6rVCwAUDYKNdU16o5hYejduzekUmkNl8u1WJvStcnwiHAAgK+fX/3yr76mvv32W4FGozEDWP/W22+95uLi0mxSWPOFf0DATKlU+klQUJC59W3ZCeHCarXi7Nmzjqoz9fX1oGka53LOISXlBCqrqgAAPG7rYis2moJIKNz+9ddfvykRiwVRUVFzKIr6QCS6k7oml8uRnpGB9PT0ZhzvWq0WLi4uUR07dmwitbpDVdOxU8fZ7dq1e8nX15ficDiw2WwOPl+r1QqjwZial3ed17tX72YmQy6XC5Ik26WlpiG0fWjizVs3yW5du9314TwEIODzQRCEPcfzd8D5VE8QBLN61WoMHDIIocEhzX7XZHK3skFxD2X63wPsc3I27XI5HISFhfFef/31eJqm40+cOP5RVtbZ1QcOHNhdXlZ+sqGhAX5+fn8JLvffA3asXC4XQ4YMCR0wcMCyvGvX3zh2/Pjxffv2nQ4JCVl57dq1mlu3bhVNmjRp0YoVK7BlyxacPXsW7du3F0X1icKy95dh85bNWPXTKmzYsAGff/451Go1du3ahc6dO8usVmtcfHx8744dOz6pVCrJzz7/DMtXfCsjCEAua14L424+8gdzJd4R5t98882hVatWjQeADevX74/sEvmbj/ClpaWEWCzeefz4cSTEx/uwVlLnNMZbN2+SLq6uiZ5eXpCIJdDqtMjMyIRIbNeKtVot5s2bp2gpFMUSMTFo0KC+mZmZ+53zw0mShMFgwK0bt2D35NlhMVvA4XCMPXp0ZwBAqVLSjz3xBITC1tozTduJbYqKCuHi4oKPPvoIly9fRkJCAkwmM9zc3ODm5gbyHtZKgiBwq6CA365du4lA2/NvNBitn3/66XaT1QKZTMZ99NFHCxYsWGApKSmxj+Wdt94GYF9cWq22Z7du3Qp5PN4tmqZvFhcXU2wtWRbsiaxr166hc+fO5bi5ud21g+7u7ti9ezeys7MhFNqFsFgshtFkxNZtW9G9azdEhEfAYrG0eT3NMNBqNDcuXbzE79GzByK7dWGOJR+Djbmjodc3NiIiIgKxMTGwOkUbNvlVxjeRCjRDVN++8rq6OreysrIKoVAIoVAIDw8PsKec0tul/NOnz5zu3at3vzsEGvZxh4WFTRk9ZvTcM2fOYN/efUe6de027KEfvW2wxVk4HE4z68lvQfPiIOD8/MvP4JJcdGsK2HTWEGw2m5WiKTCcByO+eIj/Pdp6b5xN8hwOB4MHD5EPHjxk0WOPPbbogw8+SFr5/crhFpu17YoafyPQTaMnuSQ6hYcLO4WHJzzx5BMJDQ0Nb+zYvsMYGhL6s0qt0ixevBhXr15NdXNzS37z7bdMHTp0kEV0jsCOnTshFApdO3XqNKGhvkE2fPhw9O7dO2HEiBEdAwIDZcoWAcQt7303/Ja9jBWL69atP7Rnz54RERERWLBgwcEZM2Y0S1G7X5vsO75v37608opyDB06FB07dZrR/FoHoUxuQUEBPzw83GIwGiCRSNC7Vy9YLBZwOBwUFxWjR/fu05zHySqiXC7X7eTJk63u7+7ujuB2QTBb7uinjQ2NkMikE729vIUAmB9/+DGzurq6zeJgBEE4fPk6nQ6FhYXgcDjg8XmwmCwwmU2IjY1FZGQkNBpNmxUhGYZBRUUFr2vXrr3YPrdE6e1S6/CEhGytVoOGxkbfrKws36effvoUazEgx40d6xgwj8e7RVFUdWFREY4fSxbk5eeZu3Xr1iaJvp+fn3Hjxo38+vp6Y1tmd4qiIJfLUV9f36pQitVsBUmSkCnksFI2GM2mNhl1CBAoLi3hpqSeTO/Rs0eUzWKNP37s2GchISFWVpsnuSSyGxvQ0NDQLOXAbDbj2WeeqW/Lf+vp6cmNiY6eXl5R8aVUKnXkELK/5fF4FqPBcIwB+rX0kffs3UtY+15tZ5FIdNFsNp8BMOyhH/3u4PPsTHF/ZH5Yoa1Wq0WhISEuRYVFtdXV1RyguQ+PaiJjflht7Z8BNq+dPbC5ublh9OjRcevWrYPZYjb8nXzodwOB5sJVKBDC08NTMH/+fAGARTq9Hvv274fVYoFer9eKxCIYTSZUllfi9ddfx7vvvCMWicVciqIgb2Mf/k/EDrJWM3bH3rBhw6HNmzeNKCkpwTNPP3NwxowZCb/13uyjJLnkCZPRhFs3bwb17du3meRky9FSFHUwMjLS4u7uDrlcjrTUNBQUFEAhk0Gr04HH47lGx8YGOl/L7iH9+vWbNW3a1BdDQ9vrWCEokUhw+fJl3Lp1CwInU7yrQICePXp0AUCUlJZQERERuwkup00GVYaxx3Nlpmfg0qVLIJpiyBjaLvvEEjGu513HkSNHoNFoWqVfA4DBaIRUIqGWLFmiByBpS1G8fj2PoGhK3Ld/f71CLtcKhcJG5yh5snNkpGNQtbW1FYsWLRJduXJFbzKZDFFRfddPnTL1ubYaVru4SHr16jXHbDZ/I5W2jq6XSqU4f/48CgoKWp1GeHweKIpCysmTGDtmDEJCQmAyt225V7uoLRwO5xCAqAEDB8b6rl5NC4VCxwFAJBLBZLYH3DlPUnV1NdfN3T3B/jCdJh4AyeWiY6dOHU6dPk34+fkxVqsVLi4uMBgMMBgMMJlMOHDgQM6ChQsZsUjUrPMKuYKjUipHlJaWXjx65EjWktdfp6USyd/W/PcfBWFn8rtzWPvtO7Dz2pNKJVxvL++hedeub6mpriaBOy8qwzCwWa1mhsEDURA/xN8Dd56/XahX19RoaZoGhyA4fzcf+oPAWQhyQEDaVN0LIhEUCoUMAFT3uf4/TX3sLMx/WPnDoSNHj4w4f/48pk6denDRi4t+hzC399dgNGDb9m3nwsPD0aVLlwlKpbLVQCxmCxITEy9yOBxotVpodTr4B/jD18cHFE1Bp9PB08trqq+vb5uTEBISQut1Bsvly5cdB3+FQoHc3FxcvXrVIasIgoDFYiEGxMZ6A0BqampFVU01GRwcbGmVrcUw4HC4EAmFMJlMAFrvQRwOFw31DfD09ETPnj3brH2i0+kgFApnuLm7Se42R1mZmZv279+vT0pKQkBAgOmLL77IZyPcAYD86quvHB0wmUzuoaGhQT169DjRJIgb7lqkhc9Hly5dZGfOnIHBYGgxPgZ8Pt9OpdcU9dfyezbEX6/Xw9fXFyaTqc1gAbFEgvQzZxqwYAG6dO1qKSkpCcnLy7vOCm+r1Yro6GhMnDQRNdU1jgdSXFIi6dixYyzQOo2GAIFu3bpNu3379tNGo9Huu7h1C5GRkXB1dYVer4fFYtlTWFBAdOrUyela+4Pu1q17n+MnToDL4ey/du0ap2ePHq36/RAASyzzWwiG2m7F/kz5fAE8PD1DUlJPorq65goARwADwzCwWKx6mm5dBvEh/t5wDkx1iqn+xz9kZ9eD8x7W1r+BBzdv/xE4P4OXX355/4ULF0Y3VWA78MUXXziE+e9xQxbcKoBBr99548YNTJo0qVtblr1btwpw+PDhHRRFOfLPwzp0gK+PL8wWC0pu3yaGx8d3Ju9iFXRzc+Pt27/PBUC58+eRkZFYuHAhGhoaHJ8VFhbyBg8ePB0Arly5sjHjTLol79r1Vm2yabLlFRUA7OW2WxFfObGhgmFgNBjBbSH0uVwuunXt6i9sojdv/oyb6qAI+EUJCQmQy+VoaGjo8c033xQIBIJSh8X62WftJGoMw8Dd3b02KSmp4eDBg7CYzbhw4UKB2WKGSChqtmgY2A8ADMN0PXLkCCGVShnn0wYbrm+1WiEUCmFuQ/smCAIkSeLo0aPISE+HRCJpCpxq/p7qDTpIpbK11TU1n7u5uvKfeuqpaTU1Ne+wUYparRYRnTtj1JhRsFisoCk7fV5tbS3j6+urQ4vkfHYcffr0Ubi4uHShafoCl8t1sMyVl5eDy+WisLCQm5SUlNKpU6cBzmMnQGB4/PAxq9esRk1tLQ7s37+vZ48eox+a3e/Aedtlg0AomgbTRNfakrv7XnAOhiFJEu3ateMBwPnz5xMBdHPQYDIMKJvN2GZFpYf42+JuQoH5M6r9tGgRcN59mlKk/gJv9d348+/27z8TzoKZfW8rKirwwgsvvF9RUfGGTCbDyJEjD37yySfNNPPf06dDBw8eq6quhs1qRVBQ0ATndtj3PPlY8mmCIGwhISGO1GedXo/cSxcBAPX19UyPHj2m3q0PUqmUP2TokGkV5RVfsr5wPp+PiooK/PTTT46sLq1WC6VSKenVqxcHAEpLShuGDh2KllzwDMNAKBSCoijs3r37rvFggN2aXFRUhLxr15u5eFmYrRYiqk9UIKtAt7S0WKxWXLp0qREAampqMHDgwLy4uDhTVVXVHZN7cnKy4wI3Nzf93r17Q0+ePMnn8Xg1YrF4U1Vl1YqAgABh8+Ak+99jB8SOn3B5Aunn59cshFmlUuHEiRNISUm56+AAu1Bny5j2jeoLjVZjr2ftNBAGQGlJif5kykntxIkTVDw+n7tlyxZImkxRNpsNx48fR2lJCUQiESwWC6yUDRwQzOLXl9w1EkutVmPChAkjTpw4ccHV1RUWiwX19fWQSCSgaRru7u7WsrKyEwAGtBTWnTp1gkgkGkhR1InMjIyjAEa3PCX/W9FSmxKKRPbiLDabIy2xsrISDMNovby8ZL/lJE/ZbBg0eBDB4XLg7uauoxnaYdWxa+gWDUPdv8LRQzyEM5pWHw0OAblC7sZ+yuAfbwS4L1oKc4PBgGeffXb8rl27di9atAjt23c4+PTTTzUJ898HdpbPnT9/kKZpiCWSvr169eK39ZvampoTffv2pVxcXCAQCFBaWoqCggJIJBJYrFZ4enr2jIqKUtqvab23EBwOOoV19PBw93AIZy6Xi9DQUBiNRsfeYTQaQZLkbLVaLTCZTPT58+c3arVatHQvs4rpjRs3YLVa2/SNs2DN7CNGjYS/vz+MRmOz7wsLC/mxA2KmAU6uRMcqJFBXW2s6e/bs2pqaGhgMBqVer+eRJFlZU1PjaIOsq6tz/KOqqgpRUVGK6OjoxpqaGly5coW5euUKERAQAPYmzugY1tGamZmpSExMrGED42iahkKhQG1tbSte3LYgFApRWFiI2to6+DTVGG9Z4q6istJ6/drV9QCe79gxbFrniIh3g0NCbDRNQ6lU4sypU1i5cmXLpnlL31zaqgPO/riOHTuOXLVq1YcWi8VBBmAymWC1WmEwGLBr166U1//v/2ilQsGB04FGoVBwZ82aNfSHH344kZefv6u8vPxrLy+vf70wZ8HOE5fLhYAvcCMIAgxNQyQUoby83HL82LFRGzZuTO/Ro8cWO6PUgwl1LpeLs9lnzTySRN++UXybzQY+z/7eMzQNi8WiY0++D7fih3hQNK0VHkVRuHb9+jmbzdbjzt713ytd+lcFK8z37dtXf+rUqak3b948AgC9e/c+NG3aNEcFtvsRx9wLdXX1uHnz5kEej4cpU6YMValUjqBXdm/QanXUju3bT5otFmg0GjAMA6VSiS5duoCmaZSXl2N43PDRSqXyrvchCAL+AQEmpUoFgUDgUCoLCwthdiruZTQaMWzoUBkAZGRkmAICAor9/f1bufMkEglu3LiBnJycBwrGFQqFqK6uxtmzZ6HRaBwy0mAwQCaT8cPDIxxT2FKoX716lR8VFaV3dXUFADGXy/W/dOlSqfN9ybFNUe6APaWsrq7u8osvvsgrLS2FXq839+nde3N8QsKcliUNAcDVzVUYGxM720bZvmBN4AqFAunp6cjPzwdJkg5uXI1Gg7KyMoFUKjW3GjhBwEbZ0LdfP/B4ZFNgwZ2JMxj0qKysrACAuGFxIbt37QZLekMQBEQSCSRiMaQSe8S6RqOBu4eHXCBoI2HQCSNGjOj/wQcfeFqt1gq5XA6tVuuYYA6Hg7ra2uPnzp2zDRo4kO+c/NAUcTtUp9O9IZFISlJSUm5NmzYt6O53+neiobGROnjo4J4bN244Tr48Pt9otVqPHDx4EP4B/hcAJDxIW6yb59LFS7LNmzdDqVCSXbvd4QCgGQYWs0VH0TQ4XM7DRPSHeGAwDAO+QCDz8/PD0qVLe166dOmViRMnju7br2+Ml5dXs9ief5twZ4X5nt17khcvWTwjIiKiSqfTdVq5cuWP06ZN6w/8MTM7i7S01AqbzXa1pqYGPj4+cfb27GDlzbVrV7kWqzVRLpeD5S+vr6+HVqsFABQVFiGsY9go9tq2+kMQdu4StnQ3K6Nu3LiBsrIyiEQicDgc5OXl8QYNGhQPAIcPH96yd+9eRiAQNHPn0TQNuVwOg8Hg0NTZ71m3c3FxMUcoENJ8vj3bhyAINDY2IiQkBH5+fg53tMFgAI/He8TDw0PIjrmlvE09eXLP1q1brWKxGCqVqv7TTz9tUKvVzWLYyJ9++slpsARMJpO6S5cugTExMaeuXr3K6PT6EjbtjB0Ke3LgkTxE9Y2SJCYmOthxaJqG2Wx2nHwA+wvTq2fPQU888cSmtNS0p2tra3c7n3TYh7Nr9y4EBweDpqhmHjKdXgepRLrNarUu8/HxQU1NzQSz2byV5WJXqVRQKVWsmQQEAM49ombY/rdr1w7dunUbn56e/j1b2MPX1xe+vr6wWCzIz8/H1cuXdw8aOHDKnXx0u6wYOXJkn48+/NCtoKCg+sTx4wemTZv2POfhaR6Ao1AK88zTTy+prKxMcnV1hZe3dw0AGI1Gjt5ggK+vL3p07/Ek8GAbwR03z4CJ27ZuW3L0yNHyZ5+bf+d7hqatlNX0ZxSBeYh/FwgAHA6H09DQAJVKBZvN9umKFSs+PXToUEB4ePgTAwYMeNLPz8/D3al2u32VNd9w7Z/8M95/dpzl5eVYvnz5N3V1dQtKSkoQHR2dsHXLlv09evbkAH/8gMPe51Ra2p7s7GzweXzV2LFjo4HW/vPExMQD1dXVIEkSGo0GLi4ukMlkMJlMMJlM8A/wbxefEN/dfu3dYKcbZv/jcDgwNtUZcXFxAUmSsFgsCA0NtY4YObI/AFRWVhZGREQwzooom5Z28+ZNmEwmCIVCR3q2zWZjg+LEr776au65nHM31q1fF89yttA07XBDsvuV1WpFTEyMmjXZtwyIYxgGVqs1d8CAAYybmxs0Gk2X1atXFwoEAkOz2iYvvfSS4x9NgXH1R44c0e7ZsweNjY04cfx4jt5gYKQSCeF8aqBh15gom23U6dOnP+7QoYOFYew1qUUiEfr06ePQygoLCwULX3zxhxEjRngEBQXtWrd+XYzFYkljNWxWuDc0NMDHxwceHh7Q6XTNzBtlZWU3UlJSNEOHDlXEx8dHJCUlbVUqleDxeLBYLCgtu93ssRWWFGvM9uNP8ygGdqxNEzV48KBpR44c+V4kEjkeBBvk4Ofnh/Pnz6fSDD3Ffkq/0x9/f3+0DwubUt/QsOLkydSDRqPpeWcGu38v7DN7PS9Pr9Vqv6FpGprGRukTTzwxBgCMRiNtsVjg4uIChUKh/K2tR0REtPPw8MDBxEObNBrNl25ubvb0NYaxMYC5KaXpzx3SQ/yzQXBgMpl0jY2NeOmll/aFhoYWpqSkfHX58uWbt27dWrp58+aloaGhCQkJCbNDQkJGR0VFNeWpOgt34J8SFssK2ePHj2uOHTs2c+fOnft9fX3Rv3//hf/3+v99GdguEMCfZ60wm81ITEraHx4ejujo6CmB7do1+559m0+fPn2YpmlUV1ezMTNwcXEBRVGoqKhAXFzcJC/P1lU3ndFkwSU0Gg2EQiH4fD6MRiPq6+uh1+vB5/Oh0WggFovjOoaFMRRFITk5+ZCpqTy3cztisRhcLtfhNycIewlxqVQKlVKJt95+++DUqVOD+0f3D/74k0+kFRUVOj7Jg5WyQavRQKfTOZTfW7du8YcOHTq0ZUYZq8iYTCacSU/PpygKDQ0NSEhIuDl06FBzdXVz/vlmQXEA4OLiYtizZ0/n9PT06sjIyAoXtXr37dJSqkOHDi380faNO6pf396+vr4WwF4znGEYhIWFoWvXrg461crKSlFAgH8oAISFhWHlypXbx4wZ48mx13N11ImlKAqHDx9Ghw4d0DJaubS0FFlZWVuGDh06T6FQDLl+/fp77du3t1JNBepnTJ8Ob28fmM0mWKxWcAiOxWaz3bUINztRY8aOjX33nXfdaJqulslkKC4uxs2bN8HhcGAwGMDlcre9/n//tzwwMNBhWLIvMgIDBwwYcy4nZ0V5RfnhU6fSGoYOHaq852r6F4CNNCgvK6P79OkDT09PWK3WRcPi4oYBgEwqFX355ZeexcXFFSdPnvxy8uTJL/8Wy4ZSoTDMnj0blVWVtRqt1uDm5iYHAJuNotAk0AmidZrlQzzE3cCAARjGJBAK0KNHj1FjxozBwIGDnjt9+tSJX3/99VBqaupnoaGhhzZu3HjIy9MTe/fsedHP33/k6NGjB3t5ezulH/29LXSsINfrdPjhxx8PrV69ekZMTEzDrVu3uI8//vieV155ZSTw5x9bsrKyjNXV1ft5PB569+49ij2QOyuQJSUlyMvL2+nq6gqpVAoulwuhUAi9Xg8OhwOLxYIBAwdMudO/u/WSQWFBoaS2rhZisRg8Hg8NDQ0QCoVgLb4CgQCxsbF9ARCpqamGqqqqLLVa7aCvpmkaMpkMZWVljmtZWcUK3C+/+OLgnDlzBgD2IPGgdu08b5eW3pDL5bBarZBIJOA3+fAZhoGHh4etb1TfAfYetk5JLCkpsWRlZW2xWq2gadqNpmkll8vNdw6IAwBSo9E0+0Cr1aJv3750dXW1kcfjoVGjEWRnZ9d16NDBvS1zUvv2HSx1dXVRpaWl6XK5HCaTCUqlEl5eXmDbLikpsWm1WgYAwQAYOXKkx+5duw69sXRpQlVVFXQ6nSMK2mKxwM3NDe7u7tBqtQ4t3cPDg7l69eoVABg7dmy/HTt2UDweDwKBANXV1Yjo3Bljx45FdU0NOASB6upqTl19ncDPz++eiykkOAR9+vSZcCY9/QfW/KFSqUCSJFQqFYqKiioPHz6c/vTTT0exy4wNUhg3blzcjh07uDdv3qSOHz++e+jQoY/+22lg2dM0l8Mh9Ho9v3v37ma1Wi1mP/fy8uL369fv5eLi4pe///77pZMnT54XGxsrf9B543I43K1bt+KZZ56G0WBwHDIZmiYAGLhcLhRyxZ9Sf/0h/h1oWpscykqhurq6EoCHr68PpkyZMnDChAkDU1JS3iy7XbYpNS11T3Z29v6rV69+ERMT80VGekZI125dH+3bt+88X19fN+fa7Xfz4f5Vwfb76tWrxrfffvup2tradU0aaNzGjRu/nzRpUhDQ3NXwR8EKq9OnT+82mUzg8/no2LHjKPt9mhPkHEk6kl1TXVMWFBwEiqLsEeoEIBAKYDFb4OXl5Tt8eHzP+92TomikpqWdKy8vc6QqswVebDYbuFwuiouLycmTJ/cDgJycnO0+Pj5EaGgow+4pAoEAtbW1KC8vB4/Hg8lkarbfjBw5csmjc+c6YoMMBqOltLTUYLFaUNVU0U2j1aKwsAgMQ8NitUIsFncK6xhmAdCidop9HnLO5Rh8fHx4ffv2tQUHBzNGo1F2/fr1VoF45JQpU5p90HTyKHz//fdVJpOpUSAQmPr27bsBwKK2NCm1SsUfNmxYXFZWVjqXy4WLiwuuXbuG5ORk54hBfa9evfbFD48fw143esyY+MysrD3Lli0b65w+QFEUjhw5Ajc3N4jFYkdQXZM5ZHNDY+NXAQEBsNls43Q63U6JVAqBQICjyclITk52TGxhYaFt2XvvabtEdnFx9nI1J5lp8oePGjUz7dSpH9j7cTgcsKVVXVxckJ6evosV6M6jb9++PTw9PcdVV1fvOHTo0Jalb775qFAgABwv9d/nhf6zIRAKIZFIUF1VDYPBYPbz9wPZVNZ0xYoVC9LT07cUFhZmPTf/uVk553L2ssGI95sxbx8fCc3QPT759NPsdkFBZEREBABALBYLfXx8BikUioO3b9929fXxAdB26spDPERr2PcIB69B05ohSRJDhgyRAHhi3PjxTyQlJdbt3Lnzh8CAwPWpaalXGhob3ti0adMbbm5ug0eNHDktonPnGdHR0ZK22mLv4uwb/m+vzZb3ZAV5fV09tmzdkpScnDxHq9VWVFVVYdasWV9MmTJlUWBgIACA+pMT+QgAVpsNSUlJWyUSCby9vUf1cCLpYsA4+nc2++x+F1cXh5mcy+WCpmgIeALU19YhJiZmJpsl1Tbpjh319fXW+vq6HRaLBRY7nS6MRiMiIiJgNBphsVjg6+trGz9+fBwAXL58Oad9+/YMa25nGAaurq4oKipCQ0MDBAIBfH19oVAooNFq0D60/cjt27d/ANwpmVt2+zZiYmI0IokYJIcLs8UMlVIFf397UJxOp4O7u8dYpVrVilOW7X9RQdG6iooKY/LRo7h48SLx/vvvX3d1dW1F6kYmJSU1b8AeKCB/8cUXXerq6kpLSkpQWFhYbaNsjg35zoTbH4qXl1fotWvXCE9PT8ZqP21g4sSJdh87RcFkMjECgSCDZugxHIKDpvJnePfdd8ecO3fu5QMHDnzGBtWx7D8ymQzt27dvpqUXFRVVJiYezps6ZWr7uGFxXVPTUneqFEqIJWJcvHgRFZWVjsLxtbW1hrLy8i0Anr1fcNyEiRNjli9f7iMWi2+zNdsVTYUNmtIS9lbX1Hzs5urqWCwM7C6GYcOGTc3IyNhRXFx8ODMjQxcbGyv9X76w/2s4AiZ5PDupkMUMnpl0vFEMGKjVavLdd99dO3v27I4lpSX7Tp8+bY6NjRU8yExJZTIMGDAg4ddff83OyMjYNHHixDn2z6WYOnXqwJ07dx5MTU3df+rUqfkikehfNvsP8WfjTjlRQCaTYuLEieqJEycuKSkpWdKjR4/U3Xt2H87MzPysa9euxzZv2XLM7/SZeYcOHXrF1cUlfvSYMbHtgoJIZ0awlv7R/zZa5pUDQE52TuXSN5c+df78+T2enp6IjY0dNmXKlLcfe+yxfvZr7gjXP6PPzvviuZwc261bt3ZrtVokjEiYyufzwbT4TUNjIwoKCvZ27NgRcoUcdbV1yDmbjbraOvAEPJjMZix9661HgNZ+/ZaFXS5dvGgMDw8nvLy8HDFe169fR0VFBXg8HrRaLUQi0Yj27dtDq9Hg8OHDWy0Wi4P3hMfjQaPRoL6+HjweDzabDf7+/hCLxYjsHJnww48/7hcKhc36ceHChWqdQW/18PQAYN+rCm7ewuVLl0CSJAqKCokli5cEkpzW7HYE7KRcDQ0NlRPGjYdGp4VIJPI/depUGcMw+pYkWqQztSlgP4H4+vpWrFu3jtq0aZNIJBIZPTw8NtXX1S9zc3NrxtjBbt5Dhw6d/OOPPz6iUCiaRfq5ubmBJY7PvXDBdidvmLELdYLArl27Pu3Xv1/+2ayze0iSBNFUQ7uosBAVFRWQSCSgaDvZjFarRWpq6sGpU6a2V6qUscnJyVw/X1/KarFCLpejf//+jtrbwcHBuHLlylX2lHQvjmNfHx8MGzZs7qFDh5Z5eXmBYRjQTVR9EokEhYWF106mpBRPnDjRv2X1tejo6DEuLi5kVVWV7WRq6t7Y2NgZ/2ku5b8DSJKEQCCA2WwGz4mPgD0EPvLII2GrVq0alZaWtj85OXlLbGzs7Ac6ADEMRo8eJRcIBDJvL6889jlwOVzEx8dP+uKLL14tLCw8vGTJkr1fffXVGA5+P+HFQzyEc3YLCw4I+Pn5wc/PL2bMuLExmRkZb9TV1SXx+fxfMjMzdx85kvRpt65dPz127JhLjx49nh88ePBjIaGhft7e3s2sAP8Ls7yzID979iyOHTv2xeXLl18tKyujTCaTsH///t+8+uprT3p5eQL4c03szmDnIDMz86BOp4NIJMLgQYPH2+/WfK8+lZZWqdVqc7y8vCDgC1BTXQOzxQKlSgmjyQgfb5+oUaNGhd/7fnZkZWXtTE9PN/n6+gKwp1P7+fnBy8sLNpsNJEli4KCBUQBwOPHwDZIky4ODg+1tEATEYjFyc3Nhs9nAa6okWVpaCk9Pz4SPPv7ooEQidhxI2HvevHlzfe6FC+aS4mJHGfEhgwZDJpfDYrFAqVSiY6eODkKZlqivr6eWf7t8h9lkgkqt5o8fP74wLi6usbS0tFVePJmRkdGqgXPnzjEAfAcPHlwqkUiMFRUVxVlZWYYRI0a0rsICIDIykiRJsnN5eflFiUQCiqKQmZkJgiBAUXbCfJVK9XNtTe0yLy8vHvtAadiD4Y4fO757wIABY3Jycvaxke8UTUGtUsHVxRUarRYcDgEel0TaybSjABZOmjRpwKuvvMqvqa018nk8aDUaFBUXQyQWgWEYlnp2w6uvvbY8rEOHuwpz1lowaNCgx44fP77Mzc0NDv56e6oARCIRsrLObps4ceJLzn50AOjWvZugc+fOE7Kzs7fu2rHj51defnmGQCD412uGMrmc5+3tTbD15tsKFlqwcMHwy5cu77+Ym5sNYPb96HNpMOCSJIbHxy/o2LHT0/7+/nw4XTNs2LB2L7300tbPP/98yvHjx8d+/PHHB1577bURds3ifsEyD/EQrdEWh7rzWia5XPTr108EYOzAgQPHHjlypOH4seM/dgjrsCcxMfF0ZlbW23v27n07MDBwQK9evUa0C2r3ZPzweJVKpWom3Fvf948Le04bbVMUhbS0NGNaWtovFy5c+CEzK/OCxWLBzBkzn5w2bdonPXr0ULK/vbu2+8fAavs2mw179+37QSKRIDg4eHTv3r0lLX8DALt3795x+vRpyOVyWG1WqBQq+Hr7AARQXlGOCRMmzFUqFPfsHQHARlFIS03d7+3tzbBVNhUKBSwmM6oNRnC5HBQWFHKnTp3aHwBOpKQcrKysdJi1abumbOdUb3InW61WmM3mfitXrjzYpUsXx3NjnytFU7BaLOaZM2dCLBZDLBbjbNZZZGVlQaVSQavTQSKRtOvdp3eb2VgAcDE31yYWiq6FhYXB28dbzTCMz549e7LZID1nkF26dGn1oVAohFarvZGYmMirra2FwWBghg8fvmXEiBGPt6VFubq6cuOGxY3KzMq8yOPxHCbzXr16ORL3i4qKGi5dvGRhBToLGgykUilOpqbu7d2rV78rV66c8fDwAMMw9pKoXBLe3t4wm+2c8vX19QcuX7mM8E7hiI6JGV9TXbVRLJGAz+OjprYG1dXVIAgCQqEQVVVV9bt37Tq2ePHiwQTaTrNgl3x8fHy7NWvW9Kuurj4tlUphsVggFAohl8vB5XKRe+HC5vrGhpdUTZlWLCsSySUxeNDgSceOHdtaXlZ2NC0trX7IkCGqf5up3Y47G4jNZiOvXr1Kq1QqiIQiE8Gwv2AXOg2jwVRns1mhdnFxedA7MGAglUj5nTp14gPsM73j4vj4448nl5SUfJWZmblw48aNI3Nzc3/esGHDo84c3f9ml8hD/H60tVbYPYUDAlKpFOPHj1eOHz/+1aqq6ldDQ0Nzt2/fvq2+rv7zysrKlF9++SWFoZnXfvzhx24jR44c6+rqGtu5c+eeHh4eEncPdw6Hw7VXKORw7ynsfwusNiuMBhMaGuq1KcdPZCcdPZKUnp7+KY/Hs8nlckyfNn2Ii1r9+suvvDK45Zj+U2Bbz8zKajx/7txBs9mM+c/On0aSZCsTuUarwaGDBzeJmiikAXsgnI2hYLVYQTMMJkwYf1fudue2zuXkWAsKCnYrlEoQBAGr1Qq1Wg23YDdYLVZYrBa4uLjwpk2bNhgAUk6kHFYoFA66VzZnnaIocLlcB2/7jz/+uI2Vo84FcggQ0DRqbN+vXLmzoaEBYrEYVqsVffv2xZhxY9HQ0AC9Xg9PD89JarW6FV81+/yPJifv1Gg0RFVlJVNTW2sa/froWxKJxFHZzRlkTk5O6+Hbc8NF3bp18zIYDLUkSTI3b97MZwfS3A9kny7/AP+IjZs2Et7e3gzDMNBqtVi3bh3MZjM4HA7MZrMtvFP4xmFxw5505vtm25CIxXjvvffWP/744x3cPdxtHIIDq9UKlUoFL08ve7AaQSAvLw8pJ1K2h3cKn9SrV8/+y5cv3+ji4gIul+uovc6y1snlciQlJm5avHjxYHaC2ipsQICATCaDv7//42vWrDnt6+sLg8EAHx8ftgodCgsLzx5JTMqbMmVK+5Zj7x/df2y3bt1k2dnZ2p9++mnzkCFDnvk3kcyw8+q8Il995ZXv9u7dqycIAnPnzpU9/sTjLa5ikJp6kmYA9OnTZybw4BvJ3X5Hw077umXLlgULFy70z8jImJCSkjI3Ojr6cmJi4qcSicRhDnuIh/gz0bLsqbu7G+Li4iKHDBkSmZ+f/0ZGesaZkydTjgH48ujRo+d++uGncwwYBAW1Q319g8rdw/2JsWPGSELat8fOHTsgl8qCA4ODYt1cXVUKpQImowkCgcCeasXng+RyweVwQTP26Gyj0QipVAqSy0VJcQlOnjx5sV1QuyMcLtd2MiXlPEXT+9NPp0OpVsLX1xfBwcEzO0d0fvTJJ58cKpaIW43hPwmWmHn7tm07rVYrgoODRQMGDhgHONvP7G/qkaQjxbfLytKkUimMRiP8/PwQGBgIq9WKxsZGBAcHD+oXHa241/3Ytz0lJWUvxTCUm5sbKIqCQCBAo0aDouxs8EjSXnrV03Ocp6cncnNzLbU1NYfUajX4fL5DDvj4+DgY3/Lz8/H888//NGrUKO/mfb+Dy5cvc2Qy2YXAwEAHZ0pZWZnjYHDr1i3ijTfe6MC9i/+cAVBUUHAxoF0g4+vnC6FAGJSSknKbdS23RJsaepMfvXbt2rW2ffv28UUikSUwIHB7Y6PmA7Va1aYffdCgQRNXrFgxk41C1Ol0EAgE6NixI8xmM2w2G1NeWXHbuaMtzVkTJkwIOnYs+Y1z5y+8zUYsWqwWmMwme4AdAHcPd5w6derIs88+O2n48OHTT548Od/b29vh37h8+TIqKioc5VkzMjN3Xrt27aewsLA2J9xu+reb3Z944olJmZmZCzw8PHRCoRD19fWoq6tz0MGmpKRsmjJlylt3TMP2Rde1a1c+QzOT9Hr9z5WVlb/o9fpn2CCKfz6aRwenp6cbvvvu+691Ot3rMTExSE1NxfTp058B7vjjCBCora1j0lJTE8eMGYOuXbsG/lm9YWMmvvrqq/HvvffewYKCghHbtm37LDw8/OapU6d2+vj4ONbBQ+38If5sOPOZM7Bn7oSFhQnCwsIGzpg5Y2BNTc3SPn2iSurq6tYdOnSwUC6X/9KxU6f6r7766lMAWPL6Emzfth3lFXeqe8plcowbPw7e3t4Os61AIACPJEE3uQX5fD6OHD2CjDPpMBqMqGuox5TJU7Bzx07EJQyHzWpFu6B2c+bOfbSbUqV6LC4uTuac8vTfVj60Wi327tnzq16vB4/HG9OrV69mJmfW3J6RkbGlX79+8Pf3h9lsRmNjo4NmVafT4ZlnnnmXz+M5Dupt0r3Cbm4/duzYZolYjMbGRnBJLurq6lBcXAwOhwOCIFBXV4fx48fHAEBiYuJmoUgEHx8fh+CkadrhjtXpdOjapWvkO++88wTAzp+zHdD+9+Tko3tqamoIgUDAmM1mR6wX25ZcLmfCwsKm4C6or6ujjh07dsBmo1BeXs599tlni959913dzZs32ywTTZ4+fbrNhng8no2maf+ePXvednd3rzKbzbfOZp81xg0b1kxSsR3v3r07KZfL++h0ugyRSASBQACZVIr6+npQNht0ej1Sjh8/WFdf95ZapSbYa5sxzwGY8+ijrxybNftTsUCo5wsEoCgKF3IvOHjWrVYrKIra/tXXX/8waNAglUQi6dbY2HhOLBaDw+FAJpOhpKQEVqsVBEHAaDTW7dm791hYWNjgu/lo2Wnp1auXXK1WTzxx4sSvbG6iv78/1Go1CIJA9tmzG2pqat5ybRHtTgAYNXrUY9k52T/fvn078/ChxKsTJ03oeLeH9E+Bs4/u+LFjup9Wrfri4MGD7woEAmratGkIDAyMmzBhwuKhQ4eqWs67XCYjGhoa0zdt3oz3P/jQCEDa/JX4/WDX0tKlSxN+/fXXg+7u7iO+/PLLXbNnzx558MCBAwIhW2/4fl77h3iI3w7naoO00yrj8Xjw8vLizXtqXhCAt+Y9NQ8Wi+WbGzduQCKRXA4LC0u0WWx4+ZWXceHCBcvli5cu5ObmHjPo9cZx48aBLxCg7PZtRwEpiqIgFArh6uqKXr164eTJk7hdVgY/X99u4yZOGDZo4EBxcFCQe/dePWf16dMbUolUplKpnPr5v0NycnLFzVu3Uvh8PiZNmvRcW/2pb2jAuXPnNkqlUphMJjsjaLF9b7darTDo9R4DBw1y0MS2bXmzf5Z99qwtPz9/j1KpBE3Z6cnVajU6dOjgqF1eVlaGUaNGzQKA48ePJ7K8KqwL12AwwGazgcPhoKioCIsXL16hUqkcDjxnmc72pKys/EJoaCjD+txpmkZFRQX4fD60Wi04HE7nqKiou/rPL1+5TIEgcr28vcDhcFykUqn3xYsXzzsXVXMG6Zz354wmFp6ikydPci5dugSj0Yjo6OjtccOGzWleG90+kSqVijt69OihycnJGTKZDAKhEPl5eWAYBpKmE2VtbV3W2ayzuri4OFnrybfPRq+evcSeHh4Tjx8/vlatUgNgIJZIIPH0dLDx3L59u27Xzp2n582b10+tVg9LT08/J5VKHUF4XC7XcepSqVQ4cfz4ttdefbVNge7ssyEAjB8/fl52dvavHh4e9lKuTSc3m82G0tLS/P3792c++uijvVk7Azv+WY88Er1mzRq/wsLCkn379/48cdKET/4JZndn90hb+atXr17FypUrv9i/f/9LdXV14PF4nOnTpy8ZOnTotAEDBkQ68jcdLxyButrais1btuj8A/zRrl3gKLVaKWXv9SDbzP19301ZFCAwZ86chEOHDh0kCGLEhg0bDr773nsjnnnmmYO+vr5wjoB/6E9/iD8Dzj7UO5/Z0dIsr1arAUDm6emJ6OjoKABROr0evaP6gKHppjgTg8VoMpn5PB6MJhOC2rVzCHNWU+ULBBBLJPjss8/wxRdfECKxWMrlcCAUiUC2UQHsf7knObjbT51a6e/vD5qiPafPmN6Mu50Vh4cPHcq9fv36+cDAQLYaGSIiOwMMUFpagn79+z8T0hSB3vz6O2ClzJkzp/cTDKwe7h52jZthIBAJYTKZwDAMDAYDxGJxz9jYWHlVVRVMJtPuoKAgCIVCWK1WXLt2DRRFgSRJtiqb79SpU5v3u4VIa9Q0MsePH08xGo1ga6/TNI3r1+310E0mE2JjYxNcXFw4LfvPysekxKTdGo2G4HI4DAHCRhDE7QMHDjgOIS1BXrt2rc0vmvLRyaioKHeNRlNjsViYK1euXHBEgDvdmD2YtGvXbmhdXd2HMpmM1ut0CAkJgVgsdmzmtwoKiNzc3O1xcXFz27on287UGTOezb18aa2np6e9xArDwErZHP1Sq9VITk7ePG/evH7R0dEJW7du/cTLyws0TUMgEEAqlcJqtYKNsE5LTd2el5f3ffv27du6LdjJJEBg2vTp/VavXh1pNptz5XI5GhoaYDAY7DnVZjP279u3/tFHH+3NwZ1QLADwcHfHuLHjntyydcub69etW/XyK698EhF+z0yKvw2cD1/sC1lXV4ddO3cmrlu/fv7ly5dvRkREuM+aNWtJXFzcU1FRUaK7mfMIANu2bbvx8ssvj3Fzd8PM6TO6s8RCDyLO2+oLjTvHK2ew5veEhIQELpd76KOPPkpY/u23h8rLy0c899xzB7t37+5IaXwozB/iv4m2hCoHBKQtXHVSiYSPFuxhvwX/i9S4+6G4uAS//vLrt3wBHxMnTnzC18e32fesT/fQwYO/GgwGaLVaGI1G5ObmQiAQwGazob6+Hm+9/XaTK+/u42PzuI8lH98gk8mh1+lAcOyc62UV5Q4iMY1Gg/79+w8DgI0bNyZfuXLF4OXlBavVCoFAgPbt2zvy1ktLSzF69Oh5bOrb3ZCVmWUoLy8/oVQq0eRagEgkcqS7lZSUEN27dx9iHwPbX+ca6EBWVlaGRCJhQkJD4erq6ltVVVXOplW3BTIqKqrNLxiGgZeXV+3WrVsFmVlZEoNer8/Nzd1aUVHxhbe3d4sTqF0YjhwxYuDRo0cFEonEyE48Sz7PMAzaBQYyubm5OTRNz+VwOG2mRRAgMGHSxD6//vJzR6FAeFUgEIBLkmhoqIdWp3MQ4Z89e3aXxWL5ZubMmQMXLVqkqq+vr+fz+TAYDCBJEjwezzFonV5fs3Xr1uNvvPHGoPtpYq4uLujevfu8tb+ufc7Ty9PBT19VVQWaprFj5871Fy9d+qpzRISjRid7EOndp/cTH3z4wZsA6o8fO5YUER4e90/Q/FqSUaSeTNUs/3b55G3btiWFhYXxnn322RXjxo57tlv3bo5r2nrJ2OcbExsb/dJLL9V/++23YBj05BAc3Klj92DgNBPs9w6U44BAXFxc/DfffJP0wgsvxG3ZsuXQtWvX4j788MNdAwYMkDjzFPzdn9U/HQRBcNvyHf4JYJqCgcn7//Q/g7ut4dbV3IhmB1hni6nz3/9qYPu2ft260zW1NbUMwyA6OvpRAI5Rsb2+du0aNm/Z8qtUKkV5eTlEIhHCmxSkhoYGhIeH9x88eLD7g9w3O/us/tq1q3sVCiXMZjPIJnKY6ppqR3xUWVkZYmNjEwDgwIEDW7Varf23JInGxkbk5+dDKBTCYrGgsbERS5YseRy4W+aUfZwXzl/Y6eHhgZCQEACAVqeDXCaDUGi3DEgkEs6IkSPi7Fe13n8qKitRX1+/U6FQICcnRzhlypS6MWPGNJaXl7e6Jwvy5s2bd/2yoqKCkslkooa6eq5SpQQY5vbJlJM3p02fFsx23LkDwaGhjMlkmlhYWLheIpFAKBSipKQEjY2NDh8EQRCbCwsLlwcFBeFuOpmbiwui+vaddvDgwbe8vb3BpSlQNA29Xu9IXaisrCzdvHlzxuzZs/tMnjx5fEVFxRqJROIwiWRkZDgeCI/Hw759+1bZBfrdtUB28392/vzZly9dft3D00PD8vY2mZNRWFhYfyQpKbFzRESC/THceamGDx/u1bdv3+iioqK01atXv/vEE0/E/d3Zypz9gQDw3Xff7XvllVfGtG/fHs8999ySKVOmvBUTE+OoO087Xs3WwpFt5dSpU2dX/rAS3l7emDBxwmj7fe78eb/+cEAgJyen9sSJE98GBAR0GzZs2GiZXE7cbRNjn+vzzz8/TK1Sp896ZNaAvLy8I5MmTeryzTffbJ0+fXp3u1B/iL86BAKBuIkO2taSJeuPgGEY2Gw2iEQiwf1//Z9Fy3entX+49UpvKcz/iodTAvY8+O++/26xSCRCRERE/1GjRgUDrfeZ5GPHjnl6etYGBQU5qmCy7G5GoxGPP/74Z0Kh8J4jZFtLPHx4r8Fksnh7iUEzDAgCsFE2sKlwBoMBCoXCfdasWTFarRbp6ek7FQqFg/6bFfpsie2AgICBQ4YM8b7XOGmGRnZ29mlfX1+HDDKbzSgoKACXy4Ver4eHh8fYsA4dHX1teUA7dSqtzGAwFIaHh6Nv374itVotz8jIKG0r/5wFGTtwwF2/lEikqKmurt60caO7zWbTlBQXIzk5ed+06dMWsmQdzuCRJNGtW7c+33///XqlUgkAMBqNUKlU4PF4kEqlKCkpqTlw4EDq888/H9O2T7tJ2+3de+r27dvfYidRKBSCy+U6TOlCoRB79uxZO3v27D7Dhg0b++23365xd3d3MNUNGDDAkQNvsVhQXVW9Jycnh+7evTvnfsbdHt27y1zdXGecPn16pbu7O/h8PpRKpaNwzJ49e76Y/9xzCYImmkK230KhEE888cSHCxcujCkrKzt19OjR0tGjR/v+lU/NLdGyr6wmXFZWhscee+yZY8eOrZwzZ06vQYMGLZ8xY0Yf9rqWZvWWY3XWqIuLizeRHC4sZvPQ8IgIO2mgYz3d3+gOAOvWrbuyfv36t9966y3U1NRY5XI5ea8rWaE+c9bMPiKJKGP+M8/OsVitF2bMmNG3rq4uaf78+QPsmv4dJ9Lf4Xn908E+DdYMm5ubu8FgMMBkNEk5nFapu78bBpORZ7FZcfbs2V+nTZ82/38Z/9LWurvXWmzbb//XWrvsvnL8xPGGysrKVA6HgxkzZrztrPCwh3WKpnFg//7PvL29IRKJYLFYUF5ejtLSUpjNZnA5nJAhQ4ZEsde0dS/WbG0ymbB3777VYBhU19SA4BCOimgMwzgOCD179hwnFovx5ZdfntTpdDWs75yNU2Cpya1WK+Lj46ewuel3w40bN7Fr966tHC4XYoFds7fRFCQSCWiahlarxahRowby+W3XPweAE8eO77x69SqaAr4VAwcOrFAoFG3mn7Mgb9y4cc+HoHZRc0eMHInExEQoVSpknc1KNVssC+3C7E4n2A1zwMABU06fPv28j4+PI6y+rKzMUcmGy+Xi8uXLRwC0KdBZDB48pIOHh0egyWQqFAqF4HA4kEgkMBqNIEkSDMPg9OnTO8xm84phw4aN+fDDD3Hz5k3weDwH9axarYZAIACXy4VGp9GnpqYmdu/ePcHu/257w2ZPiuPHj5974MCBlWx5OlFTCoPZbEZ+fv7R1NTUxqFDhihaXhcbGxvN5/HclEpl9a5du74bPXr0B+w4/4qn5pZwPumzQvjWzZtY8/PPAxITE0/GxcXN//ijj79Vu6gBtDY53RkjgZbbrclkwvr1648v//qbXxiAmPXIIzPFIhHnQfx8d9q1tz1q1Khu+fn52LplK/z9/WuCgoI87ze/7BqdMH5CF5lUnvHKKy8PUSqVp5577rmBLi4uh6ZNmxZ/R6g/xF8BzuvxwoULKSdOnJhltVrh4+0TKRHdNTj4N0EgEEAhk7mYzWaknUp7PikxMTRu+PB/hLvsrwBnzTspMelrV1dX1NXVqeLj/5+9q46LKuvfz51mgu5OscVCsbHBFru7C7s7cHXtWLu7kdS1sEHAVkq6e7rn98dwxwHBdft93x/PfmZB5t5z7z3n3PM933q+PbsC3777Tx4/Fr58+TLSxMQEIpEIeXl5kEgkulKnw4YOnfq9Kpr67T19+rQsISHhnpmZGeQKOahUKiQSCRQKha4YWHl5Ofr27TscAK5cuXKUwWBAoVCARqNBKpXqSnsrlUptLfKefv2B7xOVhdy+HaVQKEpszc2hUqpgZGyEOp6euvom2dnZ6Nip0zftkD2lUCgQ8+rVEzs7OxQVFcHBwYEmEAgoWVlZ+J5lihZfDbGMrmM0gJmpaVFSYpKRQqEwqVe3XqlCqbiRmJCARo0aVXtOh/YdLH8xPthcJpPFMllMaNQaODg4gEajQa1Ww9raGjk5Ob+WlZevNzYyqrYNALC0tEDz5s3HPHnyZL2JiYluM5CZmQmxWAyK1myRf+nSpZgxY8a0tLCw6JmVlRVB8snrE80AgEatwa2bN3+eMWOmH51Oq/FF1QXmDRvmvWPHDh+BQPCcrJXr4eEBOp2O9PR0RIaH7+napcuqqjt5d3d3TJs+fe6FCxdWnjhxYt/s2bOXN23a9C9LyfonoJ9XHh4ezt+/b1+v9x8+PJk1a9bl3bt3DyY1o+pM1PqUjQAgk8nw6NEjQXJy8pm8vLy7hw4dusnhcuHv788dGBDQv7pzqk5wQu938rtmzZsxhUKh55MnTxLq16t7q2/fvlN/JKiOFOrdunVlHjh48Mm6tWv97OzsIhISEvyuXr0aNmjQIL/v+eRr8c+DAJCRkYF+/fr1T09PR6tWrUYcOXpkLog/P05qaEAhCOzatWu2QCDIj4iM3DVo8OAe0TExmrqenrWz4E9CP2j6w4cP8l07du60srHG9OnT53h6elY6llwDDhw4sK+0tFStVqtBEATc3d1hYmICiUSC3NxczqzZs6cA33/XyVUjJCTkGoPB0LG9kdox6Y6t0HaNRo4c2am4uBgsFutmv379YGBgAAqFgpiYGF2uegWxTFvfLr425FWq3gV53fi4+Fv29vYw5PKgAcBg0KHWqEEBpaLEuEl9X1/fb3Yl5AY2JSUF5mbmN1gsFt69e2fi7Oys6datW1Fqamq1+ee6PmzcuAlq+jRp0gSOzk4YN2E8unbtyqBQKXj79q3m1q1b4fo3rw8TExO4uLj2+fTpE/Jy8pCbk4v8vHwIhUKIRCJyd/L84YMHWdXdkH68cWffzmM/fPiAx48fIyoqCk+fPEVOTo62gptEAgqFgkuXLh0BgIEDB44GAFNTU5iZmYHH46G4uAQlJSUoLS2FTCZDXFz8vadPn5TXdO/aG9BOQC6Hg8mTJ29Sq9Wwt7eHiYkJPn78iMePHyMlJQW/HDq0K6mKdYNcXLp36z5HLBJRAAgOHDhwXnu9/zwzWFVQQOheqtycHBw5cuTOtGnTHB9FRT3p0KHD2b179w4mgxmr26Don//lyxfcuXMnfPjw4d1nz5pluHTp0pn79++/KZFKAI0GDx48UDo7ORmQ5wFAQUEBgMpjQwDIz8+XpiSnCPW/MzE2obdo0WK8rZ0twsLCz8tksm/uo+qHBDlObXx8sHnLlnBnZ2c/Go2Gu3fv+u/YsSNc/55q8W9DtzC/S09PL2vYsGGPx48fn7O3t2f/VZsuNTSwtbPjhEdE7Gzbtm1vgUCAWzdv3v9LGq+F7k06ceLEDYVKWV5cUgx/f/85wLcbsvT0dESEh+9ls9kgBbFIJEJOTg7evXsHNze3YW3btjUEvifQtauEQCDAjevXT8rlcuTn5yM3NxdCoRAdO3ZE79690a1bN3Ts2BHDhg3ra2pqirCwsEcCgUBApVKhVqtRWloKoVAIU1NTGBsbg8FgoE/fPqMMeYaVnqsq8gsKkJScFGJjYwMrW2uYW5hDrdagIK8A2VnZSElJgaurS2/zahivyfUtODj4QXRMtFKj0aBDhw7Udu3aUV+/fo2CggLk5+fX+KFY21jjex8HBwcYGRmV5uTkmJSWlIBCUPDo0aPQ6h6IHJzmLZr3Ki4qhkQshlKpQFFhIcLCwnD37l38+uuviIuLw43r168C1S+cpODz8/dzdXZ27kilUsFms2FiagIDlgH45eUQC0VQKBQICwu7WlBQgCFDhoygEhQqv0z7nUalBovBAJ/PR3l5OaRSKYQiIY4ePXrm671XMyR6fxowYICvQCCwjY2NxYcPH1BWVgZ7e3vUrVsXRsbGJREREQ/JQdAXQh06duA5Ozv3YzAYePXq1cFyPr/m6/3DIKr5T1/gJSUl48yZM5HHjh/v+OzZsx6urq7lgYGBIadPnx5ZU3tAZV970JYtZ/r27et24MAB/7S0tLtsDqfF+vXrt65Zsya/s2/n2XyhAPn5eVKlUqlT8i9cOH/d3s6uXkhoqIi0EJAFHBYtXLRk5syZdp8+faq0J+7SpcvY7OxsZGZnRf28/ecX+vchFAkhlkggFotRzufr7lE/1U0DoHmzZli5cmVYWWmpH4/Hw+nTp/2XLl16nTz+Kw/evz92/x9B9jqfz5cYGBjAysrKisx0qWnj9kc+JOzs7BpRqVQIhcL8f+Fx/+eg0WjHUCyR4PXr1ztZLBbcXN16du3WzVT/OPL9unv37lMHB4ecbt26oVWrVpBIJPj48SM+fvyIsrIyjB49Wo+E5vsbutu3b79Nz8h4IpfLIRAIUFZWpquBXlxcjNLSUqSkpKB3797jAeDCxYtb5HI5srOzkZWVhdTUVADQlUnVqDUYMnjIMADfTXWNCA+P+5LyJVGlUqG8rFxr4pfLIRaJIJNIUFJcjFberfpV9wTkTHz69OkNlUqlzs3NhUAgMJHL5QXkPX/vQ0tOSPpup6g1atjZ2gocHBx4nz9/ZtvY2Ig/f/p0LT0jY5+To2O15/Ts2bPFz9u328vl8iwugwsujwtrK2sIRUKSJx6Rd+5cLCsvn1fV7E76rTQAeDweBgUEjD156tQjGxsbaKCBVCIFt6IYi1qjRmpqWmnwrVv3Jk2e3KVu/Xo9sjOzwtgcDggC4BkZgsFigsPlQq1SwdraGmlpaccFAsEskvDkW3xNDHFyckL37t3nXL16dSmXy4VKpYJGo4FEIgGHzca5s2dXTp485QmLydBtZkjNddLkySsnTZp0Izk5+fXxY8diAgMDW/4Ybcrfj6oRpYA2TSQqKiosPj4+SCKRPNZoNDA0NGy/efPmrT4+Pj4hISGnKRSKuk2bNmONjI0Jsh2KXktbt26NPHfu3PLMzMw4oVCIVq1azZ82bdrkJl5edW2steUYZ8+evWfq1KlmLVu2bG5ja2sAaNMzli1bPplGo4nMzcwqSU6CQsDG1kZ84eIF/q2bNx/Wq1evE/ldjx49rH18fAY+f/78+s8/b5/Yw6/nC6lEUsxgMk9tC9qK9+/f58uVCmXnzp3tevToYe7m5jbTy8tLl3uOCnNgnTp1EDh/ftiBAwf837x5E/727duAvLy8PceOHZutrV1Qc+R+Lf5ekHO1T58+Xjdv3MT79+9P//TTT4O6du3ayYDNhkqlgkqlrNZi9P12tcdTKVSdX/XDh/eP3r17t8XOzg69e/ce+Pc80f8vkNbhc2fPvnr37t1LqVSK6dOmr6cQhO6tIgPYFAoFzp8/v4JGp6O0tBQAYG9vDzs7O/D5fBgbG/sEBAR4Ad9fR8nYnbCwsFOOjo6wt7cHQWhzz9NSU/Hi2XNQKBTIlQpIJBKTbt27+6alpaniY+PuGBsbo7S4BFQaFYaGhiT5D8rKyuDu7t65ffsOxjVftyI6/cmTSwwmAxqNtpoov7wcSqWSLHoGM1Mza/9e/hW15r99kpycHKSkpNy0tbWFWCxm2dvbq2QymTQnJwe/FQhKo9K+ZRLSBxVUCEUihbOzMwUAVQMNiktK8sJCQp5NnzGjTXWLnJ2dHTzrePZ/8fLlvgpWHcikUl0KAJ1OR35+/su7d+6kDh482KXqNfXZyfr26zfw6tVrk5hMpppOp8PUxBQMOh1ikRgaAFZWljh/7vyWSZMndxk2bNjiHTt3htnYamuaazQa8Pl8LXkAnQ4Wi4XU1NT4W7eCX40aNbJFdQJWf0NBAFiwYMGMjx8/brC1tRWxWCwkJiYiMTGRDKh4evPGjffDhg1t+PU87X2PGDGi2cEDB1rHv379YuPGjbNmzZr1kl7BOfxvoqq/Oj4+HhHh4Wc/f/68VyQWR4tEIpiamvp06tRp9fDhw3uqVCo0bdp0tEKpONu3T1/YO9gPamxszFXrtSMSibBixYqJp06dOk6hUNC/f/8148ePX9C2bdtKfNHvP7yXNWzQkHno0KE1+n6go0eO3ElPTy9ZvWrVLyQNIjkCVAoVjo6Os2xsbI5KJJLrKpW6E5WqNftTKBTs2r3rWP9+/a/L5fKPqV++2N0ODhanpaerAgYOxL3796BSq2Fra4uVK1dCpVIdXbhw4S9TpkxpRej1hwaAra0tZs6cGXbp0qVeycnJYadPn56TmZkZGxwcfJLD4dT61P8lkJvFBg0aMHza+Nw0MTXpf+3q1b7lZeW0Bg0bGJQJ+BIKQSgJ4vdttghouTE0KjXNyMjI4MOHD5KnT58qzczM0KRJkyOtWrX619PX/hdAQOu33rRx49yCggLU9fRsPXbc2JZAhfZOfA16DAkJSXvw4MEjsg6GpaUlPD09QRAEBAIBJk6c+BOZqvZbo52QkICrV66c5nC5SEtL0wWjqTUacA252hZEInTo0CHAwtwc27dtOyFXyDXUCjIyiUQCLo+ny5QqLy/HlClT1tBo1EobkarIycnBy+joKzY2NmBXbDjFYrGWqlYihkQiQfMWLQY6OTlV01fafoiIiHiVk5OTWUGQRnd1dSXEYrGUpI/9HmgJCQm/eVBFSdRykUhkrVAoBPb29oiPjw8H0KaqUCQFYZu2bQcF3w7eR7GyhlgshoGBAaRyGeRyuW6Xcfny5SuDBw9erB9YVjXnsl37dkZcHrdbdHR0JLOC250A4OriCjqdDqlMhnfv391LSkpS9e7du+PRo0e5AIRkZaKysjJ8/vQZBgYsgCBQUFCAK1cun65JoFflaG/dujWvTp06E1++fLmnwv2AZs2aQaPRIDs7GxcunD84bNjQ/aRJnRTqBgYGmDJ16vbly5e3Ky4ujj5x4kTclClTmv2bWp6+IH/16pUyNCTk5NNnz7bJ5fJEFosFJpPZsEOHDqsHBgwc7FnHE1lZWdixY4d/wufP4YbGRuatWrU6Vb9efY7+puDEiRNPDh06NI/JZMb27t170OLFi482atTom2jHw4cP30xITBjr6uK6a+bMmeP1v7O3t79jZ2eHwqIivY75uqnr1q1rk6ioKMTGxgkUCjmoVJKLHfBu6W08Z86cW6tWreoXEhIiePToEdIzMrx2797d/9iJ41QKQUFuXq7k8+fPmwG8Xrp06QA/P790BwcHupZh7muNaxsbG8TExIR269Yt4NWrV9fv379/qlWrVqWRkZG3yKIutRr6Pw/yXQwKCup38eLFOzt//nmjBpoogUAgEAuEaOrlBTqTAUXF2vA9kGV8yRTYxJRkpUAoFAgEAmRmZnovmD9/7fgJE/2A2sDIPwtyHT9//vzb9IyMZ2w2G1OmTt1AVj0EtGNL6pxXLl/Z7+zsDEdHRygUChQVFeHz588QCoUgCMKhb9++7fRbr05PJ68Z9fjxM0cnpyJnZ2ddEFlmZiYEQgFoVBoIgkBZaSlGjx49VXuP505IJBLk5edphb9ajTJ+ua7Manl5uWm7du06/NazhoeHx6SlpaWSFeHUajWEQhHUajUICoGi4mJ06NBhAPnsldvQIj4+PtLCwgJMJhNCodAyIyOjtKioCN/LPydBa9q06W8epNFo4OrqqiwsLKTduHGD7ubmpsjJzY0oKSnZoDVJfO1c8uUbGDCwY1DQFksKjVrAZrMhk8lgb28PMzMzKBQKSCQSZGZmXigtLV2sLRjwlf2oslAlMGrUqDXr1q2LtK4w2wKASCKGQqAAhaCgnM/Hjh07Dh88eHA6QRD9b926dZbM92MwGFAplJCIxboc9eDg4DNx8fFBzZo2/U7ey1c+8NGjRs+5efPmHpIm0MHBARYWFjA1NUViQuLp5y+e/+TT2oejP0kJAH369Gm7a9eu+nw+/+Phw4dXT5kyJeTfMLvrm9efPX0muXT50oHY2NhdSqUyS6VSwdTUtIGvr+9qf3//IWT2wokTJx7Pnz9/xsCBA9+vXrOmh5eX15WePXtW8lNERkaGHDx4sE9MTAwOHz58e9SoUb3J0rUkkpKSsG3bth1v3rxZYGtrC0OeYaUDpNpgNoM2bdogMTFx3rHjx2zHjhnbl0aj6aLozczNxSHBtyGWSi7RmfQT5LlkPy9evLhvUlLS0ePHj08CgKlTp47z8vKa6+XlBQAQCoUQlPM7Llq8uAeXy819/PixYMSIEaZkC/obHWNjYzx58uSav7//5Pv37x9NS0sLPnXqlP/YsWPD7OzsUJuf/s9Cfy1gMpkYO3ZsNz8/v25RUVEr+Hz+ZkdHx+WNGzdeSmcwoFSrf1ugV/ykEBQolApoKAhKT03fXL9Bg+XLly/fRK4xtcL8z4Ps61OnTv3MYDBgamrqMnjwYF2qmlbQao96FRsrSkxKPNSoUSOw2WwkJSUhIyMDLBaL1I4XOjg4/OammgAgk8tx9vTpZQwGAyKRCAB0rKFGhkYgCAIymQxGxsYWw4cPb/H06dO8rKzsZ2SNcQqVChsbG1hZWYH0qffs0WMsuTZ+jzP+0aNH5w0MDKDRaHQscwwGA3Q6DRKpFGw22zQgIOBrH1RZTwQCAQoLCsKdnZ3B5/MpAwYMYHh5eakLCgp+09wOADQ3PXL778HKyorftGlTqxMnTrAzMzPLRSLRq/v376cPGjTI6Sur+dfXyc3NDa19fAKePXt2kMwL5/F42rJ/FebvlJSU17dDQuLHjB7dtLoocPKBx44Z67Nnzx47mUyWzWazdYXlXZxdQBAELCwsEBsbewTA9AkTJgS+ePHiLJfL1REHqOgqMOh0UGlUQANIpdKyy5cuXWvWtOnoH9GYBwwc4Obi7Nw2NS3tKQDk5eWBy+VWFJwpFu7etXuXz0WfFWSxD7IfbGxs0Lt375Xbtm0b8fr169CQkJCs3r17/+NEMwQApUKBg7/8cmf//v1jRCJRvrGxMYyNjZ27dOmybPCgQVO89DZ2d+/eDb948aJ/WVkZJBJJwLx5gVdZrK8WSLlcjqlTpx6MiY6Zweaw21y+fPn04MGDdROptLQUqampoo+fPj0MCQkJin758olcLmeOHDny1pw5c3oAQHFREX69d+/JrVu3rl68eHH3hg0bYGBgIJsxY0a/6JfRZw8dOjSSFLQslgHb0dGx2+fEhLv79x+4O2fW7G5fOdgJUCgUHDt2bOL79+8fRUdHnwkPDz+QnJIy093NjaYBwOVysXDRou4nTp6sk5KSkigQCL5WNtBoUFZeLvvy5Yu8foP6XCaTRTCZTERGRBwZPGSI89OnT1eWlZWF79mzx3/UqFFhjRo1gn76XC3+OZBuHktLS1hYWLjTaFQYGhm5W1ha1hQQ85uwNLd0F5TzoVKp3WuF+V8Hco27f/9+SWxs7Fm5XI7+/fsvq8x//tUau3fPnn2xsbGCzMxMkFzlehZZ7qxZsyZrz/jtsbl/715h1OPHUebm5igqKgJBEGAwGLC3t9dRgmdmZqJXr17jKRQKTp06tdPV1RUODg5gMBjIztZGoqenp0Oj0UAul6Nf//7jtdevGRkZGbh7585FQ0NDUCgUyGQySKVSbc16ldaM37pVq4FV0/X0+ysqKio3Ny/vKYvFAp/P5zEYDIWrq2sZWdzlt0DLzs7+oQOLiorg6OhY7ubmZk6hUssJgkBcXNz1QYMGBeoXuNDPO+zRvcfwBw8eHDQ1NQWdTtfl/5F+VYFAgLCQkNNfBXr1sLaxho+Pz/Rr166tNDIyIikaIZFIdHnmKSkp8deuXXs7duzYZps2bbLjcDjZJA+8SChEYX4BaBo6AA14PB4unD9/cMXKlaN5XO53B0kDgCAIzJ4zd8fmLZtbWVlagkajobCwEEVFRaDRaLhy+cq2jRs3LnV3d9c5jHU0sjNmDtu9e/dMuVxeeuDAgVW9e/c+QYAsq/j3a3vkFuvipUt3b9682UMkEkEmk/GGDh26fvCgwXM963rqdmE5OTlYtmzZATabPdPM3BxTp0w5v3HjxuH6wlwoFKJnz54jnj59esHc1Mzl3IXz97p3786KjY0VhoWFZRkZGV168fwF/9WrmB1t2rWDUCCAra1tzx07dpzz9vY2LSkpQWxs7J0tmzdvevDwYZSTkxNGjRzl7uDgMCo3N7dALpMfOHr06CifNm2cxo0d2w4AKASBxo0bdywpLbk7d/ac7nY2tgkBAQF1yDlDugCuXLlyunHjxvczMjISL1+6dHz58uVTyIcTicWQy+UyR0dHmJqZsgCt9UUsleDkyZOr3797d3D0mDE5HTt25KqhAY1Ox40bN1aMHTvW9fbt2yM6deoUvnDhQv/Vq1aHtW3XFpRaof6PgwCB4uJizbNnzyJevHx5WlBeDiqFevrN6zcZTCYTatWPk/dSqNp84JLikocCAR8ATquUSk4nX98hlpaWujWs1hrz+6C//gPAiRMntpSVlakBGM6dN28c8HWdJ49LS0vD1StXthsYGEAqlcLIyAienp6g0WjIzMxEK2/v+Y0aNTL45mJVQCoAN2/e3NeoUaNKwXDx8fGIjo7W0bhKpVKMGzdunlAoxNGjRw8ZGRlBIBCAIAiw2Wy4uLjoctaNjY079O3bt5H2nms28184f+FJQWFhngYAn88HQRBa/hRoxYJEIkFPf7/RlfuAVIa1uH7t2o2oqCh4eXnBw8PD1MnJSfThw4caq6tVBc2A8+NsSzYWtrKx48dZ3omIpDGZTOWH9x8ulZWXBRobGeuO0S8e0G9A//Y/bfvJlkKh5LDZbJ2pg6RvNTIyQkRk5NmUlJSdNVkKSME4efLkGRHh4SstLCx0lc9IMwQZxHD06NE9AQEBR4cOHTrz4YOHy+3s7EChaA3O93PzkJmVqTU/UwiUlpY+v3Tx4qtJkya1+J5g/Rq1PtE7PDzMW6PRRJuamsLQ0FBHYJOVlVW+d+/eY7t3755StS1nZydixIgRy0+ePLno3r17JyMiIjb07Nnz+2V6/kIQFULr1atXwQRBoLi4GIGBgb+uXLnSG9Bq24lJiYKXL16+PHLkyI6XL1+Gt2zRAstXrAjr37+/n35bWVlZ6Ny5c9+kpKTbxsYmKCopFu7evdv6wYMH5fHx8fj1118xa9YsCEUiiMRiqJTKrnPmzFnUqFGj7jY2NkhISBDPmjVraEZmZkhBQQH8/Py6Dx40eFGfvn268ng8yGQyPH361O727dsrVq9aNbBTx445zs7ONAqNBqFQqHJ1cQWTxcL4ceN6+bRpk2RrY1PpdXB0dEQnX98ZkRERK8rLyjLkcjnIQJKoh4/ykpOT0ykUCurWrUfV6yC8f/++LDEpSVBSWqIBtAsDOe6nTp0avnDhQqMP79/34nK54UOGDulw5MiRi/7+/ra1Qv2fBQEgIjJStHPHDn/tJnsOLM0tHubm5j5kGbC+y6D1TVsEAalUirp160IoFGLPnj0Pg4NvP1y1elX3CRMmGNfGS/xxkMIpKiqqNDIycpdGo8GQwYOXuLu50YHK9S8A4ODBg5fEEkmRh4cHAMDIyAgikTYtOTc3lzpq9OhAoHoiq6pITExUnzx1ai+Py0VxcTEAaFPONBqYVeR9i8Vi2NjYtG3Xrp3N8ePHHxgZGZW7urqCRqOhpKQEcrm8UjDc9OnT53CqVMHTf1ryea9evbqTIAgIK8z8BiwWeDweKtIgweVyLQcOCOig3wf6EAgEiLxz55KRkRHkcjnF1taWaWtrW0zS1P4IaJQfrFyk0QB0Gq2cx+FaajQaDp1OL//w8f3LOxF3koYMHeJBPpo+PaeToyNatGgx8NGjR/uMjY21qQJyua4CW0X0YtGlS5eeLl++vO33BGv37t1N7OztOyYmJj6iUChQq9UwNzdHhw4ddCw++fn5V0rLSo8GBAQs3LRp03IzE1NQCAroNC0znLWNNRh0bTpBYWEhTpw4sXXSpElX9APaqn12aMDj8tCubduNQVu3dq9Tpw6oVCrMzMwglUphZW2FS5cubVy8ePEUMnhKf6e6fMXyeadOndokl8vLjh09urVnz557KSCg/r25Nn8QBAhIpVIOl8uFhbkFUpJTft65c1f9mJhoZKZn3BkQMPDdkSNHBCwWCxYWFiajx4y52L9//+76bdy8cSP/4C+/jC4rK7vbvXt3FBYVgsWsW/jkyRN8/PhxTLNmzUxmzJhB6927ty1BEGZUKnVsmzZtdAL17LlzHxfOX9BJA02hs7Nz24kTJqydP39+V3LHDGh9pFevXl3u5up6IzMz89Xx48cvr1+/foRaqURqetpdExMTNG3aNPDOnTs7hw8b1jMyMjKCxWLpTO8EgEmTJo2/dfPmijOnz1zbuGnTRkC7M545c+YwAGjerPno+vXrc772DSAVS9gpKSlQKVWVTLfaGApg+/bt/tt//jnsS0qKf4MGDR7369ev+fHjx6+NHj26jX6lNqBWCPzdoBCE+vXr16DSaCxbW5uF9es3oDk5O2mDjn7Hy6SBRkcnnZqaivT09L0FefnFBKAgj6jF74d+wOy5c+d+LioqUgLgrl23br72+68goHVfXrlyZY2Li4uO57y0tBQEQSAnJwfe3t7DfH19jcnWq4P+uJ86dSpELpOVGtraQq1Wg0ajgUaj6QqxEASB1NRUTJ06dR4AHDhwYLWxsbGujCrJ815SUgK1Wg2xWGzYp0+fXsD3NxQvXr4QisSi0Pbt28PAwEAbcJmYCIFAAAqFAoFQgLY+bQe6ubnW2Mbdu3czs7Ozo5ydncHhcAxtbGxUNBqNT8Z+/Qho5WXlP3QgAEjEYjg6OpZZWFgYl5SUlDMYTLyKfXVjyNAhi6tqK6Ss6tmjx9CnT5/uMzY21nHnfvnyBVKpVMfJfvHixQ3Lly+PqCmNDNDuqCdNmrR148aNrS0tLXV87bGxsSApAnNycvhbNm85/tNPP01o0sTLp7io6LmhIQ9qtRp0upZ1SK3RDouVlRWSkpJuPnr0SNCxY0deTQsxeU8EgLHjxnXbtn27ZVpaWgGLxYKhoSGsrKxgbm6OxITEzNOnTj1atnx5x8qmOgIe7h60sWPHrjh58uSiu3fvHvj1119Xde3a1fKfCJDTQLtTNDY2Njt06BAAQFDOv5ySnAyBUAg2mw17e3vweDw0a9YMderUmT579uzuACCWiJGeli4PDw8POXP69HAjY2O5qakp2rZtaxQREVHerFmzXocOHTrt6elpymAwIBAIkJ+fr8u5JCo2cNHR0cppU6e2F4lEJf3791+44+eft7m4uuruT3/HzmAwsG37tlMTJ0xscPXylQN9+/btEh8ff+Lzp09Pho8Yzpo7d94OR0dHt3379s26dOnSy7Fjx7bST3OsX7+edb++/Yhbwbc+f/r0CR4eHhg4cODi1LTURxQKBVu2bNlEpVD0zIIE+PxymlQixYf3H97Y2tqG5ufn+/UfMKCp/tgvXLDA7+rVq2FGRkb+d+/ezRszZkxbiUQSOWXKlO5fK7XVCoG/GzQajWCxWPDw8Oji7e29gcvhwtLyh6poVgsKQcDExASNGzcueSl6sYcg/sKKL/+P8ez5c354ePg2jUaDIUOGLK9Xrx4L+FY7P3fu3Au5XJ5A0monJyfrNGuxWIwpU6Ys0Z5XfaoY+TcKtJrx69evt/bs2RMcDgcEQUAul+v4QwCtti6VStkTJ04cFBsbWxYbG/vEyMgIfD4f6ooUVy8vL6jVamRlZaF169bTvby8tGk13wmGu33r9s2iwiKZIZcHiUgMkUgEgiBgYGAAgiBQXl4Ov15+w6trhdwAhdy+fYPD4cDMzAzGxsYcBwcHfnp6+g+b2wGAxmKxfvhgCoUCU1NTmbOzs2U5v5zm5uam/PDhw9XSstLFJsYmlY4lF9iAwYPb7dmzx00oFKaw2WwolEo4OjpqhatajQpavjsPHz0SdOrYsdrgFnJRnTBhQqsTJ07UV6lUHzkcDhQKBQQCAcwtzEGlUMHmcBAZGfnzTz/9NGHhgvnb582d19bWxgYgCMikMlCpFNjZ2EGpVJIWAuW1a9d2duzYcfWPmE+dnJzQv3//BWfPnl2iUqnA5/NhaGgIY2NjODg64OrVq/MmT5kSb25urnM9kPe+bPnyuSdPnlxfzucLtm/btqBr165nCOKfEegEgKVLl85K/fIl+eatWxfYXI7Fly9fDMvKyl7b2NggNjYWhoaGyMvLg0AgOLRz504MGzaMMXfOXPW79+/2qVSqEiMjI/Tv3797WVnZFicnp+ve3t6bRo4cGUJGfn7+/Lns3LlzB5KSkva5uroWmJubsz3q1Gn/8sUL76tXr14QiUQly5cvv71p06be5L1V7W9yznTq5Ft/27Zt3H179j4NvnXLmUKlSOt61oW1tY3G1dUVO3funHn6zJnl69etGzl27Nhk/Y1RaUkpYWltxQYgmjt37hgrKytNRETEWXd3dxw7diy8Q4cODmq9RcWAxYJEKlOXlJbg5cuX3pZWlvInT55k9+nTZz+NRoNao4GG0L50gwYN8qPT6eGGhobD+Xx+2e7du3u0aN48slnz5t1/y8pTi78GGo0GDDoddAaDTmcwQKFQvikC9HvBZDJB0ydMqMUfBimc9u3btyYzM1MOgLN27dr5QGUNl4A2eDY4OHi2s7MzjI2NkZKSomNnAwAHB4fWQ4cOrdF3/bUt7TVPnTgRHRsb+8zW1lYXEF1cXIyysjKddl5SUoKuXbsONjc3x9KlS7e5ubnB3t4eFAoF+fn5yMrKQm5uLsj1fffu3dO1916zwicQCnHxwoXDcrkc2qA+NegMJmzsbEFAayGkUWl2gwYNqtHcXl5ejoiIiMsEQaCsrIzSpEkTtpWVVX55eTn0rZi/BQqLxcKPfuh0OoyNjfn29vbSB/cfsD9+/IjPCQkxEeERb/U7Vh8W5ubwrFt3UnJyMtJS05CRno6CggKkpaUhMTERWVlZyMvL0/xy8OAvwPepYM3MzODdsuWUpKQkZGdnIy8vDzKZDIJyAYR8ATQqFdLS0j5evnz508CAgDZCscgoNT0NOTk5KCopQlZ2Np4+fYoXL17g+fPnSElJweHDh3d8+vRJ9nV4qr82OQRLliyZBYArFAohkUjw5csXAFoO+/yCgtcnTpx4RvaFfmt1PDzokyZNWgMAkXfunL12/XpCTX32V4IUdsbGxgYXLl48lJycnP054XNSTOyreAqN6pKdm4OPHz/C2NgYr169QmpqanFaWtrm27dvr3V1c11PoVBKNGpNp9GjR9+ZOnVq5Nq1a5s5OTmpEhMTkZCQ8DwlJUU4f/78PUOGDHHm8/krnj17lrtjxw5VXFycIOrRozCVSrU2ISEhoXu3butIYa7G9yOJ+Xw+/9Pnz0IHZycIRSKpVCqDUq3CL4cOyTQajYRGo6Gpl9eIL6mpKVs2b34IfJ03Dx48eHDt6lWJo5Mj+Hz+mU+fPp1t164dZf78+fc6dOjQ85trCQRITU+9TYDAm9ev5YsXL4a7m5v91/W9clpbv379em7fvn3xokWLkJ+fj55+fr3evXsn+wc8J7WA1lKn1migVCikSoVWc1FD84c/AKDUEo78uBpUixqgfQsiIyOzrl+9ugsARowYsaJevXraqFrNV+ppADh/7lxMQUHBKzIeic1mo27dumjcuDGsrKywYMGCPZQKa1pNIFnmAODgwYPL8vPz8e7dO7x58wZv376FsbExGjVqhDp16qBOnTqwsbHBwoULlxQXF+PYsWN78/LyEB8fj9jYWFSQaKFu3bqwt7dH+3bt2vfo0cOp5qfVXvnWjRuvvqSlPhaLRSgoKEBxcQmsrazg7OQESwsLUClUdO/RfZKtzbcl1PXy17/k5uU9dXR0hLW1tYGTk5OCw+HwGQwGmEzmD38oRkZG+NGPsbExQBDo1q2boH7dehb5efkQlJfj3r17evzoX0G+MBMnThwPADQaFVw2B1KJFBSCAmdnZ1hZWcHFxQVxcXEHyVKl+g9LClSyrekzZoyvX78+t0mTJvD29oaXlxfKykqRkJiAtNQ08Pl8/LR16wI2m43AwMDFdvZ2aNqsKZq3aI4GDRqATqdDKBSCLOYhk8nK9+3ddwTAd3f65H00bNiQ3atXr0UAYMjlQSqRoKioCBQKBZaWlrh06dLM4uLiSqZ68t5XrV61wNLc0gIANqxbP7Nqn/0Z4a5zTei1UbX/KnLoeVwul+Lq6ordu3dfAGBaXFwMoVCo2ySJRCLs37cPnp6e3YOCgiLv3b/3YM6cOd3IHPPgW7dY4eHh2L9/f5sdO3bYnTt3bu67d+/KCwoK2qxZs+bEli1bnsXGxjbevn077ty5Ay8vr45nzp5dTd7Hb9klRGIR9u/f7/T06VNIJBIkJSWBz+dzVq1cGWphYcGSSqWQSqUyniEPmzZv7nH58uWwmJcxgkOHDsVs2rRpio+Pj9rN1Q1UKtXoy5cvMDU15fn7+3cm2yf5u4VCEWbMmHG2rLQsqWnTpjCzMAebzWa6ubuPJQitGZ1S0Z18Ph+XLl16c/To0XWnT58+zOVy0adPHxQVFSlTU1NrLlBci78cGrUaaqVKjt8RBPc91G7G/jy0tRe0CAoKCpTJ5WCz2SYbN25cAlRk9RBfBXBpWSmuXLkyw8zMDGq1GiKRCBYWFmjcuDHs7OzQvHnzlpMmT9Iyyv2A1Ss4+HbWh48f7zs5OcHZ2RkuLi6oX78+nJ2dYWFhASsrK7DZbDRt1rR19+7d6+3aufMSAAGDTgeVoIBJZ8DMzEwn6+RyOUaNHr2RyWTWeHVy3ly+fPmkpaUl6tWrj8ZNmsDGxgZJyckIDw3Dw4ePEBcfB19f30lkP1TXxrNnT082btwYbDYbhoaGNk2aNJGTfvzf86E9e/bs94wbAMDc3FzsWa+ueRm/nGFsZCy/G3nnXHpGxraauN07d+5iVcfDo1NBQeFDcifBYDKgUGjfSRaLhby8vNRz5869mDt3buvvCbZWrVoZurm5jXn27NkB0lTi4OQE+wrSAYVcjk+fP4d/+fJFNXbs2EVBQUErysvKQafTQaFQwGazdb57snj95cuXf1qydMksxxrunwQZcb98xYoFiZ8+B9na2klAACqV1oRvZmaGlJSU12fOnHkxb9681vpPoQHg6OCIqdOm7Nm8cdPwN2/f3Nuze0/8nLlzmv4V6WtfLQlfswyqtlm1LOmMGTNaeXh4pN67d2//mzdvMqysrO5YWlq2r1Onjkvnzp19fX19O9jY2OjuX0fKQdGKOWcXZ8hkMn5JSQnc3d17LV26NKRJkyYAAGcn55ujx4yeyWIyTfcfOHCYTAX6ETRo2JCXnJz8adGiRVsSEhJ21a1bt++lixe3d+zUyRoAaT5zcnR0QufOvvLjx473crC352ZlZwstrayQn5+PpUuXhjo4OHRctmz5wJCQkLsUCmXr1atXl5C9lJSYVLZgwcJpDx8+uLRm9RrExcchPz8fzk5ObDMzM1tAu8HLyspCaGhoyLVr11bWqVPnTUJCAp48eYKhQ4fy8vPz2WPGjNnZqVMnQ/0xqMV/HzS/J0S+FjXizNkzbx8+fHgVAKZNm7bFxcWlkp5Eru2XLl6KKS4peeXi4gIqlaolVCksBJVKRVJSEhYuWLiLw+b85htFWs8OHz602czMDCYmJlCr1aBQKCgvL8fz58+11yUI5OfnY+PGjUsB4MWz57s7te8ILo8LCoWC9Ix0pKenIzMzEyKRCBqNxqFHjx7fmMirrtWvX7+W3g4JOcvlcpGWnga1RgMaharNoadQIJZK4Ojg2L5rt241ZjZl52Tjwf0Hp6hUKt69e8cYOHAgs0WLFrm/Vfu8OtAEAsHvOkGj0UCpVAobNWok/vDhA6esrFSel5+fe/nSpahFixZ1qPrAGgBstgEGDx488cjRow+tbaxBJSjgCwXIyMjU+hcq6tKePHlyw9y5c0P1tVp9kFHHI0aMmBkcHHyAz+eDjHivV68e7OzsdAEEu3fvDtq9e/eKhg0b+r5///4BQRC6zrG3t4e5uTkUCgXYbDYSEhIyjx49GrZ+/Xr/HxGubXx8OPUaNpgU/eLlXgcHB6iUKigqeOp5PB5OnTw5adSoUe/Nzc2hTy9KgMDM2bOGhUWEb4h9Fftx7549U2fMnBFNo9EqBYf9KH6rxGdVbb06dOvWzbBbt27LSkpLAA3UVCqVwjM0hH72w9d707ZiZ2ffA8Cali29cfnyZaxfv773uHHjbusL/wEDB7hkd80JYzKZYFXscmsOPKx8dwwanXB1dTW4du3a+ujo6PXe3t6VjqfT6dizZ8/i8IgIpkajDn/y5HGUSCwWDhsyFHNmz+4uFouXBwQEdASAyZMmdZVIJXeePXu29MCBA+WjRo1i7tixQyYQCA4QBMr79esHewd7XL9xnfL27Vu1iYmJaFBxcR4A66LCQsyaNavfnTt3giUSCYYOHTqve/fuJt26dRvl5eVl0adPH4aTkxMT+LGUmlr850JTESxbq63/MRDQ1nRYEDh/CgB4eHg4LliwYCqgH9CmXb9LSktx9uzZaWSqqlKpBBn8JRaLAcBu5KhRNRYvqYr79+/zX7x4cdTFRUs0RnKeFBcX63zpFXLBYM6cOf1u376d9Pb9++d2trYQCAWQy+VITU/TcaRIpVKMGTNmTnV861Wpyc+ePRsMoJx0GzAYDBgwWWAytV6GrJxsDBo8aJxhNcXAyHZuXL/xOC09PYPDZoPJZBp06dJFolarRT/CDFcVNLNqarL+5kk0GrhcbpmVlRWXRqOVikRihIWGndQK9Oq53QcNHtzvwcOHhlZWVnwKhQI3AwO4uLoiKysLNBoNCoUCGRkZEQ8fPuRrNZ7qYsC1rfXv379+u3bt2paWlj41MjICnU5HTk4OHj9+rEs92LNnz+Z169at2LJlyy8TJ070tLOzg0ajgUKhgImJiY6YhkKhoHHjxoiIiFg3Z+4cf3Mz89/w2ZB56ZOW3A4O3svhcrTmJjEFDBYTFIKChMTED7t37b66YeOGQfqasgYaWFlaYfy48cdiX8X65BcWxJw8efLJpEmT2pET/nupGVUXGw00KCstA18gEEgkEggqCtGoVCqAIECn0cBgMMBms2FsbAylSgkATGNDIwadyYRSqQSTyQCFoMDUxBSoxuvwdWNFpmUB48aPawUCIY5OTq+mTJniO2L48A7a9LGvd0aAgFEFuxHZxvc2IGq1GnKFHAK+AEKhUFBaVgYDFovl4eFBLysrk4nFYrWxqYkBNADbwAAtW7Y0aNmy5dLCwsKlHA73bnp6+rMO7dpN79+/vyVdr4hBXFwsvay0lGdmZiZ4+fLlFh6PB5FIhNTUVDRo0ADFxcVdHB0dt4wbN449Y8aMhrm5ufIjR44MoFAoPS0sLB6LRKJ7EokEJ06eeDR40OAOHA4Hffv2/aaPyDKrtVr6fx80ADTq2j3ZH4UeZ3t0YVHRSwCYNm3aGVtbW+gXGSWP++XgwbuJiYlx7u7uEIvFKC4uRnl5OZhMJgoLCzFz5swVdnbf+purglxPrly58rOTk5PCxsZGp7Sx2WxYWVmBILRMktnZ2ejevfsqHo+HpUuWTiwoLEBhYYFus8HmssFisUiKWMO5c+dWGwxXKapeKMTHjx93d+nSBTweT7f2UqlUKJVKqJRKgEJwhg4bNkjbVtV+0yIsJPQcKoqJubu7G2VkZJTu3r37d2vnAP5YcGdFeL+kWbNmdmfPni1u1KiRhEqlXHv95s1eryZNqs3A9/Ly4hkZGQ0PDQ09ZGlpqUttatiwIUjuWwMDA3XwrVu7OnXqtJoCQK0hoKumUAENtFGp48eP37Zr1642lpaWYFREu+bn50OhUJBMdOKtW7ce37Jly4SmTZu2lsvlL7hcro7cRqVS6QbQxMQEycnJ0efOnns5d+7cVt/LKdaVc+zdx86nbduBr17FXLe3t4dKqYRCqDW983g8HD5yeOb06dMG2VbKS9f6jyZMmNB648aNrfLy8l5u3759TK/evZJtrG0qhGnNDgeRSAS1RoP3794LPn38ECuVSh+t37Ahtnv37rdHjhyJ+Ph4yOVyyOVyUCkUMJhMcDgcmJiYoGXLlti/fz9Onz5t0KB+/V729g4NmjZtSnTu0hkxr2KauLm5d3F3c4OxsTHLyMiIrlSpwOVwqhXCJiYmCAwM7AWgl/64VEcBDFQW5CTpgkwmE2dnZanevHkj+/z582l3Dw9B8K1b6k+fPh1bvnx5tkgkQmlpKZycnGBgYIAFCxZQDQ0Nx02cOMGBy+Ux6TTaxK7durFsbGx4Cxcs6Aagm/41SSG7Zu3aOSNGjJi4e8+exY8fPz4XExODwMBA8Pn87l5eXqMbN27cr2HDhmjfvj0+vv8wNzYubndxcfGLiIiIFy4uLoiKisLs2bMvjBs7roN+2+RzVh5b4jetJtVZnvT7q3ZD8CMgoCGqrgx/BppKP2rx+0AAKC4uxpEjRyYCgKmpacupU6dWmKsrH5efn4/Dhw9P5nA4EAgEUKvVKCoqgkajQUlJCWg0muG8wMApQPVWr6oW1FevXoni4uJ+dnBw0HGbkNHsZCEwpVKJ7Oxsypw5c5a9evUq/+Onj48tzMxBpdFAIQhYWlmBV5HenJWdBX9//2nNmjWrVo7pB+GdP38++u3bt88cHBwg1jJRIjMzUyeDSktL0a5du4HeLVsakmdX7g3gzZs3svDIiMs2NjYwNDRkeHl5cV1dXYvy8vJ+iLu9Kmh16tT53ScBgJGRkaxt27aCgwcPmqSmpUo0Gg3/xvXrwV5Nmgyv3OlfjbUBAQET3r55e8jJyYkU4MjJyUFmZiYYDAakUinevH69c8bMmavd3d2/e/2ePXv6bNiwoUFcXNwHLpcLKo0GR0dHrXYKrfC7cOHC1i1btkzo3r37mgULFvi5urpCo9FApVLByMgItra22pJ6ajUsLS1x+fLlmaNGjXplZmb23Shs0pe+IHD+toBBAdeVCqXOMqBSqcBgMJCVlVWwYcOGnQd/+SWQUmXhNzAwwI4dO46OGDGiUUJCQuq8ufOCLl26tFxfFIhEIhAUCrKzswR3I+7IbexsT3z6+FF0O/j2zZbe3q+vXL6MkaNHoaCgAPn5+fj8+TNMTEy0KTgVaQ5yuRxCoRAZGRmIj49HYkIiDJhMycvo6Ksvo6OvduzUEW9ev8bcOXNhZGiINWvW4uSJExw2hzN5ytQpxhQKBfm5uX3bd+jgbu/gAFMzUx5BUMBgMEGjVp5sBCoLJrVGQ5YNlKWlpckf3n9QbGtne0YkFqvXr1mXM3zUiKP169VTjxkzBhwOB4sWLcbNmzfBYrHw7v07eLh7wMLCAnl5eUhJSQGFQlG9ffv22K93foWxiTGCg4OXte/QEXm5uRPXb1jvIJfJAuo1qO/kYO/AMzAw0AlWDodD8WralHfixImDly5d+kkul8Pb2xsjRozgVeVHDtr2087Zs2YlFxYWhjo7O2PTpk0YN27cT9u2bRumP+76QpvQ/dT+plKroajo93J+uUCpVEGlVILL47EdHOyp+ueSueu1QvwPQfODXBu1+BtBzvtlS5fuiImJeQ8A27ZtO0xWVNPf7ALA1q1bD6enp6d7eHhAKpVCoVCARqOBSqWiuLgY06ZNW+/u5lahZVavUAFflYRly5Ztj46OFukfY2FhAQMDAyiVSl3qWuvWrQc5OTlh7dq1P9vb28PBwQFUGhUikQilJaUo52trlmdmZmLP7j0zgO+lqlUw3P1ycH12djbISmi2trZwdnbWuX0JgsDQIUOn659Xleo1NDQ0jMfjldapUwdmZmZmHTt2FNra2orJOuy/FzRtpbM/cCKNhpYtW5b7+/tbR0ZGgkaj4cKFC4cWLlw4nMfjVexjNNDXTAMGDfI+ceJEM7lcHsflcgFoA5wsLCygUqnA4/HwRSAoO3/u/IPVa1b71pSnrYG2fnWfPn0C9+7dO8nOzg4atRp0BgP2dvagUCkwNTVFQkJC4vnz5z/OnDmz55IlS4zy8vLK2Ww21Go1ysrKwOPxYGJiouMPTk5Ojj1//kL07NmzvH+E9GVgwEBXb29vv7i4uHBbW1sdkUF5uZas55dDh1bNnTt3et169ViVAyuA4cOHN7x08eKkW8HBRy9fvrxx9OjREzw9PTkXz194b2hsdKe0tAR37ty9M2Xq1Gfr169Huw7twefz8SL6JcZNGI+sTJ++9erXb3by5Ml2piam3lbWVuCw2aBWvByAlkRBJpNBIpGgvLwcnTt3hkQsRmZmVpxIInrUspW35sGdX9G6Zav81PS0Yyqo5WpoRC9evtg1ZeoUhISE4OrVq2t7+ffCrNmzsH7dutbu7u49+/brh3fv3pl61qkzwtnFhcFkMsHlciGXy8nNwzV7O/v0AwcPCH07++5zc3OTzl8wH71798aAAQOQnpmO2JgYNKhfH3U9PV29W7Ua5e7mRlm7Zg3bwdFxtJu7G8fM1AxUqvaFa9y4MTp37ow3r9/ctbSyfJefl6+2srI6RiGI7Ni42GMRERG4euXq2ukzp+PTx09D+/XrV49KpfavW7euq6OTE8/AwAA0KhVDhw79xpGlz/LGYbOJZcuWhdy5c2eHWq0WnDx5suuYMWPakseSi4hAKASTyYBIJIZQJBSUFpfg48cPSE5MPl+vQf288NAwzZVrV6/17t37/fTp0xEfH4+tW7caBwQEzG3Xrl23Zs2aNbd3sGcxGUygkoCvFew/BEIDgiBqCWD+A0AAeP/uvfLI0aMrAaCzr++ICRMmeJHf6wuwT58+yfft27eQw+GgrKwMCoVCW3ylgoaXRqOZLFy4cI72vOqJZL5eFUhISBB9+fJlW7169XSmdZlMhoyMDAiFQlAoFCgUCsjlcixZsmR9aWkp4uLiDjZq1EjLX0ChIDsrG4WFhWAymSgpKUGD+g18+/TpU2OqGolnz56JigqLIlq3bg06na6jiVUoFNBUKDPW1taeQ4YO8SGfp+oTiEQiXLx4cRePx0NMTAy8vb05Xl5eRWKxWOeD/72ghYaG/qETNRoNzM3Ny11dXU3r16/PKS8vFyUlJT2KvHMnY1BAgKP2pitvoY2NjFC3bt0px44dm8blcnV0ey1atICrqyukUik8PDzw+s3r5WKJ5DnbwKAaL/rX4KzZs2eP3r9338KCvPwyFosFiUQCtgEbLVq2gEKhgLGxMa5evTp+xIgRL6dNm7Z23759gWq1GhqNBjKZDMnJyfDx8YGBgQHUajUcHBxw69bNWaNGj4o2MTb+ruZE+tLnzZu3bcSIEeF5eXm6SeXh4QEGg4G8vDzRL4cObd21a9cafYpQMrhvzdq1v9wKDj4HQHL//n33y5cvK86cOSOfN3cePiV8wvPnzzFx/ASMmzDeLCUlZWbvXr0ovXv3HtmjZ0+rUaNG8VgGBqD+MWKrjgA6qjUaNGnUGHMC50EilezIz89XONrbIzc3L9TO1i6hTp06MOIZ3qPT6Y8/fPiA5y9evCAolBd0Oh07duyAUCic4+vri1GjRoHL5SI1NRWrVq0Cl8tFYGAgYmJioFKq4DzJCQ0bNvS0srQcZmdnRxzYv7+JuYVFl+bNmyP6VQyPAAFWhdD9HgYNGjQQwEA+n4/5C+ave//unaB7j+73cnNz39jY2gQnJSbFXbt27ZKNjQ2uX7++duzYsXj+7Hnn1j6tOxibGDf0bundvWHDhjwKlQq2gUEFKUnlOerh4QEPD4/5FdzLKCwsFGdmZaqys3MQHxf31tPT81djY2OcOnUKYWFhd0aPHv2spbc3xo4ZAyaNjotXLiMxOUlXnOHNm7cQi8Xg8/llwcHB6xITE9cdOXyYzmQyF7Tv0KFN7969Ozk6OfK4HC4otcL9t0EAGrUGSqVSWhuX/u+CnK8bN22cB0ACgBUUFHQaqLxRJo9bvGhxkEKhECgUCohEIpibm4MkNhOJRBg2bNhCNzc33UtQkzAnV7zdu3dvd3R0FJHZSQYGBnj27JkuJZmEg4ND6x49eniOGTNm29u3b4UkeY1YLK5k0QWA2XNm/0QQRI0bCr0CMDs8PDxU9vb2oNFoyM/PR2JiIlQqFeh0OgoKCjB69Oip+jFqVdu6f/9+/rt376IcHR1ha2vLcXFxUYeHh5eRadB/BDSS6esPnUyjwdXVVZ2cnGynVCoT3dzccDfyzqFBAQGbyFKi5N6ENFdOmz5t5LFjx5ZoNJpyMnggOzsbFApFt6vKzcl5ceb06eipU6d6V79L03a3h4cHo2+/fgtu3rq5ik3VBqVl52SD9poGJpMJjUaDrKys6LCwsJRNmzbNO3jw4AoGgyGm0+ngcDiQSCTIy8uDubm5roLbl5SUmDNnTr+cM3tOq5p3iF996QMHDmzQrFmzTgUFBQ85HA4oFAqsra3B4XBgZWWFGzdubBw0aNCCdu3accnztD8JNG3alDpu3Lh1J0+eXHzt2jVRQUEBo1v37hNberd08KzriQ7t2vdp1KSxx5BhQzlKpZJSnTXljy78BAhQKqgJAYDD4bDMzcxZDeo3AIBhao0G7dq3w9IlS9eUlJYIUlJSsHHjxgwPD4+rBiwDjBkzRnXol19uWVlZvfX09ERiYiIMeTxwOByTvn36zPD09KRv2rTJysHBYWTLli0xavRoHkGhgM02AIXoUUOf/rYPmQICpKm8Q8eOvA4dO/ZXKpX9Fy1evCYuNlbQokWLh2KxOM7V1fWRQCB48ObN6/uNvZrcX7duHUaOHIm6np5Wr+NfT5s3P5CIjIxkUCkUFzabw0jPTE/38WnDr+PhgeDgYCQmJqru3LlzefDgwQn9B/TH0iVL8PHjR/Ts2RMbNmxAYmIiysvLIRQKQQBwdXV1bNWq1RgDAwPavHnzKP379x/dtGlTMx6PB4IgYGVlJc3Lyzvy4cOHe+/fv7+vUCiCPn76hPz8fBgYGExp1KhRFwtLSz9vb29eTbELPwIajQZDLo/JoNGhUqt+O+n/vxDaIDa18q96NAIEiL+b4el/BFW76ciRI28uXbq0HwCGDh26uqW3t25XrtGpPcDbt29lMTExW1xdXUGhUMBgMODs7KzLcCosLOQFBgbOBb6/ppFXj46OFh88eHCb/ncGBgbw8PBA48aNdXTg+fn52L1792mhUIgzZ86sBaArEGZpaQkrKysolUqyeEqr0aNHt/h679Xj46dP0l27dm3ncDggK6E5OjqiXbt2OqrZvLw83uzZs7/NPdcQOm6L+/fvH2zSpAkkEgkMDQ0tW7ZsqQG0AX1/FLSPHz/+4ZMJLQ9yQWlpqeOXL1+oXC5XdezYsQPzAudtqFevXrVbjBbNW3D79+8//uXLl7vs7OxAEAQkEglevnypSxuQy+U4cODAmqlTp4bXZPomNwhLly0NTEpO2mJjYyMm88ufPn2q2xyo1WrMnz9/3OfPnx8vX758TWRk5BJ7e3tdBCGfz0dJSQkoFAoIggCXx8Ppk6emjBg+4o2WwrVmkAF6AQMDphw6fOihra0tlEolioqKkJGRAQAoKipSLliwYPTLly9v6NPLkhuC3Xv3LLpy+crZjIyMtw0aNGhy9MiRo2ZmZqipus9fpbl9z3NLCntyYvEMeTwnJyd07ty5AYAGQpEI7Tu2x6ZNm9aLJRKBSCQEm8MBh8NGwqBBHDabTTFgG4BKqV7j/jPPUF3UKY1Gg5GhIXx9fXm+vr59lCpln5mzZuLTh4+Cxo0avTc1N79zNyLyS2lp6ekLFy/mGxoaristLcWe3bvBFwhAzrH8vHxs2LwR9369hxcvX4BKpaKgoAAcLhc+bdugKL/Qz8nJqVVpaSlWrVqFjx8/9m/RooWrq6sb4uLieXSGttYyt5qxa968OQ/A8rKysuVRUVGCvLy844mJiY8TPidcMzYxPpyTk3OYz+fj+ZOnkxs2atSytLR0WLOWzWFtZQ2RUEiAIMj0f1AICkFQCIJCoYJCoVAI7Xc0KpUKhUKJrOwsqVgsBo1K03bR/yJ+tFrFD0KtQW3e2g9A34etUCiwYsWKCQDQ1KtpnZ07dy4FKr+jpBCYM2fOBIJCSMlI9NzcXERFRenM4q1atQpo3rx5TSXNdCCH58iRIz9ZWFiIDCosbSqVCubm5mjQoAE0FRHjIpEIderU8R4wYIDHkiVLfgEgJt27FAoFnp6eMDQ0hFKpRFJSEmbOnPkzm82ucWXU+c4PHDivUCj4ZEU2Op0OqVSKL1++QKPRICcnB61btx7RsmXL6nLVAACJiUk4fOjQHlMzM+Tn51P79etH79q1a8YfyT3Xxx/2oZMwMDCQDB48WGpgYGAtEAiy+Xx+2a1btyLr1avnV1UYk0J42LBhE27evLmLNC0olUqYmprC1dUVKpUKcrkcnz59iggPDy/w8/P7buWFVq1acZo3bz4vOjp6s52dHRgMBho0aIBPnz6BRqNBqVQiISHhycOHD9Pnz5+/+MaNG2slEomENGkYGBhALpfrgjM4HA6Sk5PfHj9+/NHixYs7/oiW3rFTxz779u1FRkYGDAwMIJPJkJaWpou4jI6Ovrlr1674efPmVSKR0UADQy4PW4K2nJgzZ07zT58+xew/sH/31qCtFTtV4N9QsL4n7CkgdALLgGUAY2Pjavn3te38M1HbVYU8jUoDl8NFS29vXktvbx8NND4dO3RAQWHBvvCwcLGFhcVxoVAoHztunCYnJ0emVCrVNjY2THNzc2pmRgamzZiOtu3bGjds0HCQtbW1oZWFJbYGBWHH9h1aoa1SgcPhoF+/fjXeE/nsXzMmtIubsbEx+vbtywMwVyAQzH3x4oWAz+ffSk5KfvH58+f9ySnJR548e3okOjp6yoFfDiIzMxPTJk1BSVkpwWGztZstCoVCUAgKhaBQqDQqjUJQqDQajUWj0+gaDcGQSMVFhQWFqOAF+J/T0P9qaAWAWl3bVT8Gck7Pnz//WGFhYRwALFy08IyNjU2lzAPyuAMHDrx59OjReQ6Hg/j4eDAYDFhbW4OMTM/NzYWvr+9g4MdG4NmzZ6IHDx781KJFC101R41GA4lEgtTUVJ3rMzExETt37jypVqtx+PDh1aampmCxWLp4LZFIhLKyMtLc3mDAgAFtyXuovhAMUFBQgF9//XWfh4eHrjRqRkYGPn/+XOnYgICAydU9D7khiYgIf8jl8korCrFYDh8+XGVjYyP9o6Z2EjRPT88/1QCdTgebzebfuHHDPC4uDkZGRjh58uSmWbNn+3E51TP99O7Tp1HjRo1blfPLX5K+dCaTCTMzM50QpNFouHjx4i4/P7/NNRVOITcIo0ePWXT9+vXNJBscjUaDsbExxGIx2Gw2hEIhFi9ePDk6OvqOv7//6rt37y6zt7eHWq0GlUoFi8UCSYJPEASMjY1x/PjxKWPHjUuw+gGGs2bNm3GdXVz6iUSiW0ZGRjrtOikpScuvS6Fga9DWSTNmzIhlMBi69kiD1OzZs5uFhYZNiIiMOL5/3/75A/oPGNG6dWsL/Wv8p5Tn1M9d+BErpX6U699x79VXX9L/uzYqncfjgcfj8WbNmsUDsEwoFKL/gP4V7KHakaBSKFAoldVq2NXht6Jg9e+P0JvDJKcAj8dDt27deABGiUSiUW/fvg3Kzs6+/cuhQzH9+vXbx2IwFVcuXYaVjTV4hjwNQVCgUimh0WhUCqVSpVAooFAoZSqFEkqlgq/SaKCpoNFUadSg0enay/0PocIi8Zczu2k0GjWhDZT68UoY/w9Bzt3nz5/L9u3bNwkAOrRvP3Lo0KHeQFVWNW1g7rZt2yaQ67pMJtPVoWexWBCLxbC0tISfn1/PqudXBemGOvTLL5spFIpEKpWSRDS6bCVAK9wFAgFsbW0bDxs2rF5QUNClsrKyQhcXF2g0Gh1TKEmqlpKSgiVLlqy2sbH5rtUSACLvRMYYGRrGu7q56YLwhBVVK2k0GoRCIXg8ns+gQYOaV/c8BACxRIITJ04sZzAYeP/+PVq0aMFkMBjFV65c0T3DHwXt3r17f6qBisLxpR4eHtyCggIWn8+XJiQkPA0JCXk7bOjQxtUxx3HYbEybMX3Hrp072zo5OelKoSoUCt2Oy8XFBa9fv9778uXLFa1atfruCtu1axfjpk2bDnrx4sVV0oxPpVJ1/mEbGxvExMTcjY6Ozl+0aNHSkJCQdQRBSEmTMpvNhkAgQEFBAeh0OgiCQFJSUuL2bdtObdu2bexv5QmzWAZo3759u5iYmFtUKhU0Gg10Oh3W1tbgcrnQaDRITU2NW7BgweG9e/dO+Zq//HVTsvWnrUcj70SeEolEqjFjxgx7//79PQaDATVqcjr8O6g8lj9+X//URqS6eIuqrwgFBMgsi6ogo0v/jHWhJv4C/d/1j6CAAIfDgY+PDxfA8C5duwxXq9Sbs7KzFYMHD8bgwYN1wTtkUKdKrYZapYZGrYZKrdKoVWqVlsVRQcvOzg68dfPWsaSkpP8pYQ4AFA3BUimUUKvVqr9SpCuVSkIqlwE6S/5/1nv3b6GqIkEK6RkzZgypOITy844dJ6lU6jfU0gCwYsWKM3l5eXF169YFpaKccnl5Od6+favTqi0tLdt6enp+t7PJ9u7cuZN3Kzg4yNXVFeXl5TrztKGhoU5QUygUZGRkYPv27ecBYO/evYvt7e11fCUymUxX3lQkEsHQ0NCafJ7KFNoANARAVESli8XYsWPHLJFQBPnnz1AqleDxeLC2ttZV8ExKTMSUqVM3aTO9qkdkZGTK69evn9vY2MDFxcXAzc2N8urVqzLS9ftnQGvXrt2fagDQBuI0bdqUWlZW5piRkZEok8lw7uzZo8OGDt3zLXOcVlvr3bt3m7Vr1ri8fPkylSw+L5VKUVZWptOUhUKh8KetW3dcu359Vc1autaUOXfu3E2PHz++qlAodFo+OYBEhT949erVcyMiIi527dp11cWLF1dwuVydRi8SiSCVSnUpX1wuFwcOHJgzY8aM0S4uLpTfCtTQaDSKBw8e6P5GbiiKi4t1vvx9+/bNHD9hwsRmTZtSK/cJ0LhxY2LFihVXNm7cODApKen+hg0bbm7YsKE/2X//tmb+v4T/tAjyyj5HAhWliFlmZmasJo0b/+72SstKGyQlJeFVXOxfd5P/EqrmMadnZDwSSyUwMzNz/4MZHt+AQqWAxzM0EQqFSElOjgAwtFacV8VXtWbPnj0Rr1+/DgaABfMXnG3RogXtq7j/+tu7d+9UP/3000QAyMzMhFKpBIfDQf/+/cFisSCXyyEWi2Fubj6AZWBQY4qLPkvmxo0bZ0ukUjVZv1ylUsHMzAykP5usPW5tbd1o6NChDQ4cOBBVUlKSQaa2qVQqFBYWQqlU6shfJk6YsLDGOh7EVxPX2TNnXr2Ofx2t/zWDwYCpqSlUKhUkEgkIgrAKCAjwBb5ds0kLw+VLlw47OTnB0NAQVlZWdsOGDVOr1WooFIofGIfvg5aWlvanG6koTJInk8k84uLimAwGQxYSEnIqOjp6i7e3d7XatYO9PXr5+886cfLkAisrK11AHDkwNBoNNBoNN27d2pGQkLDE09OT8T2zbUBAQB39nHC1Wg2lUqnLEbSyskJkZOSl169f716xYsXyPXv2bCwoKJDot2FhYaGzFrBYLBQUFPA3bdq09+jRo3N/y+zv6ekZYGxsvNrDw0MJaAc6NzcXubm5IEvg8QUC5fzAwHH3798/Q6FQdKkd5IK1YsWKAefPn+/y5cuXexs3bhzQp09fpbd3S2otpej/H+in+5Cobuwrk1R85clWKJXIzMjkCwVC0CjU/4lJo7+gf/z0MZrD4cCntY97hUvhz7dPUFC3rieFz/eFkZFxuvaatQIdqOy6IgC8f/8ey5Yv7wcAdrZ27TZu3DicPO7rPNSO1sqVK2cYGBgoSFdqbm4uWrVqhUGDBqGwsFCXPszlcsU/ci9Xr1599/jx46u2traQSqU6lymvCk96cXExtm7deg4A9uzZM5m0AtPpdJSXl0Mmk+mqblIIitEibUnsGrh/v76PB/bvX0yhaDlOyCh6AJBKpbosrZEjRgQ6V8MBTyIuLk508eLFX7hcLtLT0+kWFha0goKCtJKSkj8VDEeCZmdv96cb0WgAI2Mj6fARI4qfPHlipFAoCgDwd+3ete/8ufNLqgpDUqueM3fulOSUlNU2NjYiQBuglp2djZiYGNI3j4KCgrLt27fvPXLkyILqXjKiwqRKAYH5gfO3Dxs+LFwsFoNKpUImk4HFYumY0+h0OubPnz/z/v37V4cPH776woULy0jaWYVCAYlEAmdn54pn0oDFYuHunTs/5ebmziULj9QEDofj5ujoyLaxseEDWg3dyMgIFEKrnVNpVBgbG+PRo0dnL168OHPEiBGtK5vytVXnLl68eGXw4MGm6enpmDR54sD4uPhbWqtBrVD//4LKwXQ/OuZfU4TIf2m+Bgj810J/06JSqZGVmRVLpVAgV8i5rO+Utvzx9gEmgwGFQmGWkZGBp0+fPp45a+Zihl49gP/P+MpdrsX06dOHy2Uyubm5OS5cvHCeZcD6Ksw1X5MP9u3b9yo4OPiwpaWlTpNmsVjw9/eHlZVVJfIrFoulpnwnaYH85tixY4fI8qZqtRosFgtFRUV48eKFrpqmWCyGs7Nzy6FDhzbas3v33dTU1MS6detCpVJBoVCguLgYgNZ1JZPJMHr06CWederUyOJCvofXr19Pefvu3QNbW1vQ6XTIZDI4OzvD3t4eUqlUG92em8OdO2/eTKA6OaVtZ+/evUcA8CusxqYjRowQ2NjYSGvKavq9oJHlLv90QzQ6mjRuUjZkyBDHly9fFhcWFqqCbwXvyszMXOLg4FAlKEq7+Hh5eXEbNmiw4PmLF+vt7OwgFArB4XBgYWGBkpIS0Ol0GBoa4vz580FLly2d7+bq9s2o63fc4CFD6q9bt7bDp8+fo0gzCABd3rKdnR0ePHhwLT4+vvDw4cNLL1y4sF4mk0k4HA5ZkhMymUwXmMBgMJCZmZlz8eLFB4GBgb7fsxCo1WqVXCpTKeVas4mKUIJKocDE2BgikUhrgmeywHB1w7o1a0e2adMmwdnZmaafxgYQaNmypcmUKVPObtq0adS7t++CV69eHbJp06bef36EavHfhN8S5DXFMhDQuv1AAIR2df2f8aPHxr5SvHjx4iqFRkOfPn0qooj/nEgnt0ED+g+YdObMmYXXrl8LuXfvXrGfn59ZLcf+14hvANi+fXvEkydPLlKpVEyZMuVo+/btHTSAbgXTmqcJFBYWqlcsXz4W0GrLZNyHhYUF3N3dUVxcrCN/USgUoHyX9E977fcfPuD+/fvnTExMUFZSCgqVguLCIgjFIm0hFJUKGo0GarUa69evPw0AP+/YMcnGxkZnqS0uLoZIJAKDwSAj27nLly8PBL4X4KrF7t27lzCZTBgYGEClUoHL5eraBLRlln18fOa0bNmyEt8I2QoBICcnB5GRkXsrSsZSfHx8THv37p0tFot1dLF/FrSY6Ji/pCGNWgNrG2tx3bp1NdevXze3sbHJp9PpeaGhoc+mTZvWpurxpKl68JAhC67fuLGNxWJJSL+3mZkZxGKxLuI8IyOjaN/efYd37tw5tapQrZQWRCGwfOXKfaNHjWpMoVBApVLJcq+g0+mg0+lgsVgIDAyc9vDhw2uBgYFBO3funMvhcHTmH6lUCmtra51Qp1AoePv2bZgG8P2eGa6goOD558QEkaQi6lIDgEGno1wggFAk1AX7EQSBsrKyL4GBgVtu3Lixqrrc9EWLFo2MjIw8GRUV9evmzZv7dO3aVezr62tQq6XX4v8jSBPupg0bZpSWlaJt27ajunXr9ufybXXQiqx27dsZ+fj4zAsODt61Zs2acX5+fre1QavaY/6uLI3/fGif/c2bN1iyZIk/ADRu3Ljj6tWrJ2q/rew2BIDAwMAgvkDw0cjISKexl5WVwdvbGyUlJSgsLNS1LpPJwONy6WqNb7VXJwXqzRs3IuVyeZlCJocGGtCoNKg02rrnJHlTWVkZ3Nzc2o4YMaLunj17IvPz8zPq1q0LgtDmzAsEAtBoNF1M0+DBg5fUrVuX9Vs9EBISkhkVFXXNzc1Nl4HF4XC02SQV0fU5OTmUESNGzAOq48rQ4t69ezG2trZfxGIxkpKSjIYNGyZ7/vw5Pzc3908Hw+mutW3btt8+6kcb0/rSjXbt2mWYkJCQaW1tDTab7R0dHf2Sw+F886Dki9qzZ8/Jz58/P2pnZ6crTk/uuABAKBQCGjjHvIpJtbOzq6Gk3VcSg+bNmnd/8/bNXbL4ij4HBZn4f+/evWRfX183Nzc3ZxqNlm5oaKjLT8zNzUVhYaGOxYhGozVITk6OMzc3Z9T0DOvWrV+1e8+ujTz21+hpgiCg1qhRWlYGtVoFkn66Iu+ddvHixbihQ4c20g96I/2F9+7dE3ft2pUDAF26dOkWGXnnDpVK+Y8L6KrFfw4o0MZ/fPj0cd26NWvX3r4V7JxbkJ9sbmZGBYCy8nJ4uLr5tO/Q/kXg/PlrW/u0XkOn0f+j55ReEY6woKCgXvZ29rh85XKhj4+P+V9z32ThWyA6OlrWqlUrFgDMmTPn1u7du/sCWqGu3cz/5/bT3wUKtMRfPj4+vd68eRMGAGFhYYV+fn7mZLYGKcgJADdv3vw0MGBgYwOWgZLNZutIXhQKBby9vWFjY6OLMAcAgUAAKyurdcePH19Np387FynQrqHTp01fHfPq1QY2ywAUCqEzn5OlkuVyOZKTkxEVFZXepk0bRzs7O2sajZbPZrNBpVIhEAjA5/N1AdAKhYL36dOnAk9PT1ZN40vOvb59+8589uzZAQcHBwBaGcKvKFVNkk81a9ZseFRU1HngW4FO9mH79u1blZeXR6elpcHd3d16zpw50uLi4rK/MgOTRubi/RXQaDRgMpn8Vq1acd+8ecNIS0uTA4g+ffr0q+nTp7eoLoWNADBu3Lg5kZGRR5lMpk6rZrFY4HA4UKlUMDY2xufPn9P27dt3bsuWLSO/bedrQAYBYMnSJXuGDh1aj6y2o9FoIJfLAUDnu5k7d+6kd+/ePdiwYcO1devWtTA1NdWxFpGkB0qlll2SL+B/SklJIczNzat9brVaDUNjQ5NZs2dXItVnMpkQCoU4uP8A+Hw+WCy67u8lJSXKwMDA8X5+fjGGhoY6QgZNxUN06dKFvXz58uDNmzf3vXfv3t1lS5f+8tO2n6bVFJxXi1r8r4FcUI8dOxZ++fLlXgAwf8H8MB8fH/O/7A2oeN80ALy9vZlbg7aGL1221O/KlSv9rKyswpYvX+5HwX95IMIfBCmoN23cdJEU5gsWLLiqFeb6nBRaZUokFGL+/PljNWqN0sjISOfyBLTuy6dPn0IqlX5zHTabfXbXrl0rzCo2nlXB5/NVoSEhz0QiEXg8Huj0CiuuRAJFRc0EoVCIIUOGzG7fvr3jsmXLDuXn5+c7OjpCItHGPZPxVBQKBaWlpRg/fvxKT09PVpUktW/w6717JU+ePPnFxcVFR1lbWFioU/hUKhVEIhEmTZq0gOyL6vrwwoULsbGxsWSEPGPSpEkGEyZMKEhOTv5LSQ+JN2/e/GWNAVphpVQqbSZPnszIz89Pz8rKgpubW+ePHz/eA6rfvQBAkyZNurx///6+ubk51Gq1VkgaGoLJZOo6TaVS2cbGxmbb29vXKNTI9lq3bt03Jibmtr29PQBt8IVIJAKNRoNarUZpaSlu3LjxsX///vUaNmzo/eHDhxiSjMbD3QPNmzeDSqm1EiQmJDJnzp6ZOG78eMfq7l8oFGkaN2rYrbCw6J6R0deSnBSCArlCAYlUAhaLVSmKUaPRoKioCKNHj95y+vRpHWUiadanQJti0aljx/5Pnj69xWGzcfz4iddDhg5pUjUNsBa1AP47NfTvFcAAgJUrV95+/Phx36ioKHTr1m1xZGTkVoL4eza15HWHDRt27MqVK5OaNWsGH5/WV3bt2j2INIl+FWL/u2Z4fY07ODj48/hx4+uVlJbAy8urV3R0dIhWkwa+pqhpz5g6der2w4cPL7K1ta201qnVajCZTJibm2utlnrkKRqNBoWFhcS58+dlHTt0oFe3vqakpPBXrVhppNZowONyIRaLcenyJagqk7CwMjMzJRXMa0Z0Op3P5XJ1/nsAOsGvVCp5Hz9+LHF3d6d9M480BEBodHOhT58+M1++fHnA3t5ep/BlZGRAqVSCRqOhrKwMHu4ebRMSE55UNy/Jdpo1a+b/6dOncAsLCxgZGbmfOXNGbmpqmiEUCv/IENUIGp/P/0sbBAALC4uSfv36Nbx27Vohm80Wv3///v6t4OCMfn37fpPsR2rVCxcs+HnM2LFNyZQC0qdNRqEbGhoiISEhZ//+/We3bNkyqiZ/Ntne6tWr9wYEBITweDwNmbKQlpaG4uJinRY9bdq0sf3794/esGHD6YEDB9YzNDSEhYUFRGIRTp85o9+s7GV09Llx48cvq+4ljouNlQn5gnuW5hagM/RSaTQaGBsbQygSoai4CHS9NBuCIMBisXD27NmVvXr16jl06FCvyrSwWmvC+QsXbjo6OlqJxOKCOXPnjOvVu1c8pwYGvlrU4r8R+j5YUpSnpqZi4sSJc+Vy+R4+n48ePXqsvnXr1jqyEpb+eX8VyLies2fPTlSr1eWlpaULnjx5OrhFixajr1y5ctrNzQ0kGdT/ei0XAlr2tcDAwLElpSUwNTXlnTt/LoROp+utUF+F+c2bNz+dPHlyCY/H05nZdW1V1OsoLi7Wkb/of1dWVoYH9+8Hd+zQIaC6Mc3KyiK8mjXl2djaCpgMBvh8Pp48fwYBnw8Wi4Xc3FyMHz9+nb29PSZPnvyTXC7nGxkZQS6Xg0KhgCyaBQCFhYWYPXv2Fnd39+oZAQmNbmQjIyNz7969e8DNzQ1yuRxMJhNlZWWQyWRgMBg6q+/iJYv3fE/LDg8Pz3v79m24p6cnZDKZQd++fY3EYvGHv1o7BwBafn7+X9ogAAgEApmrq2uZQqGwUygUSRYWFjhy6HBQv759D1Q1GZMCePSYMV7rN2xon5KS8tjY2BhqtVoXxMBms6FSqWBjY4OTJ08umTVr1ig7O7vvvsz+/v5Offr0WRAbG7vd1dUVdDodDAYDHz9+hEKhAJPJRH5+fsy5c+fejBw5ssnw4cMDQ0NDd5qZmUGlUqF58xbwatoEUokUKrUKHnU8BKR/v3JmJvD6zevbFpYWqFPH8xvqPg6Hg7fv3kGSJflm8AwMDCCVSlXTp00b07VbtzdmpqaEvgYAEHBwcMC+ffuuzJo1q2N+fv7rUaNGDb50+dIVBp1Ra3qvxX89yHmur5XfuH79XUhoaOCDBw/uOTk5YcGCBTdmzpzZn+RuAL6t+vVXQQ0tNejly5fnnz171nPz5s29P336dGbx4sU5/fv33zh69OjW5L3+r75/ZM9OmjhxTHp6ejQAHDx48Gb9evWhb2onjy0vL9fMnDlzjFwuV5uYmHxDkELSrcrl8mpN7gYGBprY2NhHAAKqU9Sys7Nx5swZODk5gUajQSKRwMTYGKYmJhCLxTAyMqrzyy+/LM7MzFQdPXp0LQBd4J2zszOsrKygUCjA5/Ph4uLiumz5splATXnnX+fWvn371pHR7CTLHRnVrlKpIBaL4eDg4DNhwoRmqOa+yXly/Pjx7TY2NhAIBGAwGJbOzs6FGRkZUv1Ygr8Kf6kPnYRAIIC1tXVm8+bN616+fJnl7OwsffHyxeG7d+9u6Natm1mlgzU6dj0sWLBgx/Tp01uSeeQqlUoXyECabdLS0nK2bt26f8+ePTNr8ieTm4SlS5eu6tq1697ExEQZyR5Xp04dWFpaQqFQQCwW45dffhk3cuTI+M2bN/984cKFvXw+Xwlo6WBnzp4FDpuD8vJyCAQCpkKpBFMvP5UcilfRMWHWNjZaLYPy7QCRTHgkPSAJVUWRj9KysnfDhw1beufOna36ddNJrWXmzJkdnj19tvH8hfMrb968eXX/vv1hgYGB/rX+9Fr8t0NfkL98+RJ37979KTQ0dImBgQHat2/v7uvr+8vs2bO7AF8X4L9bOyY19VGjRvXKysq6Fx0dvay8vPzetm3b7n38+HFDr169VrRr1474XxTs5DMFbd0afvLUqTMA0KdPn2VDhgzpDHx1C+ofO3r06PU5OTmvjI2Nv6lFDkDnSydjoqpCJpPh17u/XkpMTNxTp06db74XiUWSvLw8BZvNBovFQnZ2NgoKCkClUlFWVoaLFy+eYTAY2LZt20ZbW1uJkZGRrjAXh8PRCWShUIiFCxcetbG20cmImnzeoaGhGZGRkYfc3d11lORFRUW6tDdSO1+wcOFurZJXvXr57NkzQXx8/H5jY2N8+PCBMXjwYBaXy/2Sl5f33XH4o6D91TZ8Ejk5OfLGjRsXh4WFmebk5OQYGRmpzp07t7Nbt24btYJIL2e2AlOmTGkRFBTkk56e/pzU0lUqlU5T12g04HK5OHLkyIrAwMDpLi4u38T660eLN2vWzLBtu7bLQm6HrCW/z8/PB4VC0THIvX///nVQUFDw0qVL+65YseLYtm3bxtrY2IBCoSA2+hWMjY0hEAjA4XBUpNlGf0GJfx0vjouPv0KW4auKsrJyGBrywGazK1HLkiArA929e/enK1eu9Bg8eHBn/fbJxeXU6VMr8vLzou7fv39n27Ztvdzc3N717du3YW2ubC3+G1DVlKovyF/Hv1b/eu/XS2FhYRs+ffr0KT8/H6NHjx6ybt26s87OznQAVax6f/8815VnXrq0c05OzsugLUHjo6OjTx46dGjV/fv3j/fu3XuZn5/f+BYtWtD0BXvVFK7/lndSfx25eeNG6rKlS/0BwMfHp/OVK1c2A5WFuU7whYQ+DA8PX0en03UBzfogWTebNm0KOp1eY751WnpawZMnT57XqVPHp2rfUSlUGp1Op5Cpx4WFhRCLxVCpVGjUqFHvoUOHer97904REhKy2cvLS1cQ6/Xr10hKSgKDwYBEIoGjo2OLWbNm6WhZq9sYkn/ZsGHDbAA6i4JQKERZWRkYDIbO2mBtbe09Y8aMltr2vvaKfsbV8ePHf2YymdLMzEzQ6XQTc3Nz/vv37xVkUZm/GsSKFSv+loYriAQY4eHhDnfu3Elv3Lixkslkcvft25vn7d2KU3Xykx15/Pjx1xMnTmzK5XJ1QpzMTye17Ly8PIwfP37r8ePHF+unfFUFBQQSEhIUzZo1s2QwGGVkZTdyx6bRaCAWi6FQKMwSExPzLSwsqA0aNPD++PFjjL29PeRyOWQyGSRiMWbOmrV0x44dW4CvLzsATJ06dc+pU6fmktXbauoLsmhATSkKUqkUCrmc9+z5C36dOh7fmBYJAE+fPkXPnj1pQqFQZWZq2iQpOfm1iYlJxbHkZPrvWEBq8dfjPzUoTn/hJH/TaDS4d++eIPjWrV/i4uN3EgSR26hRI5SXlXV1dnFZtGbNmu4kd8O/qQHrhLVajU2bNt3Nysraxmaz77548QIKhcKiUcOG8ydOnDijXfv2umhY/Xf3P/19rDo2EqkUjerVb5OSlvqcRqPhzp07Ql9fX07lUs4EKABSU9PQvl1bcwqVWsxisao1H5MUqSTfenVrJMm/bmJs3PbuvXtPmIyv7kQKCISEhAhCQ0OtmzZtKr5//z4uXbpEnkp9/fq1rEmTJlRfX9/hr1+/vkgGQYtEIuTm5uoUKJFIhD179sTPnj3bi3TzVFepkQBw6dKlT8OGDatvY2OjU7hEIhH0LccymQwHDhx4NX369OZfZdBXnZ8CAq9exYhbtvS2YrPZQrFYTO3Xr5/zokWLstLT02V/tamdBK06E8lfhZKSEnmjRo1Ez58/N01JSSnw9PQUXrhwcbu3d6s1NdHBTpgwwWvTpk1tv3z58pSs1U5W5QGgK6Zy4sSJDYGBgXMaNWrEqumV0QDw9PSkz5s3b2dQUNB4S0tLXaRiYWGhjgu4vLy8eNasWZsvXbq0Kigo6GTfvn0b5+fnq0xMTODo6IjExEQ4OzkPIdskkZOTg1s3b/7M5XJrJNYn/UcqlQpCofAbDV3/uOKSEsGoUSN7P3r0KMTAwADqSoYcAm3btsWlS5fCR40a1b24pOTNoEGDeoeGhoawWKyKY2tRi/8sfKUO/bqAff70uezqtau7g4KCNllZWSmkUikaNWzoGxAQsNTT07M7uSj/J5iydYKFQsGqVau65eXnd/uSnHwnLS1tW1xc3K83b91aJpZIViYmJa3y8vKa07RZM5P/JlO8vkIll8sxcsSIARlZWc8ZNDpx7vy5cF9fX45+EBygXaelUinGjR3TNzsnp5gk4qpOWalIZUZSUpKWFa4GAhWlUon3QuHT8LCwjP79+1cKnq7jWYe4cuWKIjk5Genp6TAxMUFpaSmmT5++vUmTJtTLly+/ffjw4UUzMzPk5OSAIAiYmprC3d0dVCoVKSkpaOXtPWD27Nle5JNUJ07Jv61ds2YaoFfZUKWCXC7XkdKIxWLY29u3njptqq5Eqv7mjRz/1atWbwMgrNDGzefMmSNr27atrG7duj8wMn8MxLhx4/62xjUaDUxNTRn379+3f/PmTXrDhg1VHC6XvX/fvoLmzZtzqhKqaH8Cp06ffjtu7NgmJiYmuh2SSqVCaWlppfZ79OixLiIiYjVQ88tDJvXXqVOneVZWVhyLxdKZ8vXr5wJgv3v3rrRhw4aMvn37rrt9+/bazp07IysrC0lJSZzExEShu7u7zqxGAFi7dm3wzp07+3l4eHyXWJ/FYiEjIwNZWVmV8tT1QaZzyOVyBAYGnt6xY8do8rmqEudMGD/+wImTJ2cCwJgxYw6cOnVq+vf6oBb/P/CfqKGTi5tGo8GDBw/Snj17djg9PX1Leno68vLy4NXEK8C3s++cnn5+HWysrXXnfc/y9o9CVz6zsom2oKAAv9799UnU46ijnz9/PsXlcmFoaAhXV9dF3bp1m9y2bVsPsobEf/p7SY7R7NmzL+zbt28EAAwdPGTbxcuXFgJf2fL0j121atXVjRs3DjYwMPguy5lCoYCpqSksLCy+S29KEASysrLQtGnTgIcPH17VXldDzmmNra1tn8LCwtCBAwfi+vXrcHBwaJmamhoNADY2Nq0KCwujSZM+k8kEqbxJJBKIRCLa3bt381q3bm1WOehY7/oVo/vzzz/HLly4sAVZ8RPQ1gAhx5Kso3748OG4yZMnN62uPQoIxMbGilu0aGFJEIRIo9FQ+vfv73rt2rWslJQU6V9JJPNNP164cOFva5xMNysoKLCdPHmygiCIwvr166NNmzZrDx48uAao6hsDqBUTpmXLlr3fvHkTam9vr2MaYjKZIM3mSqUSAoGAHR4eXtK4cWPmb+WlHz58+M3UqVO97O3tQaVSdfR/YrEYao0G5eXl6N692+zQkNA9+YWFKu+WLb0HBQTERUVFwdraeuft27fnkfdIAEhLT1e28fFxolKpOSQjUk0g8xVLS0srpa5V119yuRx0Oh3Hjh17MXTo0FbfBm0AEokEffr06R0VFRXKZDJx6NCh8BEjRvSsabLW4v8H/pMEOvneKVUqPHr48O3Vq1cPvn///hczMzMwGAxYWVnN7NOnz8yOnTrV0w80/U8XfkDl6m8qlQr37t37cv/+/QMFBQU/5+TkIC0tDT169BjZtWvX+d27d29GbuKrKjD/xntaHXU2AeB2yO3I6dOm98zOzoaPj4/fnbt3w7hV2D3JY2/cuPFm4sSJXnK5XOcKrQkajUa33v6WICO5OY4fP/5u/PjxDUnLAAEC58+fjx49enSrKVOmIPbVK8wNDPwwcsSI+gcPHnw+Y8aMNmQpbKVSCQaDoXNz8vl8DB02bOPFCxdWAN9X/JRKJdzd3VtmZWW9YjAYUKvVYDAYYLPZujLcOTk5qF+/vu/7Dx/uE9W0R857Pz+/dREREWsJgoBGo7GKiIhg+Pj4ZGZmZv5lNK/VgSgpKfnbGge0wozH4zEHDhxof+PGjTQ2m60Si8Wcp0+fFrRp04ZdHY0rASA0NDSrT9++Dq4uLrqSpiYmJrCystL51VNTU9GgQYO5165d2wVU3knqt0h235DBQ+aFR4TvtrGx0U00Z2dnMBgMSKVSJCQkUE6fOi3v2Kkj9cGDB9kRERFH3dzcGg0bNmygoaGhzi0AAAMHDtxw48aN1SR5wW+BnNS/BZLJiEGnO6d8+ZL6LYmO9nmEQiGaNGni8+XLlxcAcOXKlY+DBg2q95+waNTi38G/K9C/UqgCgFyhwM3r159GREbuffHixSUrKys0aNCAUrdu3VWtWrWa3aJFCzNSEJBz9r9xvupbID5/+lx67vy5PZs2bdpoYWGhtLOzg6enZ19/f//5gwcP7mhgYKA9FnoFTf4FVI1dCgkJyerXr5+DWq2GpaWl16dPn+JNTU2/ic2hgEBBQQHq1KnTsLy8/IN+zYsar1Wxdn/P3K5/bGlpKdzc3Fq8//AhhsVkQlVx3Qrf9v2oqKjH48ePb9eiRYsufD5fbmNt3UwskXygUqmgUqlwdXWFoaGhLouJSqV6RkREfHBwcKB+rwALAQK7d++O2rVrV0cnJyedwpeTkwORSFTp39evXU8aMHCAe3XtaX3nr8QtW7a0BCACQO3Zs6fH5cuXM1JTU8U/Iiv+DIjMzMy/9QIajQZ2dnaIi4uz7dixo0IsFheamZkhICBgzaFDh9YCqHYXCAB+fn5T3rx5c8TFxUX3PZ/PR3l5uS7AIiMjA1evXv08cOBAz6ptVW3z/fv3qkaNGrGoVKqSLKtqZ2OLil0U0tLTsXTJkqur1qwOAACZXAYmQ7u71je1X7t+/fOggIBGHA5HSe4GvwfSnF6VV74mkDmObdq06fXrvXshBhU+cvJZyF1rcHBw+oABA5zVajWMjY294uLi4l1cXHQv4v9Pwsr/v/g3BTop2OQKBUKCb7+8dv1aUFxc3M3S0lJIJBLWokWLlo0YPmKOq5urMXnOf3NUeFXoC/Z79+7xDx06tOft27dBUqlURKFQ4NWkSa+AQYMWDRo0qCOLpa0H8m+6Fci1LCsrC+3btWublp7+DACuXL3ycVAAqRh83aARAOQyOfx7+fd7+PBhMJfLrTEeSB+kImZsbPzDFcW+fPmCOXPmHA0KCpqogXaeUPXmF6PCyvnixYvyBfPnG5uYmoLNZkMgEODNmzfgcDhQKpVIS0vDyZMnX44dO9b7t0ztOTk5mnbt2rlSqdQ0khyHTE/TVyCbNG4y9FHUo4tAzdp5YGDgusuXL6/NyckBAOvbt28zW7VqlZ6VlfW3aucAQPu7wuf1kZaWBg8PjyJfX1/70NDQUltbW+Wvd3/d/OjRo7kdO3Y00T+WDAOjgMCmTZt2de/e/XROTo6MTIsoKyvTlSMlzTiLFy+e3LdfvyhaTQFnFVOzYcOG1KCgoFtLly7tpVQqtbSDxUUgi8ur1WqUlJU9BhAAoJIwB7STms/nY87s2aMBKMm6vL8FKpVKFgT4himpOlAoFLBYLDx79ix0yuTJ+8+cOTOTTPXTn5B9+/Z1un79esTcuXN7CgSC16tWrfI/ePBgGI/Hq0gL/O/TeGrx3wVyEVOpVLh169bzK1euBH348CE4JycHXC6X4+/vv3z8uPFz2rVvxyU3s1VT0P7bWdcIvQBfCkGga9euhl27dl355PHjBecvXNgXFRW1MSbmVei79+9DL1++7D9s2LBFQ4YM6USj0Sqd+8/es9Z1FxQU5C+VyZ6ZmJhg37594V+F+Vcbgp6P/fi9e/eCSea16nLKq0I/oPlH1sqKOuE4eODApGbNmjUdMmRIMwq++tMZei5LoVBI+HbuzHBwcJATBIEHDx6ASqWiuLgY5eXl6Nmz5+hRo0Z7AzVvnMiZt2zZsq2pqalplpaWKCsrg0ql0lVVIwPjFAoFLeinoENkv1SH58+fi6KiorZaW1sjJyeHOmDAAI6fn1/mly9f8FfVPP8eaOfOnfvbLwIALBZL3rBhQ/Hz589NkpOTC42NjBWHDx3e3LFjx22V8tL1uqpZs2bs1q1bLw8NDV2j3xZpulKpVDAwMEBKSsrj48eORU6ZMqVHTTt+8m8LFizwv3btWr+YmJhbzZs3B7mh8fDwwIcPH+Dm5jZCe/y3gQ4AMHv27IlyufyVg4ODLlDit0ChUHTR9eRu73sg3QFUKhXBwcGzrly56j548KAeX3Xzr8/Tr1+/Hs+fP7+1devWfufOnQtPSEgYGh0dfYmiR5FZi1r8Uei/R/q/60et379/P+XUyZOroh4/vlBWVgYLCwtO3759l48ePXqOr6+vrvxgTYLrv33TqX//+ulW7dq3N2jXvv2ip0+ezjp/4fyBFy9ebH7+/HnYmzdvwu7evRsQEBCwqnfv3k1qior/ezbkX12Q3bt3H//kyZNwAJg1c9blESNG9CSfR3+tAYCwsLA7wbeDJ5J52D+yjgHQMbsJBIIfZkUjq6NNnDhxlK+v7zsLCwsqqejpuwqsra0pmzZtogJaIjATExO4urri7du34LDZ3H379p2uWqGyMm+HFh8+fsTp06c3AFpXJqncyWSySqVeu3XrttKntY8R2Uf6IMfwxIkTQWVlZZK0tDSwWCyzpUuXSgDIGQzG366dAwCNZLz5uyGXy2FnZ1fs4+NjFxoaWmxjY6MOvh38c0RExNyePXvaVz2e3JEFBQUtCg0NDaJSqRI2m60rr0pWZiNz1AMDA/t61vWUdezQEdqYVPL/lduk0Wg4eerUzQb16zNMTEwUZDRjRW6h86BBAd/s6MhJcPLkydenT58+bmZmphvw3wMqlarLy/wRsNlsyOVyDBs2tCeXG1Lo5+dnrn9ven3UNzY2dtqvv/76y6tXry6PGjXK99y5c9Nqje61+CtBCnId5fHr12Xnz59f8/Dhwz0ODg4wMDBgtGrVatWM6dPndejY8TcF+f8y9AV723ZtDdq2a7vgxYsXs06cOLHzxo0b62/fvn0tKSnpWkR4+OTRY8ZsaNWqlVVVwf53bHRIkTJt2rRLT548OQkA7du3H7V3397B2mvq+9i1StbdX+9KBg4c2IPBYIDH4/3ua5Jr9u85nsPhQCgUfpo5Y+amy1cur6bo1vSva2f9+vW5AwYMmCsSiYIKCwvx/v17jB8/HnQ6HYMCBt10c3OrsQfJuSwSiTB82LBeAMR0Ol2ndNFoNJC59RUWBoOtW7cuBmqez/fu3y8JDQnZwtRmUlHat2/PdnJyyklMTPxhd8OfBc3CwuIfuVCF1qno1KmT8suXL7YCgSBLKBRqli1bNqlnz54RpFml0jkAGjZsaDBz5sxt+/fvn2VjYwPgq0+aZAtis9nIzc2Vr1u7zu/ChQvhVlZWuvO/uQ8A9evVw949e+6eO39+6suXLxOgvY7r9u3bL1lbW+vO05/YMplMvWrVqpkAUF5e/k0KHQkyGrLqs5PFWKpjU6oJBEHoNgELFiwIaNeu3SMej1fpuUihHhIScnDTpk3pN2/eDL927dr0pk2bOi1cuNCvlh62Fn8W5OwhBc6Tx4+VDx892pqTk7P++fPncnd3d6J///5rGtSvP8+raVMj8rx/iqr1PxlkoC4FBFq3bs1s3br10oEDBsz49d69nSqVauPDhw+PlPP5R4ODg9d16dJlUefOnVl/1zurK0d79Fj49evXh9WpUwd+fn5+mzZvPqO9y6qKjDbffOWKlX1kMpku2hvAD61h5DpNarz666JardZRYX9P2F25euWnly9fLmzVqhVbn9BLDS1R10/btm28Gxn5fnNQUIhCoUB6errp6NFjzowePboL8O2miNTwyXYGDx685t27d2Hkuqzv8yddChkZGZgwYcL6pk2bGlT31GRba9esmVJcUqLi8XhwcnKyaNmypfzUqVPy6vjr/y78YwKdhJubW76vr2/98PDwIjc3N+nr168jT5469W7c2LGNaqpzvnbt2pkvXrw4pFKp3rHZbADa3MD8/HwUFRWBQqHAxMQEdDo94sqVK/5Dhw4Ns7CwqNY/RbY5a/bsjj39/D6fPn36kkKpEI4ZPWZ8vXr1KOQx+j8BIOpxlIQgiGctW7asNvWMpKhls9nf+MnJdIqPHz9CJpP9sKkegK42fHp6elTfvn17hYeHh7KqBMmpoSVvmDlzZtjz58/9c3Nywu/fv+/fqVOnsBYtWtQK9Vr8YXw1rxMoLCzE+fPn71y7dm16TEzMl+bNm1Nmzpy5ecSIEcvI91Iff7+B8T8fhN7/SfTo2dOwR8+ea2Ry2ZqbN27uOn369NILFy+sDgsLOzJs2LBfxo4d629dkZP/V723pNAJDQ0Nv3nrpn9FSnGPRQsXhnHY7EqbL3LM5XIZAgIC+iQlJd0zNDSEWq2ukUCrOpCKjLGxsS7wmARBEDq+dRaLBQaDAaVS+Y3gT09PF92+fftEq1atZuoCD/UslO5ublSLkSNvS6TSBwUF+bHdunWf3qVLFw75fU39AABLliwJDQ8PX0/+W6VSwcjICGQQNqk01qtXr87mzZsX6l9b9xwV7V24cOHTkydPrjk5OUEoFDI6dOhg2rBhw+ScnByw2ey/vAhLTaDVRHTyd0EulyvatWsnTExMdCopKUkAgCWLFk8ePHjQCw67+rKg5ubmmDZt2rHJkyd7k4VOAG2H0+l0MJlMXc47k8kMP3HihH+zZs0u+vr6Gn4vEtPd3R3r168fqv83fZOTPt6/e58ml8sJHo+n0SekIYNDDA0N4ePjgxcvXiAvL0/nDgCg+0mj0SCVSn/Y/0SCIAiIxWI8fPgwLCAgYFloaOgWUkjrT24rKyts3rI5zLdjp6bxcfGvAwMD/SdPnnx3zJgxXWuFei1+D6qSGT2OispatHjxZAqVGmFuZg6pVIqsrMyFUol03qWLl+JLS0sFCqVC88Pmp/+3qCArYdAJI0NDnlgqnZ6WlibQKNWrbW1sMs+fP9/rzJkz3Q/s37+nQ8eOnlWLNf0RkELs9OnTj8aOHesPADQ63WX3nt0Rdvb2OvWF/D95/PDhI34KCwsLoVAo+C2ujZpAar36Al0qlcLOzg5du3ZFWVkZmjdvDgaDATMzM1StiSGXyyGTSlNlcjlISlj9WA4NACMjI8yfP98XgK/uuqgsvPXx4f17BAUFbYqLj1/p6emJhIQEnSVBoVAgISFBdw8ymQx79uw5aWVlVW3vk8GFS5YsmQRoScSsrKwc2rVrJ9NoNApjY+Pf3Wd/BjRrPXamfwr16tVLT0tLq7d8+XI2QRDigsKCl4cPHX4aGBjY9lstXdtpo0aNarlly5bOX758uU+SzQDQFVmRyWSoSN+CSCQKHzlypMvsWbOne9TxGObo6OhUt25dJoPBZGigBpfDrf7G9K4JVBbsXC6Xo9FoNKQZhpyoAoEAhoaGMDIygqOjIx4+fIjs7GxUx23MZDLB4/F0gXi/R6iTO9iwsLCgbdu2dVi0aNE3mrcGQMsWLXHt+vXQnj17Oubl56mePHnSjcfjvR4wYECTWqFeix9BVbrWoKCg8HXr1vVydXXVeHp6QgMN2vq0AV8g+GnHjh0/8fnloBCU371R/f8I/bdPo1GDy+OBx+OhTdu2MGAbwNXVFU+fPr2z/eef66anZ9weMWJ4byqN9offWnIMw8LC0seOHduV/PvVK1dC2/i0+cbMTh5/4MCB8Nu3by9hMBggOfV/79iSa3TVaHgyw4hOp4PD4cDMzAxlZWV48eIFiouLQRbmolAoKCwsRJMmTaCfwaTPs1HTHREAlGoVZBIpVCoVcnJyBE+ePJHl5uae+PLlS+jT588f1a9XD8nJybp75XA4ungqGo0GkUgEBweHdpMmTfLRv+7Xa+hiq15mZmY+A4CEhATOsmXLDFu2bPk+JycHRkZG+CdBc3d3/0cvWKFJK8ePH59/+PBhk7S0NLGNjQ0O/fLLmGHDhqXY2NhUnvQVHxaLhZMnT57p0qWLs1wuV5C+HJVKBYlEopsAKpUKPB4PhoaGJdk52Ztu3rq5adKkSbzg4GDDe/fujV25ciWDz+cjIyOjd9OmTeu4uLjCxNQETCaTx+NxQaWQGY9EpXq5Xbp0cVy1apXRx48fyzkcDtRqNUxMTECj0WBqagomkwk+n68L0qPT6d+8AKRFgc1mQywW/yFN3cbGBqGhof7169cP79WrV099IU26E3r06GF74uTJX8ePG+cLAAMHDuzy691fv3Tp2sWwVqjX4regr90sW7487Mb1673Mzc1Rr169qU5OTjZisRiurq4gQEhVKpWCoFBogEajUVdfPrgWNYEgNGq1kkql0jQajYFEItEqAiCKlCrlvh07d/S5++vdU6dOnRpD/IGsFVLgREVFqfr07t3FwdFB6e7mjlGjRt3p169fPaB6YX7//v2I8LAwfwcHB+Tk5PyhjRrJ1KZ9ysrnkv9WKpWQy+VQqVRgMBhITk5GVFTUN2b9bt26BVCp1G9iObT3ry3XLZNKJQKBQJmRmYGEzwnC/Pz8s/Xq1RPfuXMHcXFx4ZMmTfq4bds2JZvNlvTu3RsOFcW0yM1Go0aNYGpqqtPMVSoVPn/+TDtw4MBJAwODGrXz/IICHDt2bIKjoyMyMjJgY2NjNmnSpHwul6v4IwGEfxa0qKiof/yiFAoFRkZGhZ07d3a5cOECz8DAQJCQmPhl7dq1uw4dOjSvkpaux27Qvn172x49eqwICQlZSwYxkB+yghrJ6EPu/hwdHWFtbS34/PmzIDc3dzOPx8PZs2dx5cqVtQEBAbw5c+bgwIH9uHDhQs85s+c0sLaxbufr69vF3d0dZLFUDQBXV1fKqFGjfvn555+HFxYWgslkYurUqYiKioJIJIKRkdEPTXr9e/s9mjrJaV9WVoaXL1+id+/efteuXXs7cODASrEHZHeNGzu2k6WlRVhoaJh/WGhoca/evbref3A/uo1Pm78pHaYW/ysg44kvXrz46vixY70YDIbhtKnT3kybPs3ZwMCgsulVf+pqqvy7Fn8ICrkCJ06cWHD23LnWN27cGNu+ffs6kydPbv173ltSe42JicHgwYO7Orm4pPj7+WHSpElhXl5e3YBvCb0AICQkJGPAgAF+ZHra74n3IaEvzH/0eJlMBnNzc3Tp0gXl5eXIyMhAdnY22rVrN2Dy5Mk6DZkU5gX5BYiOiU4oKyu7ePDgwcKsrKyLW7dulcfFxeHQL7/I+AKB/PDhwxCJRCgoKACXy4W7u7tuc6LvNmUymTAwMIBUqtXmNRoNcnNzMWbMmOW9e/d2I69dtX8BYMuWLUdiY2M/WlhYgEajsdu1a0eLi4vL5PP5P5R3/1eD9uXLl3/8ohVVzjTdunXj5+bmukRFRX0EoDx8+PDyGTNmzGzSpAmdzIQEQfqItTuzn3/+efmzZ892USiUMjIQR6PR6LjSjYyMUF5eXmlCqdVqMJlMGBpqKxxaWFiAw+HAxsZGYGpqCplMhqKioitZ2VlXbgXfwosXLxobGxvPmTVr1kQXFxfdGrVhw4ZhyUlJZ9MzMkKzsrLA4XBAo9F+d/qaWq0GjUb7Q5o6GR0KAMOGDev94MGD9LZt24IsB6hPzOPv5++nUqrChAKB/6tXr2KGDR3W9erVq796e3vrjq9FLSpDu1SVlpUqb924OYmiLZph139A/19ZLFZeYXGRCoR+qd5aCf5XQqNRw8TEhOLv52ezduUqFzaHnX/u/Lnxffv1+2RlaflDbywpzOPj4zFx4kR/a2vrh87OzmjdunWYl5eXH1A9O+fL6JcYNXJUX9LnTX5+3/3/sTAKgtCmkDGZTPTu3Ru7d+8Gh82pf/rM6eukyZ8CAsXFxYiPi7vz844dO0tLSyNGjhyJ8vJyFBYWgs1mw9raGm7u7sjLy9MJah6P901QHsn1QVpMk5KSdAF5YrEYcrmcPWvWrJVV++prnwEfPnyQ7961a46ZmRkMDAwoderUcerUqVNBTEyM5kdZQf9q0Dp37vyPXxTQdqiVlVURg8EwDw8PtwSQw2KxJEFbtiy+cPHiTm0aW5VzANSpU4e+bPnyK4sWLuymn0ahUCjw8OFDtGzZEi1atPjh+9AX9hwOBx4eHjA0NHz7/PnzSZ8+fbrUy99/5cxZszoAWkKbGzdvhmzevNl/5cqV4SKR6A/7Df+oUCejQys+GbNmzep++fLlOx4eHtAX0mSKR58+ffwKCgrCysvL/TMzM+9NmjTJ/9TJk2FNmzWrNgugFv+/Qc7AJ48fSwuLi940a9YMSqXq0/v37yenpKRAKvvnUnD+P0IDbayNXCpDuw7tQacz8PHzp8/hoWGp48aPc/mt80nh/PbdO8ybN8+fzWaHM5lMdOnSJWzUqFHfCHPtOcCX1C9YuGChH51Of0PWp/inhDkJkvnz8+fPEIvEjqfPnA51cf76yG/evJEuXrx4jKen5xUmkwkrKytwuVxwOBwYGhp+I7S/d59sNhv5+flISkr6JtVYLpdjw4YNlzw8POhVW9P32+/cuXM1h8ORqtVqsFgsm/Hjx1M9PDyKbW1t/7VYEtqP8PH+XSgvL0eTJk1SOnbsaPPo0SNYWFjg8pUru3r17j1l1KhR9aoSo5A+4jmzZ3c9/MsvvknJyQ/s7e2hUqlAoVAgFApx8OBBBAYGwtLS8g+ZPMga6e7u7khPT7+7d9++u+V8/rG5c+dOIIMmRo4cGRZyO2RMVlbWGZFI9Id2suS1aDSaztwD/Jj5nXxxrK2tYWhkdPfw4cP+GzZuCGMxWZX6ixTqEydO9BMIBGEhISH+CoUifNLkyf6HDh0Ka9GiRa35vRaVQL5jL1/GRN67dw8zZ84cMGLEiA75+fkyPp8PKqXWSf73gtAIpHyw2WysWbeOcePa9Se3bgdfj4uLPT1u/Lg133tfSWHz+vVrzA+c789kMsNFIhF69e4dNmfOnGqFOQXaILAL5y/4GxsbR1hbW+FLaqq2vR9c0/Rdn38UZPxTamoqGjdu7BccHHzJt7Ovzgl9/vz5eydPnpwglUozzMzMUFRUBIlE8ruvSZrY1Wo1cnNzwWKxdMyjFAoFBQUFcHR0bLto0aLeQM3kPsHBwUkXL17cam5ujvT0dKJbt27sESNGpKSmpsLMzOwP98OfBe3Bgwf/2sUrcqwVXbp0URUXF9uXl5dnqdVq7NixY+yIESOiKRTKNx2qgTbi+9jx46f9/PycZTKZiiTTNzc3R3FxMa5fvw4ajQZDQ8MfKttXHZRKJXg8HqytrXHp0qWJly9fvhsaFnrBztYOzs7OePL06enQkJBRr+PjtxcVF98lzfm/V7CTJfrIgiz66W41gXyekpISUKlUhIeHh8fHx/e6du1aqJGRUaWXlhTq8+bN85PJ5WG/3r3rz+PxwidXCHVvb+9aTb0WOpD6B4vJoBuwWHj37h3L0tJiXr169aBSa6sJ1OLvB5VChUAoQGxs3HsAYDCZ3yb664H0LcfHx2P+/Pn+VCo1vLS0FL169QpbtXKlH/DtyFFAQCgUYdiwob3z8vLCFQoFCouKdN//iEJEWhb/qDAnz83NzUVJcbFDhw4dli1btmy6o6Oj7pjdu3eHJyYm+puamuoUnz9yPfX/sXfVcVJVbfi5c6dzu5dNeunuZmFpkO4WUEAR5UORBhUFLJQSEAUUpNmlFAQElG5YNmC7pzvu98fsmZ0tWLrm8TeysHfuPbfOc956XpsNpOw5OTkZSqUSbm5ujn3pdDqw2Wz2+vXrN/J4vHIT4QwGA96ZMmWUVqsFn8+Hu7u7V79+/TRWq1VflrDY8wS7evXqL+zg5GGoVKlSNsMw1ebOnZsnlUoNycnJ5xYvXrxjzpw5b5F6WKIsTCyIVq1aBQ0ePHjxunXrZjk/eBwOB7dv3waXy0V0dDQAPLaGLrnRoaGh2Lt377ajR4+qRo4YeQAAaJqFnr16dm7YqGHnU6dOnTl86NDmgoKCH8xm82OTutlshslkcriAyntoyf5J3gAA3LhxI7Z169bdz549u18gEJRJ6h99+GFXxmaL/eeff2K4XG7ckCFDOm/YsOFwq1at4Mp+d8EZLVq1jPbz9weLxdo684OZh44cPFJHLBWzGBYe3pHDhScBBQYstVpt69aj+3UGTK5EIkGLFi3GAWVZjEXa7GdOn8E7777TNSAg4GBBQQGio6Nj58+fX2iZ279t/4Z92WY0mdC+fbs+586dO0D2xmazHcJZFW2m8lgnWZjkm5mZCblc3rlevXrTBg8e3Llhw4bFsvAmT568Pz4+vkd0dDTUajWepJmYWCyG1WrFgQMHcP/+fQgEAqjVasc8q1arMXTo0HkdO3aMBEovgMhi98svvzyQmpZ2GgDy8/MF7733nq+/v/+tI0eOvHAZBvajxJufBRiGgUQisYwfPz5706ZN/vfu3Ut2d3fH3LlzRw4ZMqRPREQEXbIjEyGoL7/88sM9u3dvy83Lu0y64gD2h8VkMmHZsmWIjIxEZGQkrl69WqHuQGWNj8PhQCKRYOOGjbH79+/vtn79+gNSid0iDwgIwIABA5r17NGz2eEjh3tv2rSpj0aj0Xl6elb45hKBGrFYDLVaDZPJBKIx/yA4Z6AyDIOrV68eiI6OHn7s2LHNNE2XSeqzZs3qunLlytiLFy/GWCyWIz179myxbdu2PdHR0V4uUneBvGvNmzXnjRs7dvOpk6em7N6zp2DwoEHH/Pz8oCvsnOXCs4NQIEBmVha2bduG1q1bC6dNnfpZ165d3cvalpD5X3/9ZRg1alRM9erVj7FYLMTExMR+/PHH5cbMGYZB927dJp07d2436YtRcr562PzzJJYowzBITU1F8+bNfx46dOhw5xbZBAsXLozbt29fj969e8M5AfpRQMKaPj4+0Gq1+PPPPx2/02g0jvMoLKeO+uabb2YBcGoWVgQKQEJCgnXZsmWDPT09kZ+fj8DAQN9JkyYV8Pl8q0wmey4NWB4E9u3bt1/oAAD7BZVKpbmjR4/2/vrrr/31en0mn8/XLVmy5MP169d/VRbRFCoEUZ99/vmGsWPH1tPr9aVKLEwmE27evIk1a9bAZrNBLBY/1kPI4/Gg1+tx/PhxAIjNy8mddOz48R+AopeFL+CjZ8+enVetWnV61KhRdU0mEx5FhY+QulQqhUajgcFgeOSSEQ6Hg5MnT/7SrVs3YWxs7GoWi1Wu+33NmjWxSUlJMTRNn+7Zs2fDzZs377S3KnSR+psOkpg1++OPh+3aubN3/Qb1f357yuRcqUwGs+HRKjpceHTwuFwoFEqEh4Z51qlXd8SAAQOkQPn9t3ft2nVr0KBBA1q3anU9PDwcVapUiX3vvfecLPPS3+ndu/dHR48e/ZEowD1qmdmTgGEYpKSkYOrUqbEzZszoSv7dWav9p59+Orh9+/aYSpUqQafTQS6XP3KiHkVREIlE0Gq12Lx5M+Lj4+Hm5gbS+Yx4iK1WK3Jzc7F48eINHh4edPECYMDZCzJx4sRPVSqVWiAQQCwW+w4aNIiXlpZ2T61Wv5AytZJ49CLDZwCbzQa1Wo1Jkyal3r59O+DXX3/NDAoKwsaNG5c3b9Z85NhxY2uXlyA3ZsyYur/++usHf/3115clNdSFQiEsFgu+++47cLlcdOjQAWKxGBwOp8LxIWdLmdS4H//77x/nz5/fY+7cuTFFfcrtt3/w4MF1tFrtoQkTJkS7ubk98oqNkHpGRgb0ej24XO4jNXPx9vbGoUOH1vTq1ctz3759S0oStL38D5gwYULXAwcOxEokkpgTJ07cHzhwYOP8/PxDkyZN6uAidRfIc9Knb19xn759JzMAzGYThHzBCx7Z6w0KgNVmQ2CQGIuXLnH8e3lkvmbNmpMTJ07s2rRpU2237t3h4ekZO2L48FJudufvDBgwYPnevXu/CAoKgkKhcEizVgRkLnqc+nSgyKpv3brNB4TMnftSAMBvv/3239ixY7vyeDxwOBxcu3YNJpMJnTp1qlBPcTJGYsAplUrs3LkTwcHBkEqlxTy5NpsN2dnZGD5s+KR33nmnIVB2xzkA2Pbbtut//fXXZ3w+H3q9Hn379vWePHly+q1btxwG2YvGc1eKKw8Mw0Amk6lHjhypunDhQiW9Xp9is9kwd97c0YOHDL4gFAqdpFPsICu69evXf9GqVavNDMNkl9UkgkjDXrt2DRcvXnRkxT8MLBYLRqPR0ZucxH3c3Nywa+fObo0aNToWExPTltTkkvrvcePGdf7555/7X7t2bXtgYOAjr2g5HA6CgoJw//79Co+VgKIoBAcHY//+/Ut79epl27Nnz2ek9SAKx0lq+rt169bVZrPFmUymrgCsBw4c6Ni0adPYevXqdSULFVcS1JuHotJHO0jMlcvhvrAxvUkglUdElpUQXUlJ3h3bdxycOHFiVwAQiUTo0KFDbK1atcrNZgeAgYMGLfvjjz8+rFy5sqOvREVB5K4Le2Y8lkWq1+vh5ubmt3HTxi/IORJQAJKTkzFs2LA+gH3eJrobDMNAIBBAKpU+NHTKYrHA5/Nx9uxZxMXFOcrajEZjKc2QwkRk96WfLV0FOLeuLTxnkm9gNOKTjz8ZDcDm6ekJFovlN3To0DwvLy95RETESyN5zI6Pj3/RY3Dg7t278Pf3zxswYEDVBQsWCAMCAnTp6ekXZ8+e/d3KlSvfKbs2nUFoaCi17Isvfh85alSbyMhIlFKzQlGDk++//x5msxnh4eEOYZiSDyaxzAMCArB79264ubkhICDA8XsWi4X8ggKMGjWq3z///JNfuXJlpwfA/mC+//77y/r06bPdYrE81sqNeBGsVusjtVwlbqTIyEjs3bv38149e7J37tq1yFk6EShWp97lh1U/HJ80eVJ3iqI0cXFxMX/++WesvfWq/YF2lbW92WBcT8ALByF1RwvU9evjkpOTYwICApCRkUH37dv3YK1atToCZYvGAMDAgQOX7/zjjw9r1KgBo9H4WCVfQqEQpG/440ClUlETJ0z8MCw0lAKKt+Y1mUwYNnRYb4vFkiEQCBzlwBwOBxaLBdeuXYNAIMCoUaOQmJhYSiiGzWZDIpFALBYjPT0dmzdvBovFgkAoAGMrzQdmiwU5OTlYt379H4GBgeVmtQPA3Llz16Wnp5/38vJCeno6f/r06V4+Pj63jx49+ljX4VmBnZKS8qLH4ECh4ps5ODg4o1atWqG3bt2K9/T0tGzduvXdwYMHD27SpEmpAj9CoIMGD24dd/DglB3bd3wvEovKJFEWi+VYlQoEAty+fRteXl4ICAiAyWRyjEEgEMBsNiMhIQE0TcNsNhdrmUoenpycnIJp06YNj42N3VzS9d6xY8cQPz+/hjk5Oecr4iYqCaPRCHd3dxQUFDiO/yikDgBVq1bF3n37Fnft0iUvNi7uR3aJJg+E1N+e9HYbXz/f85MnTx4dEBBwJiUlJeby5ctrN2zYMM5+3i5Sd8GFFwUyp1Cwl9NOmTJlS0FBwVB3d3dYrdY627Zu3TBw0KB6QDkJcDYbevbq9b8DBw58Vrt2bYe86aPAaDRCJBJh4KBBEAmFMJpMj6wRyDAMsrKzBUOGDh5vH6v97Mh+vlq+/ODpM6f3iESiUqFGPp8Pku81evToYkJcpBxNLBbhzu07yEjPgFBg99Sy2WyglGiXPW6ek5WNPr37jBkzZkw7+0jKVoS7dOmybseOHeNFIhHy8vLY4eHhIUFBQZnx8fEWpVL50ljnAMAODg5+0WMoBqvViho1ahQEBAR49+rVS6ZSqfLNZjOGDRs24MaNG39yC1voOYM88CuWr/ju559/3qvT61IfdhyFQoE9e/ZAp9PBarUiMDAQFEU5+pmfPHkSmZmZ8Pb2hlarLXMfEokEcXFxv6xft27G2HHj6tqzR+2DEQgEGDJkyIDc3NzzYvGDu7uVB7FYjFu3bmH//v2P7HonL0PlypVx5OjR1R07djTuP7B/g1gkLjOm3qdPn6pe3l6nN27YGNOwYcO4L774YvytW7eO79q165dKlSq5atVdcOEFgbz1aWlpGDRo0LirV6+unzhxIhITE6O3btm6v137dmygbDe7Xq9Hr169Jh85cuSHqKgoAI+X1EZyiY4fO/bY2h5qtRrubm78atVr8J3/nQKF+Ph4y6KFC/tKpVKUFTYFAD8/P0dOlLe3N8LDw0HTNCQSCTIyMrB40RJcvnQJNE07vLRWp1asBAzDQK/XQyqReHz99dfrSX5WSdEeFiiYzWaMGDG8X0pKCgrlXD0+++wzTmhoaH5KSgo8PDwe+To8S7zQOvTywOFwEB4eHj906NAamzZt0gAwJiQk/PXp3Lk7P1u6tG/pFqv22+Hh6YFVq1ZtnTx5ciuKohg+n//AB89qteLIkSMAgKioKIjFYmRnZyM2Nhbp6engcrmOOu+yQFZmn8yZM3HEyJH/cjgcMIWLNYvViipVqhgDAgIeKdvdGTRNo1atWrh58yaSkpIeyfUOFL24ISEh+Pvvvze2aNEi/8D+2L1BQYGO+BycYuqtWrZCSEho7LatW7tzOdwDN2/e/PWrr74qmDJ5SmyVqlVQMhbvggsuPF0Un9uKsquTkpLw008/dbt06VKsXq8Hj8eL+eqrrw6Qcq+y3OyZmZno1bt333P//berSpUqAB6PzK1WK/h8PqRiCfJz8x47y12pVIKmKG8ej1uYUVeUDzBv7rzPdDqd3l3mBoOu/NJIBkBC/F0U5OejTt06EBZmsWdkZCAjI8MhHKNUq8r8PgUKWq0GDIDff//9j+BKwU5zYVFog2DJkiX7rl+/flAmk0EoFLLbtGnj3qZNm1t6vR7u7mVWEr5QsLOzs1/0GMqEXC5npk6dmnfq1KlKGRkZiTRN2z7/7LN+/fr2NTVq1IhTckVFkkcmTZrUIjY29uP9+/cv4vF4D334SNnC3bt3sX//fiiVSiQmJoKm6QolfbBYLGRlZf23atUP/02bNrWx8+NgMBispLXr44DErLp27Yrvv//+ka10sg8A8PHxwdUrV/eNGDE8ZufOnbFubm7FrG5b4fWrFByM4cOH7z98+PDUnJycb2UyWdy48ePajxkzZtmoUaMaUCi7WYELLrjw5ChuIdrxyy+/XN+yZcu0Zs2a/eXt7Y2AgIBRkyZN2kDivkwZZK5WqzF+/Pju5/777wDxwj6Jmhufy7P/yec//AvlwGw2g8vlWa0Wq3NNGG7evKHbum3rF2wWDavF+lBjQSgU2vunnz6D69ev4+LFi3b51kJT+2FJcwyAdu3afdC/f/+29r8zxX5HFc6Fly5dwrx583oSbfvw8PCQ6dOny5OTk62P2pDreYGtUpW9knnRUKvV8PDwyJ41a5bPunXrvFJSUnI0Gg3GjRvX58LFC/vZNLsUsZCY8MaNG+dHRUUdzMrKOk+S2R70MBNhgYSEBFitVvB4vArHRSjK7tZauXLljClTJp90LufQajRQqVQOreDHQXJyMqpUqYKwsDAkJyc/spUOoFi8yWq1xq1dsyYmplu32Jo1axZTiCMPtr+/Pw4dOvTN/Hnz2qtUqj6JiYnHRo8e3ZDNZscNGzasC7HUXVa6Cy48bVDFSqV2bN9+aPjw4d39/Pwsfn5+6Ne379bPP/9iEJtTev4j1u6dO3dw7NixGIvFEkd+97hkzjAMuBwObDbmiVTaALtkqsFg1FptVhMAHrGGVyxfsRGA2k0mq/CMIuALcOvWbegNeojF4grNizRNk46ctbZu3fYFUJZxYidzm82GSZMm9QXsUuNeXl4+Xbt25ZvN5qQX1Rq1ImA/6U16ViA9cps0aRJ/4sSJypmZmQU+Pj6Wq1evHpjzyZzdS5cu7V1WowIGgKenJ2vNmjU/DxkypIZKpSrVTedBx+RwOAgJCQGACtdnmkwm3Lt379SRI0fyu3bt6kn2pS4kdEsZcZyKgigdNWvWDMnJyY9lpZPxAPbWsSyajps2bVr0rFmz9nXs2JFbnNTtH5qmsWDhwt6///bbwa+//jqmcePGtosXLnT99+y/Gz7+5ONRfn5+rri6Cy48ZZA3OzsrG19+uexXDpc7rG7durh8+TLatm0bN2LEiC5A2brsAHD877+xcsWKrjExMQdJk5AnscyNRiMMBgPU0DzWPkoiJzfHYDKZLQB4FOz9KM6fO7+qdlQtiMXiCo2VzWZDo9EgPTMDUpm0QvMhRVFQq9XgcrnU2rVrN/v6+lBlZ7Xbr+PChQv3//vvv7u8vLxgtVpRs2ZNj/bt2ydnZmYyjyPv/bzAfhIXyvOAUqk0jhs3Lic5OTni5s2b8RKJhPnss8/69O7d29ykSRN26fWVfYXVo0eP6uPHj1+zYsWKCY96TC6Xi6ZNm4LNZldILpbFYsHb2xuxsbHfdO3adT5gzyxVKhRQKBSP3C+9JFQqFXx8fBAYGIj09PTHstIJrFYrvLy8wOVyDw8YOKDh1yu/3jB8+PAGzqRO3OosUBgwcGC0Wqu9dPnSpffS0tL+2r5jx+j4u/G7N2/evNvHx8cxkbjwcoDNZiMkuJKbWCSGxWYt8ZDY64hFIhECgwLdOGx75YbrHr5cyM/Px6TJk/rt2rVrZ7du3VCnTp02b7/99ucjRoxoAhSFx4DiZWnbtm279eHMmaObNmv2r6en5xNZkSQUyefzIRQKH0s2uyTMZjN4PJ7FbDY5BrZt27ar2bk5NypVqgSL7eHHoABYbFaYLGbweLwKC9xQFIXs7GxMnjx5Zf/+/esARQnMzoYhBeDixUuYN29eD6FQCLVajapVq0aMGTOmQKFQ6IgmycsK9svqOiAwmUyQSCS5ffr08dbr9e7x8fEFADBi+IjuFy9dPCgSiUolhJAAzcKFC8cfPXJk97Xr12M9PDwqlJ3JMAxMJhP+++8/mEymR1JQOn/+/GedOnea0rNHTx+BQID8ggJ+bm4uHjfL3XnfRqMRlStXRkZGxmNb6QRWqxW+vr7g8/jXRowY0ZDL5cYNHDiwCyH1kj3Vx44ZUzsnJ+fPPr379gSwr06dOns++OCD9r6+vh+Eh4c3sFqtL2fc5g0DRVE0GIYTHx9/7p9/TsFd5gaUIGs3D3ec/fcslixe8l/duvXuUxSsDMO4Gq68BGCxWNL79+9fVKlUX1WtWvVPAEhPT+++Zs2afSR0WHK2Jnd39+7dh0aNHNkjKCjI7O3t/cQEbLPZYDabMWXKFMyYMQP3n0Z5sz27nJJKpWwAyM7JwY8//jguMzMTCoWiQkaKjbGBAgWpVOqoT3/4YRlkZWWhc+fOXb766qupQOF1LLx4JKmaBbvQzKhRI7sBII3DPPr27csWCoV5Go3mhTdfeRjYL6vrgMBms0Gn0zG9evW6e/Xq1ZoXLlzQ0jRtjL8bf2jOnDkbly9fPqo8rXeRSISt27YdaNOmjYzP46n4FYxls1gsaLVaFBQUPOpwTRPGT4iRbpNub9qkSVhubm5WdnZ2uWVvj4KcnBzSqg8FBQVPLDNosVggk8nAMAz+/fffrtnZ2fumTp3avbRUrJ3UfXx88Nvv2/auXLlyNU3TbycnJx/bu3fvsUeRpnXh2YKiKBgNBoSGh4OiKFjMFk1JLS6r2WIUCYU4d+7clt9/+20LvwwRJhdeDCiKgsViQc2oKETVrImJEycunz179ntFZM44DBYbbKALHfTr1q07kJKS0t3Xzw8ymeypWNNGoxEymQy1a9fGnTt3oFarn3ifAKBSqWz+/v4Ci9mC8ePGdbt27dq5iiQvA0Xd3yRSCTgcToXP02g0gs/nc+fOnRvH4XBKaMHZQVhwyZIlv127di0WALRaLbtWrVqVevbseTczM9P2ssi7PghsNze3Fz2GCsFoNJomT56cdubMmbD4+PgEgVBgWbt27ehOnTq17tq1a3h5pWw1a9bE6tWrdw0YMKADj8dzkNjDQNM0PD09oVQqATy8BavNZiMiNBdWr15dc/PmzWOysrI2E4W6JwXDMLDZbBCJRI+z0CgTpG1reHg4du7c2ePw4cOz165dt9jf38/++2JxdQZBQUH48ssvJ65duzbi1q1bo959990cnU5nftkXhW8SLBYLfHx8BFqNhr1z5y43lVJp8fL0pAFArVbbvLy9OV27dpWIxCJLTk62ns3mPGyXLjwnMAwDkVDIOX/hgme1atU2TZs2rTNQ9P6h8E9WYdpcTnY2Jk+ZstxsNs/o1asXuFzuU0vWYrPZoGkaixYtgl6vf2oxY5PJpHV3d+8fHR0dT9P0VfLvFe2tQerL9RXo+kdRlCOHafPmzfubN29eKvegKHQB/Hn0aMbatWsHCYVC6HQ6VlBQUPiUKVPSzGaz9nHEwV4E2I9bI/28wTAMwsLCcufNm+c9efJkqdVqLVCr1Zg6deqw8+fP/yOTyaiSmdcknt6vX7/2ffv2Xbhjx445Uqm0Qscj8SPAXj9ps9keSuqFrWDh4eGhT0tL+57IFj4tsFisp7L6dgZZ3NSoUQPff//9kiFDBl/btm3bXl9fX5TMZifW+vjx4zs2bdYsWa1SGbhcl773ywIGAKuwdTBN0+g/cKDNz9+PQ94Ib29vasPGDYcMBgNNFnM2hoFrOfbywGQy4a3+/bm1a9fmASWysBkKrMKblZ+Xh5GjRvU+ePDgng8//ND+66foaSGVP0ql8omSekvCYrEwFotlB1HCdD7eg0DmYy6XW+E5kGjPd+ve7aNhw4Z1AspXg1NrNMyMGTMGFRQUkHbZkk8++YQVGhqan5eX99haIs8b7PJUeV42MAwDg8GAAQMG3Dx16lTNVatWWf38/JQJCQln+vTpM/Ovv/76sizXOyGhLVu2fKKQy08d/fPPQ35+fijZma08iEQi0DTtiPE87MEjbhmRSOR4KV52C5Zch0J52X1z587t2KZNmzWDBw8OL6miRPITakVFcQC4zLtXAOQp5/N4VJ06ddxe5FhcqDicm+MwYBxk/scff2SfOXNmmM1mO0ryc55V2ITP5z9VI8JsNkMgEIDH48FgMFToOzabDTwez2FgVSQpzWq1Qi6Xo3nz5h13bN/xGVC2fgaZmQf07//xlatXTxb2OZcMGTIkdODAgdczMzOZRyljftFgZ2VlvegxVBgURSE3NxctWrTIycjI8D59+rQSAI4dO/bV9u3bO/fv379zeaVsHA4H8xYsOHj23395FovFVNEbZLPZHJmearX6pc5wfBKQhYefnx+sVuufo0eNirJarbuGDRsW7awQB7iEZV4VFLWALNS8dlLDKiuO6MLLgeJZ18Wbsvz+++9HJk6cOHDkyJFyX19fh9HwuoKUEhMtj4f1RCfXwmKxgMvlYvHixQf4fH4xo4SAXNt9+/YdPXjw4FLAXivfsWNHn1atWqVduXLFajKZXqnry35a8djnAYZhwDAM6tatmyuTyaR//fVXJIAEmUyGESNGdAsKDjY3a9q0RBpQERm1aN4c27dvPzBi+PBOWVlZ4PF4j5TkQDqzvSqrtceB1WqFTCZDUHCw/u+//+5y9uzZVR/P/niSf4B/sVIZF14NON+r4j8X/d+Flw8l37HsrCx8+dVXm0wm06jAwEDIZDLk5ua+oNE9P5Ce5VqttkJzL6lSEgoE2Lp166G2bdtyibZGWYlwt27dwogRI3pKpVKoVCqYTKaQsWPH0hEREfl37951dHx7VcAmIiqvEqxWK+rXr5+0ZMmSiHnz5rlpNBqFwWCwLF60KGbPnj2xNE2XUj8jK7QuXbp07N69++oNGzdONBgMZbZaLQsURTms89ed1El8tXLlyliwYMHka9euHVq3bt2uoKBgF5e74MLzRGHJ1cSJE/tdvHhx59y5c3Hy5MknrjGnKApyuRxarbZcJcuKCnI9a5CEYPJzWSDjJBZ19549l/ft27cwqbB0KhwpURs4cGA3hUKh53K5kEqlnp988gmnUaNG8Xl5eYiIiHhm5/Ss8NKXrZWFwlUY07Fjx5zdu3eHHD16VCkSiZgjR47EjRs3buWGDRumPyie/v2qVRNS09L2njhx4oDVYgFNs/Gwy2B/jhjQLBpg7GUjrzO7kRcnICAANpttz9y5c+uwWKx+hS0bX/DoXHDh9QeRKuXxeAcAnKuIjPWDQIhcpVIhIyMDdevWBcMwuHLlSqnkXaISx+fzwWKxXrjUaUUsc2JotWjRImb9+vXvAWWFB4sa3rzzzjvfX7t2LZa0a42KivJr1apVBmml/Spy40ur5f4wFMr4qT7++OP7BoMh/NSpU/fYbLZ1//797+/ft79W9x7dO5QVT7fBXvqwc+fO/VE1oxqlpKac54MCRdOlYizOoACAsf/JZtGwMM8uEeVlATm/whaB1/Ly8q4xDOMidBdceA6gaRr5+fkICAiAu7s7srKyHmvOcSZyhUKBsLAwDBs2DO+//z6WLFmCCxculFJcoygKBoMBDMPAzc3tuZM6Ca9WBETVrlAFs9au3bsOiITCBybB/fnnX8fj4uLeoexVIezevXuHjxo1KkWr1arVavUrO7e/9Epx5YFhGJjNZgQGBqoGDhwYdOrUKW+LxZJls9mY4SOG9zp48KCmSZMmZdIzA3sv85Vfr9zat2/fyqTlaUWajZBtaIoFyxsisEVc8CKR6KnJQLrgggsPBk3TMBgM4HK5jyXsQixMpVKJzMxMREVFYfTo0ejevTuqVq0KgUDwwPbQ5PgKheKFkPqjNMgi237//aqtXp5e5c7kFIBLly5h+LChb7HZbHh7e4NhGHcvLy+em5ublpTpvYrWOQCwX9WVCGDPZMzOzkb79u1vLly4MGzlypUypVKpZBhG++mnn8bs2rUrVigUluoMRoqv+vTpE/nrll/jpk2b1lWlVMFiNoOuoDYw8Gq6ZFxwwYXXG4TgyCLA09MTU6dORe/evREREYGCggLcu3cPxIX/ILDZ7OdG6gzDPFKnS/Idk8kENpuN1atXxw4Y0L8mUH7c3Gg0MgsWLOimUCrzLRYLKlWq5DljxgxZtWrVrpEkw0fxDrxsYJGb/6p+ALsF2aFDB2WDBg1qWCwWHkVROHz4cFy/fv3+B5Sdy0tu+JDBQ7r07dN3k8lkgq1E8sXDPjab7ZW98S644MLrBeJ6lsvlUCqV8Pb2xqBBg7B9+3bMnDkT7u7uuHfvHkiYtaLE6UzqwMNVMx8HhMxpmgZFUWCxWA/9MAwDjUYDo9GIvn37fjNmzJiuAEr19gCKutgNHjx4we7du+PMZjPMZjPt4eER4evrq3RWgnvRnPYkn1dGWOZBMJvNkEqlBfPnz7/F4/H8T58+fS8/Px8HDx78bMvWLa2HDB7S9UFJcqtWrRpx8eKl3efPn9vF5XJfaZeLCy648OaBYRikp6fD08MDtWrVQs2aNdGsWTP4+flBrVYjKSkJwON7FZ+1pU4I2mw2V2h7m80GiVgMN3c31KtXv/uGDRveBUonwTnrMPy4+se4Xbt2zSfHa9GiRejcuXPviMVipV6vx+vAhezXQbqTYRjQNI3w8HBF586dg06ePFkLwDVfX1/Mnzc/RiQUXe7Vq1cdonpW7Luwx4oOHzm8c+SIETF///13nNVqBZvNfqSH32KxvBKqcC644MKrDzLPqNVqyOVy6PV6tGvXDiNHjETzFs1hNBphNBod3Rmfxrz0rEidjK2iZE4kXVkUhVYtW3X9ddvWfVwut5wkODud7/xjZ/yktyfFcDgcmM1muLm5VR82bBgvODg4UaFQODwDrzrYD0qKeJXAYrGgUCggkUiujxo1KjI+Pl547do1XXx8PIYNGzbk4sWLNypXruwkXurcUQxwd3PDZ599FtukSZOaJpPpJmAn+orWYj5Jj/IHgaIox8qVy+U+cW91F1xw4dUFi8WCxWKBRqNBdnY2vL290aZNG9SsWRM9e/aEUChEZmZmMa2Mp0lUT4PUiTx2WZn1D4PNZoPVaoXNZoPBYAiZ9b//xfJKkDkRE6MKP/kF+Xh36rtDAEAsFiMiIkI4ceJEY+/evW/J5XJ4eno+0vhfZrBJXOR1AMMwCA8PR9OmTVP27NlT+/z582kAsmiavrl06dKYVT/8EMvn8VCkHOScPEGhRo0a2LRp0+/9+/ePIt2GKhonpygKZrMZKpUKHh4e0Gg0jg5sZYE0WrFarY6GA1arFQKBAAqFAhwOB3w+H7m5uXBzc4NQKASLxYJYLEZ+fv5T8QaQffD5fKLjDjab7fi4u7vDZDK99kI6LrjwMoMs6vV6PfLz86HVauHr64vRo0fD19cXNWrUgEqlglarhVwuL5Zf9CxQFqkbjUb7XMbjgmaVb9yQOedRmqyUPDaZO3/99dcdDRs1LPZ7Z7ljCoBGo0GP7j1isrKyLgCAWq32rVatWkTr1q0vkzn+dQK75CrpVYder0d6errJYDCkSiQSn5ycnCylUokNGzbEpaWlTTt8+PDXdvucKrTTi3cS69u3b829e/fGrVixomt+fj5SUlKgUqkqZKlTFAWlUom4uDhH7ajZbAZF2eULTSYT9Ho9DAYDpFIpuFwu2Gw2LBaLw+WTk52NevXrQ6lUIicnB61bt0ZCQgLat2+P06dPY/To0fjpp5+QkpLiWHAARate8iKRxBLyd/KnQCCAj48PRCIR2Gw2tFotlEol9Hq948W0WCxQqVT466+/wGazodPpoNPpUJhI8kzL1miadrxkROChIuBwOPakEDYber2+zEVIScuA3BdyjwiIfn9hO1xHEo5zMwmGYcDlckHTdKmcC6I/bbFYHNf1RYAs0Hg83lO5Z2TRWtEcE4ZhIBQKQVHUC8tLIc+E1WqFRqN56AROnhFSnlkWMZF96nS6p+bOLgs0TcNkMkGtViM3NxcikQjVq1fHkiVL0LBhQ0gkEuj1euTk5DjG9byuMSF1pVIJqVQKgUDgIFqTyQS5XA4+nw+BQOB4NwH7eyqVSnHs2DHcu3fPkQj3MBDDx9/fH+7u7pgxY0bcW2+91RAouyMBuQpvvfXW7DNnzsSx2WwIBAK0bt3ao0+fPvE6nU6nUCieaie5lwHs162mmDxQjRo1yq5Zs6Zm/fr1wefOnUvNy8vDkSNHvlm8eHGXjz/+uCsLdle7s5iMDfZsyG7dunVJTEyMXbhwYcyjHJu86OfOnYO7uzs8PDwcfXt5PB7c3NxQvXp1yGQyHD58GNWqVUP9+vXxyy+/ICwsDB3at8eatWtRpUoVpKSkICUlBdHR0cjKynKQEJvNRuPGjcFms5GWllasvztFFbVrtVgsxbwLHA4HMpkMSUlJ+P3333Hv3j3HNqtWrQIAeHt749KlS7h69SpUKhWOHTuGjz/+GDweDxcvXoTFYoFAIHimhE5eMIqiypWkLAkSUyMdnLhcbrkkyjAMjEYjaZEIjUZTKl+CoihHD2g3NzeHi5PP5xdzY5IFh1AohMFgcLTYFYvF0Ol0sNlscHNze2FlMISAybUkY3zcSZ90vRIKhQ89H3IMg8EAiqIgFAod4aJnSYIknwaAY0GmUChgMpkQFBT00EWi8+JbIpHAbDY75EQpigKPxwOXy4VCoXAs+p7VvaVpGhqNBv7+/ujatSt8fX1RrVo1sFgs5OfnQ6PRPFcSLwlybJPJhG7duiGqZhQ2bdqI1LQ0dO3aFXK5HOnp6VAqlbBarQ6jKDMzE/n5+Y6FU0U9oAzDICUlBaNGjYp96623ugBlJ8GRRjZr1qyJO3To0FIACAoKQteuXcMnTZqUUb16dWViYiI0Gs0LW2w/K7ArmojwKsLX11fXuXPn8EuXLnkCuOLm5sbs378/plGjRoc6d+7c2U7qRVmQDJhCUqcwderUrpcvX964YcOGUY/ixSAubLlcXky0QSqVwtPTE1WrVkXt2rXx119/wWq1FrOexGIx+Hw+NBoNTCYTWCwWCgoKYLVaHUSnUqng7u6OqlWrIjs7G+7u7sViWMSqcE7SIwsNT09PJCYm4vLlyxCJRBAIBOByudBqtWCxWI4Yvc1mA5vNhlgsRlhYGAIDA+Hn5weDwfDUXVTkZSaeitu3b+P06dMQCoUYPXr0Qz0CXC4Xer0eR48exaVLl3Djxg189dVXqFSpEtRqdbHJTigUIikpCfHx8VCpVDhy5AjatWuHbt26Qa/Xw8rYQDGAn58fVq5ciQMHDqBNmzaIj48HwzBYsGCB4xr5+Pjg999/x8GDB1G/fn14enqCz+fDbDYjNTUVJ0+exIABAzBnzhykp6c/1WtWUXh4eOCvv/7CV199hSpVqiAoKMixWHkcYpfL5YiOjkZ0dDTy8/MBqnzxYzabDT6fj2nTpiE7OxthYWGQyWRgsVgQCAQOYn2a5M5isWAymRySpeQ9Sk1NRXR0NCZNmoTMzMwH7kMkEiEjIwNvT5gIiVSK2nVqQyqT2RezfD7y8/Nx4sQJ3L9/H7/++itq1qyJZxm2NJvNEIvF8PX1hVarRV5eHoDna40/CIQQ+Xw+pFKpY07r0aOHwzDIysqCVqsFAIcn8mGSsiVLgwlPDRo0aMWsWbNKlac5xlP4RK5fv/7o/PnzY8RiMTQaDbKysmrZbDa2yWRKzsrKcrj9XzewX6eEAGcUupyZ8PDwa2+//XbEvHnzRAqFQnP58mX06tUr+rdtvyX07NUzwtlCJz+ThIr169ePTExM/OvEiRM/l7V/54/zA1gW+Hw+GIaBTqeDc4c7i8XieCkq0qqPTFo6nc5B3GUds+QLT14KgUBQzPIl9Z/kZ7J4IRaqRqNBbm4uaJqGVCp96qISzoRuNpshFAodXg2xWAyDwfBQQiffT05OhkajgUAggFAoLOXmFQqFYLPZ8PHxwdWrV3Hz5k20a9cOEqkEAByELhaLwePxUFBQgL1798JqtSIiIgJisdiRKEn0n/Py8nDlyhUEBARALBYjNTUV9+7dg1KphEAggJubG1Qq1Qux0KVSKSQSCXJzcyGXy5GRkYGQkBCQtpuPSuzEQpdKpXZr+wGETlpeklphuVwOlUoFg8EAPz8/SCSSJyZ3iqIcVrjNZoNer0doaChu3bqF3NzcYt4rNzc3SCSShyquEa+NQW9AYlIicnNyULlKFQRXCsaF8+dx9epVR+hFIpFAKpU+U7ctSYJLT09/aZqllAWz2ey4LgzDIC8vDxqNBmazGWw2G1KptFhO0sO8VuQ8SbhLoVCgRYsWA3/55ZfpQJEhVrwdqh2HDh3KHTduXGfAPi+4ubnxR44cqaxXr16K0WiEXC6vcEb9q4bXltDJAxMYGIguXbokAgj//fffmbS0NK1KpcKYMWPe+vvk35dq1qhZRoJcYXc2isL+A/s3DR82PC81NTWWxWJBqVQ6SkJIxiWJu9E07YhZikQiiMVihISE4NatW0hISHgRl+GpgMRAn8XE5RzjJ/FZEkc3mUwPtdCJW5lhGMdCxWKxOL7rPAGaTCZHhqxzAwaTsfA4hYRuNBqLhSqsVis4HI5DkYq4YW02G4RCIXg8HnJzc3Hr1i3odDqIxWIolUoHyTjv73nCYDDAbDZDJBKBoihkZWUhOzsbvr6+j0Xs5DkwGAwPJXSyP+IdEolE0Gq10Ol0UKlUUCqV0Ol0CAgIgEQicVhtZKIti9ydcyDIYpbEcInF5eXlBU9PT+Tl5TmsWhaL5SCch1WJcDgce0iGy4FUIoXBYMC1K1dw+fIlyJ0scR6PB5PJVKF9Pg28qq5hUt/9ySefQKlU4vr168jJyXEQvsFgKGaUcDgc0DQNsVgMmUyGgIAACIVCVK9evev06dO3FXXSLG2IUaBw+84dTJw4sRcARiKRoHnz5tKePXv69+rVK0GtViM/P9/h7n8dwX7dy6DkcjnUajXq1KkjP3fuXMOkpKQ7NE1n8fi8yz+s+iHm66+/LtZuFYCTjQ5IxBLs3r37wPwF82OSEpPiVCoV8vLyoFQqHZOEzWYDh8Nx6J27ubnB398fQUFB6NatGzZt2oSrV6++oCvgQkk4x1kfhookUREykUjslv7LZkURIhSJRLDZbKWI3c/PD1ar9Zkm8DkveoVCIdRqNfR6PVQqFVQqFfR6Pfz8/ByLj/LInaZpFBQUgMfjwWw2Q6PRQCqVQiaTOVzsZFH4NBZRXC4XbJpGvrwAoChwChd0LlQMJK/E3d3dsejm8XgO4iYWOAH5OwnZ6PV6eHp6dp0wcWKsQCAA8Q+W1BQhrvZNGzfGcDicMzRNQ61We+Xl5UXRNH0tIyPDShbhr1tmuzPYxN36uoJke7u7u8tHjhx5k6Io3/3792fn5OQwhw4fjnvrrbd6bNu2bR+PxysRk2Ec5W0sUBgyeEjszJkzY9LS0uLYbLZj4igZqzYajdDr9Q7Bh7S0NLyqHe1ceL1AntOyiD0iIgIymey5kFV55K7VaqFSqRyWu0AgcCSpAXYX982bN6FQKODn5wd3d3eHtV5eRvrTAofDAeVU5eBCxUDCkTqdzuExslgsDk9ZSfc7+ZmiKGRnZyMgIKDr9OnTYz09PMowuoqEY8xmM0YMH9779p07cSkpKbBarejYsaNsyJAhl318fBQ0TYPH4732Ut2vPaGTGxgeHo42bdrk1q9fXy0UCn3v3r2bdePGDSTcvbu/Z8+e7xw6dOi7suRhATupV65cGYsWL4odOnhIF7lcfojP5792JQ8uvBkoSezJyckQCoXw8fF57tZnSXJXKBQwm83Q6XSQy+UwGAxo2rQpFAoFvL29kZ+fX+FSJxdeTdA0jdzcXAiFwvbLli2LrV69+gO7pwFAv379Pt23b98eDoeDiMhIVKlcOWDhwoU5VapUUd+/fx8Gg6GUkM3riFe2feqjQq/XIyEhASwWyzBixAjByZMnq7Fp+vaNGzdx+PDh76dOm9rhm6+/6VMWqRMXfFTNKPzw448HBw0a1EqtVp9yd3d/MSfjggtPAYTYSbXDi54LCLmTZDmtVguTyeRIPCNJmy9bSMOFpweappGTkwM+n193y9atR+rWrevollkyCY642T/66KP9+/btWygSi1EpKAit27Sp1aZ1ayNFUZnx8fHFtDped7Aq0lXsdfmQ/r4JCQnJt2/fFqbcv9+Iplnw8PDA4UOH+3777bdxQNGDAhR16yEPUvPmzfHzzz8f12q1ITk5OS5LwQUXngGcLXfion0TJuQ3GcQy12q1si1btpxo07p1YXCdJMEVgczRmzdvjvvzzz97BAYGwmwyISUlpU78nTu8xMTEeIPBwJBcijflw37TCInD4SAqKgo+Pj4XW7ZsWXPp0s+CCwryU318fHDx4sWYs2fPxjZt2tTRnc15RUjU5Nq2bUvv2L7j7959ercymUypXl5eL/CMXHDBBRdebdA0jfz8fBiNRrfdu3ef7NSpkwRwrjUvbZnv3r07LjY2Nkan0yE9PR1isdhr5gcfqP0DApJ8fX0dctZvEse9UYROXHZRUVGQSCQQCoU3pFKp/4wZMwSpqal6Ho+HadOmxYwfP/7guHHjoh/UcrVrTNeQHTt2nOjZs2fNvLw8nZ+f33M/H5vN5vg8bTAM4yjPslgszyy2SqwucjyiI0+SZypStmaxWBwazwCKjdnZPUvcthwOx7EtEe1xLlsrKzeCbEPGSbYhLmLyHhFFLDIOhnn2CVvlgcjaVuTYDMM89Flyft6sVusDy9aIaMjjitg8DZBjKhQKFBQUgKKoh6ocOpeiArDzSDnXjyR2vYpqm8Sie9K5g3SmfBIQy9xoNNI7duw40atXryjg4cIx48aNi+HQbDRv2QJhYWG8mJgY7uTJk5Py8/OhVquh1Wodnp43Bew3zY3FMAy0Wi20Wi04HA7at2+ft3LlysDU1NSsuLg4w3///Yf//vuvi0QiOT1w4MBmDyL1Hj16hO7cufOfvn37ts3NzVUGBgY+13PhcDhPTafbGUTO0Wq18oVC4Sw+j//M4qvk+WOz2ZDJ3PgZGRnnlErlHwKBoA2Px2v3sEmYy+VCKpUKGIY5ajQajwBgiUSiWTwej0uypAkEAgFkMplHbm7uhywWywAARqOxE4/Ha2GxWByELpPJKLFYfAPA72R8BoOhmkAgGEQWDkKhEBKJJM9qtX5HGuswDOPQtAYAFovVi8Vi1eMWWgrPG2yaBpfLNanV6iVEwrYsmEwmRzOgB0mjstlsHpvNfp+maR6XwwUolEvobA4HbDYbQqHwTF5e3qHQ0NDnOrGS2vOsrCzUqFFjYPt27avrdDpwC6WRywObzQaXywXFYn0LIN/esqv0WVIUxeNyuTNomuY+bJ8vI6ii8rC/ARx75O8XVh8QcZ/HBU3TyMrOhtFoFGzbtu1Yv379agEPJvNdu3ZfGTduXCcAqFe/HmJiYoRVqlQJCgsLS7l161ap+eJN4rjXP+2vHJByCrlcbpbJZLl5eXnVWrRokUzTtPLMmTMYNGhQe4lEcismJibUmdRJYgYh9T59+tTdvn3Hif7932qVnZ2tCgkJeeZjJ7Wd/v7+8PPzeybZ9iaTCZMmTdrVp0+fLqDKNVKeGtg0jZzcHHz88ezet27exB9//HGwbdu2fFupAzu3v6XApmnEx8dj3759uzMyMjB27NivBg4cOJ1iUWAY5y3tk/VXX32VunPnzg8LJUB5I0aMONyyZUvYGPuChUXZlbkuXLgwESiqQ58+ffqWTp061XPe19KlSzdnZ2dDoVCAoiiEhYXB29sbCoUCtWrVqj516tTdbm5ukMpkJcb/fMCiWOjduzd+/vnn3CtXrqwNCAgoc3Jjs9mw2WyQSqUQCoUPWrzxQ0NDlwQEBMDPvzyPFFXsp59++gkrV67cuWvXrlFisVj9rPtOk30XFBTAZDJ5v/XWW5smTZrUVSgUwmgyISg46MHfh12/ny/gH6E57H+4fB7YbDZogx5gGMfZsShKULly5cVBQUEICAx4Zufz9EE5/k9RFLy9vdcBOPaoVjax8OvVq4fs7OxHaqREQNM0MjIyYNDruVu2bPl74MCBjYAHk/mRI0cK+vXt0x4AateqjahatdxycnKqiESiW1Kp1BAQEFDhDpmvI95YQgeK1UhqDQZDikKhqBsUFHS1Ro0a8tu3bxv69u3bJjY29lb79u2FD4qpv/VWv9p79+79r0+fPh1zcnLSKleu/MzHTV6GvLy8p2r5UBSF3Nxc1KtXr8msWbO6PE+ras7Hn3z277//7hk6ZMj8jp068QGgImv/mTNnLkhNTT3TsmXLOl988cV0TjkWU3x8vHn+/PlVARjUajXeeeed5W3atIH9OEVH2rx585mLFy+uCQkJgVKpRJMmTfrNmDGjnvO+/vrrr4Tdu3ePdXdzB4tFwWAwID09HSkpKdBqtVi7du0G8hzQLzArWyQS4dNPP/162NBhP3t7exvLujZEiOVhnh6GYWwsmqWmKEpCUxWzygICAvDFF1/07d6tW6uPPvpo5L379+N8fHyeibVOtCCysrLA5XJ7rly58pdGjRpJyO95FdTupu1eGMoRTmGz7cmxDONYjzEMY6PZtIaiKHFFr8XLCApUDgBQj8h/RoMR/r6+aN26NTZu3PjIx2Wz2cjJyYFWq5Xt2LHjeL9+/eoCDybzEydO2AYNGtRWwBcUBAUFwdffz0utVtdzd3e/BODBmr5vCN5oQi+BAgDXtVptU09PzwtVqlTJyczMTBk+fHiH7du3n2nevHmpsgmgmPu96s6dO0+OGDEiOjs7O/5ZJ8qRuHFAQECxNqlPAiKjKi8oYL33/vsbWCyWo2TkWYIFCpcuXWLWrlv3Px9vH48vli2bA+CBxyaCEidPnszct2/fQgCYMH7Ceg8Pj8JlV5GWFJkQ3n333UVqtVoPAN7e3nWXLVs2GSjShaYAZGRk2D7//PMRYWFhpBkN+5tvv/mJbMeCXSp11MiRo61Wq5lFURDwBPAt9JTcu3cPNWvW7DZixIgm5DsvEixQaNGihaBjp44f7d69e4Gbm1spC5lYNF5eXqhatWq5eufOMddHOS8WKLRu08Z7z549sV8tX/7Hvn37xggEAtXTbDBCOpNdu3ZNNGTIkF86derUOyAg4LHGWniOTiomZX//ca7FywLyTjzuvGG1WkHTbNCshy8ES4KmaWRnZ0Or1Qbs2LHjUL9+/Qpj5qVBsjT+/fdfjB07tiOXy73m4eEBkUTsZTQYGkEmOw8g77FO4jXEm5MtUAZIQpVWq4VCoUBOTk5+RkbGhTt37jQoyM/3DvD3h0AgODtmzJiOZ8+csbupSkQNKSd3fM+ePUN37tx5UafVtSINTZ4VzGYz/Pz8wOPxHPW6T/oxGAzIzc3FqNGj/zd82LDqwPMhcwD46KOPhgHA7I9n7woICKAetpCgABiMBowZM2YwAEuDBg269x/Yv4F9zKVju8ePH79/+PDhJURIadasWev5fL7jCGT7999/f+nt27cTDAYDMjMzER0dPb9xo8ZS523WrllzKjUt7RSfy4NarYZKY286otfrwefzOT/99NNWLpf7UkzztsJBvPPOO7Py8vJECQkJuHv3brFPYmIikpKScPv2bTwLoSkGdtLz8fXF559/3m/1jz8m8vn8bunp6Y5+848LogR57949SKXS6EGDBsWPHDmyd0BAgOO4Ljw9EDVMPp8PgUgIo8n4SIsyUmeu1Wjq792z51IRmRNdTqdjFc62586fw6RJk7oIBIJjhd3wPBITE6MyMjL+zcnJyZXL5dBqtcVCjy+6fOyFla29ySINVqsVMpkMNWrUgL+/P+rWrQuNRpPD5/PPHjp0qOqO7dsNVapWVfN4vD8nT5nS9ccff4xr3LhxMRJnCq07Yr21b99etHnzzyc+mjWrS15e3qFnSeo8Hg+pqanIzc19KhNxYbck7vTp0z8Bnn20lyyO1q9bd/XIkSNbqlat2mzi2xNbV/R7W7ZsOZOQkPA3h8PhrFmzZgufxy8kc+JJocACYDAaMWbMmFEcDscikUhQu3btPu+//359oPii4d9//7X89ttvCwH7gikgIMBryZIls4Ai6zwlJcX2zTffjggLCYVEIoFWp0NaRjru378Pq9WKHj16fNK4cWMJUGjYlXi9WKWWGk8fZZFYnTp1BIMHDZ69ddvWjz08PErFyY1GY7Fn6XFiokDR+ZWnuEgBaNW6tdfuXbv2f/nVVztiY2PH8Xg85ePE1tlstn1BpVKhW7du3w8aNGgySUy1OY5Y9hifl+fpZYdEIhEAFe8/YLVawaJYCI+MhMVscuSeVAQkm91kMrXbum3bwY4dO3KBsp8VQuYXL13C+++9H8Plcg+pVCokJibyunXr5telS5cLer1eLRKJIJPJ4O7uDjc3NzAM88SJeq8y3miXu9VqhVQqhbe3t6O5SmG3NPngwYOvm4ymiD1799ytWrWqztPT8+CUKVO6fvfdd3FNmjQBqwSpA0WTfus2bfDDDz8cXDB/fkxBQUHcs4gXksS4yMhISCSSJy4dYRgGycnJmD79vdU1a9bkP8sJr6g7kv08PpkzZxAA/LRhwz5Cyg9ztWdlZTErlq8YCQBdunT5pH79+o5YKfmuk0V9Jjk5+bhIJAKLxeKuXr36V/t29g9duOX06dMHAzACQF5eHpYtW7YtJCSExRTeVwD46KOPliYmJSZLJBKoNGoIhUL4+/tDr9MBDLxWrFgxm+zbOTBJxp2ZlYWzZ86oST/op3GNKditJl9fX1aTJk1ExVoCU0VEunDxwg937vzjc4PBoBKJRMX2wTCMo5Man89/rDE4ozwZZfJv3j4++Pzzz9/q1bNnh5kffjgiJSVlv5+fX4WsdWKVJyQkwMvLq9OAAQOWDB06tCFQOkxDOQRJmGIEa7FawKbZz+QZJ/f6v//+M6WmpRnFItEzXzw8KijYG+Bcv3FdDgBma8USaw0GA5o1a4bQsFAc/+tYqfteHpzqzLuuX78+tmHDhgAeHDO/cP48ZnzwQQyfz4/LyMhAUlISt0uXLgGbNm1K9vDw0CuVSkc5qclkgtFodLRMflMN1Tea0MtrC2q1WuHt46PZ/MvmuwMGDAg4ePBgas2aNY1ubm4HJ0+e3PW7776Pa9asaZmTFonH1q1bF4sWLY49feZ0TH5+fhw53tOCwWBApUqV4O7ujn///bdYj/NHBel7HhISUn/xokWjgGdnnZMJgFyJ5cuX/5GVlXWrVctWM5s3a+ZpP/aDXe0A8MGMGV9cv379rpeXl+yr5ctnA0XXnhynkPhta9asGRUcHIzU1FR07NDxk3r16gnIccjksWLFigtnz57dIZNKoVSpEBIS0mrKlCkd7NvZj3vlyhXTyZMnF4aHh0MikSA1NRXp6engsNkwmkz46suvfouIiGCXXpDYx2IwGDF44MD+Mje3Q0KR0O7ZeQrlgBRFgcPh4PTp0+Kff/45sXnz5gJyJYrGQSEiPII9adKkz1d+/fUkf3//YvFThmGgUqlw//59+Pn5PXJLUHJffvzxx795PL7P6NGjqpdMJC0robR5ixbuu3bt2rdy5crdsbGxYzgcjpzD4ZT7rhCrXC6Xo0ePHounTJ48Oyw83LHPkiDHJPf58uVL+Zs2/Xz5iy++6EDRz+Y5pwBYbVYcOHDgq3Pnzi0ViUSOJjJlgc/ng8/nQ14gh8VqeS5kRDqgXbx40QAAJvODPTIUKMc8WaVKFXC5XJjNFYudk37mDMN0/fLLL2Nr164N4MEx83PnzmHGjBkxfD4/LiUlBUlJSXS7du18fv755xyr1aq/fv36A61wV5a7Cw7QNI3cnBy4ubnpNm/enDlixIjAuLi4tHr16pmEQuHB8ePHdVy1atXR1q1blyJ1Z3dvjZo1EBoWGvvHH390B3AAeHqkTgQTSAehJyF0Ij4y88MPf+JwOU4x6NJJgE8DDOwT7I0bNywffvjhW1wuB+vWr/sMqFjM88LFi9Zft2z5GAA+/PDDHZUjI9nE1U5Afnrvvfc+u379eryPjw8CAwN9V6xc8T/7cYq20+l0WLRw4VgOmw1fX1+YzGZ8++23PwsEAsdYAWDq1KmjrFar0d/fHxaLxdEyValUwt/fv9mUdya3t59f8eeBYMWK5Rf+PnFiR+/evVErqhZUKtVTmXj4fD4K3ZHqdevWrWvevPm7JZ8yEhqaNXv224ePHPmGpulbpN0rgVgsfmxdA8ei5+qVAz/+8OMyNpveP3z48G6O5CuUXqiRe+3j44MlS5b07tG9e5sPP/poREpKyn5fX99i1jpxo965cwdhYWFtp0yeMnfylMltnfdVVtIq5XQH1qxe88/mzT+P8fLyqs9isTo88kk+AixWK0Iqhai4XK46MzPTsegi99tms4HH40EilSI9LQ0JCQmoV78exCLxc2n6RFH28rwbN27gzp07YLMe7KI2mc2oXr06TCYTFAoF3NzcwGI9eC4jnpS0tDQYjcaYqVOnHvDx8SnXA0eeldOn/8H06e91cXd3P5SRkYE7d+6wOnTo4Lt+/Xq50WjUKhSKN9al/jC80UlxDwJJ3jCZTNpffvklq0uXLsGXLl3im81mCASCP4cPH97iyJEjKqB4rKykNSIUCrFu3br9bdq2HXPjxg0AT4fUnQVXyM+P+9FoNGjXtt2QyZMm1XE+j2flJiQP3dsTJ37MMAy+Wr58X5UqVVgPOx65znM++WQCAKuPj0/jd955p6PzeJ33cfr0acO2bdsWAEBOTg7ef//9rWFhYewim7XQ1T5t2soCufyKj48PcnJzMXDgwJk9evQIdT72N998e+nEiRNblUolLl++jGvXrkGn05Ff02vWrFnPc4rhExCi0+v1+O6778bbM3yzYDabHQJHT/oxm81ITEyEUCjE/v37v0pNSytmnVOF/zEAfH188Pbbb69Ta9TgcrnFPjKZDHK5HCaT6bGfUU9Pr1AAiIuL696rV+8PExMTC8dQPsjiqlnz5u5//PHHvhEjRuxOSUnxzM/Pt19cmobJrtON5i1afPTL5s3HCJkXJb5RpZ4eVuGdyEhPx7fffrt51Q+rWprM5vi27drVND5mjkCFwQAms4kvlUoRGhrqUBgkpbIisRgMw+DwwUP4ZdPP+PPPP6HX60UURUlMJtNz+YCBxGq1cgF7dKjcD+xjDgsNhZe3V4W8N+T5SUxMRLNmzQaPGD68QmR+7Phxy9ix49oLBIJDubm5uH79Ort9+/YBGzZsUJrNZq2rf8aD4bLQHwBC6r6+vrpff/01d9SoUVUOHTqU0KpVK51arT7dp0+fxlt+/XV3z169qtktdcDZiUeshsDAQBw9enT96FGjWt65c2dM5cqVnxqpA/YQAZG2fNTvF7p8BV9+9eVmMubngZMnTmac+uefL0JDQ2q+M+Wd7kB57k9CRfZz+/7776/ExcX9RNM0vvvuu43EinbeniwY5s2bN4XD4RgLKwKaTp48uZ3zcSgA58+fN69dt+4jiqKQX1AAg8HAmzVr1mLATjQs2Ml48aJFY0hsjkjLksYhnTp2nN29e/cyqwLIHVmxYkWsXq+/VLt2beRk52D1j6vBPAVJVOKpYdE0wsPDkZiYeP+HVat2L1mypDexWEt6DCZOnNj8y2VfNjx58uR55y5rJC/D3d0dderUgUqleuTx8HlcK0VRSE1NRUZGxrJp06ZdGjRo0BfDhg2rx3Ii3eLXiXGQuo+PDxYuXNgrJiam7cwPPhiekZm5Ty6XIy83r2aPnj1WDB8+vBP5VnHPWFFXRKBo0XjgwAH5oUOHhuXn58c2bdoUmZmZyM/Ptz7MunxSUFRRboNUKkVISAju37/v6B5H0zQOHjmKS1cug8fmIjQkNLJnz57npBIp/bwsdAFfgKvXri47e/bsQvpBOThM0VxjMBgemudAtr116xbeeuutb3755Zd3eTxeuXMLIfO4uLjMUaNGdQ8ICLgIAJcuXWJ37tw5eN26dXkmk0mbk5ODkrkfLhSHi9AfAkLqfn5+qi1bttwbM2ZM7cuXL9+pXLmyXKlU3unVu3fjX3755fDQoUObslA6LkQmGTZNY/PmzaO//fZbv3v37sWYTKYnFtewWCwQCATw8PAARVHgVlA4g4CiKGRkZGDYsGGf1q9f/7l4a4i1Om7s2D4AsHDhom1A+bFMUk3Ogv18P//88zEAMHz48A/69+9fikTJNL36xx+vHjly5KfKlSsjIzOD+vbbb53K1Ipi559++ulkoVBo8vT0RF5eHmbNmrWuatWqHOcE9bmfzv1ZrpBfrlatGhiGgVKphMlkglarhdVq5X21fPnHQHnZukBaejqzevXqyUKREDnZ2VApVU9VY7pIl9uKwIAA/Hn0z/m57+f19vbyKjUiBna53HenvvvjzJkzG5Z8Do1GI7KystC8eXMolcpHXyQWaiLcunULkZGR4PP5R4cPH14/JSVl79uTJvXwKGw5XN79JrH1Zs2ayXbt2rV3+YoVv8kL5BfmzZ/3WY0aNVj2bUoc08nVTs5EqVBi/U/r45YtWzZ0yJAhcqlUCk9PT4el/DxhNBohk8lQqVIlZGdnw2az4fD+A0hKSkJ4aBhUSiVEIpFX506d3Z7rwABERES4ASj3WST5NUFBgejQsSO++eYbBAWWr7bHYrFgMpmQlJSE3r177585c2Y3oHxDgbyHv//228XBQ4b0DAkJSff09MStW7ckPXv2rLRu3bp7arXaZZlXEC5CrwAIqdeqVUvVrl27xD///LNpnTp1znfq1Cl369at6mHDhjVTqVQHJ02aVGZDF6Boonr33Xe7bt++/eDy5cu7+Pv7P3F2usVigZeXFyQSySPHY3U6HTzcPap+8cUXH9nH+GxBXNHr1qw9HZ9w97/+/fu/O2zYsCig/EQ4EvsFgMWLF29LTU29CICaOXPmIvuYS1vEBoMBS5YsHQ0AWVlZGD50+P/eeuutGkX7s+OHH364EhcXt87LywsZGRnw9vKqN3fu3GH27ezkcOvWLcuyL5eNB4CUlBQQYgCApKQkzP7f7J9q1arFK8qrLxU/Z6a+8+6HKSkp99mFamxcNuep+0EoikJmZibYNI2ExMTL69euOzjrf7O6lIwrk4XKjA8+aLB27dqW8fHxp5zL2DQaDZRKJfLz88Fmsx85nk6eQaPRCK1Wi6CgIISEhGDTpk09L1669Na3X3+93T8goNwseKB4JvzSpUsH6vT6gcLCHJHiEsxF5+TsmUlJuY8PPpg5KDEx8bfQ0FBIpVLk5ORAKBSiPBXBZw2j0QhPT0/QNI3NP/+M5KRkkOtuYxhYLRaTXCGHu5v7c/GSESLVarV6oPwkMoaxy1zLZDLweLwHJnGy2WwolUrI5XK0atUqbujQoV2A8ucVMoYffvjh6OTJk7tIpVJro0aNUFBQ4KFUKmu3a9fuupeXlzYxMRGkDaoLD4aL0CsI4l6Vy+W5HA7nvE6naxQaGvrvxIkT87///nusXr26S+PGjWMbNGjQteRkVbJWvX///tHr168/u3z58mk5OTn/PomlZjAYEB4ejtTUVKSkpFS4Ht1qtUIul2Pjpk2b/P39H1X58bFAAcjOzsZXy5cPAIBPPvlkOfDwhQQF4OaNG8aFCxeOAICpU6euqlGjBq/kmAnxL1iw4Oes7KyLQqEQarWaP3Xq1DlFx6EcXoJFixaNAezX0Gq1Ys6cOT/ZrfgiC37hwoUzhEKhycfHBwaDASqVCnq9HgqFAtWqVWswb/68IUBxhXnncZ87d067/8D+He5u7l4CAZ9nt3ifjbuXZFfn5eXpfv31lx8nTZ7UUSaTsUteJxJKWLBgwZpBgwbVYNNsUJzCNEiKQnZ2NvR6PQQCwWM3/uFyuZDL5UhKSoJMJoNMJgMYZsf7M2a0bNCgwaIPPvigbXmkXhQqsJ+TUCAoJ/HUDue3Z+7cuUcuX7r8MZfHPefj4wO1Wg02mw2SyPgiO6MRdcfMjExHhz6r1QoKAEVRLySfiSrsPFOWJ4ZiUVCp1fD29IJ/YCA0Gk25Hhu70ZMNk8lU98fVq78dOnRoSwCwOi2gnVHUaGXXwcmTJ3cFgEGDBoFhGO+srKyGbDb7nFwuz9NoNC4yfwS4CP3xkAvgbF5eXu2WLVteHTp0aIHJZML58+djjh8/HjtjxoyuzjH1orrrIlIfM2ZMk/r16p39YtmymJycnLjw8PDHjqfabDbQNA03N7cKWSAsFgvJScmoUaNGzNAhQ5rYR8mUIqSnAoYCqKJJd+q7U+ffT7mf/v57739bu3ZtNnGBlztWYtWvX7/EarWaPT0963/++edvk28REifjv3nzpnnZsmWThEIhVCoV3n/vvZXVa1TnO8fNAeCTTz75KTMz82KDBg2QkZmJJk2ajJg8ZUrdov0Cu3bvit+2bds3VatWBZfLhUAgAJvNdoiuvP/++z+x2ewSaZBOpw4gPCJCeDcp8YpYKOLabLbnNWlbNRqNks3lsEoveoqu9sCBA6uvWrVq4Pnz538LCgpyZF7bbDbk5+cjNDT0sQVmOBwOVCoV/v33X/j7+zuaCSUnJ//z7bfftrPZbOuGDR06NqBQCMY5Wcr5z/IWbQTk+biXnIwvv/pq/tq1a+e1adMGIaEhSEhIAEVRyM/Ph0AgeO6udmcwDAOj0Qg/Pz+8PWkSvlm50pEtTjahaft0/DQFaZyva1lVAA+C0WCETCpF15iuyMzKKnMxRJL8srOzERwc3PW3336LbdO2LQCycCx5zCJPysYNG+KSkpNjPDw8MGjQIISHh3v+999/dQGcg0vO9bHgIvTHRwHDMJcKCgrCO3bsaJo9e7bG19cX+fn5Me++++4f33zzTV8WRYFBaVUqYiHVrVcPixctir1582b/hISEHYiOfixSt9lsMBqNjv7bDwJJ6uLyuOw1a9ZsLCIkoLSN+RRAFZHo2X/PGn/f/vs8Px+/yks/W/oO8LCac0eyTOKGDRuWAMCcOXMcsXCyX+fSsilTpnxqsVh0arUaoSGh9ZcsXTrR+TgUKFy7ds26fPnyKRwOB7m5uWDTNPer5V+tBopCIzqdDu++8+4ohmGQmpoKm80GkUjkIKpu3bqNHT9+fO0HnQMDBp4eHixPDw/pY1+/x4S3l5cAKC92yTgm23nz5q0aOnToH4GBgRYOlwsKIDXDjjKrx3kmGYaBUCiEXq+HSqWCt7c3zGYzJBIJ6tWrh82bN4/77bff9qxds3Zb/Qb1hRV98opb5vZx/fzzz//u2rVrzr17947UrFkTEokEFovFkeRnsVhgND6aROnTBHknhUIhjEYjmrdsATaHjS8++xypqamk5S6HeBCehsvdZrOBx+E+9htNgYLRbEJEZASqVq+G23fulLp+5O9ZWVmoX79+7/fee2+Xe2GOhLMmhPM+HToSM2fuVatUvbRaLXr06IE+ffpIDh48GAE7mSseY8guwEXoTwSKopQMw9ymKMovMzOT+emnn7QjR47E3r17+yUkJEzftGnTCh8fH7J10fdQ9MCHhYfj7Jmz29+f8f7Gu3fvjn6cZDkOhwODwYDs7GwI+HyU69It/Ge9Xo9+/fp92qJFC2+gyNJ9NmVqRS/2Rx/a9drnfPrJbxXROieu8YkTJw5XKBSWZs2a9Zk2bVpdMuaifdvP4MiRIynHjx//XCAQQK/X44OZH/zE4/FKxVgXLFgwnc/nG8RiMVJSUjB82LC5dWrX4du3so/1m2++OZqenn6GpmkYjUawWCyo1WpSsiNYvHixYwHw4LN/9hKjj4KSY2nXrp1Ht27dPo6NjZ0vFolAUSy7yAgDBAYGPlYc3XEskoFfmCjn3EQoICAAqamp+2Z+OLPqmDFjNgwdOrRjRSVZCZGnp6Vh7759W37//fehNE2jcuXKiI+PdyQJkuOIRKJHFsp5WnAmcw6HA4vFgoz0dDRs2BCffDoHO//4A/+dOwdzcvKdS5cuzvX28mZpNJonPCjA4/OQk53D9fb1ntGwQUPuozyHZNHP5/IglkigkJeu+ybJb/F37mDMmDHfLlq06B1nMi8ainPpJJCbk4Nx48fPS0xMnN+uXTusWbMG3bp3EwHwYxjmOgAdXHhsuAj9CaHT6fQeHh6pK1eu9Fu2bJksPT09o0mTJti+ffvKiRMn3vt506ZdEqnU4W4HSroUKfAFfKxatWrUhp9+8v11y5YYpVL5SMlyBoMBvr6+oJii0qMHjBcSkdhj2bJlhQIrZQtyPC0Qglz1/aqLJ06c2NGyZcs+k6dMqQc82HIg31uzZs0/qampZ9zd3OjVq1dvIWMmINa5wWDAxAkTRvJ4PEYikaBBgwYDp0yZUse+TdGiYuPGjdd37NjxXbVq1cBiseDj41Nt8dKls8i+KABJyUnWr7/+epi/vz9EIhGsViv0ej0AuzUyYcKEhXXq1KFfHpp+dFCFISEWgPHjx3+4bt26ZXCaTJOTk9G4SWN4eXtBr9M/9nE4HA6USiWuX7+OOnXqACgiOQ8PD/j6+qb9/fffnWJjYxcuWbLkk5CQkFKWXVk4e/asYsKECSNkMtm+hg0b4t69e8UEWcxmM7hcLqpUqVJu97hnjZJkbissU2QYBhkZGahRswZqRtXEyROn8PfxY/LsrKwFQoEQWq32iY7LZrNhMpuwes1qxMTETLYTesXfc4ZhYDKb0KBBQ3h4eJQKu5DktwJ5ATpHR8dOmDChK1CyjLB4PwXAnnA5ddq0/nv37t0xZMgQXLp4EWw226Njh46C/Pz8+xRFPWNxgNcfLkJ/QthsNuTl5VkmTJiQrtFoau/YsSNg1KhR5y9dugSj0bh78y+/xDRu3Di2YcOG5WT2Frk/R48Z09VitZ47derUzMzMzONAxURoSHJNWka6Q52pLDAMA5PJhKVLl25zFlh5mmTuHNMmfzOaTJjzqV2vfcXy5TsA54VEefsB0tLSrN9///1wAOjWrdvCWrVqlRIZd8pYP5Z8795xoVAIkUjEXbVq1Ub7OIpGZbFasGzZstEAcP/+fej1enzzzTcbgoOCWM4u/P/N+t/SrKysbLFY7OhkZ7PZYDab4e7uHrXsyy9nFO37wXgZrPOyJnJnSdjGjRsLe/Xq9eGePXvmicVi2Gw26HQ63LlzByEhIU9E6M4x1sI+CQ7Cstls4HK5CAoKwoYNG+bMmzfvRK9evdbUrVfXs7BRUDHQNA2T0YSTJ0+eWr9+/XCDwZBPSgmdQwPkHbDZbC8sCc5mtUGr1+YQydeyzictNQ1sNhtNmjRGrVpRkMsV0Gqvo7x2rRUBAzvh2mw2lDQMKvIsUhQFlUaNsJBQRHeNxl9//lXsdwCQmZmJSpUqtfjhhx++mDBhQnOgNJkTkJno0sWLuHzlSozJZIqLiIhAREQEkpOT62zevNnQqFGj+AMHDrz4F+U1gIvQnxDkIVcqlQxN01eMRmM9b2/vmlFRUTcSExORl5cXN3HixDYffvjhtwMHDqz9sLK28ePHN+zevfux/v3798zIyNjnfIzyYLFYIJFIEBYWhnv37pWZGMdisaCya5S3nDZ9WifgWZNN0Wu9aOHCjQUFBXcHDhw4t2GjRg+MJxSLs33wwWd3795NDgoK8l20eFFhaV3pMrV79+7Zvvrqq4He3t7Izc1Fq1at5hHyd7bO5306b8v9+/fPBwQEICMjA+Hh4W3Hjx/f1L6dfV+nz5zJPXDgwHxfX1/weDwolUqH14NhGMyZM2eDVCJxbF/yCr6sHbaIRV5yxOS5+/LLL2cfOnjoa4Zh5BKJBGaz+allhbNYLHC5XFy/fh1cLhccDsdh9ZEe6xEREVAqlUe2bNkSyeVyhQWFKnHO4PF4UCiVOHnypNrT09NBViXzRvR6PYKDgwGgTCJ9liDPGs2mERkeMSA/v8CHy3uwPoRWqwWHw4FMJrNnvT8FsSE+n49+fftyq1evLiDjqqh1DgCe3l7gsDkOrwcZU3p6Gnx9fXusWLFib1CQvR69PA198i7s3Lkzcfny5RN69+79V3x8PMLDwyEWi+v4+PhwW7RocTU1NZV5Fg2s3kS4CP0pgEivms1m0DR9yWAwhHK53OBr166ltmnTBlKp9MSgQYMapaWl7Z8xY0anh5G6v78/fv/9971Lly5dnZCQ8PbD4upmsxmenp6QSCSw2Wwo2R6TNKG5ffs29e23324U8Euqqz1dEBKlANy5c8e6eNHi0UFBQb4rVq6YR87zYRPM9es3zIcOHZoHAO+///62kJDQUhnbReIwcz9PT0/P9fX1RUhIiP+8efOc6urt40hMTDQvXrJ4nEwmQ5UqVWCxWDjff//9Rj6f73A9A8C0d6eOB2Dx9vYGALi5uYGiKCQmJqJRw0a933vvvYbkHEuCTOaxsbHa1NRUq0AgsIcuXyAYhoFao6Y6d4qWValSuTBJs/SQIiMjOWPGjpm7atWq6e7u7pDJZLh//z7y8/PB4/GeOEPczc0Np0+fhoeHB1q1alXKrWy1WiEQCODp6WkViUTqso5H8i48PDygUCjKrIlmsVjIz893VH0QudXnBZKZz2Fz0Kt37zYGo7HNiyArhrGBx+UVjqliYLFYUKpVCPDzR0hoCNQqtcPbYTKZEB8fj9GjxqyYO2/u9IqS+coVK/587/33+8TExKjj4+Nx/fp1REREVLJYLFqLxXIlLy/vje6O9rThIvRngIyMjHsTJkyQ2Wy2Wunp6ZnR0dF5x48fNy1fvryzh4fHvlGjRnVnUWWTOmGAgIAAfPvttxO3bdsWeeDAgaEqlSq7PKUkiqKgVCrRoEEDZGRkQC6XF1ONYxgGWVlZGDZs2Ec9evSIIMd5FlntJVuXLliw4D0GDOZ++ukf/n7+To74skF+8957741SKBSW4ODgppMnE93u0mO9fPmy/vjxY3PFIhGys7Px3XffbQ0LC7OTPwMQhc8vvvjiUw8PD72HhweSkpIwfPjwj7t06RLifMzly5dfPH/h/B6RSIT4+HhIpVJ4eXlBo9GAx+PR36/6/ufC3ZYxbvtZ7du3L3H0qFGN3dzdTQzDMC/DRKWQy/Hjqh86Xbx0aVfJZETnUsrZs2dPO3DgwHKKolI8PDzA4XBgNpsfq51qSRBiSE5ORtu2bZ9JbTGRMubxeDAYDI5Wms8bzmLF/ArqQjxrVMQ61+v1kEql6PtWP2RmZcJitcsbq1QqpKWluU99991tw0eM6AyUnwzq7GHbunXrgW+/+647ADRq1AinTp1y69Gjh+/YsWOzDh06pHxKp+aCE1yE/gyg0+kQGRmpbN26dd4ff/xR09fX96q3t7e8TZs2+PXXX3v89tu2mT+t/+mLB9Xgkrj6oEGDOnh4eNzat2/f0KTExLhmzZqVOUkZDAZUrlwZx44dQ3p6OsRiMQD7JKdWq6HX64UzZ85caN/3szManS3v/Qf239uyZcu3UVFRLUeMHNXC+fzK+h7BypUrLx09emSLQCBgfffddxtIpnpZ3dQmTZo0TKPVmA0GA8JCQ1uNGzeujWObwo2279h+Y+PGjZ9XqVIFGRkZKCgoEI4bN87RdY0FQK1WY/HixaMB+/0jYYvc3Fzk5+dj6NChCxs1aiQpeQ7Ovd31ej3GjRs3Mr+goKBps2aO2PuLhEAgwP3793Ht2rXdX3755fnZs2c3pEABTOHChCoioMDAQLzzzpSNX3/9Tfvw8HDo9XoolcpiiVHO7WmBMu9nuUIlZJGp1+sfuxzuQTCbzfDw8EBAQMATehSKL0oBOLTZHXH6ByxKi97lVwsmixlREVGoU6cObt26hdCQUCQmJqJatWqd1q9b93NMt25+QFlhL6qYVZ6ZkYG3J02aR9P0/GbNmiE3Nxdubm6eSqWydnR09M3IyEjlrl27nv8JvgFwBS6eAWiahkajgVwuz2Sz2ecNBoOHl5eXjM/no3Llyjhx4tSyr7/5pvvt27cBlK8bRl6czp07u8+aNSu2WfPmi9LS0lCWC56iKGi1Wnh6eqJSpUoIDAxEYGAg/P39weFwMG/evJ+rVKlSSjXsaYO82EajERMnTOwNAGvWrNnN5XIeuJAgFo3BYMDChQvHAMCYMWNm9ezZs1p53/n+u+8vnz17dqdWo4XFaqV/WL26sEytaEI2GAx4d8q740wmE0NqkRcsWLC5WrVqXOdEuJkzZ35ZUFBw1dfXF97e3ggNDYWfnx/EYjHCwsJCly5dWmYM3zlGv2L58kM5OTn/cDgc6PX6l0J7mqZp6PV6sNlsrFu3brLFYrH7ZSgAlHOPOvt5jR8/oV1EREQDktWv1+sfdVFSLtMxDAMPDw9cunQJKSkpT9Tyt9RBKQpyuRzVq1dHYGDgE5WpFS507LeVfF5zmM1meHl4olJoKPLy8mC1WpGSkoJmzZrNnjd33uHyyBwo7mKPj7+LH1ev7vHPP//MDwwMhEqlApfLFTMM481msy/I5fJsov7mwtOHi9CfMXQ6nbZKlSqJXbp08U9NTa1Tq1YtNGzYAHw+/8CoUaNarV+//ixA4sGlZw5b4VQbGBiIrVu3ftyxY8fDWVlZlUhrSWcrh8/nIzc3FwkJCUhPT0d6ejpu3LiB0NDQhnPnzu2HwiOwQD3TDwB8++23hzMyMq4MGjRoVrNmzTzx0OPa8emnn/5SUFBwWSaT8T/66KP55NyoEh+9Xo8lS5eMBQCTyYRevXr9L7pz50j7tkX204oVKw5m52SfBYC7d+/C39+/4Zw5c/o67/PatWuW1atXzwPslnpubi5IvO/+/fuYM2fOL8HBwazyzqEwRm9ZvmLFYC8vL3h6ekIul78UcUHiuenQoQP4fP65NWvXFj5vpc8FAGQyGSZNmrT6zJkzOHPmDHbv3g2DwQCpVAoOh0MJhAIeUHTtnK8BAPC4vAeeNIfDQV5e3iPJFFcEVqsVUqkUHh4eYHM44HA4pdrDkoQ8LpfL5fPsYYSyroFULLH/zAAUQ86v1GlRIpGIXdY+XoUPAZdr1/w1mIxo2aolIiMjkZ2djbTUVP8u0dGHdu3atTi4kj3B8GENVtavX39+0qS32wkEgv1Vq1aFj48PKIqqtWDBAj9fX987Op3u0dv3ufBIcLncnzFsNhs4HA4EAsEdm80WZbFYwvPz85NYLBYMBsOpDRs2NAvw99/fNSamGwtFMfQiFOlas0Bh+PDhnWrWqHF76LBhAzIyMvYHBgYWa6Pq6ekJq9UKhUIBALBYLIJ3pkw5AzyfjF+KonD79m0sWrSoW2hoaJOFCxcuNZlMsNps5Ro6ZIX/3/lzWLZs2XA2m43333//fHBwMNt5zA4XMQN88MEHqzIyMi76+fmBpum6ixYtWmg2m2G1Wu3XiqJw5coVLFy4sJ+7uzsaNWoEtVotGDly5GnHtaDs8paffPzJNB6PpyXSueHh4Q4vi1QqHdyzZ88WxE1c3jlPmzZtcX5+vlwsFjt6nbu7uzvERF4EiBiO2WQGm8MGzaLxw/erxrRv1+5mSKWQshP7KArt2rVr0KJFi4FKpfI3sUjseG4MBoNNIVdwnfrAl4JGoxEBeGh2vFarfWoxbqvVCpqmERoaCp1OZ0+EK+dpMxgM0Ol0ZoVcgfKyz1VKJSwms8FqscJqscBSeAwGRYI1DBgmLy+fLxQIn3j8LwoURUGr00kpAAKBEDJ3NyQnJSEwMLDbqh9+2NqpUycJ8KB4eVHo4btvv417d+rUmJiYGKhUKmRkZECr1VYJDg5md+zYMenkyZPMiw4/vQlwEfozhlMGPGMyma4FBQV51KtXr77RaEyvUaNGNofDwZGjR7uv+uGHT7//7vv5lUIqgSjJ2VH0MpHkpfoNGggOHzq0b8cff6zftm3bOJPJBLFYDIVCgWbNmkGjUuO/8+cAAHwODzdu3Ph6+vTpmsfV5X4USMUSHD58+IxGpbbUqVWbXrt27Rc6nU7/sAmezWYjKSnplEgkgp+fHxITE3fOmDFjB3H9EnC5PGi1GvOGnzYs5XN5EPIFcHN3M2/evLnYcaRSKfbv339Sr9fr2Gw2IiMjweVycffu3W/eeecdjc1mzwLOzMo0nj57elVERIRD1YzP54PFYoHNZoPNZucOGzbsU5PJpEKhC8Vms1lRGCVgGIYnEomUly5dWgfAUepltVpfaPycpmmYTCbcvRMPg9EINk2T5MlbPbv3aBNRObKdwWgsKGQoB/tRFMXicrkiHoeb6enuAYZhsHv3blgsFlgsFu2VK1e6+vj41DebzaXUWvh8viz+9p1DAKCUK8odG6lNt1osT6WFrFQqxdEjR3H54iVYLBaw6PL3abPawGazvz937lw+zWazbVZrsWA7TdNco9GoTU1Lu2Y2m2EwGBzJduxCrXWaYsFmsWnGjho9RigWeVksludbG/f4YKjC7kAMwzBcDkd28cLFOD8/fwQGBeLK5SsYPGjQt0OHDXsnsDC/p2wyL/Kopaam4tNPP12s1Wg+kclk8Pf3h1Kp9G7YsKF/SEhIxpkzZ+JdmezPDy5Cf44wGAwICgoqaNmyJe/mzZuVZDKZMSsrSyEUChEXF7fgy6++vDBw4MA/WrRowXtQaRsABFeqhPfee2+sRCKptmHDhk/j4+P/at++PcRiMfr064v7qSnIzs6G1WrVp6enfSAUiZ+L/KXNYoXRaITYfrzT9+7dO10R+VA2mw2apiEUCsFisZCTk/MpRVGlvApcHg9ajQZcJ51xk8l04/79+x8RgR0AxURFzGYz0tPTwefz9Tab7QMivEHqzGVSWTECTktLA+CQLj1qs9mOOhOPM1EzDAOJRAKpVIrMzEzHxMVisV6KCcxsNsNmscBaSNtsNhsajeZETk7OCb3BUErExOHtMdu9CoyNgUajIdeTkcvlBxmGOVhW0plAIIC2ULb0QRnsTzu7naZpaLVaKORyCBw978s/NovFysnOzv6GZrNhK/Fc0jQN4ukh95ksQErAlpeXt4Gn1bwwD8zjgIjwGI1G8Hk8RERGIv5uPGg2u/XYsWMXvv32262BB0sWkzfhzJkzth07dvTcsWPHgWHDhiEqKgr5+flu3t7elVu0aHEvKCgor+SC3IVnCxehP0ewWCwYjUYolcpMmqZzDAZDFZqmgxISEq5HRkZCLBYfmDxpUo3//e9/awYNHtyhPFIHiqz1cePGtWjdstWfH/1v1py0tLRFXl5eoGkaw4cPx8WLF/H38eNgs+2iFU+sEV0BCAQCCAQCx2QgFAorpAfOZrNhMBgcQiMcDsdB7s7g8nhgCn/v3IyGdEIjxxEIBI5yK4qiQNM0WCwWOByOo6MYj8eDUCh0TNiEzEiGO9Ef53K5eBChi8XiFyYv+jDQNA0rTTusVhaLBZFIBLFYDDaHUyahMwwDnUbrmPy5XC5sNhssFguEQiGI8ExJ8Pl8cAvj4s+19pthHCp0HO6DRVxIZ0KJRILyCJ0knTovzMrytohEIghEwpea0MkzTFEUVCqV470IDQ0Fl8sFTdPw9fP7cMniRZ/XjIoCYK/8KO/ukXj5jh07/vzyyy+ndenS5Yafnx8uXLiAOnXq1IiMjLRevXr1vFKpNJEeCC48P7iu9ouDFcBtm83GEovFlUNDQzl37tyB3mBISkhI6Dh9+vTvU1NSSiWxEDjLplapVhW7du1a2KZNm8NyubxOdnY2zGYzIiMjUblyFSiUShQUFBSboMuxOlxwwYVXHGQBq9frYbFYYDKZoNFo0KxZMzRp0gRhYWGQSCRgs9nVWrRocWjPnt0OMi9vRiDzUGpqKmbNmrUuPj6+o4eHx41CqWUWh8Op6uvry2vRosVdpVLp0mR/QXAR+osFU1BQcLVXr17KqlWrNr5y5Yonn88Hh8vF119//U5Mt249rly5ogVKS4qSUiNb4QcARowY0emjDz+6LBAIpuTm5iInJwcBgQFQKpXIyMhwSEIWFBTAYrHYLRqnphEuuODCqweyODcajY42ylqtFpUqVUJISIjDg9SgQQN4enoiNzcXVotlwgcffHBt9OjRDqEYMo/Y5aaKuiCQuef69euGvn379vz888/Ha7VayGQy6PV670qVKjXu1atXQUZGxiWlUml7lMZSLjxduAj9BcNms0EoFObo9fobLVu29KpWrVql/fv3U1wuFzKZbP+kSZOqbNiw8TCA8spn7PspfAEjIiPw+eeff9erZ89DWVlZdRISEsBms8FisSAQCODh4YHr169DoVBApVIhJyeHJH+BpmkXubvgwisC0vOdxPvd3Nzg7+/v6ENfp04dexfGwryO1NRUpKenV+3bt++hFStWrq5atSobKLvdKUDmGzt+/fXXI++99141iUSyj8ViYe/evRSfzw8E4MXlcu8KBIJcVxb7i4eL0F8wSO9hpVKpaNq0abyvr6/MZrNVad26NSsiIgJ5eXkZV65cju7fv//sxIQER+1vWSA16yKRCAMGDuz89ddfX27Xrt2MGzduQKPROGJpxFLPycmBSqWCm5sbbt++Da1Wa9fLZhgIBAJwOJyn0izCBRdceDKQfgzkZ5vNBj6f73Cth4aGYvDgwahevTrEYrGjs6LVaoVGo8H9+/chEAimzJ49+/rEiRM7iyXiYla5M0h+DgAkJSVh6LChc2/dutU5PT39vre3N5o2bQqhUFjNarV6ArhltVrzn7dmvgtlw0XoLwkKNZOZrKysa927d8+PioqqEx8f7xEcHIzAwEDs3Llz6eyPP+60devWK0D51rrdDW9H48aNsXHjxi8//PDDw1wut2NCQgJYLJZDR5skiAkEAqSmpoLP58PLywsFBQW4d+8e8vLywOVySdMZR2KZ68V1wYVnC+d3zGKxODqyWSwWmM1miEQiNG3aFNWqVXMI//D5fFitVkdSH4vFwt27d8Fms9suXbr00Mcff/xdZGRkKau8JOjCeWX79u2358+f33nXzl0LpFIp3N3dcefOHc/atWvX6dKlS65cLr/6jC+DC48IV7DjJUOhCz5PrVabmzRpEmCxWHyTkpJutWjRAnfu3Dm6devWunq9fkuHDh0Gh4SEgDTXKEqSsxecEFJngcJHH33UqU/vPp1++fWXz+Lj4z+Wy+U2wKke2GoFl8t11F+bzWaQNod169Z1WO8AHGpbZHIhWemuBDsXXHh8lFwkm81msFgshwIeh8NBgwYNcOHCBaSlpcHPz8+hfkcqEIjOBIvFglwux507d9C0adPFI0eMmF29Rg0AZRA5U3hcqsgqT01JxYmTJ3bs27dvcGJioqVmzZq4ePEiqlevXpnNZtNqtTo1JCSkwOVif/ngstBfMlAUBbPZDLlcrmzRokW8n5+fzWQy1fTy8pIxDAN/f3988sknQ2JiYrqfPXtWDthJmylDYw4oeoGrVK2CBQsWzBozevQVPz+/rpmZmY5Jw7FtITGTeDubzbaX5ggEDvW55ORkpKenIy0tza5CVuhq4/F4dgu+MF7nIngXXCgfJd8Rs9kMm83mcJMDdmL28vKCv78/QkND4eHhARaL5ViEExEjshggi/G0tDT4+vp2mTB+woXPPvusfDJHYQMjqiiMd/7ceVWfvn16zpkzp79MJrMolUp4e3uLBQJBNR8fH3azZs3i5XJ5gcvF/nLCRegvKdhsNpRKpdVoNN6hKCrPZDKFRUVF+V++fBkmkwne3t4Hhg4dGr5gwYJ9BQUF5Za3AcUzWDtHR0cdPHgwduCAAQeTk5PDUlJSQBeqiJUFknhDalYpioJCoUBWVhaSk5Nx69YtZGZmIjs7GzqdDgzseuhqrQY6nc5RQuMieBfeZLBYLKK2B6PR6PB4EUImGhVEK4HP5zu8YQzDQK/Xw2g0ltmljiwOlEolMjMzAwcPHhz759E/42K6xdQHinJryoI9JweQy+X4bOnS2DFjx4R7eHjsy8/Px5kzZxAWFuYbGRlZpXfv3gUZGRm3VCqVK4v9JYbrzrwC0Ol02dWqVcupXbt27bNnz7p36tQpuVq1avo9e/YqNmzY0PPEiRO9Fy9e/FOTJk3cS4rROLczJf/u7e2Nd959N7pW7dq3/vjjj8/u3LmzoKCgwOGGLwuEkCmKApvNBpfLdbTBVCqVYLFYEAqFMBgMCK4UjPCIcPD5fId0JlHgIhn3Lje9C68SHuVZdZJ7dpAtTdPg8/kwm83w9/d3/J6ErKxWq4OsaZp26Nw/6D0h2esFBQXIzMxE06ZN5y5csPDDqFpRQqD87HUCYgBcOH9eNXfevLHJyck7+Hw+GjRoAKFQyLt48WL48OHDOTKZ7DLDMDaXi/3lh4vQXwEUKqcxer3+Svfu3f3d3NyilAplauvWrbJu3roFs8m0e+zYsX8PHjx408QJE3t4eXvZv1fiNSbkTrJY27Rpw2vTps3cg3EH+8XHx8/Mzs4+KJPJKqTuRFzzzipdDMPAZDajeo0a8PXzhUwqw82bN/Hvv/+iUaNGjnMxGo2wWq0ONTiNRuNQZyMtTl1woaJgsVjQ6XTQ6XTg8/lPdaHIoijoDYYSi+QiENK1WCwQCATQaDQwm82QSqUQiUTg8XiQyWS4du0amjRpAj8/PyiVSuh0OqSnp4NIoxLVw4qGq4h7PTMzE35+fl1mzJixpEuXLvXIu1Nez3LnVNr8vHysWbsm9rfffhvh7++f7+fnh/DwcCgUCt9q1aoF+/n5ZRgMhgx3d3fXe/mKwOVyfwVAVvwGgwFisTiTpulLRqPRz2A0VG/YsAGvWdNmEAgE8rVr1/bs2atn11OnTqUDRN2pcB8l3PHObvguXbtEHTlyJK5P796HMjMz26WmpsJqtT6SbKPDuiicXPPz8mG1WsHj8aDX66HX61G5cmXk5eXh3r17cHNzg0gkQkpKCkQikSN7183NDTqdztFByzWJuFASZDFJ3NR6vR4RkREIDQ1Ffl4e8vPzAebJNeMpUNAa9HB3d0fjxo3RqWNHhIeGgQFgtNjFW9RqNVgsFsRiMZRKJapVq4bQ0FDUrFkTY8eORZ06deDh4eHIMZFIJI6sdWKVP8o4SaJcamoqMjIyWvXr2/fQsWPH4rp27VqPoqhyS9FIR0PyNp08eTL7rf5vddu8eXM3kUiUX7VqVdSqVYttNpurms1mHxaLdU0kEmWQxbfrPXw14LLQXyGQmnU2m21hsViXjQZjEBhUl7nJcjQaTQaHw4FcLj+4ffv2Kjeu3/i6c3TncWFhYXiYJjwFuxt+xMiRnRs2atR57dq132/cuHEum83Of1xSJYsQm80GNpvtKJMjiXj+/v4oKCjA/fv30bp1a1y+fBlisRiDBw/Gn3/+CbFYDI3G3viCw+E4JnAAjtI5s9kMxiWE88pCq9U6SiEfRGqk5logEECtVoPP50OhUMBoNCIkJARmsxktW7YEl8vFf//9Bx6Xh2PH/gJsDARCITgcziM9IywWC0aDARbGhpCQSmjRoiW8vb3h6+uLyCpV8N+//8JsMiEsLBw6vQ4ymQy1a9fGtm3bEBoaCpqmodPpIBAIHN4DksjmbIk/CogrPiUlBenp6e5jxoz5dOKECdOjatWyXyOgsP9fOedU+Ivs7Gx8tnTppt+3b38nODhYExYWhho1akCr1foLBAJvi8Ui53A4d0hIQCh8ddvDvolwEforDIqi0mw2W47JZIoCIHN3d78vFAp1NE3rft/++/gzZ89sb9So0f8mTZrUlpBhWa448u8sUKhRowZWrFgxpUuXLsMPHDiw4u7du18qFAqNQCB4IuIkBE/I2GQyORqkUBQFLpcLkUgEAKhevbqj2Ym7uztsNhs0Gg2sViu8vb2h1+uh0WggkUhgYxjodDrHfstyWRJLyIUXD4qiYLLYG7tUqlQJJpMJer0eNpsNUpkMRqMRbm5uDoliT09P6HQ65ObmOty+CoUCUqkUd+/eRWRkJFJSUmAymWCxWNCyZUu7q5vPg1AgxN/Hj8NoNEIul0MkEoHD4YAkdTnHqEljH4qioNVqIXN3h6eXJ2rXrgWpVIqCggIAgEGvh6+vLzy9vBAUGAi1Wg2lUgkOhwMulwuNRgPS9Y9krD/pewPYk9bi4+OFrVu3ntmrV6/3u3btKiXb2B7A5M6Jsj98v+rk3cSERX+fOHE4MjKShAb4LBYrxGKxCKxW622Kol6VVrAulAEXob/6MBUUFFzs0aNHUHp6enWj0ZiZkpKS4eHhgYKCgsNffPHFYavV+r8uXbp8WqVKFT6rsF6dxNOco+yE7FmgEB0dLY2Ojp57/NjxSbt275p1+fLlDcTaftoWMZlUSRawyWSCTqeDj48P3N3dkZubCy6Xi/v37wOFGb/BIZUQFRUFg8EAuVzuKPtxLr0jE7fJZIJQKHxgf3KGYWA2m8HlcmGxWEDT9FM9xzcdFCiYCluPe3p6ot9bb2HAwIH4+KNZCAwIhJ+fH/45dQp9+/TByZMncfPmTTRq1Ah79uxBixYtcOTIEdy4cQNTp07F3bt30bx5c1y7dq1Yhz4AUCgUUCqViIyMREhoCLR6LdJS09C6TRvcuH4dBQUFkMvlkMikjixyPp8PjUYDoVDoCBG1bGVfGKSnp0MsljgWiyQHRKNWQ6vVQq/XO0rIHsfyLvd6ORG5XC5H3bp1h77V760vOnTsEEC2Kb44ZxycTjQpSMDs1KlTpl9//XXR+XPnFwYEBiA8PJycRyDDMN4WiyWPoqg7T2XgLrxQuAj9NUAhkaXVrl0709fXt9qmTZvcq1WrlqhUKg3+/v7IyclZOn/+/C1Vq1ZdNX78+Bh/f/9CQZpy9udE7G3btfVp3bb1T3GxcVM3b9489+zZs3uJatSzqjcnhOw8URK3u06vh5ubG6pUrQqLxQIvLy/w+XxHaZ1Op0NwcLAjYahGjRpo3rw5UlJSSIcp0DTtaEpDJDItFgskEglMJhNEIpFDavNRiZ18j8fjwWAwQK1WQyaTgcfjQaVSgaIohzCPyWSCyWRylAQSLf3XKWZJSNBssyAwIBAenh7Q6XSIiooCwMBoMMLHxwtZ2Vm4du0aZs+ejd9//x2HDh1CcHAwfvrpJ/D5fFgsFqjVakf70wf12WaxWNBqtcjLzQMYe1vXDp06IrhSMC5evAiFXIEaNWsgMzMTQUFBjpi0u7s79Ho9ZDIZJBIJFArFc78PZOEgl8uhVCrRtGnTHiNHjvy0R48eDcvzspXYAwpLy5GdlYXftv9+cMNPG94pKChIrF+/PhiGgUwmEyQmJoYPGjSInZmZeT07O/vl7f/qwiPBlRT3GoCiKBiNRtA0bRWJRDcYhsmxWq3VrFZrFRLDU6vV93/++eduLVq0iD5wYP+/NpsNLJSvCw8UJc6xKBa6detW9+eff94zb+68v/z8/GKSkpIgl8sdE9CzhnNJj9VqhV6ncwhxGAx2L6FEIgGPx0OhdwKBgYHo378/GjVqhPz8fPB4PAQGBsLNzQ05OTngFvbOpmkaHTt2RJ8+fcAwDDp06AA+nw+tVuuo/SXytw8r6yPxUgAICwtDt+7dQBW2nRQIBBCLxY5kLjabDalUCjab7TgXpVKJ/Px8hxuazWZDLBbDaDQiPT0dCoXCMS5C/DRNO0oJeTyePd4stPelf5ELA7PVApPFDIvNisiISKz6cRViunVDZkYGlEql/ZqyaZjNFljMZkjF9oQxmUwGf39/cLlc+Pv723u3s9ng8/mP9LyRxYTVakVOdrbju42bNEadOnUQGhICDw+PYi2FrVarw13+POFM5AkJCfDz9e06f/78o1u3bt3bq1evhiwWq9yENwKSBGuz2XDo0KFLbdu167JuzbquAQEBiR06dEBKSgrUanV41apVq/Xq1StXr9df4XA4Flc52usDF6G/JiCTkclkAkVRuQaD4XpgYKClU6dOtQ0GQ0BiYiKCg4PB4/EOL168pOnnn3/+0aVLl9QAHihKA9hzbWywT3qjRo9qt2fPngNz58494uvr2yUhIeG5EvuDQGLlpL6XZMzn5eVBIpFAr9cjMDAQXC4XwcHBEAgECA4ORkxMDKpUqYJKlSrBYrGAy+XCw8MDI0aMgFgsJnK8MBgMKCgoAJvNhtFoRH5+Pjhce8IVifk3aNAAk6dMhoAvgL+/P7p16waj0YC8vDxMnz4dvXr1glAoxMmTJ1GpUiW8P2MGQkJCoNFo8M8//0AikWDIkCGIiIgAn8+HSqnEtWvXEBQUhEmTJ6N169aoWbMmAgMDIRKJYLPZoNPpoFAokJOTg/S0dNy/dw8J8QlISkx85GoFZ5CFBxE8qQjIM2C22o2+Jo0bo3LlyqhavSqkMikUhc9KWXjUjO9HAfGc2Gw2qNVqaDQaGApbjb5I+WJnIr979y58fHyi586de2T/gQOx48eP78Dj8R4oDAMUf3+vXrmqXrly5SdffPFFfQ6Hc0gqkyIxMRE8Hs+/Q4cOdQMCAmwWi+WqWCzOMRgMr5U3yAUXob+20Ov1lkqVKiU1a9YsRalUejEME1m9enVhs2bNIBAIUFBQ8MWUKVPC33///XU3btwAULLhC+XQeXYWpmEACAQCjBs3ruO+ffviFsxfcMTX17dHYmIi5HK5/ZsvwQThPIETS82ZoGQymcOVLxQKIZfLHcp2RqMRZrMZ9erVA0VRqFq1Ktq1a4fMzEw0adIEGo0GwcHB6NatGwry8qFSqdC6VSvwuTy0atUKnbtEQ6vVQqvVIj8/37EgcHNzg1AodIQTyrLQq1evjn79+jkIXalQIikpCYGBgZg0eVIpQrdardBqtVAoFMjOzkZ6WhruJd9DQvxdJCclOwiLXJOKXjsGDHKysx1tOUnFAqm5NhgM0Ov1oAqTEUlZpdFoBAD4+frhf/+bjR9XrwGXy0V+Xj50Wt0jjeN1hnOMPDExET4+PjGLFi48HBcXd/Dtt9/uKBKJHAtpoLQwDFX4HyHyW7du4aMPP9w8/b3pEQUFBYsBICoqCpUrVxbZbLbIvLw8z+bNm6eEhITc02q11sKF/3M8YxeeB1yE/pqCxWLBYDBAqVQqFArF1bfeektfuXLl6ikpKZXZbDbCw8PB5/Pz/vnnn/Fffvllm40bNx7Oyspyas/KlJk4S4RpGNhd3JMmT+q4c9fOvZ/O+fSYv79/73v37kGhUAB4eSdu51aUNpsNJXWpyc8qlQo6nQ48Hs/h0m7bti3UajWCgoIQExODtPspCA8LQ/fuPcAChdy8XOTl5hXrSkdyDQwGQzGCtdlsMBgMxXrQ6/V65OTkFHO5A3gilztJNiQeDJqmwePzwOFwQBcq94EquhYqlQoqhQo1atbE+o0/oUevnsjOzna06+TxeJBKpXBzc4OtkOg5HI5jcSIWi9GiZQs0atQQSqXC0brXhaJni/RF8PPz6/Hpp5/+uW/fvgPvTp3aSSqVOoj8QYKtjjh5djZ+/fXXw998802HM2fOjqCAXE8vT6LpHlalSpXq/fr1MykUiutKpbLAYDC47sVrDNedfQNgs9kgEonSzWbz5cDAQGvHjh2rms3mSiEhISRh68Qvv/wS3apVqy6///bbSYvFUkyUpiScFecYACKhCCNGjmi7devWXbNnzz7j7+8/NT09nUfc0C8rsVcEzsl5gH0ipmna4XJn0TTEYjF0Oh0sVstLea5kQUGS/DQaDdJS0pCflwe1UgWjwQDYGPB5PHh6eiI0JBQx3WPw7rSpaNKsKayFiYmenp6IiIhAo0aN8M6772L27NnIzcmBRqNBzZo1MXPmTHTq0hl6vR4WiwV5eXmwWCwuAkHxRWJ6ejrH39//7TmfzDm5ffv2vWPGjGkvFosBFFnkZbVGBori5FarFX/88ceZjh07xmzZsiWaoqi/2Bw2fHx8YDKaKnXu3Ll6QEAAzGbzRaFQmOKKk78ZcGW5vwEgdd8Wi8UaGhqa1LJlS+HBgwcjKIqqxzBM8t9//62IiIiARCI5NOt//zt06NCh/kOHDfuiXft2ocSl96BkHPIbPp+PAQMGNO3Xr1/TEydO/O/27dvfX7169bvU1FRF7dq1X8uJvaRr/2UG0eFXq9VQKVXgC/gQCgQQikRgs9jgcXnw9PBApZAQ+Pv7Q6VSISszy9H9CwA4HE65FrpMJoOAL3C451/26/E8QPoWpKamIj093a1atWqT27ZtO7ldu3aBpIKClJE6o+TfnXNc/j7+d9q237Z9dPz48S0ymQwURWHnzp3w8vISBwcHh8nlclZ0dHSCWq3WarVaR8KfC68/XIT+BoFkvCsUCh2bzb7GMIw3i8XytVqtbmFhYdn16tXT37x5E6lpadt/+OGHPRcvXpzZokWLGU2aNHEvr2TGeeIhP9E0jXbt2vm1a9duYZUqVWZ6eHj8cP/+/Z8yMzPjy+sY5cLzAXG501y6XJe7VquFRqMBIQvn7xJvRXkxdLPZ/ALP7uUBIfL09HTk5OSEvfXWWxOGDB48uWOnTiUEYUrD+Z1yLKhtNpw/d05x9t9/V5w/f35Zfn6+vnr16oiMjEROTo4wJCTEv0mTJuz79+9nBgcH5ykUChgMBpfS2xsGF6G/2cjNy8vL7devXyVfX99aqampJj8/v7s0TWsZhjElJiYuzsjI+O769evv1atbb1rd+vXc2E5WBUisvQSc69g7dOgg7dChw0cXL1786M7tO3svXbq0Kj09/ZBKpbLvwUXsLrwmIM+yRqNBTk4OqlWr1rlx48Zvt2nTplfDhg0d7qkH15EDKBHu+u+//5Q3b95ceefOnRVarVap0+nA4XDg5uYm1Gq1kQEBAcIuXbpkKZXKxKtXrz6DM3PhVYGL0N9wFMbXUzgcTobZbK5qtVprURSVl5mZmZyVlWUNDQ1VBgcHzxs/YfzK6M6dpw8eMmRarVq13Ios9gfsu1CSkgWgfv36qF+/fs927dv1/Pvvv88nJCRsv3z58urU1FQlyUB3wYVXEcXc6mlpknr16k+Ijo7u3759+yY+Pj6O7ezvyoPJ3Nm1fvDgQeV33323Uq/Xr+zTp48iNTUVCQkJsNlsrMDAwEqFKm86Ho93nqZpCympdOHNhevuv+Eg8XWr1WqhKOoGwzA0gFCZTFZZqVSq/vnnn6zc3Fxbfn6+ggHmjR8/fmXr1q2njxk9elr1mjXcHh5jt4vMkm5Pfn5+GDhwYEObzdbw2LFjH3t7ea9WKpW/JyYmng8KCoJYLHZZ7S689CDPqFqtRkpKCry9vev07dt3SP/+/Sd27NhR5vwMPwqRMwyDv/78U7lm7dqVhw8fXmm1WhVRUVHYtWsXbt++jaCgoEB3d3cxABPDMJcoirI46U88m5N14ZWBi9BdKAmrRqNJDA0N5XXu3Nl/165dlf/55x+1Xq/PuH79OrKzsxW5ubnz/j5xYuWx48en1q5Ve2rLVi09WRSpWS8/wceZ9FksFnHHz0xJSZlZpUqVEwkJCXuSkpLWZWRkqEiHNtck5cLLAlItQEoIKVDiiMiIsR07duzdqVOntqGhoY5tH+5WJ7XkdjAMg4sXL8p//+33b77+5uuVAoFAERwcDIqikJCQAIFAENi2bVtJr169jEeOHLl/7949g0wmezYn6sIrCxehu1AKhXKZxqCgoHtDhw7lR0VFBZw9e7bGlStXFAAy7t27B7FYrBCJRAuuX7++/OjRo5NatGj+TvsOHSqx2WxHc4gH6Vs5x9krVaqEMWPGtLbZbK2PHz8+/9y5c+sPHDhwICcn5ziHwzGbTCYIBILncu4uuFASTpoOyM7Opm1Wa7uePXt2bdy48bj27dtLncNFFSFyZ7e6xWLB8ePH08+ePfudwWBYlZqWqpLJZAgKCoJSqQSXyw1s3Lixe/PmzQ116tRJ8fDw0JEqAhdcKAkXobtQCsQSUSqVKCgoMISGhiaFhoaKmjVr5nPp0qVqN2/eVJ0+fTozPDycCQ4O1mRmZS775ttvV/zy668DO3bsOD46OrqNr69vsdas5aGk1d6+fXtx+/btp40YMWLa9evX006cOLE+KTHpl4SEhAS1Wg0ulwtSs+uCC88KLBbLoa1/9+5d+Pr6hvj4+Izu37//yDp16oT6+/s7tmUcf1Y8Pp6bm4u4gwdPHj1yZL1er9/i4+NjJgsHmUwGi8USVL9+fUm9evVMlSpVukdRlKagoAA0Tbs8Vy6UCxehu1AunIndarVqw8LCkuvWrSv866+/fHft2lXVbDbrs7OzM93d3U01atSw/Pfff7/OmDHj1927d0dPGD/hvYDAgOjatWvjQXF2QvrOulgUAH9/f/j7+wd16NBh7v379z89derU8QMHDvyZl5e3Nj4+Poc0N3El07nwtOBM4vHx8ZBIJN4R4RETuvfo3q5ly5ZtQkND2c7d95yfZyLFWhapOxP59evXkZGRcXjdunUr/v3334M1atRAzZo1oVAokJuby5HL5f7169cXN2zY0BgZGZliMBi0eXl5oGna0QXQBRfKg4vQXXgonImdy+XqpFJpss1mE9I07c9ms2tbLBaDv7//PYqiNBaLBVqt9tC169cOrV23tmZgYOConj17vt2uXTtx8cnQjuJ17ES3uggsFgthYWFUWFhYu0GDBrW7e/fuJ2dOnz61/8CBv7KyslbfuXOnQCAQwMPDw0XuLjwyWCyWQ+42KysLIpHIPTwsbHz3Hj06NG/evHXVqlX5HA7HsX3JRamzohtTWNWBwgRQAqvNhhPH/9bu279vdXZ29ubGjRtfzsjIQEhICHr16oX4+HiR2WyuxOPxeBqNRtm0adN71atX16WnpzsaDbmI3IWKwEXoLlQYJTq66QAkAuBRFBVhNpvr+Pj4yGUyWarRaFQXFBSgUqVKNw4cODBz7Zo1S0aOGjWpb9++o+rVq1fZ29vbUWf7sEig8wTK4XBQo0YNfo0aNTqOGDmy482bNz/5559/Thw/fvy02WRal5iYmEnTNMxms4vcXSgXhMTVajXkcjnYbLZvSEjI+LZt2zZr1apVmxo1aohIa12gYnFxx74BkCYIeXm5uHz5StKuXbvW//LLLz8GBwcXREdHIz09HSqVCv7+/hJvb++QmzdvulEUlQ/gNpvNNqhUKqhUKheRu/DIcBG6C08KI4Cbubm5dOvWrYObNGnid+HCBe/8/HwNi8XKoSgKAYGB8szMzCUrV65cwuVyuwzoP2BClapVYurVr8ejWSWt9orF2zkcDurUqSOsU6dOl/Hjx3e5d+/eJxcuXLhw9uzZwxSw8+7du3cUCoUxKirKNTG+4SAeJrPZjMzMTOh0Om5wcHDl0NDQ/s2aNevQoEGDRmFhYbySJF6eC90ZjJM1TsHe1e/ypUvmxKSkuN9///1Hk8l0iMPh2Hx8fGAymSCXy2Gz2byqVasmadiwITcrK0tHUdRtAJZneQ1ceDPgInQXngpsNpvVYrHca9euHbKzsz2ys7P9+Xy+n0AgyI+MjMxu1KiR5e+//0ZBQcHBa9evHVz25TL/mJiYCe3bt58YFRXl7+vr67BuHmQRlU60o8DhcFC5cmVu5cqVm73Vv38zpVw+NyIyMjM1JXV9VnbWHaVSuefu3btqHo/nst7fEDhb4Xfv3kWTxo0lVoulx6BBg6qGhIaO7dG9e6C7u3sxIRbnyozymqMUO4bTNjk5Obhx40b2sWPH1hw+fHh1ly5d0vPz88Hj8f7f3plHR1Hg+/5b1ftS3ek9e9LBSDQhrIHExASigkOAQdRRhEEHt5l7xzkziHqed7wTN5Y76nOec+59jh4G7qjj8/GM6CgQQIKIC4tsIWQka2ft7qS3qu6q6u6qen8kYToBFByccanPOZX0UqequqtOffu3Y86cOUgkEor29vZ0giBsiUQinpOT46uqqgo0NTVd7o8u8z1GFnSZy8LYzPHh4WHwPB9gWTYwc+ZMs8vlsn/88celer0+odfre61Wa1ChUCAQCAwEAoHHf//7368XRfG6W26+5Uc5uTk/qqqq0qfeZMcspQsjjXPbKxUK2Ox23HXXXRkAfh0Kh9HR3k67890fHfnsyCcEQTR0dHR0WCwW2mw2Qy6J+24wliGuUqkwPDyM4eFhatasWdm5OTm3LVu2bPbs2bOrCgsLqYm1218eE8c4S31iydknn3wSa29vb2hoaHhNo9HscTqdvM/nA8dxsNvt4DjOotPpsmmaVi5dupS2WCw9Bw4cCHIch1AoJHd2k7msyFeTzNfC6ASusNFoDCcSCR3P89k6nc5mNpszu7q6whzH9U6aNAlerzceiUS2f7D/g+0NDQ0PLliw4P5FdXXXz54zZ16+200oxtX4AhgV+NTs+HH7nTDYIs1sxowZM6gZM2YsSCSSCxiG/k1jYyOt1+tfb2xs7Nfr9a+0t7d7zWYzbbfbQdO07KL/hjPmQqdpGslkEj6fD6FQiCosLHRwHLdq2bJlGSzLLr9h/nyKoiioU5LagIuLiafWXBD4m9ALoghPdzcOfnpw37vvvdvYuHPni7cvXz4ci8UAAFlZWQgGg+jo6Mg0m81pCoUiyfN8PJFItBkMBlalUsk15DJfG7Kgy3wtTEigYwmCOCOKImiadrjdbkddXV0pwzCCw+HwDg0NDR06dAh5eXmB1tbW9d3d3evf37v3CqvVurKmpmbFjBkzrnClp49LOLqYm/LEdVQqJSwWC2677TYKwL3X1lRDEsR/b2xsZDQazZ+bTzYPOByOBr/f39HW1kZzHAeGYcBxnOym/ydCkiR4nj97Ltra2uB0Oim73Z6bSCRuXbZsmZPn+ZU3zL/BoFAoybQJVviXNTkav+65ljgA9Pf348SJE5379+//72Aw+Fpra+vn0WgUKrUaWVlZYFkWgUDAFolEHIsWLVLm5OSIXV1dflEU/QRBnG2xrNVq5R+LMl8bsqDL/ENhWdafn5/vd7vdxqNHj6brdDq7Xq/PGBwcDN56661Dra2tXCwWw+nTp9umTJlS/8wzzzzu8/pqHv23R+fZbLZ7SkpKMrOyssbdcC82C/kc691kBgBiVODvq72uFv/yr//ym2PHjtHz5s77zGq1NKWlpfnVavV/d3V1oauri2ZZFjRNg+d5WeS/BsbEm6ZpsCwLj8eDzs5OanS62EqH3eH69b/9utpd4J71wgsvUCqVCiaTadw2xgR8ohfny5LcJor40PAwdmzfPni6peXlvU1NTRRF7Z08ebLY3NwMnU6HjIwMFBUVqSORiEOv11s5juMDgUCyqqqqFwBz+vRppCbaych83ciCLvMPZSzWyfM8o1Qq28LhMIqKipzTp0+3MAxjz8rKYk6dOhX5/PPPfffeey9YlpVOnz7d5PV6m1599dWnh4eHr62trZ1XXFx878KFC53mtDSQxN8n7sDIzd5EjQhDbW0thVrUiJJUc90N1yMSjqw/dOgQrrrqqgZLmqXTarV6VCrV/x3oH0CYoWmf1wdBEMAnE7LQXyTnc5vTUQb9/f2USqWC1Wq91W63527YsCGnsLDw1rKyMpjMZoqiqHHnG7iwBS6lhGdS379QTFyChHAojO3btw+1nD79h+NHjzZ99NFHHyiUSt7tdsPlcmHq1Kl45ZVXUFxc7Jo0aRIlSZJBEARWEASvKIo+pVKJUCgErVYrXwcy/3BkQZf5pzIaa/cZjUZfMBhUchxnys7OziooKHDFYrFkUVHRsCRJPq/Xi4yMjHggENizadOmPZIkPfW73/1u9urVq2tdLtfiaVOnTcnOyVapvkK8FBjfqW4MkhgReRNlorKzswFgVVIQcNvtt4Gm6ec7Ojqwft26VovF8l40GoMtzXJEoVQ09fX1gYkytM/nOyta38fYfKpoG41GSJIEn88HJhrFwMAAxXEcnC5XVZyPz/nh0qWoqZl74+zZs69evnw5TCYTpTfooVSce4u6lLrwiWc1tcQMABLJBPp6+5LHjx9r8fv8DZv++Mcmj8fzKQB2cuGVuOaaSgiigIyMDOTm5joZhrEvWbJEmUwmEYlEerVarYcgiPhX/5ZkZC4fsqDL/FOZEGtPsiwbKCoqCkyaNMnY0dFhoigq3Wg0ugRBYNxuN2swGgYzMzMBgDty5MgHzc3NH7z//vv17737bg7H86vn1tRUls2eXZ6Xl0eZzeYJFtjFx1KBc2uRSRBQKhQwmUwwmUxUVlYWrr322jIAZRE6gnvvvxfDw8N0R0cH1j29ri0nN+ftKMPA5XJJiWTyDY7jev1+PzweDwDQfp8PABCLxUDTNAB8ayz8VLFOJJMYSwrz+/0AgO7ubsrv98PlcsHhcGS6XK4fRZmoYunSpSibNWtx2ZzZhZMnT8aOnTsoQRDOcZuPcann7JzjPE+NRDgchsfjoQ8fPnxw3759H+p1uj+GwuFuh8OBwcFBzJkzB6IoIj09Hbm5ua54PK7r7u42qNVq0u/3B6urq8Pt7e10a2srtFrtVz42GZnLjSzoMt8oxlzyoVCIUalUjCAI/YlEwiKKokatVmdIkuQsLy/nSJKMTJs2bbChoQHFxcXo7OrqEUXx8Z8/8ACeffZZ6uWXX16Wnp5+ZWZm5j0LFy60m9PSSI1aPaEs6eLEYkzUU0voUmO0BHDWXU8ZKSo/Lx+182qnA5jOMAwWLqwDz/P10WiUttlsyMvLw6lTp3a5C9wn6UgEVqsVLpcr0N3d3aBQKEJDQ0Pwer3weDxoa2ujgRGhHOs1znEcYrEYotEoGIY5G29mYyw4lgXP80gmk5hY0jeGgiChUCigVquRiMeRTCYhCAIAQKPVIBaLgeM4xONxkCR5VqTb2tqgIBVUWloaAoEA1CoVHHa72WgyLbNarVY6QmPx4sWYMmVK8dVXX73A7XYjOzsbBw4coDQaDURR/MLBOiLGGqdeXI/0C52tiT+H+HgckXBY2r59+/DAwMBLXq/3TFFR0dYHH3yQrqioAEEQsFqt2LlzJ+68805oNJp0URSpnp4eDQBFMBj0SZIUEQQhoFKpEAqF5ERJmW8ksqDLfBsIjlryg6IoWgOBgMZms2WmpaXZKIoSGYYZttlsIafTGXe5XPjwww9pjUazZevWrcjPz3+yu7s74+TJk3dWVlYWlpaWLp4+fTpFURRUKtU59ttEd+6FZrunPr6Q1JAgzgqYXq+HxWKhsrOzUV5eDgDLACxjolFcd931EEQBsVj02Vg0xkYiEaxYsQILFixAMBjs9vR4dhVfXRwJBoMwGAwwmUzgWHakSQ5BJPV6fZCNxXwxlu3lYuwwx/PRRCIRF0e6/YiiNJYUBiiUSlKpVCqUSqVKo1HrdFqdXafXZRv0hnSD0ZhmtVqUVosFJpMJBoMBwWAQixYtgttdQOXm5l5vsaS57XY7XE4XbFYbDnz8sVar1apIhQKCkITR8OWT8L7IZX6+dyRcuGvb+SzwRCIBhqZx9Ngx+uSJE+8d+Oij1qlTp77S2NjY197ezt54441oamrCokWLYLFYMDg4qIxGo1aXy2WhKEqVSCRUwWDQK0nSsCAIge9TmETm240s6DLfNgKj4j7A83waAKUoihkWi4VyOp1UWVlZ3yOPPCLV1NQMVVdXo6CggNu/f3+nWq2uX7NmDVasWEE9/PDDk+bOnbs0MzPritLSKUvKy8spQRSRNsFFD1z8aMzz8WWxXhIEjAbD2ecGvV4JOygAmDJlytjLJaMLorEYriq6CpIkQZKkv9UzSxIEQYAgjszJFkUxLgiCIAgixJSiZ4IACIIkFAqSJEkFqSBJFUGShFKpADnagpcgCJAkAYIgQRAEEokEppVOvayf+9I5fxLbGBE6gmRSwOFDh+iWlpb3BvoHWt/f+/47JSUln2/evJmuq6tDU1MTKisr4XK5EAqF0NTUZN+4cSPh8Xgyh4aGmCuvvNKQm5vb19bWJtrt9qAs4jLfRmRBl/k2EwIAgiCGksmkIh6PO9rb26233347CSBz8uTJjMfjYU0mUyA9PZ0vLy8HRVF0f3//sUAgcOy5557DE088QZ04cSK77cyZ2xYtXpw2MDDwk3nz5hEOh5MyGA0Ya2yTagd+Wc/5i+V8mfYT3c0YneBFADDo9Re76ctWKzXWlCX1SFP9EpfmDr8U/uY6J1L+CqKIKMNgaGiI3rt3LzIzM7ccO3p0ePOWLW+WlpZ2bt26lb7nnnvQ19eHmTNnYs6cOcjKysLg4KA6kUjYampqtK2traY77riD7+jogCiKg4lEIqBWqxMGg0Fu+iLzrUYWdJnvCgKAwXA4PFhdXY3e3l5Xf39/kuO4vJycHGUoFMqaOnXqmY6ODl1xcXGfwWCQZs2aBZVKRW/btu30ddddV//8889jaGjo13v27CE+/fTTpevWrZsUCASmufPdtTNmzSR1Oq3BoDdgZAzsuRbcV7VML9T1bsTVPH4s56Xs4Xx12BOfp+YCpO73fNtIXV/CeDG/0Ge4GM5ndQOAIAqIRmPgWJY98tlnya7OziabzfbZo48+2lVeXv7//vrXv8Jms9ELFy5Eb28vFixYgMrKSigUChQVFeHMmTPZJSUlLMMwhTk5Ob3xeNzV39/fVVBQEMvOzvbu27cPFEVNTMy85OOXkfmmIAu6zHeKsTpgjuO8JEmCIIjh0Ru1NDw8TObn5+eUlJRwe/bsubKysrL15MmTBqvV6k0mk3EAWL58OfOnP/0JarX6T319fVi7di0eeughqumDfcrt7753Z/3j9Wme7m630+W6aebMmcjMzKRIkoROrz+nPjqV1ISvL7Nqz9dPfOTxpfFF8f/U5190LOfLGfii9yaK/NgeLiTaACBKEthYDKIkYmBgkD5y+DC8Xt+2PHde+xP1j9M/+MEPtkiSxG/YsIF+9tlnoVarcfz4cfz4xz/Grl270NfXh5tvvlkVCoXSS0tLGY/HU7RkyZIzzc3N2YFAoMNgMPTG4/E+vV7fm5J0KfdRl/nOIV/RMt8XelmWhdvt9l9zzTXKt956yxOJRCSlUpmbl5fHe73eK6qrq9udTqeCZdnkY4895tu0aRMqKiqQn59Pb9q0CWqN+vnBwUH8as0aFBcX//ypp57CHbctL54yrfTGu+66C83NzVMcDscNpaWlcDqdOq1Op1SQJDRazTn1z+cfOEOM1sNLF7HuP5aJ1vnfXj3XV5F6vKnucpphxqoYRL/PFz1x4gT8fv+e0tLS41v+uBnHjh5r/M0T9Sc3bNiAEydO0P/5v/8LapUKjY2NWL16NSoqKtDQ0IC1a9fiySefdNhsNnVVVVWip6en0Gw2nwkGg7nRaLSFYZieysrKcDQa/aSvrw+GlDwFGZnvMrKgy3xvSLHOkkqlshcACII4EI/HoVKp1AzDRKPR6NVms5nV6XQqv99fsGDBgiORSMTm8XiYp55+Ovj6639G9bXVWFi3kN61axd6ens+mVE285O+vj488MADmDF9BvXwIw+jvr7earfZVq6++25VWVkZdu/a7TaZTTdNLipCdnY2KKPRoNFqSYVCASGZhMFgGDcEZIzx4njxwv5l1vxX+YlAjJPn8VtgolEolcoR1zXPSzTNMH19vejq7ETzqVPbCgsL2w0mI37/uxeSfr//1fr6+qFnnnkGhw4dol977TUoVUp4ejzYsWMH7rjjDphMJvyfP7+On6xejcceeywtGAyaZs+ePbRjx44ZOp2uOy0tzRSLxYwMw5xSqVSeeDzuIwjCBwBKpTIol5bJfB+RBV1GZoQxgT8oiiJ4nqe0Wm03TdOS0+nMtdvtgxqNhhoY6C+4Zdmth8vKyvT19fW6VatW9dbV1QmPPvooamtrcdNNN9GHDx9GZ2cnbTAYnuZ5Hr29vfjVml9BpVL9/IknnkB1dTXuu+8+u0aj+dH111+v++GSJejs7ELL6ZacK664Yondbtc4HA44HA5odTqoVSqNTq9XkyQJkiBAkCPDPgiM/BclCUqlcpzL/1IEW5QkJJMJkAQ5kkGPkSx6SZQgShIkUUSMZeOJeJxnWRb+IT/8Pj+Gh4YTbW1n3i4uKenOz8/Htm3bsHv37ng8Hn/jpZde8h44cADP/sdvMej30T/84RL85J67EYvF0NHRgYMHD2LVqlWgKApPPvUk1q9bD0EUFS+//HL2O++8w4XDYWbr1q1larW60263kwCyaZoe0mq1Hp7nw6Io9qTEu5nLdhXIyHyLkQVdRub80KMLCII4IIoi4vG4WafTd4XD4WQkEnFZrVab2Wz2qdVqt8fjcd5yyy2fVlRUaDdt2mRRKBTen/3sZ9Genh5s3LgRc+fORd3ChXQymcQ7b7+Drs5O2l1QsDEWi4EgSbzZ8CbefPNNkCSpq6qqUtbW1uLuu+/G8889h//1wgvGObPKaoxGqigzJwt5ublwOJ2w2WywWixwpaeDIAhs2bIFiWRCSRkplVqt1igVSi1BEhqSIFQAIEpSAhLiyWSC5eNxnmbohEqpFlbduUqSCMA3OIhgIIihoSEM+f3o6elBZ3sngqFga3PLqf0P/OsDkV+u+SUadzZi7969OLD/QyEhJGM333wzHnroIUSjUcTjcXS0t+OthrdgNpux9uGHse3tbTh48BCmTZ+B+++/H7/4xS/0u3fvTv/DS38I+fz+6P987rlylUo1bDab2202Wz5N08FwOBzS6/WdiUQiJIpimCCIztHz4vlnXRAyMt90ZEGXkbl4wqMLAJwcG4mZTCb9RqMxFg6Hk+Fw2AJg0vz585mSkhJNS0vL1V1dXcLKH6/8dOXKlbqNGzambd26VWMxp/WvW7+e83m9ePmllzCasY377ruPtVgs4Hkef/nLX3Cq+RTi8Th97Nix16dNnw6e5xGhaag1mrPZ2VqdDjRN47e//e1X+lDzaueBMpvgHxpCJBRGOBxGhKYRHU1U6+/vB8dxONl8Am+//TZIkkRdXR0qyivw4h9eREtLC1588UVUVFTghvk34Kf3/VSzZfPmrFtvuYV/6H88Eg5HwtEP9384OxQMahbMn988f/58oqurqyASjnRFwmHaaDR2JZNJNh6PswRB7Es5tO6/83zJyHyvkAVdRubvxz+6AEBHOBzuqK6uRnp6ui4ej3sMBoMYDoeJwcFBo1qtzrLb7eZwOBw0mc2KYCCQwTBMbiQSSVAUdXjFihWJ/v5+/c6dO/XvvvuungnTolFr8NKxKPvLtWugVWvQ2toKn8+HM2fOIBgMIhQKgaZpuN1ucDEWHMeB4zgIgnC2sxwARCIRREdj3RqNBhqNBnq9HvWP/TsoioLZbIbFZoXdbofL5cK0adNwbU011q55EG+88Yauu7vbuXnzZkVlZWXsxhtvjGVkZLCvvvaqIhKJzKJpWqNSqTwmk2lArVaTZpOpQK3R0D6vTwgGgzGtTtubSCQUGRkZbHV1NXv8+PHdKd+fLNwyMpcBWdBlZC4zKaVzLEmSqS5iLwDv2GATjmXVgiAENBpNUq1WizzPJ71er4phGJNSqbSnp6c72iJ00kAZ6Ht+ei+fm5dr8A14jSRJGgVB0PM8r49Go4ZQKEREIhGGJEm/QqEIAIhJkhQXBEEMhUOIRqMARiaLkSN93EkAKgWp0JMkaQkFg+lCUjAqFQpRbzTEBEGIkiQZ02g0DEmS0cVLFkd3Ne7SkQTpTk9PVymVSj/DMMNerzchCEJCrVZ7NBqNQhCEMMdxcUmS4gRB7J7wtfTJJWMyMl8v/x/APLzV85QtegAAAABJRU5ErkJggg==';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var leafletSrc = createCommonjsModule(function (module, exports) {
/* @preserve
 * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */

(function (global, factory) {
  factory(exports) ;
})(commonjsGlobal, (function (exports) {
  var version = "1.9.4";

  /*
   * @namespace Util
   *
   * Various utility functions, used by Leaflet internally.
   */

  // @function extend(dest: Object, src?: Object): Object
  // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
  function extend(dest) {
  	var i, j, len, src;

  	for (j = 1, len = arguments.length; j < len; j++) {
  		src = arguments[j];
  		for (i in src) {
  			dest[i] = src[i];
  		}
  	}
  	return dest;
  }

  // @function create(proto: Object, properties?: Object): Object
  // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
  var create$2 = Object.create || (function () {
  	function F() {}
  	return function (proto) {
  		F.prototype = proto;
  		return new F();
  	};
  })();

  // @function bind(fn: Function, ): Function
  // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
  // Has a `L.bind()` shortcut.
  function bind(fn, obj) {
  	var slice = Array.prototype.slice;

  	if (fn.bind) {
  		return fn.bind.apply(fn, slice.call(arguments, 1));
  	}

  	var args = slice.call(arguments, 2);

  	return function () {
  		return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
  	};
  }

  // @property lastId: Number
  // Last unique ID used by [`stamp()`](#util-stamp)
  var lastId = 0;

  // @function stamp(obj: Object): Number
  // Returns the unique ID of an object, assigning it one if it doesn't have it.
  function stamp(obj) {
  	if (!('_leaflet_id' in obj)) {
  		obj['_leaflet_id'] = ++lastId;
  	}
  	return obj._leaflet_id;
  }

  // @function throttle(fn: Function, time: Number, context: Object): Function
  // Returns a function which executes function `fn` with the given scope `context`
  // (so that the `this` keyword refers to `context` inside `fn`'s code). The function
  // `fn` will be called no more than one time per given amount of `time`. The arguments
  // received by the bound function will be any arguments passed when binding the
  // function, followed by any arguments passed when invoking the bound function.
  // Has an `L.throttle` shortcut.
  function throttle(fn, time, context) {
  	var lock, args, wrapperFn, later;

  	later = function () {
  		// reset lock and call if queued
  		lock = false;
  		if (args) {
  			wrapperFn.apply(context, args);
  			args = false;
  		}
  	};

  	wrapperFn = function () {
  		if (lock) {
  			// called too soon, queue to call later
  			args = arguments;

  		} else {
  			// call and lock until later
  			fn.apply(context, arguments);
  			setTimeout(later, time);
  			lock = true;
  		}
  	};

  	return wrapperFn;
  }

  // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
  // Returns the number `num` modulo `range` in such a way so it lies within
  // `range[0]` and `range[1]`. The returned value will be always smaller than
  // `range[1]` unless `includeMax` is set to `true`.
  function wrapNum(x, range, includeMax) {
  	var max = range[1],
  	    min = range[0],
  	    d = max - min;
  	return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
  }

  // @function falseFn(): Function
  // Returns a function which always returns `false`.
  function falseFn() { return false; }

  // @function formatNum(num: Number, precision?: Number|false): Number
  // Returns the number `num` rounded with specified `precision`.
  // The default `precision` value is 6 decimal places.
  // `false` can be passed to skip any processing (can be useful to avoid round-off errors).
  function formatNum(num, precision) {
  	if (precision === false) { return num; }
  	var pow = Math.pow(10, precision === undefined ? 6 : precision);
  	return Math.round(num * pow) / pow;
  }

  // @function trim(str: String): String
  // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
  function trim(str) {
  	return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
  }

  // @function splitWords(str: String): String[]
  // Trims and splits the string on whitespace and returns the array of parts.
  function splitWords(str) {
  	return trim(str).split(/\s+/);
  }

  // @function setOptions(obj: Object, options: Object): Object
  // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
  function setOptions(obj, options) {
  	if (!Object.prototype.hasOwnProperty.call(obj, 'options')) {
  		obj.options = obj.options ? create$2(obj.options) : {};
  	}
  	for (var i in options) {
  		obj.options[i] = options[i];
  	}
  	return obj.options;
  }

  // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
  // Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
  // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
  // be appended at the end. If `uppercase` is `true`, the parameter names will
  // be uppercased (e.g. `'?A=foo&B=bar'`)
  function getParamString(obj, existingUrl, uppercase) {
  	var params = [];
  	for (var i in obj) {
  		params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
  	}
  	return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
  }

  var templateRe = /\{ *([\w_ -]+) *\}/g;

  // @function template(str: String, data: Object): String
  // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
  // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
  // `('Hello foo, bar')`. You can also specify functions instead of strings for
  // data values  they will be evaluated passing `data` as an argument.
  function template(str, data) {
  	return str.replace(templateRe, function (str, key) {
  		var value = data[key];

  		if (value === undefined) {
  			throw new Error('No value provided for variable ' + str);

  		} else if (typeof value === 'function') {
  			value = value(data);
  		}
  		return value;
  	});
  }

  // @function isArray(obj): Boolean
  // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
  var isArray = Array.isArray || function (obj) {
  	return (Object.prototype.toString.call(obj) === '[object Array]');
  };

  // @function indexOf(array: Array, el: Object): Number
  // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
  function indexOf(array, el) {
  	for (var i = 0; i < array.length; i++) {
  		if (array[i] === el) { return i; }
  	}
  	return -1;
  }

  // @property emptyImageUrl: String
  // Data URI string containing a base64-encoded empty GIF image.
  // Used as a hack to free memory from unused images on WebKit-powered
  // mobile devices (by setting image `src` to this string).
  var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

  // inspired by https://paulirish.com/2011/requestanimationframe-for-smart-animating/

  function getPrefixed(name) {
  	return window['webkit' + name] || window['moz' + name] || window['ms' + name];
  }

  var lastTime = 0;

  // fallback for IE 7-8
  function timeoutDefer(fn) {
  	var time = +new Date(),
  	    timeToCall = Math.max(0, 16 - (time - lastTime));

  	lastTime = time + timeToCall;
  	return window.setTimeout(fn, timeToCall);
  }

  var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;
  var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||
  		getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };

  // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
  // Schedules `fn` to be executed when the browser repaints. `fn` is bound to
  // `context` if given. When `immediate` is set, `fn` is called immediately if
  // the browser doesn't have native support for
  // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
  // otherwise it's delayed. Returns a request ID that can be used to cancel the request.
  function requestAnimFrame(fn, context, immediate) {
  	if (immediate && requestFn === timeoutDefer) {
  		fn.call(context);
  	} else {
  		return requestFn.call(window, bind(fn, context));
  	}
  }

  // @function cancelAnimFrame(id: Number): undefined
  // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
  function cancelAnimFrame(id) {
  	if (id) {
  		cancelFn.call(window, id);
  	}
  }

  var Util = {
    __proto__: null,
    extend: extend,
    create: create$2,
    bind: bind,
    get lastId () { return lastId; },
    stamp: stamp,
    throttle: throttle,
    wrapNum: wrapNum,
    falseFn: falseFn,
    formatNum: formatNum,
    trim: trim,
    splitWords: splitWords,
    setOptions: setOptions,
    getParamString: getParamString,
    template: template,
    isArray: isArray,
    indexOf: indexOf,
    emptyImageUrl: emptyImageUrl,
    requestFn: requestFn,
    cancelFn: cancelFn,
    requestAnimFrame: requestAnimFrame,
    cancelAnimFrame: cancelAnimFrame
  };

  // @class Class
  // @aka L.Class

  // @section
  // @uninheritable

  // Thanks to John Resig and Dean Edwards for inspiration!

  function Class() {}

  Class.extend = function (props) {

  	// @function extend(props: Object): Function
  	// [Extends the current class](#class-inheritance) given the properties to be included.
  	// Returns a Javascript function that is a class constructor (to be called with `new`).
  	var NewClass = function () {

  		setOptions(this);

  		// call the constructor
  		if (this.initialize) {
  			this.initialize.apply(this, arguments);
  		}

  		// call all constructor hooks
  		this.callInitHooks();
  	};

  	var parentProto = NewClass.__super__ = this.prototype;

  	var proto = create$2(parentProto);
  	proto.constructor = NewClass;

  	NewClass.prototype = proto;

  	// inherit parent's statics
  	for (var i in this) {
  		if (Object.prototype.hasOwnProperty.call(this, i) && i !== 'prototype' && i !== '__super__') {
  			NewClass[i] = this[i];
  		}
  	}

  	// mix static properties into the class
  	if (props.statics) {
  		extend(NewClass, props.statics);
  	}

  	// mix includes into the prototype
  	if (props.includes) {
  		checkDeprecatedMixinEvents(props.includes);
  		extend.apply(null, [proto].concat(props.includes));
  	}

  	// mix given properties into the prototype
  	extend(proto, props);
  	delete proto.statics;
  	delete proto.includes;

  	// merge options
  	if (proto.options) {
  		proto.options = parentProto.options ? create$2(parentProto.options) : {};
  		extend(proto.options, props.options);
  	}

  	proto._initHooks = [];

  	// add method for calling all hooks
  	proto.callInitHooks = function () {

  		if (this._initHooksCalled) { return; }

  		if (parentProto.callInitHooks) {
  			parentProto.callInitHooks.call(this);
  		}

  		this._initHooksCalled = true;

  		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
  			proto._initHooks[i].call(this);
  		}
  	};

  	return NewClass;
  };


  // @function include(properties: Object): this
  // [Includes a mixin](#class-includes) into the current class.
  Class.include = function (props) {
  	var parentOptions = this.prototype.options;
  	extend(this.prototype, props);
  	if (props.options) {
  		this.prototype.options = parentOptions;
  		this.mergeOptions(props.options);
  	}
  	return this;
  };

  // @function mergeOptions(options: Object): this
  // [Merges `options`](#class-options) into the defaults of the class.
  Class.mergeOptions = function (options) {
  	extend(this.prototype.options, options);
  	return this;
  };

  // @function addInitHook(fn: Function): this
  // Adds a [constructor hook](#class-constructor-hooks) to the class.
  Class.addInitHook = function (fn) { // (Function) || (String, args...)
  	var args = Array.prototype.slice.call(arguments, 1);

  	var init = typeof fn === 'function' ? fn : function () {
  		this[fn].apply(this, args);
  	};

  	this.prototype._initHooks = this.prototype._initHooks || [];
  	this.prototype._initHooks.push(init);
  	return this;
  };

  function checkDeprecatedMixinEvents(includes) {
  	/* global L: true */
  	if (typeof L === 'undefined' || !L || !L.Mixin) { return; }

  	includes = isArray(includes) ? includes : [includes];

  	for (var i = 0; i < includes.length; i++) {
  		if (includes[i] === L.Mixin.Events) {
  			console.warn('Deprecated include of L.Mixin.Events: ' +
  				'this property will be removed in future releases, ' +
  				'please inherit from L.Evented instead.', new Error().stack);
  		}
  	}
  }

  /*
   * @class Evented
   * @aka L.Evented
   * @inherits Class
   *
   * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
   *
   * @example
   *
   * ```js
   * map.on('click', function(e) {
   * 	alert(e.latlng);
   * } );
   * ```
   *
   * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
   *
   * ```js
   * function onClick(e) { ... }
   *
   * map.on('click', onClick);
   * map.off('click', onClick);
   * ```
   */

  var Events = {
  	/* @method on(type: String, fn: Function, context?: Object): this
  	 * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
  	 *
  	 * @alternative
  	 * @method on(eventMap: Object): this
  	 * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
  	 */
  	on: function (types, fn, context) {

  		// types can be a map of types/handlers
  		if (typeof types === 'object') {
  			for (var type in types) {
  				// we don't process space-separated events here for performance;
  				// it's a hot path since Layer uses the on(obj) syntax
  				this._on(type, types[type], fn);
  			}

  		} else {
  			// types can be a string of space-separated words
  			types = splitWords(types);

  			for (var i = 0, len = types.length; i < len; i++) {
  				this._on(types[i], fn, context);
  			}
  		}

  		return this;
  	},

  	/* @method off(type: String, fn?: Function, context?: Object): this
  	 * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
  	 *
  	 * @alternative
  	 * @method off(eventMap: Object): this
  	 * Removes a set of type/listener pairs.
  	 *
  	 * @alternative
  	 * @method off: this
  	 * Removes all listeners to all events on the object. This includes implicitly attached events.
  	 */
  	off: function (types, fn, context) {

  		if (!arguments.length) {
  			// clear all listeners if called without arguments
  			delete this._events;

  		} else if (typeof types === 'object') {
  			for (var type in types) {
  				this._off(type, types[type], fn);
  			}

  		} else {
  			types = splitWords(types);

  			var removeAll = arguments.length === 1;
  			for (var i = 0, len = types.length; i < len; i++) {
  				if (removeAll) {
  					this._off(types[i]);
  				} else {
  					this._off(types[i], fn, context);
  				}
  			}
  		}

  		return this;
  	},

  	// attach listener (without syntactic sugar now)
  	_on: function (type, fn, context, _once) {
  		if (typeof fn !== 'function') {
  			console.warn('wrong listener type: ' + typeof fn);
  			return;
  		}

  		// check if fn already there
  		if (this._listens(type, fn, context) !== false) {
  			return;
  		}

  		if (context === this) {
  			// Less memory footprint.
  			context = undefined;
  		}

  		var newListener = {fn: fn, ctx: context};
  		if (_once) {
  			newListener.once = true;
  		}

  		this._events = this._events || {};
  		this._events[type] = this._events[type] || [];
  		this._events[type].push(newListener);
  	},

  	_off: function (type, fn, context) {
  		var listeners,
  		    i,
  		    len;

  		if (!this._events) {
  			return;
  		}

  		listeners = this._events[type];
  		if (!listeners) {
  			return;
  		}

  		if (arguments.length === 1) { // remove all
  			if (this._firingCount) {
  				// Set all removed listeners to noop
  				// so they are not called if remove happens in fire
  				for (i = 0, len = listeners.length; i < len; i++) {
  					listeners[i].fn = falseFn;
  				}
  			}
  			// clear all listeners for a type if function isn't specified
  			delete this._events[type];
  			return;
  		}

  		if (typeof fn !== 'function') {
  			console.warn('wrong listener type: ' + typeof fn);
  			return;
  		}

  		// find fn and remove it
  		var index = this._listens(type, fn, context);
  		if (index !== false) {
  			var listener = listeners[index];
  			if (this._firingCount) {
  				// set the removed listener to noop so that's not called if remove happens in fire
  				listener.fn = falseFn;

  				/* copy array in case events are being fired */
  				this._events[type] = listeners = listeners.slice();
  			}
  			listeners.splice(index, 1);
  		}
  	},

  	// @method fire(type: String, data?: Object, propagate?: Boolean): this
  	// Fires an event of the specified type. You can optionally provide a data
  	// object  the first argument of the listener function will contain its
  	// properties. The event can optionally be propagated to event parents.
  	fire: function (type, data, propagate) {
  		if (!this.listens(type, propagate)) { return this; }

  		var event = extend({}, data, {
  			type: type,
  			target: this,
  			sourceTarget: data && data.sourceTarget || this
  		});

  		if (this._events) {
  			var listeners = this._events[type];
  			if (listeners) {
  				this._firingCount = (this._firingCount + 1) || 1;
  				for (var i = 0, len = listeners.length; i < len; i++) {
  					var l = listeners[i];
  					// off overwrites l.fn, so we need to copy fn to a var
  					var fn = l.fn;
  					if (l.once) {
  						this.off(type, fn, l.ctx);
  					}
  					fn.call(l.ctx || this, event);
  				}

  				this._firingCount--;
  			}
  		}

  		if (propagate) {
  			// propagate the event to parents (set with addEventParent)
  			this._propagateEvent(event);
  		}

  		return this;
  	},

  	// @method listens(type: String, propagate?: Boolean): Boolean
  	// @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean
  	// Returns `true` if a particular event type has any listeners attached to it.
  	// The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
  	listens: function (type, fn, context, propagate) {
  		if (typeof type !== 'string') {
  			console.warn('"string" type argument expected');
  		}

  		// we don't overwrite the input `fn` value, because we need to use it for propagation
  		var _fn = fn;
  		if (typeof fn !== 'function') {
  			propagate = !!fn;
  			_fn = undefined;
  			context = undefined;
  		}

  		var listeners = this._events && this._events[type];
  		if (listeners && listeners.length) {
  			if (this._listens(type, _fn, context) !== false) {
  				return true;
  			}
  		}

  		if (propagate) {
  			// also check parents for listeners if event propagates
  			for (var id in this._eventParents) {
  				if (this._eventParents[id].listens(type, fn, context, propagate)) { return true; }
  			}
  		}
  		return false;
  	},

  	// returns the index (number) or false
  	_listens: function (type, fn, context) {
  		if (!this._events) {
  			return false;
  		}

  		var listeners = this._events[type] || [];
  		if (!fn) {
  			return !!listeners.length;
  		}

  		if (context === this) {
  			// Less memory footprint.
  			context = undefined;
  		}

  		for (var i = 0, len = listeners.length; i < len; i++) {
  			if (listeners[i].fn === fn && listeners[i].ctx === context) {
  				return i;
  			}
  		}
  		return false;

  	},

  	// @method once(): this
  	// Behaves as [`on()`](#evented-on), except the listener will only get fired once and then removed.
  	once: function (types, fn, context) {

  		// types can be a map of types/handlers
  		if (typeof types === 'object') {
  			for (var type in types) {
  				// we don't process space-separated events here for performance;
  				// it's a hot path since Layer uses the on(obj) syntax
  				this._on(type, types[type], fn, true);
  			}

  		} else {
  			// types can be a string of space-separated words
  			types = splitWords(types);

  			for (var i = 0, len = types.length; i < len; i++) {
  				this._on(types[i], fn, context, true);
  			}
  		}

  		return this;
  	},

  	// @method addEventParent(obj: Evented): this
  	// Adds an event parent - an `Evented` that will receive propagated events
  	addEventParent: function (obj) {
  		this._eventParents = this._eventParents || {};
  		this._eventParents[stamp(obj)] = obj;
  		return this;
  	},

  	// @method removeEventParent(obj: Evented): this
  	// Removes an event parent, so it will stop receiving propagated events
  	removeEventParent: function (obj) {
  		if (this._eventParents) {
  			delete this._eventParents[stamp(obj)];
  		}
  		return this;
  	},

  	_propagateEvent: function (e) {
  		for (var id in this._eventParents) {
  			this._eventParents[id].fire(e.type, extend({
  				layer: e.target,
  				propagatedFrom: e.target
  			}, e), true);
  		}
  	}
  };

  // aliases; we should ditch those eventually

  // @method addEventListener(): this
  // Alias to [`on()`](#evented-on)
  Events.addEventListener = Events.on;

  // @method removeEventListener(): this
  // Alias to [`off()`](#evented-off)

  // @method clearAllEventListeners(): this
  // Alias to [`off()`](#evented-off)
  Events.removeEventListener = Events.clearAllEventListeners = Events.off;

  // @method addOneTimeEventListener(): this
  // Alias to [`once()`](#evented-once)
  Events.addOneTimeEventListener = Events.once;

  // @method fireEvent(): this
  // Alias to [`fire()`](#evented-fire)
  Events.fireEvent = Events.fire;

  // @method hasEventListeners(): Boolean
  // Alias to [`listens()`](#evented-listens)
  Events.hasEventListeners = Events.listens;

  var Evented = Class.extend(Events);

  /*
   * @class Point
   * @aka L.Point
   *
   * Represents a point with `x` and `y` coordinates in pixels.
   *
   * @example
   *
   * ```js
   * var point = L.point(200, 300);
   * ```
   *
   * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
   *
   * ```js
   * map.panBy([200, 300]);
   * map.panBy(L.point(200, 300));
   * ```
   *
   * Note that `Point` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function Point(x, y, round) {
  	// @property x: Number; The `x` coordinate of the point
  	this.x = (round ? Math.round(x) : x);
  	// @property y: Number; The `y` coordinate of the point
  	this.y = (round ? Math.round(y) : y);
  }

  var trunc = Math.trunc || function (v) {
  	return v > 0 ? Math.floor(v) : Math.ceil(v);
  };

  Point.prototype = {

  	// @method clone(): Point
  	// Returns a copy of the current point.
  	clone: function () {
  		return new Point(this.x, this.y);
  	},

  	// @method add(otherPoint: Point): Point
  	// Returns the result of addition of the current and the given points.
  	add: function (point) {
  		// non-destructive, returns a new point
  		return this.clone()._add(toPoint(point));
  	},

  	_add: function (point) {
  		// destructive, used directly for performance in situations where it's safe to modify existing point
  		this.x += point.x;
  		this.y += point.y;
  		return this;
  	},

  	// @method subtract(otherPoint: Point): Point
  	// Returns the result of subtraction of the given point from the current.
  	subtract: function (point) {
  		return this.clone()._subtract(toPoint(point));
  	},

  	_subtract: function (point) {
  		this.x -= point.x;
  		this.y -= point.y;
  		return this;
  	},

  	// @method divideBy(num: Number): Point
  	// Returns the result of division of the current point by the given number.
  	divideBy: function (num) {
  		return this.clone()._divideBy(num);
  	},

  	_divideBy: function (num) {
  		this.x /= num;
  		this.y /= num;
  		return this;
  	},

  	// @method multiplyBy(num: Number): Point
  	// Returns the result of multiplication of the current point by the given number.
  	multiplyBy: function (num) {
  		return this.clone()._multiplyBy(num);
  	},

  	_multiplyBy: function (num) {
  		this.x *= num;
  		this.y *= num;
  		return this;
  	},

  	// @method scaleBy(scale: Point): Point
  	// Multiply each coordinate of the current point by each coordinate of
  	// `scale`. In linear algebra terms, multiply the point by the
  	// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
  	// defined by `scale`.
  	scaleBy: function (point) {
  		return new Point(this.x * point.x, this.y * point.y);
  	},

  	// @method unscaleBy(scale: Point): Point
  	// Inverse of `scaleBy`. Divide each coordinate of the current point by
  	// each coordinate of `scale`.
  	unscaleBy: function (point) {
  		return new Point(this.x / point.x, this.y / point.y);
  	},

  	// @method round(): Point
  	// Returns a copy of the current point with rounded coordinates.
  	round: function () {
  		return this.clone()._round();
  	},

  	_round: function () {
  		this.x = Math.round(this.x);
  		this.y = Math.round(this.y);
  		return this;
  	},

  	// @method floor(): Point
  	// Returns a copy of the current point with floored coordinates (rounded down).
  	floor: function () {
  		return this.clone()._floor();
  	},

  	_floor: function () {
  		this.x = Math.floor(this.x);
  		this.y = Math.floor(this.y);
  		return this;
  	},

  	// @method ceil(): Point
  	// Returns a copy of the current point with ceiled coordinates (rounded up).
  	ceil: function () {
  		return this.clone()._ceil();
  	},

  	_ceil: function () {
  		this.x = Math.ceil(this.x);
  		this.y = Math.ceil(this.y);
  		return this;
  	},

  	// @method trunc(): Point
  	// Returns a copy of the current point with truncated coordinates (rounded towards zero).
  	trunc: function () {
  		return this.clone()._trunc();
  	},

  	_trunc: function () {
  		this.x = trunc(this.x);
  		this.y = trunc(this.y);
  		return this;
  	},

  	// @method distanceTo(otherPoint: Point): Number
  	// Returns the cartesian distance between the current and the given points.
  	distanceTo: function (point) {
  		point = toPoint(point);

  		var x = point.x - this.x,
  		    y = point.y - this.y;

  		return Math.sqrt(x * x + y * y);
  	},

  	// @method equals(otherPoint: Point): Boolean
  	// Returns `true` if the given point has the same coordinates.
  	equals: function (point) {
  		point = toPoint(point);

  		return point.x === this.x &&
  		       point.y === this.y;
  	},

  	// @method contains(otherPoint: Point): Boolean
  	// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
  	contains: function (point) {
  		point = toPoint(point);

  		return Math.abs(point.x) <= Math.abs(this.x) &&
  		       Math.abs(point.y) <= Math.abs(this.y);
  	},

  	// @method toString(): String
  	// Returns a string representation of the point for debugging purposes.
  	toString: function () {
  		return 'Point(' +
  		        formatNum(this.x) + ', ' +
  		        formatNum(this.y) + ')';
  	}
  };

  // @factory L.point(x: Number, y: Number, round?: Boolean)
  // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

  // @alternative
  // @factory L.point(coords: Number[])
  // Expects an array of the form `[x, y]` instead.

  // @alternative
  // @factory L.point(coords: Object)
  // Expects a plain object of the form `{x: Number, y: Number}` instead.
  function toPoint(x, y, round) {
  	if (x instanceof Point) {
  		return x;
  	}
  	if (isArray(x)) {
  		return new Point(x[0], x[1]);
  	}
  	if (x === undefined || x === null) {
  		return x;
  	}
  	if (typeof x === 'object' && 'x' in x && 'y' in x) {
  		return new Point(x.x, x.y);
  	}
  	return new Point(x, y, round);
  }

  /*
   * @class Bounds
   * @aka L.Bounds
   *
   * Represents a rectangular area in pixel coordinates.
   *
   * @example
   *
   * ```js
   * var p1 = L.point(10, 10),
   * p2 = L.point(40, 60),
   * bounds = L.bounds(p1, p2);
   * ```
   *
   * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
   *
   * ```js
   * otherBounds.intersects([[10, 10], [40, 60]]);
   * ```
   *
   * Note that `Bounds` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function Bounds(a, b) {
  	if (!a) { return; }

  	var points = b ? [a, b] : a;

  	for (var i = 0, len = points.length; i < len; i++) {
  		this.extend(points[i]);
  	}
  }

  Bounds.prototype = {
  	// @method extend(point: Point): this
  	// Extends the bounds to contain the given point.

  	// @alternative
  	// @method extend(otherBounds: Bounds): this
  	// Extend the bounds to contain the given bounds
  	extend: function (obj) {
  		var min2, max2;
  		if (!obj) { return this; }

  		if (obj instanceof Point || typeof obj[0] === 'number' || 'x' in obj) {
  			min2 = max2 = toPoint(obj);
  		} else {
  			obj = toBounds(obj);
  			min2 = obj.min;
  			max2 = obj.max;

  			if (!min2 || !max2) { return this; }
  		}

  		// @property min: Point
  		// The top left corner of the rectangle.
  		// @property max: Point
  		// The bottom right corner of the rectangle.
  		if (!this.min && !this.max) {
  			this.min = min2.clone();
  			this.max = max2.clone();
  		} else {
  			this.min.x = Math.min(min2.x, this.min.x);
  			this.max.x = Math.max(max2.x, this.max.x);
  			this.min.y = Math.min(min2.y, this.min.y);
  			this.max.y = Math.max(max2.y, this.max.y);
  		}
  		return this;
  	},

  	// @method getCenter(round?: Boolean): Point
  	// Returns the center point of the bounds.
  	getCenter: function (round) {
  		return toPoint(
  		        (this.min.x + this.max.x) / 2,
  		        (this.min.y + this.max.y) / 2, round);
  	},

  	// @method getBottomLeft(): Point
  	// Returns the bottom-left point of the bounds.
  	getBottomLeft: function () {
  		return toPoint(this.min.x, this.max.y);
  	},

  	// @method getTopRight(): Point
  	// Returns the top-right point of the bounds.
  	getTopRight: function () { // -> Point
  		return toPoint(this.max.x, this.min.y);
  	},

  	// @method getTopLeft(): Point
  	// Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
  	getTopLeft: function () {
  		return this.min; // left, top
  	},

  	// @method getBottomRight(): Point
  	// Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
  	getBottomRight: function () {
  		return this.max; // right, bottom
  	},

  	// @method getSize(): Point
  	// Returns the size of the given bounds
  	getSize: function () {
  		return this.max.subtract(this.min);
  	},

  	// @method contains(otherBounds: Bounds): Boolean
  	// Returns `true` if the rectangle contains the given one.
  	// @alternative
  	// @method contains(point: Point): Boolean
  	// Returns `true` if the rectangle contains the given point.
  	contains: function (obj) {
  		var min, max;

  		if (typeof obj[0] === 'number' || obj instanceof Point) {
  			obj = toPoint(obj);
  		} else {
  			obj = toBounds(obj);
  		}

  		if (obj instanceof Bounds) {
  			min = obj.min;
  			max = obj.max;
  		} else {
  			min = max = obj;
  		}

  		return (min.x >= this.min.x) &&
  		       (max.x <= this.max.x) &&
  		       (min.y >= this.min.y) &&
  		       (max.y <= this.max.y);
  	},

  	// @method intersects(otherBounds: Bounds): Boolean
  	// Returns `true` if the rectangle intersects the given bounds. Two bounds
  	// intersect if they have at least one point in common.
  	intersects: function (bounds) { // (Bounds) -> Boolean
  		bounds = toBounds(bounds);

  		var min = this.min,
  		    max = this.max,
  		    min2 = bounds.min,
  		    max2 = bounds.max,
  		    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
  		    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

  		return xIntersects && yIntersects;
  	},

  	// @method overlaps(otherBounds: Bounds): Boolean
  	// Returns `true` if the rectangle overlaps the given bounds. Two bounds
  	// overlap if their intersection is an area.
  	overlaps: function (bounds) { // (Bounds) -> Boolean
  		bounds = toBounds(bounds);

  		var min = this.min,
  		    max = this.max,
  		    min2 = bounds.min,
  		    max2 = bounds.max,
  		    xOverlaps = (max2.x > min.x) && (min2.x < max.x),
  		    yOverlaps = (max2.y > min.y) && (min2.y < max.y);

  		return xOverlaps && yOverlaps;
  	},

  	// @method isValid(): Boolean
  	// Returns `true` if the bounds are properly initialized.
  	isValid: function () {
  		return !!(this.min && this.max);
  	},


  	// @method pad(bufferRatio: Number): Bounds
  	// Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
  	// For example, a ratio of 0.5 extends the bounds by 50% in each direction.
  	// Negative values will retract the bounds.
  	pad: function (bufferRatio) {
  		var min = this.min,
  		max = this.max,
  		heightBuffer = Math.abs(min.x - max.x) * bufferRatio,
  		widthBuffer = Math.abs(min.y - max.y) * bufferRatio;


  		return toBounds(
  			toPoint(min.x - heightBuffer, min.y - widthBuffer),
  			toPoint(max.x + heightBuffer, max.y + widthBuffer));
  	},


  	// @method equals(otherBounds: Bounds): Boolean
  	// Returns `true` if the rectangle is equivalent to the given bounds.
  	equals: function (bounds) {
  		if (!bounds) { return false; }

  		bounds = toBounds(bounds);

  		return this.min.equals(bounds.getTopLeft()) &&
  			this.max.equals(bounds.getBottomRight());
  	},
  };


  // @factory L.bounds(corner1: Point, corner2: Point)
  // Creates a Bounds object from two corners coordinate pairs.
  // @alternative
  // @factory L.bounds(points: Point[])
  // Creates a Bounds object from the given array of points.
  function toBounds(a, b) {
  	if (!a || a instanceof Bounds) {
  		return a;
  	}
  	return new Bounds(a, b);
  }

  /*
   * @class LatLngBounds
   * @aka L.LatLngBounds
   *
   * Represents a rectangular geographical area on a map.
   *
   * @example
   *
   * ```js
   * var corner1 = L.latLng(40.712, -74.227),
   * corner2 = L.latLng(40.774, -74.125),
   * bounds = L.latLngBounds(corner1, corner2);
   * ```
   *
   * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
   *
   * ```js
   * map.fitBounds([
   * 	[40.712, -74.227],
   * 	[40.774, -74.125]
   * ]);
   * ```
   *
   * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.
   *
   * Note that `LatLngBounds` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function LatLngBounds(corner1, corner2) { // (LatLng, LatLng) or (LatLng[])
  	if (!corner1) { return; }

  	var latlngs = corner2 ? [corner1, corner2] : corner1;

  	for (var i = 0, len = latlngs.length; i < len; i++) {
  		this.extend(latlngs[i]);
  	}
  }

  LatLngBounds.prototype = {

  	// @method extend(latlng: LatLng): this
  	// Extend the bounds to contain the given point

  	// @alternative
  	// @method extend(otherBounds: LatLngBounds): this
  	// Extend the bounds to contain the given bounds
  	extend: function (obj) {
  		var sw = this._southWest,
  		    ne = this._northEast,
  		    sw2, ne2;

  		if (obj instanceof LatLng) {
  			sw2 = obj;
  			ne2 = obj;

  		} else if (obj instanceof LatLngBounds) {
  			sw2 = obj._southWest;
  			ne2 = obj._northEast;

  			if (!sw2 || !ne2) { return this; }

  		} else {
  			return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
  		}

  		if (!sw && !ne) {
  			this._southWest = new LatLng(sw2.lat, sw2.lng);
  			this._northEast = new LatLng(ne2.lat, ne2.lng);
  		} else {
  			sw.lat = Math.min(sw2.lat, sw.lat);
  			sw.lng = Math.min(sw2.lng, sw.lng);
  			ne.lat = Math.max(ne2.lat, ne.lat);
  			ne.lng = Math.max(ne2.lng, ne.lng);
  		}

  		return this;
  	},

  	// @method pad(bufferRatio: Number): LatLngBounds
  	// Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
  	// For example, a ratio of 0.5 extends the bounds by 50% in each direction.
  	// Negative values will retract the bounds.
  	pad: function (bufferRatio) {
  		var sw = this._southWest,
  		    ne = this._northEast,
  		    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
  		    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

  		return new LatLngBounds(
  		        new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
  		        new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
  	},

  	// @method getCenter(): LatLng
  	// Returns the center point of the bounds.
  	getCenter: function () {
  		return new LatLng(
  		        (this._southWest.lat + this._northEast.lat) / 2,
  		        (this._southWest.lng + this._northEast.lng) / 2);
  	},

  	// @method getSouthWest(): LatLng
  	// Returns the south-west point of the bounds.
  	getSouthWest: function () {
  		return this._southWest;
  	},

  	// @method getNorthEast(): LatLng
  	// Returns the north-east point of the bounds.
  	getNorthEast: function () {
  		return this._northEast;
  	},

  	// @method getNorthWest(): LatLng
  	// Returns the north-west point of the bounds.
  	getNorthWest: function () {
  		return new LatLng(this.getNorth(), this.getWest());
  	},

  	// @method getSouthEast(): LatLng
  	// Returns the south-east point of the bounds.
  	getSouthEast: function () {
  		return new LatLng(this.getSouth(), this.getEast());
  	},

  	// @method getWest(): Number
  	// Returns the west longitude of the bounds
  	getWest: function () {
  		return this._southWest.lng;
  	},

  	// @method getSouth(): Number
  	// Returns the south latitude of the bounds
  	getSouth: function () {
  		return this._southWest.lat;
  	},

  	// @method getEast(): Number
  	// Returns the east longitude of the bounds
  	getEast: function () {
  		return this._northEast.lng;
  	},

  	// @method getNorth(): Number
  	// Returns the north latitude of the bounds
  	getNorth: function () {
  		return this._northEast.lat;
  	},

  	// @method contains(otherBounds: LatLngBounds): Boolean
  	// Returns `true` if the rectangle contains the given one.

  	// @alternative
  	// @method contains (latlng: LatLng): Boolean
  	// Returns `true` if the rectangle contains the given point.
  	contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
  		if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {
  			obj = toLatLng(obj);
  		} else {
  			obj = toLatLngBounds(obj);
  		}

  		var sw = this._southWest,
  		    ne = this._northEast,
  		    sw2, ne2;

  		if (obj instanceof LatLngBounds) {
  			sw2 = obj.getSouthWest();
  			ne2 = obj.getNorthEast();
  		} else {
  			sw2 = ne2 = obj;
  		}

  		return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
  		       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
  	},

  	// @method intersects(otherBounds: LatLngBounds): Boolean
  	// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
  	intersects: function (bounds) {
  		bounds = toLatLngBounds(bounds);

  		var sw = this._southWest,
  		    ne = this._northEast,
  		    sw2 = bounds.getSouthWest(),
  		    ne2 = bounds.getNorthEast(),

  		    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
  		    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

  		return latIntersects && lngIntersects;
  	},

  	// @method overlaps(otherBounds: LatLngBounds): Boolean
  	// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
  	overlaps: function (bounds) {
  		bounds = toLatLngBounds(bounds);

  		var sw = this._southWest,
  		    ne = this._northEast,
  		    sw2 = bounds.getSouthWest(),
  		    ne2 = bounds.getNorthEast(),

  		    latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),
  		    lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);

  		return latOverlaps && lngOverlaps;
  	},

  	// @method toBBoxString(): String
  	// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
  	toBBoxString: function () {
  		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
  	},

  	// @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
  	// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
  	equals: function (bounds, maxMargin) {
  		if (!bounds) { return false; }

  		bounds = toLatLngBounds(bounds);

  		return this._southWest.equals(bounds.getSouthWest(), maxMargin) &&
  		       this._northEast.equals(bounds.getNorthEast(), maxMargin);
  	},

  	// @method isValid(): Boolean
  	// Returns `true` if the bounds are properly initialized.
  	isValid: function () {
  		return !!(this._southWest && this._northEast);
  	}
  };

  // TODO International date line?

  // @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)
  // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.

  // @alternative
  // @factory L.latLngBounds(latlngs: LatLng[])
  // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
  function toLatLngBounds(a, b) {
  	if (a instanceof LatLngBounds) {
  		return a;
  	}
  	return new LatLngBounds(a, b);
  }

  /* @class LatLng
   * @aka L.LatLng
   *
   * Represents a geographical point with a certain latitude and longitude.
   *
   * @example
   *
   * ```
   * var latlng = L.latLng(50.5, 30.5);
   * ```
   *
   * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
   *
   * ```
   * map.panTo([50, 30]);
   * map.panTo({lon: 30, lat: 50});
   * map.panTo({lat: 50, lng: 30});
   * map.panTo(L.latLng(50, 30));
   * ```
   *
   * Note that `LatLng` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function LatLng(lat, lng, alt) {
  	if (isNaN(lat) || isNaN(lng)) {
  		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
  	}

  	// @property lat: Number
  	// Latitude in degrees
  	this.lat = +lat;

  	// @property lng: Number
  	// Longitude in degrees
  	this.lng = +lng;

  	// @property alt: Number
  	// Altitude in meters (optional)
  	if (alt !== undefined) {
  		this.alt = +alt;
  	}
  }

  LatLng.prototype = {
  	// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
  	// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
  	equals: function (obj, maxMargin) {
  		if (!obj) { return false; }

  		obj = toLatLng(obj);

  		var margin = Math.max(
  		        Math.abs(this.lat - obj.lat),
  		        Math.abs(this.lng - obj.lng));

  		return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
  	},

  	// @method toString(): String
  	// Returns a string representation of the point (for debugging purposes).
  	toString: function (precision) {
  		return 'LatLng(' +
  		        formatNum(this.lat, precision) + ', ' +
  		        formatNum(this.lng, precision) + ')';
  	},

  	// @method distanceTo(otherLatLng: LatLng): Number
  	// Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
  	distanceTo: function (other) {
  		return Earth.distance(this, toLatLng(other));
  	},

  	// @method wrap(): LatLng
  	// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
  	wrap: function () {
  		return Earth.wrapLatLng(this);
  	},

  	// @method toBounds(sizeInMeters: Number): LatLngBounds
  	// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
  	toBounds: function (sizeInMeters) {
  		var latAccuracy = 180 * sizeInMeters / 40075017,
  		    lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);

  		return toLatLngBounds(
  		        [this.lat - latAccuracy, this.lng - lngAccuracy],
  		        [this.lat + latAccuracy, this.lng + lngAccuracy]);
  	},

  	clone: function () {
  		return new LatLng(this.lat, this.lng, this.alt);
  	}
  };



  // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
  // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

  // @alternative
  // @factory L.latLng(coords: Array): LatLng
  // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

  // @alternative
  // @factory L.latLng(coords: Object): LatLng
  // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

  function toLatLng(a, b, c) {
  	if (a instanceof LatLng) {
  		return a;
  	}
  	if (isArray(a) && typeof a[0] !== 'object') {
  		if (a.length === 3) {
  			return new LatLng(a[0], a[1], a[2]);
  		}
  		if (a.length === 2) {
  			return new LatLng(a[0], a[1]);
  		}
  		return null;
  	}
  	if (a === undefined || a === null) {
  		return a;
  	}
  	if (typeof a === 'object' && 'lat' in a) {
  		return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
  	}
  	if (b === undefined) {
  		return null;
  	}
  	return new LatLng(a, b, c);
  }

  /*
   * @namespace CRS
   * @crs L.CRS.Base
   * Object that defines coordinate reference systems for projecting
   * geographical points into pixel (screen) coordinates and back (and to
   * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
   * [spatial reference system](https://en.wikipedia.org/wiki/Spatial_reference_system).
   *
   * Leaflet defines the most usual CRSs by default. If you want to use a
   * CRS not defined by default, take a look at the
   * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
   *
   * Note that the CRS instances do not inherit from Leaflet's `Class` object,
   * and can't be instantiated. Also, new classes can't inherit from them,
   * and methods can't be added to them with the `include` function.
   */

  var CRS = {
  	// @method latLngToPoint(latlng: LatLng, zoom: Number): Point
  	// Projects geographical coordinates into pixel coordinates for a given zoom.
  	latLngToPoint: function (latlng, zoom) {
  		var projectedPoint = this.projection.project(latlng),
  		    scale = this.scale(zoom);

  		return this.transformation._transform(projectedPoint, scale);
  	},

  	// @method pointToLatLng(point: Point, zoom: Number): LatLng
  	// The inverse of `latLngToPoint`. Projects pixel coordinates on a given
  	// zoom into geographical coordinates.
  	pointToLatLng: function (point, zoom) {
  		var scale = this.scale(zoom),
  		    untransformedPoint = this.transformation.untransform(point, scale);

  		return this.projection.unproject(untransformedPoint);
  	},

  	// @method project(latlng: LatLng): Point
  	// Projects geographical coordinates into coordinates in units accepted for
  	// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
  	project: function (latlng) {
  		return this.projection.project(latlng);
  	},

  	// @method unproject(point: Point): LatLng
  	// Given a projected coordinate returns the corresponding LatLng.
  	// The inverse of `project`.
  	unproject: function (point) {
  		return this.projection.unproject(point);
  	},

  	// @method scale(zoom: Number): Number
  	// Returns the scale used when transforming projected coordinates into
  	// pixel coordinates for a particular zoom. For example, it returns
  	// `256 * 2^zoom` for Mercator-based CRS.
  	scale: function (zoom) {
  		return 256 * Math.pow(2, zoom);
  	},

  	// @method zoom(scale: Number): Number
  	// Inverse of `scale()`, returns the zoom level corresponding to a scale
  	// factor of `scale`.
  	zoom: function (scale) {
  		return Math.log(scale / 256) / Math.LN2;
  	},

  	// @method getProjectedBounds(zoom: Number): Bounds
  	// Returns the projection's bounds scaled and transformed for the provided `zoom`.
  	getProjectedBounds: function (zoom) {
  		if (this.infinite) { return null; }

  		var b = this.projection.bounds,
  		    s = this.scale(zoom),
  		    min = this.transformation.transform(b.min, s),
  		    max = this.transformation.transform(b.max, s);

  		return new Bounds(min, max);
  	},

  	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
  	// Returns the distance between two geographical coordinates.

  	// @property code: String
  	// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
  	//
  	// @property wrapLng: Number[]
  	// An array of two numbers defining whether the longitude (horizontal) coordinate
  	// axis wraps around a given range and how. Defaults to `[-180, 180]` in most
  	// geographical CRSs. If `undefined`, the longitude axis does not wrap around.
  	//
  	// @property wrapLat: Number[]
  	// Like `wrapLng`, but for the latitude (vertical) axis.

  	// wrapLng: [min, max],
  	// wrapLat: [min, max],

  	// @property infinite: Boolean
  	// If true, the coordinate space will be unbounded (infinite in both axes)
  	infinite: false,

  	// @method wrapLatLng(latlng: LatLng): LatLng
  	// Returns a `LatLng` where lat and lng has been wrapped according to the
  	// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
  	wrapLatLng: function (latlng) {
  		var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
  		    lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
  		    alt = latlng.alt;

  		return new LatLng(lat, lng, alt);
  	},

  	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
  	// Returns a `LatLngBounds` with the same size as the given one, ensuring
  	// that its center is within the CRS's bounds.
  	// Only accepts actual `L.LatLngBounds` instances, not arrays.
  	wrapLatLngBounds: function (bounds) {
  		var center = bounds.getCenter(),
  		    newCenter = this.wrapLatLng(center),
  		    latShift = center.lat - newCenter.lat,
  		    lngShift = center.lng - newCenter.lng;

  		if (latShift === 0 && lngShift === 0) {
  			return bounds;
  		}

  		var sw = bounds.getSouthWest(),
  		    ne = bounds.getNorthEast(),
  		    newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),
  		    newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);

  		return new LatLngBounds(newSw, newNe);
  	}
  };

  /*
   * @namespace CRS
   * @crs L.CRS.Earth
   *
   * Serves as the base for CRS that are global such that they cover the earth.
   * Can only be used as the base for other CRS and cannot be used directly,
   * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
   * meters.
   */

  var Earth = extend({}, CRS, {
  	wrapLng: [-180, 180],

  	// Mean Earth Radius, as recommended for use by
  	// the International Union of Geodesy and Geophysics,
  	// see https://rosettacode.org/wiki/Haversine_formula
  	R: 6371000,

  	// distance between two geographical points using spherical law of cosines approximation
  	distance: function (latlng1, latlng2) {
  		var rad = Math.PI / 180,
  		    lat1 = latlng1.lat * rad,
  		    lat2 = latlng2.lat * rad,
  		    sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),
  		    sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),
  		    a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,
  		    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  		return this.R * c;
  	}
  });

  /*
   * @namespace Projection
   * @projection L.Projection.SphericalMercator
   *
   * Spherical Mercator projection  the most common projection for online maps,
   * used by almost all free and commercial tile providers. Assumes that Earth is
   * a sphere. Used by the `EPSG:3857` CRS.
   */

  var earthRadius = 6378137;

  var SphericalMercator = {

  	R: earthRadius,
  	MAX_LATITUDE: 85.0511287798,

  	project: function (latlng) {
  		var d = Math.PI / 180,
  		    max = this.MAX_LATITUDE,
  		    lat = Math.max(Math.min(max, latlng.lat), -max),
  		    sin = Math.sin(lat * d);

  		return new Point(
  			this.R * latlng.lng * d,
  			this.R * Math.log((1 + sin) / (1 - sin)) / 2);
  	},

  	unproject: function (point) {
  		var d = 180 / Math.PI;

  		return new LatLng(
  			(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
  			point.x * d / this.R);
  	},

  	bounds: (function () {
  		var d = earthRadius * Math.PI;
  		return new Bounds([-d, -d], [d, d]);
  	})()
  };

  /*
   * @class Transformation
   * @aka L.Transformation
   *
   * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
   * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
   * the reverse. Used by Leaflet in its projections code.
   *
   * @example
   *
   * ```js
   * var transformation = L.transformation(2, 5, -1, 10),
   * 	p = L.point(1, 2),
   * 	p2 = transformation.transform(p), //  L.point(7, 8)
   * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
   * ```
   */


  // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
  // Creates a `Transformation` object with the given coefficients.
  function Transformation(a, b, c, d) {
  	if (isArray(a)) {
  		// use array properties
  		this._a = a[0];
  		this._b = a[1];
  		this._c = a[2];
  		this._d = a[3];
  		return;
  	}
  	this._a = a;
  	this._b = b;
  	this._c = c;
  	this._d = d;
  }

  Transformation.prototype = {
  	// @method transform(point: Point, scale?: Number): Point
  	// Returns a transformed point, optionally multiplied by the given scale.
  	// Only accepts actual `L.Point` instances, not arrays.
  	transform: function (point, scale) { // (Point, Number) -> Point
  		return this._transform(point.clone(), scale);
  	},

  	// destructive transform (faster)
  	_transform: function (point, scale) {
  		scale = scale || 1;
  		point.x = scale * (this._a * point.x + this._b);
  		point.y = scale * (this._c * point.y + this._d);
  		return point;
  	},

  	// @method untransform(point: Point, scale?: Number): Point
  	// Returns the reverse transformation of the given point, optionally divided
  	// by the given scale. Only accepts actual `L.Point` instances, not arrays.
  	untransform: function (point, scale) {
  		scale = scale || 1;
  		return new Point(
  		        (point.x / scale - this._b) / this._a,
  		        (point.y / scale - this._d) / this._c);
  	}
  };

  // factory L.transformation(a: Number, b: Number, c: Number, d: Number)

  // @factory L.transformation(a: Number, b: Number, c: Number, d: Number)
  // Instantiates a Transformation object with the given coefficients.

  // @alternative
  // @factory L.transformation(coefficients: Array): Transformation
  // Expects an coefficients array of the form
  // `[a: Number, b: Number, c: Number, d: Number]`.

  function toTransformation(a, b, c, d) {
  	return new Transformation(a, b, c, d);
  }

  /*
   * @namespace CRS
   * @crs L.CRS.EPSG3857
   *
   * The most common CRS for online maps, used by almost all free and commercial
   * tile providers. Uses Spherical Mercator projection. Set in by default in
   * Map's `crs` option.
   */

  var EPSG3857 = extend({}, Earth, {
  	code: 'EPSG:3857',
  	projection: SphericalMercator,

  	transformation: (function () {
  		var scale = 0.5 / (Math.PI * SphericalMercator.R);
  		return toTransformation(scale, 0.5, -scale, 0.5);
  	}())
  });

  var EPSG900913 = extend({}, EPSG3857, {
  	code: 'EPSG:900913'
  });

  // @namespace SVG; @section
  // There are several static functions which can be called without instantiating L.SVG:

  // @function create(name: String): SVGElement
  // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
  // corresponding to the class name passed. For example, using 'line' will return
  // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
  function svgCreate(name) {
  	return document.createElementNS('http://www.w3.org/2000/svg', name);
  }

  // @function pointsToPath(rings: Point[], closed: Boolean): String
  // Generates a SVG path string for multiple rings, with each ring turning
  // into "M..L..L.." instructions
  function pointsToPath(rings, closed) {
  	var str = '',
  	i, j, len, len2, points, p;

  	for (i = 0, len = rings.length; i < len; i++) {
  		points = rings[i];

  		for (j = 0, len2 = points.length; j < len2; j++) {
  			p = points[j];
  			str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
  		}

  		// closes the ring for polygons; "x" is VML syntax
  		str += closed ? (Browser.svg ? 'z' : 'x') : '';
  	}

  	// SVG complains about empty path strings
  	return str || 'M0 0';
  }

  /*
   * @namespace Browser
   * @aka L.Browser
   *
   * A namespace with static properties for browser/feature detection used by Leaflet internally.
   *
   * @example
   *
   * ```js
   * if (L.Browser.ielt9) {
   *   alert('Upgrade your browser, dude!');
   * }
   * ```
   */

  var style = document.documentElement.style;

  // @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).
  var ie = 'ActiveXObject' in window;

  // @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.
  var ielt9 = ie && !document.addEventListener;

  // @property edge: Boolean; `true` for the Edge web browser.
  var edge = 'msLaunchUri' in navigator && !('documentMode' in document);

  // @property webkit: Boolean;
  // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
  var webkit = userAgentContains('webkit');

  // @property android: Boolean
  // **Deprecated.** `true` for any browser running on an Android platform.
  var android = userAgentContains('android');

  // @property android23: Boolean; **Deprecated.** `true` for browsers running on Android 2 or Android 3.
  var android23 = userAgentContains('android 2') || userAgentContains('android 3');

  /* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */
  var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit
  // @property androidStock: Boolean; **Deprecated.** `true` for the Android stock browser (i.e. not Chrome)
  var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window);

  // @property opera: Boolean; `true` for the Opera browser
  var opera = !!window.opera;

  // @property chrome: Boolean; `true` for the Chrome browser.
  var chrome = !edge && userAgentContains('chrome');

  // @property gecko: Boolean; `true` for gecko-based browsers like Firefox.
  var gecko = userAgentContains('gecko') && !webkit && !opera && !ie;

  // @property safari: Boolean; `true` for the Safari browser.
  var safari = !chrome && userAgentContains('safari');

  var phantom = userAgentContains('phantom');

  // @property opera12: Boolean
  // `true` for the Opera browser supporting CSS transforms (version 12 or later).
  var opera12 = 'OTransition' in style;

  // @property win: Boolean; `true` when the browser is running in a Windows platform
  var win = navigator.platform.indexOf('Win') === 0;

  // @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.
  var ie3d = ie && ('transition' in style);

  // @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.
  var webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23;

  // @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.
  var gecko3d = 'MozPerspective' in style;

  // @property any3d: Boolean
  // `true` for all browsers supporting CSS transforms.
  var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;

  // @property mobile: Boolean; `true` for all browsers running in a mobile device.
  var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile');

  // @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.
  var mobileWebkit = mobile && webkit;

  // @property mobileWebkit3d: Boolean
  // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
  var mobileWebkit3d = mobile && webkit3d;

  // @property msPointer: Boolean
  // `true` for browsers implementing the Microsoft touch events model (notably IE10).
  var msPointer = !window.PointerEvent && window.MSPointerEvent;

  // @property pointer: Boolean
  // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
  var pointer = !!(window.PointerEvent || msPointer);

  // @property touchNative: Boolean
  // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
  // **This does not necessarily mean** that the browser is running in a computer with
  // a touchscreen, it only means that the browser is capable of understanding
  // touch events.
  var touchNative = 'ontouchstart' in window || !!window.TouchEvent;

  // @property touch: Boolean
  // `true` for all browsers supporting either [touch](#browser-touch) or [pointer](#browser-pointer) events.
  // Note: pointer events will be preferred (if available), and processed for all `touch*` listeners.
  var touch = !window.L_NO_TOUCH && (touchNative || pointer);

  // @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.
  var mobileOpera = mobile && opera;

  // @property mobileGecko: Boolean
  // `true` for gecko-based browsers running in a mobile device.
  var mobileGecko = mobile && gecko;

  // @property retina: Boolean
  // `true` for browsers on a high-resolution "retina" screen or on any screen when browser's display zoom is more than 100%.
  var retina = (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1;

  // @property passiveEvents: Boolean
  // `true` for browsers that support passive events.
  var passiveEvents = (function () {
  	var supportsPassiveOption = false;
  	try {
  		var opts = Object.defineProperty({}, 'passive', {
  			get: function () { // eslint-disable-line getter-return
  				supportsPassiveOption = true;
  			}
  		});
  		window.addEventListener('testPassiveEventSupport', falseFn, opts);
  		window.removeEventListener('testPassiveEventSupport', falseFn, opts);
  	} catch (e) {
  		// Errors can safely be ignored since this is only a browser support test.
  	}
  	return supportsPassiveOption;
  }());

  // @property canvas: Boolean
  // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
  var canvas$1 = (function () {
  	return !!document.createElement('canvas').getContext;
  }());

  // @property svg: Boolean
  // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
  var svg$1 = !!(document.createElementNS && svgCreate('svg').createSVGRect);

  var inlineSvg = !!svg$1 && (function () {
  	var div = document.createElement('div');
  	div.innerHTML = '<svg/>';
  	return (div.firstChild && div.firstChild.namespaceURI) === 'http://www.w3.org/2000/svg';
  })();

  // @property vml: Boolean
  // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
  var vml = !svg$1 && (function () {
  	try {
  		var div = document.createElement('div');
  		div.innerHTML = '<v:shape adj="1"/>';

  		var shape = div.firstChild;
  		shape.style.behavior = 'url(#default#VML)';

  		return shape && (typeof shape.adj === 'object');

  	} catch (e) {
  		return false;
  	}
  }());


  // @property mac: Boolean; `true` when the browser is running in a Mac platform
  var mac = navigator.platform.indexOf('Mac') === 0;

  // @property mac: Boolean; `true` when the browser is running in a Linux platform
  var linux = navigator.platform.indexOf('Linux') === 0;

  function userAgentContains(str) {
  	return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
  }


  var Browser = {
  	ie: ie,
  	ielt9: ielt9,
  	edge: edge,
  	webkit: webkit,
  	android: android,
  	android23: android23,
  	androidStock: androidStock,
  	opera: opera,
  	chrome: chrome,
  	gecko: gecko,
  	safari: safari,
  	phantom: phantom,
  	opera12: opera12,
  	win: win,
  	ie3d: ie3d,
  	webkit3d: webkit3d,
  	gecko3d: gecko3d,
  	any3d: any3d,
  	mobile: mobile,
  	mobileWebkit: mobileWebkit,
  	mobileWebkit3d: mobileWebkit3d,
  	msPointer: msPointer,
  	pointer: pointer,
  	touch: touch,
  	touchNative: touchNative,
  	mobileOpera: mobileOpera,
  	mobileGecko: mobileGecko,
  	retina: retina,
  	passiveEvents: passiveEvents,
  	canvas: canvas$1,
  	svg: svg$1,
  	vml: vml,
  	inlineSvg: inlineSvg,
  	mac: mac,
  	linux: linux
  };

  /*
   * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
   */

  var POINTER_DOWN =   Browser.msPointer ? 'MSPointerDown'   : 'pointerdown';
  var POINTER_MOVE =   Browser.msPointer ? 'MSPointerMove'   : 'pointermove';
  var POINTER_UP =     Browser.msPointer ? 'MSPointerUp'     : 'pointerup';
  var POINTER_CANCEL = Browser.msPointer ? 'MSPointerCancel' : 'pointercancel';
  var pEvent = {
  	touchstart  : POINTER_DOWN,
  	touchmove   : POINTER_MOVE,
  	touchend    : POINTER_UP,
  	touchcancel : POINTER_CANCEL
  };
  var handle = {
  	touchstart  : _onPointerStart,
  	touchmove   : _handlePointer,
  	touchend    : _handlePointer,
  	touchcancel : _handlePointer
  };
  var _pointers = {};
  var _pointerDocListener = false;

  // Provides a touch events wrapper for (ms)pointer events.
  // ref https://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

  function addPointerListener(obj, type, handler) {
  	if (type === 'touchstart') {
  		_addPointerDocListener();
  	}
  	if (!handle[type]) {
  		console.warn('wrong event specified:', type);
  		return falseFn;
  	}
  	handler = handle[type].bind(this, handler);
  	obj.addEventListener(pEvent[type], handler, false);
  	return handler;
  }

  function removePointerListener(obj, type, handler) {
  	if (!pEvent[type]) {
  		console.warn('wrong event specified:', type);
  		return;
  	}
  	obj.removeEventListener(pEvent[type], handler, false);
  }

  function _globalPointerDown(e) {
  	_pointers[e.pointerId] = e;
  }

  function _globalPointerMove(e) {
  	if (_pointers[e.pointerId]) {
  		_pointers[e.pointerId] = e;
  	}
  }

  function _globalPointerUp(e) {
  	delete _pointers[e.pointerId];
  }

  function _addPointerDocListener() {
  	// need to keep track of what pointers and how many are active to provide e.touches emulation
  	if (!_pointerDocListener) {
  		// we listen document as any drags that end by moving the touch off the screen get fired there
  		document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
  		document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
  		document.addEventListener(POINTER_UP, _globalPointerUp, true);
  		document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);

  		_pointerDocListener = true;
  	}
  }

  function _handlePointer(handler, e) {
  	if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || 'mouse')) { return; }

  	e.touches = [];
  	for (var i in _pointers) {
  		e.touches.push(_pointers[i]);
  	}
  	e.changedTouches = [e];

  	handler(e);
  }

  function _onPointerStart(handler, e) {
  	// IE10 specific: MsTouch needs preventDefault. See #2000
  	if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {
  		preventDefault(e);
  	}
  	_handlePointer(handler, e);
  }

  /*
   * Extends the event handling code with double tap support for mobile browsers.
   *
   * Note: currently most browsers fire native dblclick, with only a few exceptions
   * (see https://github.com/Leaflet/Leaflet/issues/7012#issuecomment-595087386)
   */

  function makeDblclick(event) {
  	// in modern browsers `type` cannot be just overridden:
  	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only
  	var newEvent = {},
  	    prop, i;
  	for (i in event) {
  		prop = event[i];
  		newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;
  	}
  	event = newEvent;
  	newEvent.type = 'dblclick';
  	newEvent.detail = 2;
  	newEvent.isTrusted = false;
  	newEvent._simulated = true; // for debug purposes
  	return newEvent;
  }

  var delay = 200;
  function addDoubleTapListener(obj, handler) {
  	// Most browsers handle double tap natively
  	obj.addEventListener('dblclick', handler);

  	// On some platforms the browser doesn't fire native dblclicks for touch events.
  	// It seems that in all such cases `detail` property of `click` event is always `1`.
  	// So here we rely on that fact to avoid excessive 'dblclick' simulation when not needed.
  	var last = 0,
  	    detail;
  	function simDblclick(e) {
  		if (e.detail !== 1) {
  			detail = e.detail; // keep in sync to avoid false dblclick in some cases
  			return;
  		}

  		if (e.pointerType === 'mouse' ||
  			(e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents)) {

  			return;
  		}

  		// When clicking on an <input>, the browser generates a click on its
  		// <label> (and vice versa) triggering two clicks in quick succession.
  		// This ignores clicks on elements which are a label with a 'for'
  		// attribute (or children of such a label), but not children of
  		// a <input>.
  		var path = getPropagationPath(e);
  		if (path.some(function (el) {
  			return el instanceof HTMLLabelElement && el.attributes.for;
  		}) &&
  			!path.some(function (el) {
  				return (
  					el instanceof HTMLInputElement ||
  					el instanceof HTMLSelectElement
  				);
  			})
  		) {
  			return;
  		}

  		var now = Date.now();
  		if (now - last <= delay) {
  			detail++;
  			if (detail === 2) {
  				handler(makeDblclick(e));
  			}
  		} else {
  			detail = 1;
  		}
  		last = now;
  	}

  	obj.addEventListener('click', simDblclick);

  	return {
  		dblclick: handler,
  		simDblclick: simDblclick
  	};
  }

  function removeDoubleTapListener(obj, handlers) {
  	obj.removeEventListener('dblclick', handlers.dblclick);
  	obj.removeEventListener('click', handlers.simDblclick);
  }

  /*
   * @namespace DomUtil
   *
   * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
   * tree, used by Leaflet internally.
   *
   * Most functions expecting or returning a `HTMLElement` also work for
   * SVG elements. The only difference is that classes refer to CSS classes
   * in HTML and SVG classes in SVG.
   */


  // @property TRANSFORM: String
  // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).
  var TRANSFORM = testProp(
  	['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

  // webkitTransition comes first because some browser versions that drop vendor prefix don't do
  // the same for the transitionend event, in particular the Android 4.1 stock browser

  // @property TRANSITION: String
  // Vendor-prefixed transition style name.
  var TRANSITION = testProp(
  	['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

  // @property TRANSITION_END: String
  // Vendor-prefixed transitionend event name.
  var TRANSITION_END =
  	TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';


  // @function get(id: String|HTMLElement): HTMLElement
  // Returns an element given its DOM id, or returns the element itself
  // if it was passed directly.
  function get(id) {
  	return typeof id === 'string' ? document.getElementById(id) : id;
  }

  // @function getStyle(el: HTMLElement, styleAttrib: String): String
  // Returns the value for a certain style attribute on an element,
  // including computed values or values set through CSS.
  function getStyle(el, style) {
  	var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

  	if ((!value || value === 'auto') && document.defaultView) {
  		var css = document.defaultView.getComputedStyle(el, null);
  		value = css ? css[style] : null;
  	}
  	return value === 'auto' ? null : value;
  }

  // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
  // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
  function create$1(tagName, className, container) {
  	var el = document.createElement(tagName);
  	el.className = className || '';

  	if (container) {
  		container.appendChild(el);
  	}
  	return el;
  }

  // @function remove(el: HTMLElement)
  // Removes `el` from its parent element
  function remove(el) {
  	var parent = el.parentNode;
  	if (parent) {
  		parent.removeChild(el);
  	}
  }

  // @function empty(el: HTMLElement)
  // Removes all of `el`'s children elements from `el`
  function empty(el) {
  	while (el.firstChild) {
  		el.removeChild(el.firstChild);
  	}
  }

  // @function toFront(el: HTMLElement)
  // Makes `el` the last child of its parent, so it renders in front of the other children.
  function toFront(el) {
  	var parent = el.parentNode;
  	if (parent && parent.lastChild !== el) {
  		parent.appendChild(el);
  	}
  }

  // @function toBack(el: HTMLElement)
  // Makes `el` the first child of its parent, so it renders behind the other children.
  function toBack(el) {
  	var parent = el.parentNode;
  	if (parent && parent.firstChild !== el) {
  		parent.insertBefore(el, parent.firstChild);
  	}
  }

  // @function hasClass(el: HTMLElement, name: String): Boolean
  // Returns `true` if the element's class attribute contains `name`.
  function hasClass(el, name) {
  	if (el.classList !== undefined) {
  		return el.classList.contains(name);
  	}
  	var className = getClass(el);
  	return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
  }

  // @function addClass(el: HTMLElement, name: String)
  // Adds `name` to the element's class attribute.
  function addClass(el, name) {
  	if (el.classList !== undefined) {
  		var classes = splitWords(name);
  		for (var i = 0, len = classes.length; i < len; i++) {
  			el.classList.add(classes[i]);
  		}
  	} else if (!hasClass(el, name)) {
  		var className = getClass(el);
  		setClass(el, (className ? className + ' ' : '') + name);
  	}
  }

  // @function removeClass(el: HTMLElement, name: String)
  // Removes `name` from the element's class attribute.
  function removeClass(el, name) {
  	if (el.classList !== undefined) {
  		el.classList.remove(name);
  	} else {
  		setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
  	}
  }

  // @function setClass(el: HTMLElement, name: String)
  // Sets the element's class.
  function setClass(el, name) {
  	if (el.className.baseVal === undefined) {
  		el.className = name;
  	} else {
  		// in case of SVG element
  		el.className.baseVal = name;
  	}
  }

  // @function getClass(el: HTMLElement): String
  // Returns the element's class.
  function getClass(el) {
  	// Check if the element is an SVGElementInstance and use the correspondingElement instead
  	// (Required for linked SVG elements in IE11.)
  	if (el.correspondingElement) {
  		el = el.correspondingElement;
  	}
  	return el.className.baseVal === undefined ? el.className : el.className.baseVal;
  }

  // @function setOpacity(el: HTMLElement, opacity: Number)
  // Set the opacity of an element (including old IE support).
  // `opacity` must be a number from `0` to `1`.
  function setOpacity(el, value) {
  	if ('opacity' in el.style) {
  		el.style.opacity = value;
  	} else if ('filter' in el.style) {
  		_setOpacityIE(el, value);
  	}
  }

  function _setOpacityIE(el, value) {
  	var filter = false,
  	    filterName = 'DXImageTransform.Microsoft.Alpha';

  	// filters collection throws an error if we try to retrieve a filter that doesn't exist
  	try {
  		filter = el.filters.item(filterName);
  	} catch (e) {
  		// don't set opacity to 1 if we haven't already set an opacity,
  		// it isn't needed and breaks transparent pngs.
  		if (value === 1) { return; }
  	}

  	value = Math.round(value * 100);

  	if (filter) {
  		filter.Enabled = (value !== 100);
  		filter.Opacity = value;
  	} else {
  		el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
  	}
  }

  // @function testProp(props: String[]): String|false
  // Goes through the array of style names and returns the first name
  // that is a valid style name for an element. If no such name is found,
  // it returns false. Useful for vendor-prefixed styles like `transform`.
  function testProp(props) {
  	var style = document.documentElement.style;

  	for (var i = 0; i < props.length; i++) {
  		if (props[i] in style) {
  			return props[i];
  		}
  	}
  	return false;
  }

  // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
  // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
  // and optionally scaled by `scale`. Does not have an effect if the
  // browser doesn't support 3D CSS transforms.
  function setTransform(el, offset, scale) {
  	var pos = offset || new Point(0, 0);

  	el.style[TRANSFORM] =
  		(Browser.ie3d ?
  			'translate(' + pos.x + 'px,' + pos.y + 'px)' :
  			'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +
  		(scale ? ' scale(' + scale + ')' : '');
  }

  // @function setPosition(el: HTMLElement, position: Point)
  // Sets the position of `el` to coordinates specified by `position`,
  // using CSS translate or top/left positioning depending on the browser
  // (used by Leaflet internally to position its layers).
  function setPosition(el, point) {

  	/*eslint-disable */
  	el._leaflet_pos = point;
  	/* eslint-enable */

  	if (Browser.any3d) {
  		setTransform(el, point);
  	} else {
  		el.style.left = point.x + 'px';
  		el.style.top = point.y + 'px';
  	}
  }

  // @function getPosition(el: HTMLElement): Point
  // Returns the coordinates of an element previously positioned with setPosition.
  function getPosition(el) {
  	// this method is only used for elements previously positioned using setPosition,
  	// so it's safe to cache the position for performance

  	return el._leaflet_pos || new Point(0, 0);
  }

  // @function disableTextSelection()
  // Prevents the user from generating `selectstart` DOM events, usually generated
  // when the user drags the mouse through a page with text. Used internally
  // by Leaflet to override the behaviour of any click-and-drag interaction on
  // the map. Affects drag interactions on the whole document.

  // @function enableTextSelection()
  // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
  var disableTextSelection;
  var enableTextSelection;
  var _userSelect;
  if ('onselectstart' in document) {
  	disableTextSelection = function () {
  		on(window, 'selectstart', preventDefault);
  	};
  	enableTextSelection = function () {
  		off(window, 'selectstart', preventDefault);
  	};
  } else {
  	var userSelectProperty = testProp(
  		['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

  	disableTextSelection = function () {
  		if (userSelectProperty) {
  			var style = document.documentElement.style;
  			_userSelect = style[userSelectProperty];
  			style[userSelectProperty] = 'none';
  		}
  	};
  	enableTextSelection = function () {
  		if (userSelectProperty) {
  			document.documentElement.style[userSelectProperty] = _userSelect;
  			_userSelect = undefined;
  		}
  	};
  }

  // @function disableImageDrag()
  // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
  // for `dragstart` DOM events, usually generated when the user drags an image.
  function disableImageDrag() {
  	on(window, 'dragstart', preventDefault);
  }

  // @function enableImageDrag()
  // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
  function enableImageDrag() {
  	off(window, 'dragstart', preventDefault);
  }

  var _outlineElement, _outlineStyle;
  // @function preventOutline(el: HTMLElement)
  // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
  // of the element `el` invisible. Used internally by Leaflet to prevent
  // focusable elements from displaying an outline when the user performs a
  // drag interaction on them.
  function preventOutline(element) {
  	while (element.tabIndex === -1) {
  		element = element.parentNode;
  	}
  	if (!element.style) { return; }
  	restoreOutline();
  	_outlineElement = element;
  	_outlineStyle = element.style.outlineStyle;
  	element.style.outlineStyle = 'none';
  	on(window, 'keydown', restoreOutline);
  }

  // @function restoreOutline()
  // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
  function restoreOutline() {
  	if (!_outlineElement) { return; }
  	_outlineElement.style.outlineStyle = _outlineStyle;
  	_outlineElement = undefined;
  	_outlineStyle = undefined;
  	off(window, 'keydown', restoreOutline);
  }

  // @function getSizedParentNode(el: HTMLElement): HTMLElement
  // Finds the closest parent node which size (width and height) is not null.
  function getSizedParentNode(element) {
  	do {
  		element = element.parentNode;
  	} while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
  	return element;
  }

  // @function getScale(el: HTMLElement): Object
  // Computes the CSS scale currently applied on the element.
  // Returns an object with `x` and `y` members as horizontal and vertical scales respectively,
  // and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).
  function getScale(element) {
  	var rect = element.getBoundingClientRect(); // Read-only in old browsers.

  	return {
  		x: rect.width / element.offsetWidth || 1,
  		y: rect.height / element.offsetHeight || 1,
  		boundingClientRect: rect
  	};
  }

  var DomUtil = {
    __proto__: null,
    TRANSFORM: TRANSFORM,
    TRANSITION: TRANSITION,
    TRANSITION_END: TRANSITION_END,
    get: get,
    getStyle: getStyle,
    create: create$1,
    remove: remove,
    empty: empty,
    toFront: toFront,
    toBack: toBack,
    hasClass: hasClass,
    addClass: addClass,
    removeClass: removeClass,
    setClass: setClass,
    getClass: getClass,
    setOpacity: setOpacity,
    testProp: testProp,
    setTransform: setTransform,
    setPosition: setPosition,
    getPosition: getPosition,
    get disableTextSelection () { return disableTextSelection; },
    get enableTextSelection () { return enableTextSelection; },
    disableImageDrag: disableImageDrag,
    enableImageDrag: enableImageDrag,
    preventOutline: preventOutline,
    restoreOutline: restoreOutline,
    getSizedParentNode: getSizedParentNode,
    getScale: getScale
  };

  /*
   * @namespace DomEvent
   * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
   */

  // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.

  // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
  // Adds a listener function (`fn`) to a particular DOM event type of the
  // element `el`. You can optionally specify the context of the listener
  // (object the `this` keyword will point to). You can also pass several
  // space-separated types (e.g. `'click dblclick'`).

  // @alternative
  // @function on(el: HTMLElement, eventMap: Object, context?: Object): this
  // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
  function on(obj, types, fn, context) {

  	if (types && typeof types === 'object') {
  		for (var type in types) {
  			addOne(obj, type, types[type], fn);
  		}
  	} else {
  		types = splitWords(types);

  		for (var i = 0, len = types.length; i < len; i++) {
  			addOne(obj, types[i], fn, context);
  		}
  	}

  	return this;
  }

  var eventsKey = '_leaflet_events';

  // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
  // Removes a previously added listener function.
  // Note that if you passed a custom context to on, you must pass the same
  // context to `off` in order to remove the listener.

  // @alternative
  // @function off(el: HTMLElement, eventMap: Object, context?: Object): this
  // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`

  // @alternative
  // @function off(el: HTMLElement, types: String): this
  // Removes all previously added listeners of given types.

  // @alternative
  // @function off(el: HTMLElement): this
  // Removes all previously added listeners from given HTMLElement
  function off(obj, types, fn, context) {

  	if (arguments.length === 1) {
  		batchRemove(obj);
  		delete obj[eventsKey];

  	} else if (types && typeof types === 'object') {
  		for (var type in types) {
  			removeOne(obj, type, types[type], fn);
  		}

  	} else {
  		types = splitWords(types);

  		if (arguments.length === 2) {
  			batchRemove(obj, function (type) {
  				return indexOf(types, type) !== -1;
  			});
  		} else {
  			for (var i = 0, len = types.length; i < len; i++) {
  				removeOne(obj, types[i], fn, context);
  			}
  		}
  	}

  	return this;
  }

  function batchRemove(obj, filterFn) {
  	for (var id in obj[eventsKey]) {
  		var type = id.split(/\d/)[0];
  		if (!filterFn || filterFn(type)) {
  			removeOne(obj, type, null, null, id);
  		}
  	}
  }

  var mouseSubst = {
  	mouseenter: 'mouseover',
  	mouseleave: 'mouseout',
  	wheel: !('onwheel' in window) && 'mousewheel'
  };

  function addOne(obj, type, fn, context) {
  	var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');

  	if (obj[eventsKey] && obj[eventsKey][id]) { return this; }

  	var handler = function (e) {
  		return fn.call(context || obj, e || window.event);
  	};

  	var originalHandler = handler;

  	if (!Browser.touchNative && Browser.pointer && type.indexOf('touch') === 0) {
  		// Needs DomEvent.Pointer.js
  		handler = addPointerListener(obj, type, handler);

  	} else if (Browser.touch && (type === 'dblclick')) {
  		handler = addDoubleTapListener(obj, handler);

  	} else if ('addEventListener' in obj) {

  		if (type === 'touchstart' || type === 'touchmove' || type === 'wheel' ||  type === 'mousewheel') {
  			obj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? {passive: false} : false);

  		} else if (type === 'mouseenter' || type === 'mouseleave') {
  			handler = function (e) {
  				e = e || window.event;
  				if (isExternalTarget(obj, e)) {
  					originalHandler(e);
  				}
  			};
  			obj.addEventListener(mouseSubst[type], handler, false);

  		} else {
  			obj.addEventListener(type, originalHandler, false);
  		}

  	} else {
  		obj.attachEvent('on' + type, handler);
  	}

  	obj[eventsKey] = obj[eventsKey] || {};
  	obj[eventsKey][id] = handler;
  }

  function removeOne(obj, type, fn, context, id) {
  	id = id || type + stamp(fn) + (context ? '_' + stamp(context) : '');
  	var handler = obj[eventsKey] && obj[eventsKey][id];

  	if (!handler) { return this; }

  	if (!Browser.touchNative && Browser.pointer && type.indexOf('touch') === 0) {
  		removePointerListener(obj, type, handler);

  	} else if (Browser.touch && (type === 'dblclick')) {
  		removeDoubleTapListener(obj, handler);

  	} else if ('removeEventListener' in obj) {

  		obj.removeEventListener(mouseSubst[type] || type, handler, false);

  	} else {
  		obj.detachEvent('on' + type, handler);
  	}

  	obj[eventsKey][id] = null;
  }

  // @function stopPropagation(ev: DOMEvent): this
  // Stop the given event from propagation to parent elements. Used inside the listener functions:
  // ```js
  // L.DomEvent.on(div, 'click', function (ev) {
  // 	L.DomEvent.stopPropagation(ev);
  // });
  // ```
  function stopPropagation(e) {

  	if (e.stopPropagation) {
  		e.stopPropagation();
  	} else if (e.originalEvent) {  // In case of Leaflet event.
  		e.originalEvent._stopped = true;
  	} else {
  		e.cancelBubble = true;
  	}

  	return this;
  }

  // @function disableScrollPropagation(el: HTMLElement): this
  // Adds `stopPropagation` to the element's `'wheel'` events (plus browser variants).
  function disableScrollPropagation(el) {
  	addOne(el, 'wheel', stopPropagation);
  	return this;
  }

  // @function disableClickPropagation(el: HTMLElement): this
  // Adds `stopPropagation` to the element's `'click'`, `'dblclick'`, `'contextmenu'`,
  // `'mousedown'` and `'touchstart'` events (plus browser variants).
  function disableClickPropagation(el) {
  	on(el, 'mousedown touchstart dblclick contextmenu', stopPropagation);
  	el['_leaflet_disable_click'] = true;
  	return this;
  }

  // @function preventDefault(ev: DOMEvent): this
  // Prevents the default action of the DOM Event `ev` from happening (such as
  // following a link in the href of the a element, or doing a POST request
  // with page reload when a `<form>` is submitted).
  // Use it inside listener functions.
  function preventDefault(e) {
  	if (e.preventDefault) {
  		e.preventDefault();
  	} else {
  		e.returnValue = false;
  	}
  	return this;
  }

  // @function stop(ev: DOMEvent): this
  // Does `stopPropagation` and `preventDefault` at the same time.
  function stop(e) {
  	preventDefault(e);
  	stopPropagation(e);
  	return this;
  }

  // @function getPropagationPath(ev: DOMEvent): Array
  // Compatibility polyfill for [`Event.composedPath()`](https://developer.mozilla.org/en-US/docs/Web/API/Event/composedPath).
  // Returns an array containing the `HTMLElement`s that the given DOM event
  // should propagate to (if not stopped).
  function getPropagationPath(ev) {
  	if (ev.composedPath) {
  		return ev.composedPath();
  	}

  	var path = [];
  	var el = ev.target;

  	while (el) {
  		path.push(el);
  		el = el.parentNode;
  	}
  	return path;
  }


  // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
  // Gets normalized mouse position from a DOM event relative to the
  // `container` (border excluded) or to the whole page if not specified.
  function getMousePosition(e, container) {
  	if (!container) {
  		return new Point(e.clientX, e.clientY);
  	}

  	var scale = getScale(container),
  	    offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)

  	return new Point(
  		// offset.left/top values are in page scale (like clientX/Y),
  		// whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
  		(e.clientX - offset.left) / scale.x - container.clientLeft,
  		(e.clientY - offset.top) / scale.y - container.clientTop
  	);
  }


  //  except , Safari and
  // We need double the scroll pixels (see #7403 and #4538) for all Browsers
  // except OSX (Mac) -> 3x, Chrome running on Linux 1x

  var wheelPxFactor =
  	(Browser.linux && Browser.chrome) ? window.devicePixelRatio :
  	Browser.mac ? window.devicePixelRatio * 3 :
  	window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
  // @function getWheelDelta(ev: DOMEvent): Number
  // Gets normalized wheel delta from a wheel DOM event, in vertical
  // pixels scrolled (negative if scrolling down).
  // Events from pointing devices without precise scrolling are mapped to
  // a best guess of 60 pixels.
  function getWheelDelta(e) {
  	return (Browser.edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
  	       (e.deltaY && e.deltaMode === 0) ? -e.deltaY / wheelPxFactor : // Pixels
  	       (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines
  	       (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages
  	       (e.deltaX || e.deltaZ) ? 0 :	// Skip horizontal/depth wheel events
  	       e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
  	       (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines
  	       e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
  	       0;
  }

  // check if element really left/entered the event target (for mouseenter/mouseleave)
  function isExternalTarget(el, e) {

  	var related = e.relatedTarget;

  	if (!related) { return true; }

  	try {
  		while (related && (related !== el)) {
  			related = related.parentNode;
  		}
  	} catch (err) {
  		return false;
  	}
  	return (related !== el);
  }

  var DomEvent = {
    __proto__: null,
    on: on,
    off: off,
    stopPropagation: stopPropagation,
    disableScrollPropagation: disableScrollPropagation,
    disableClickPropagation: disableClickPropagation,
    preventDefault: preventDefault,
    stop: stop,
    getPropagationPath: getPropagationPath,
    getMousePosition: getMousePosition,
    getWheelDelta: getWheelDelta,
    isExternalTarget: isExternalTarget,
    addListener: on,
    removeListener: off
  };

  /*
   * @class PosAnimation
   * @aka L.PosAnimation
   * @inherits Evented
   * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
   *
   * @example
   * ```js
   * var myPositionMarker = L.marker([48.864716, 2.294694]).addTo(map);
   *
   * myPositionMarker.on("click", function() {
   * 	var pos = map.latLngToLayerPoint(myPositionMarker.getLatLng());
   * 	pos.y -= 25;
   * 	var fx = new L.PosAnimation();
   *
   * 	fx.once('end',function() {
   * 		pos.y += 25;
   * 		fx.run(myPositionMarker._icon, pos, 0.8);
   * 	});
   *
   * 	fx.run(myPositionMarker._icon, pos, 0.3);
   * });
   *
   * ```
   *
   * @constructor L.PosAnimation()
   * Creates a `PosAnimation` object.
   *
   */

  var PosAnimation = Evented.extend({

  	// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
  	// Run an animation of a given element to a new position, optionally setting
  	// duration in seconds (`0.25` by default) and easing linearity factor (3rd
  	// argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
  	// `0.5` by default).
  	run: function (el, newPos, duration, easeLinearity) {
  		this.stop();

  		this._el = el;
  		this._inProgress = true;
  		this._duration = duration || 0.25;
  		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

  		this._startPos = getPosition(el);
  		this._offset = newPos.subtract(this._startPos);
  		this._startTime = +new Date();

  		// @event start: Event
  		// Fired when the animation starts
  		this.fire('start');

  		this._animate();
  	},

  	// @method stop()
  	// Stops the animation (if currently running).
  	stop: function () {
  		if (!this._inProgress) { return; }

  		this._step(true);
  		this._complete();
  	},

  	_animate: function () {
  		// animation loop
  		this._animId = requestAnimFrame(this._animate, this);
  		this._step();
  	},

  	_step: function (round) {
  		var elapsed = (+new Date()) - this._startTime,
  		    duration = this._duration * 1000;

  		if (elapsed < duration) {
  			this._runFrame(this._easeOut(elapsed / duration), round);
  		} else {
  			this._runFrame(1);
  			this._complete();
  		}
  	},

  	_runFrame: function (progress, round) {
  		var pos = this._startPos.add(this._offset.multiplyBy(progress));
  		if (round) {
  			pos._round();
  		}
  		setPosition(this._el, pos);

  		// @event step: Event
  		// Fired continuously during the animation.
  		this.fire('step');
  	},

  	_complete: function () {
  		cancelAnimFrame(this._animId);

  		this._inProgress = false;
  		// @event end: Event
  		// Fired when the animation ends.
  		this.fire('end');
  	},

  	_easeOut: function (t) {
  		return 1 - Math.pow(1 - t, this._easeOutPower);
  	}
  });

  /*
   * @class Map
   * @aka L.Map
   * @inherits Evented
   *
   * The central class of the API  it is used to create a map on a page and manipulate it.
   *
   * @example
   *
   * ```js
   * // initialize the map on the "map" div with a given center and zoom
   * var map = L.map('map', {
   * 	center: [51.505, -0.09],
   * 	zoom: 13
   * });
   * ```
   *
   */

  var Map = Evented.extend({

  	options: {
  		// @section Map State Options
  		// @option crs: CRS = L.CRS.EPSG3857
  		// The [Coordinate Reference System](#crs) to use. Don't change this if you're not
  		// sure what it means.
  		crs: EPSG3857,

  		// @option center: LatLng = undefined
  		// Initial geographic center of the map
  		center: undefined,

  		// @option zoom: Number = undefined
  		// Initial map zoom level
  		zoom: undefined,

  		// @option minZoom: Number = *
  		// Minimum zoom level of the map.
  		// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
  		// the lowest of their `minZoom` options will be used instead.
  		minZoom: undefined,

  		// @option maxZoom: Number = *
  		// Maximum zoom level of the map.
  		// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
  		// the highest of their `maxZoom` options will be used instead.
  		maxZoom: undefined,

  		// @option layers: Layer[] = []
  		// Array of layers that will be added to the map initially
  		layers: [],

  		// @option maxBounds: LatLngBounds = null
  		// When this option is set, the map restricts the view to the given
  		// geographical bounds, bouncing the user back if the user tries to pan
  		// outside the view. To set the restriction dynamically, use
  		// [`setMaxBounds`](#map-setmaxbounds) method.
  		maxBounds: undefined,

  		// @option renderer: Renderer = *
  		// The default method for drawing vector layers on the map. `L.SVG`
  		// or `L.Canvas` by default depending on browser support.
  		renderer: undefined,


  		// @section Animation Options
  		// @option zoomAnimation: Boolean = true
  		// Whether the map zoom animation is enabled. By default it's enabled
  		// in all browsers that support CSS3 Transitions except Android.
  		zoomAnimation: true,

  		// @option zoomAnimationThreshold: Number = 4
  		// Won't animate zoom if the zoom difference exceeds this value.
  		zoomAnimationThreshold: 4,

  		// @option fadeAnimation: Boolean = true
  		// Whether the tile fade animation is enabled. By default it's enabled
  		// in all browsers that support CSS3 Transitions except Android.
  		fadeAnimation: true,

  		// @option markerZoomAnimation: Boolean = true
  		// Whether markers animate their zoom with the zoom animation, if disabled
  		// they will disappear for the length of the animation. By default it's
  		// enabled in all browsers that support CSS3 Transitions except Android.
  		markerZoomAnimation: true,

  		// @option transform3DLimit: Number = 2^23
  		// Defines the maximum size of a CSS translation transform. The default
  		// value should not be changed unless a web browser positions layers in
  		// the wrong place after doing a large `panBy`.
  		transform3DLimit: 8388608, // Precision limit of a 32-bit float

  		// @section Interaction Options
  		// @option zoomSnap: Number = 1
  		// Forces the map's zoom level to always be a multiple of this, particularly
  		// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
  		// By default, the zoom level snaps to the nearest integer; lower values
  		// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
  		// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
  		zoomSnap: 1,

  		// @option zoomDelta: Number = 1
  		// Controls how much the map's zoom level will change after a
  		// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
  		// or `-` on the keyboard, or using the [zoom controls](#control-zoom).
  		// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
  		zoomDelta: 1,

  		// @option trackResize: Boolean = true
  		// Whether the map automatically handles browser window resize to update itself.
  		trackResize: true
  	},

  	initialize: function (id, options) { // (HTMLElement or String, Object)
  		options = setOptions(this, options);

  		// Make sure to assign internal flags at the beginning,
  		// to avoid inconsistent state in some edge cases.
  		this._handlers = [];
  		this._layers = {};
  		this._zoomBoundLayers = {};
  		this._sizeChanged = true;

  		this._initContainer(id);
  		this._initLayout();

  		// hack for https://github.com/Leaflet/Leaflet/issues/1980
  		this._onResize = bind(this._onResize, this);

  		this._initEvents();

  		if (options.maxBounds) {
  			this.setMaxBounds(options.maxBounds);
  		}

  		if (options.zoom !== undefined) {
  			this._zoom = this._limitZoom(options.zoom);
  		}

  		if (options.center && options.zoom !== undefined) {
  			this.setView(toLatLng(options.center), options.zoom, {reset: true});
  		}

  		this.callInitHooks();

  		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
  		this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera &&
  				this.options.zoomAnimation;

  		// zoom transitions run with the same duration for all layers, so if one of transitionend events
  		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
  		if (this._zoomAnimated) {
  			this._createAnimProxy();
  			on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
  		}

  		this._addLayers(this.options.layers);
  	},


  	// @section Methods for modifying map state

  	// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
  	// Sets the view of the map (geographical center and zoom) with the given
  	// animation options.
  	setView: function (center, zoom, options) {

  		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
  		center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);
  		options = options || {};

  		this._stop();

  		if (this._loaded && !options.reset && options !== true) {

  			if (options.animate !== undefined) {
  				options.zoom = extend({animate: options.animate}, options.zoom);
  				options.pan = extend({animate: options.animate, duration: options.duration}, options.pan);
  			}

  			// try animating pan or zoom
  			var moved = (this._zoom !== zoom) ?
  				this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
  				this._tryAnimatedPan(center, options.pan);

  			if (moved) {
  				// prevent resize handler call, the view will refresh after animation anyway
  				clearTimeout(this._sizeTimer);
  				return this;
  			}
  		}

  		// animation didn't start, just reset the map view
  		this._resetView(center, zoom, options.pan && options.pan.noMoveStart);

  		return this;
  	},

  	// @method setZoom(zoom: Number, options?: Zoom/pan options): this
  	// Sets the zoom of the map.
  	setZoom: function (zoom, options) {
  		if (!this._loaded) {
  			this._zoom = zoom;
  			return this;
  		}
  		return this.setView(this.getCenter(), zoom, {zoom: options});
  	},

  	// @method zoomIn(delta?: Number, options?: Zoom options): this
  	// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
  	zoomIn: function (delta, options) {
  		delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
  		return this.setZoom(this._zoom + delta, options);
  	},

  	// @method zoomOut(delta?: Number, options?: Zoom options): this
  	// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
  	zoomOut: function (delta, options) {
  		delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
  		return this.setZoom(this._zoom - delta, options);
  	},

  	// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
  	// Zooms the map while keeping a specified geographical point on the map
  	// stationary (e.g. used internally for scroll zoom and double-click zoom).
  	// @alternative
  	// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
  	// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
  	setZoomAround: function (latlng, zoom, options) {
  		var scale = this.getZoomScale(zoom),
  		    viewHalf = this.getSize().divideBy(2),
  		    containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),

  		    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
  		    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

  		return this.setView(newCenter, zoom, {zoom: options});
  	},

  	_getBoundsCenterZoom: function (bounds, options) {

  		options = options || {};
  		bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);

  		var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
  		    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),

  		    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

  		zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;

  		if (zoom === Infinity) {
  			return {
  				center: bounds.getCenter(),
  				zoom: zoom
  			};
  		}

  		var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

  		    swPoint = this.project(bounds.getSouthWest(), zoom),
  		    nePoint = this.project(bounds.getNorthEast(), zoom),
  		    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

  		return {
  			center: center,
  			zoom: zoom
  		};
  	},

  	// @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
  	// Sets a map view that contains the given geographical bounds with the
  	// maximum zoom level possible.
  	fitBounds: function (bounds, options) {

  		bounds = toLatLngBounds(bounds);

  		if (!bounds.isValid()) {
  			throw new Error('Bounds are not valid.');
  		}

  		var target = this._getBoundsCenterZoom(bounds, options);
  		return this.setView(target.center, target.zoom, options);
  	},

  	// @method fitWorld(options?: fitBounds options): this
  	// Sets a map view that mostly contains the whole world with the maximum
  	// zoom level possible.
  	fitWorld: function (options) {
  		return this.fitBounds([[-90, -180], [90, 180]], options);
  	},

  	// @method panTo(latlng: LatLng, options?: Pan options): this
  	// Pans the map to a given center.
  	panTo: function (center, options) { // (LatLng)
  		return this.setView(center, this._zoom, {pan: options});
  	},

  	// @method panBy(offset: Point, options?: Pan options): this
  	// Pans the map by a given number of pixels (animated).
  	panBy: function (offset, options) {
  		offset = toPoint(offset).round();
  		options = options || {};

  		if (!offset.x && !offset.y) {
  			return this.fire('moveend');
  		}
  		// If we pan too far, Chrome gets issues with tiles
  		// and makes them disappear or appear in the wrong place (slightly offset) #2602
  		if (options.animate !== true && !this.getSize().contains(offset)) {
  			this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
  			return this;
  		}

  		if (!this._panAnim) {
  			this._panAnim = new PosAnimation();

  			this._panAnim.on({
  				'step': this._onPanTransitionStep,
  				'end': this._onPanTransitionEnd
  			}, this);
  		}

  		// don't fire movestart if animating inertia
  		if (!options.noMoveStart) {
  			this.fire('movestart');
  		}

  		// animate pan unless animate: false specified
  		if (options.animate !== false) {
  			addClass(this._mapPane, 'leaflet-pan-anim');

  			var newPos = this._getMapPanePos().subtract(offset).round();
  			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
  		} else {
  			this._rawPanBy(offset);
  			this.fire('move').fire('moveend');
  		}

  		return this;
  	},

  	// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
  	// Sets the view of the map (geographical center and zoom) performing a smooth
  	// pan-zoom animation.
  	flyTo: function (targetCenter, targetZoom, options) {

  		options = options || {};
  		if (options.animate === false || !Browser.any3d) {
  			return this.setView(targetCenter, targetZoom, options);
  		}

  		this._stop();

  		var from = this.project(this.getCenter()),
  		    to = this.project(targetCenter),
  		    size = this.getSize(),
  		    startZoom = this._zoom;

  		targetCenter = toLatLng(targetCenter);
  		targetZoom = targetZoom === undefined ? startZoom : targetZoom;

  		var w0 = Math.max(size.x, size.y),
  		    w1 = w0 * this.getZoomScale(startZoom, targetZoom),
  		    u1 = (to.distanceTo(from)) || 1,
  		    rho = 1.42,
  		    rho2 = rho * rho;

  		function r(i) {
  			var s1 = i ? -1 : 1,
  			    s2 = i ? w1 : w0,
  			    t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
  			    b1 = 2 * s2 * rho2 * u1,
  			    b = t1 / b1,
  			    sq = Math.sqrt(b * b + 1) - b;

  			    // workaround for floating point precision bug when sq = 0, log = -Infinite,
  			    // thus triggering an infinite loop in flyTo
  			    var log = sq < 0.000000001 ? -18 : Math.log(sq);

  			return log;
  		}

  		function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
  		function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
  		function tanh(n) { return sinh(n) / cosh(n); }

  		var r0 = r(0);

  		function w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }
  		function u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }

  		function easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }

  		var start = Date.now(),
  		    S = (r(1) - r0) / rho,
  		    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

  		function frame() {
  			var t = (Date.now() - start) / duration,
  			    s = easeOut(t) * S;

  			if (t <= 1) {
  				this._flyToFrame = requestAnimFrame(frame, this);

  				this._move(
  					this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
  					this.getScaleZoom(w0 / w(s), startZoom),
  					{flyTo: true});

  			} else {
  				this
  					._move(targetCenter, targetZoom)
  					._moveEnd(true);
  			}
  		}

  		this._moveStart(true, options.noMoveStart);

  		frame.call(this);
  		return this;
  	},

  	// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
  	// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
  	// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
  	flyToBounds: function (bounds, options) {
  		var target = this._getBoundsCenterZoom(bounds, options);
  		return this.flyTo(target.center, target.zoom, options);
  	},

  	// @method setMaxBounds(bounds: LatLngBounds): this
  	// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
  	setMaxBounds: function (bounds) {
  		bounds = toLatLngBounds(bounds);

  		if (this.listens('moveend', this._panInsideMaxBounds)) {
  			this.off('moveend', this._panInsideMaxBounds);
  		}

  		if (!bounds.isValid()) {
  			this.options.maxBounds = null;
  			return this;
  		}

  		this.options.maxBounds = bounds;

  		if (this._loaded) {
  			this._panInsideMaxBounds();
  		}

  		return this.on('moveend', this._panInsideMaxBounds);
  	},

  	// @method setMinZoom(zoom: Number): this
  	// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
  	setMinZoom: function (zoom) {
  		var oldZoom = this.options.minZoom;
  		this.options.minZoom = zoom;

  		if (this._loaded && oldZoom !== zoom) {
  			this.fire('zoomlevelschange');

  			if (this.getZoom() < this.options.minZoom) {
  				return this.setZoom(zoom);
  			}
  		}

  		return this;
  	},

  	// @method setMaxZoom(zoom: Number): this
  	// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
  	setMaxZoom: function (zoom) {
  		var oldZoom = this.options.maxZoom;
  		this.options.maxZoom = zoom;

  		if (this._loaded && oldZoom !== zoom) {
  			this.fire('zoomlevelschange');

  			if (this.getZoom() > this.options.maxZoom) {
  				return this.setZoom(zoom);
  			}
  		}

  		return this;
  	},

  	// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
  	// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
  	panInsideBounds: function (bounds, options) {
  		this._enforcingBounds = true;
  		var center = this.getCenter(),
  		    newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));

  		if (!center.equals(newCenter)) {
  			this.panTo(newCenter, options);
  		}

  		this._enforcingBounds = false;
  		return this;
  	},

  	// @method panInside(latlng: LatLng, options?: padding options): this
  	// Pans the map the minimum amount to make the `latlng` visible. Use
  	// padding options to fit the display to more restricted bounds.
  	// If `latlng` is already within the (optionally padded) display bounds,
  	// the map will not be panned.
  	panInside: function (latlng, options) {
  		options = options || {};

  		var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
  		    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),
  		    pixelCenter = this.project(this.getCenter()),
  		    pixelPoint = this.project(latlng),
  		    pixelBounds = this.getPixelBounds(),
  		    paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]),
  		    paddedSize = paddedBounds.getSize();

  		if (!paddedBounds.contains(pixelPoint)) {
  			this._enforcingBounds = true;
  			var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());
  			var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);
  			pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;
  			pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;
  			this.panTo(this.unproject(pixelCenter), options);
  			this._enforcingBounds = false;
  		}
  		return this;
  	},

  	// @method invalidateSize(options: Zoom/pan options): this
  	// Checks if the map container size changed and updates the map if so 
  	// call it after you've changed the map size dynamically, also animating
  	// pan by default. If `options.pan` is `false`, panning will not occur.
  	// If `options.debounceMoveend` is `true`, it will delay `moveend` event so
  	// that it doesn't happen often even if the method is called many
  	// times in a row.

  	// @alternative
  	// @method invalidateSize(animate: Boolean): this
  	// Checks if the map container size changed and updates the map if so 
  	// call it after you've changed the map size dynamically, also animating
  	// pan by default.
  	invalidateSize: function (options) {
  		if (!this._loaded) { return this; }

  		options = extend({
  			animate: false,
  			pan: true
  		}, options === true ? {animate: true} : options);

  		var oldSize = this.getSize();
  		this._sizeChanged = true;
  		this._lastCenter = null;

  		var newSize = this.getSize(),
  		    oldCenter = oldSize.divideBy(2).round(),
  		    newCenter = newSize.divideBy(2).round(),
  		    offset = oldCenter.subtract(newCenter);

  		if (!offset.x && !offset.y) { return this; }

  		if (options.animate && options.pan) {
  			this.panBy(offset);

  		} else {
  			if (options.pan) {
  				this._rawPanBy(offset);
  			}

  			this.fire('move');

  			if (options.debounceMoveend) {
  				clearTimeout(this._sizeTimer);
  				this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);
  			} else {
  				this.fire('moveend');
  			}
  		}

  		// @section Map state change events
  		// @event resize: ResizeEvent
  		// Fired when the map is resized.
  		return this.fire('resize', {
  			oldSize: oldSize,
  			newSize: newSize
  		});
  	},

  	// @section Methods for modifying map state
  	// @method stop(): this
  	// Stops the currently running `panTo` or `flyTo` animation, if any.
  	stop: function () {
  		this.setZoom(this._limitZoom(this._zoom));
  		if (!this.options.zoomSnap) {
  			this.fire('viewreset');
  		}
  		return this._stop();
  	},

  	// @section Geolocation methods
  	// @method locate(options?: Locate options): this
  	// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
  	// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
  	// and optionally sets the map view to the user's location with respect to
  	// detection accuracy (or to the world view if geolocation failed).
  	// Note that, if your page doesn't use HTTPS, this method will fail in
  	// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
  	// See `Locate options` for more details.
  	locate: function (options) {

  		options = this._locateOptions = extend({
  			timeout: 10000,
  			watch: false
  			// setView: false
  			// maxZoom: <Number>
  			// maximumAge: 0
  			// enableHighAccuracy: false
  		}, options);

  		if (!('geolocation' in navigator)) {
  			this._handleGeolocationError({
  				code: 0,
  				message: 'Geolocation not supported.'
  			});
  			return this;
  		}

  		var onResponse = bind(this._handleGeolocationResponse, this),
  		    onError = bind(this._handleGeolocationError, this);

  		if (options.watch) {
  			this._locationWatchId =
  			        navigator.geolocation.watchPosition(onResponse, onError, options);
  		} else {
  			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
  		}
  		return this;
  	},

  	// @method stopLocate(): this
  	// Stops watching location previously initiated by `map.locate({watch: true})`
  	// and aborts resetting the map view if map.locate was called with
  	// `{setView: true}`.
  	stopLocate: function () {
  		if (navigator.geolocation && navigator.geolocation.clearWatch) {
  			navigator.geolocation.clearWatch(this._locationWatchId);
  		}
  		if (this._locateOptions) {
  			this._locateOptions.setView = false;
  		}
  		return this;
  	},

  	_handleGeolocationError: function (error) {
  		if (!this._container._leaflet_id) { return; }

  		var c = error.code,
  		    message = error.message ||
  		            (c === 1 ? 'permission denied' :
  		            (c === 2 ? 'position unavailable' : 'timeout'));

  		if (this._locateOptions.setView && !this._loaded) {
  			this.fitWorld();
  		}

  		// @section Location events
  		// @event locationerror: ErrorEvent
  		// Fired when geolocation (using the [`locate`](#map-locate) method) failed.
  		this.fire('locationerror', {
  			code: c,
  			message: 'Geolocation error: ' + message + '.'
  		});
  	},

  	_handleGeolocationResponse: function (pos) {
  		if (!this._container._leaflet_id) { return; }

  		var lat = pos.coords.latitude,
  		    lng = pos.coords.longitude,
  		    latlng = new LatLng(lat, lng),
  		    bounds = latlng.toBounds(pos.coords.accuracy * 2),
  		    options = this._locateOptions;

  		if (options.setView) {
  			var zoom = this.getBoundsZoom(bounds);
  			this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
  		}

  		var data = {
  			latlng: latlng,
  			bounds: bounds,
  			timestamp: pos.timestamp
  		};

  		for (var i in pos.coords) {
  			if (typeof pos.coords[i] === 'number') {
  				data[i] = pos.coords[i];
  			}
  		}

  		// @event locationfound: LocationEvent
  		// Fired when geolocation (using the [`locate`](#map-locate) method)
  		// went successfully.
  		this.fire('locationfound', data);
  	},

  	// TODO Appropriate docs section?
  	// @section Other Methods
  	// @method addHandler(name: String, HandlerClass: Function): this
  	// Adds a new `Handler` to the map, given its name and constructor function.
  	addHandler: function (name, HandlerClass) {
  		if (!HandlerClass) { return this; }

  		var handler = this[name] = new HandlerClass(this);

  		this._handlers.push(handler);

  		if (this.options[name]) {
  			handler.enable();
  		}

  		return this;
  	},

  	// @method remove(): this
  	// Destroys the map and clears all related event listeners.
  	remove: function () {

  		this._initEvents(true);
  		if (this.options.maxBounds) { this.off('moveend', this._panInsideMaxBounds); }

  		if (this._containerId !== this._container._leaflet_id) {
  			throw new Error('Map container is being reused by another instance');
  		}

  		try {
  			// throws error in IE6-8
  			delete this._container._leaflet_id;
  			delete this._containerId;
  		} catch (e) {
  			/*eslint-disable */
  			this._container._leaflet_id = undefined;
  			/* eslint-enable */
  			this._containerId = undefined;
  		}

  		if (this._locationWatchId !== undefined) {
  			this.stopLocate();
  		}

  		this._stop();

  		remove(this._mapPane);

  		if (this._clearControlPos) {
  			this._clearControlPos();
  		}
  		if (this._resizeRequest) {
  			cancelAnimFrame(this._resizeRequest);
  			this._resizeRequest = null;
  		}

  		this._clearHandlers();

  		if (this._loaded) {
  			// @section Map state change events
  			// @event unload: Event
  			// Fired when the map is destroyed with [remove](#map-remove) method.
  			this.fire('unload');
  		}

  		var i;
  		for (i in this._layers) {
  			this._layers[i].remove();
  		}
  		for (i in this._panes) {
  			remove(this._panes[i]);
  		}

  		this._layers = [];
  		this._panes = [];
  		delete this._mapPane;
  		delete this._renderer;

  		return this;
  	},

  	// @section Other Methods
  	// @method createPane(name: String, container?: HTMLElement): HTMLElement
  	// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
  	// then returns it. The pane is created as a child of `container`, or
  	// as a child of the main map pane if not set.
  	createPane: function (name, container) {
  		var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
  		    pane = create$1('div', className, container || this._mapPane);

  		if (name) {
  			this._panes[name] = pane;
  		}
  		return pane;
  	},

  	// @section Methods for Getting Map State

  	// @method getCenter(): LatLng
  	// Returns the geographical center of the map view
  	getCenter: function () {
  		this._checkIfLoaded();

  		if (this._lastCenter && !this._moved()) {
  			return this._lastCenter.clone();
  		}
  		return this.layerPointToLatLng(this._getCenterLayerPoint());
  	},

  	// @method getZoom(): Number
  	// Returns the current zoom level of the map view
  	getZoom: function () {
  		return this._zoom;
  	},

  	// @method getBounds(): LatLngBounds
  	// Returns the geographical bounds visible in the current map view
  	getBounds: function () {
  		var bounds = this.getPixelBounds(),
  		    sw = this.unproject(bounds.getBottomLeft()),
  		    ne = this.unproject(bounds.getTopRight());

  		return new LatLngBounds(sw, ne);
  	},

  	// @method getMinZoom(): Number
  	// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
  	getMinZoom: function () {
  		return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
  	},

  	// @method getMaxZoom(): Number
  	// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
  	getMaxZoom: function () {
  		return this.options.maxZoom === undefined ?
  			(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
  			this.options.maxZoom;
  	},

  	// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
  	// Returns the maximum zoom level on which the given bounds fit to the map
  	// view in its entirety. If `inside` (optional) is set to `true`, the method
  	// instead returns the minimum zoom level on which the map view fits into
  	// the given bounds in its entirety.
  	getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
  		bounds = toLatLngBounds(bounds);
  		padding = toPoint(padding || [0, 0]);

  		var zoom = this.getZoom() || 0,
  		    min = this.getMinZoom(),
  		    max = this.getMaxZoom(),
  		    nw = bounds.getNorthWest(),
  		    se = bounds.getSouthEast(),
  		    size = this.getSize().subtract(padding),
  		    boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),
  		    snap = Browser.any3d ? this.options.zoomSnap : 1,
  		    scalex = size.x / boundsSize.x,
  		    scaley = size.y / boundsSize.y,
  		    scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);

  		zoom = this.getScaleZoom(scale, zoom);

  		if (snap) {
  			zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
  			zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
  		}

  		return Math.max(min, Math.min(max, zoom));
  	},

  	// @method getSize(): Point
  	// Returns the current size of the map container (in pixels).
  	getSize: function () {
  		if (!this._size || this._sizeChanged) {
  			this._size = new Point(
  				this._container.clientWidth || 0,
  				this._container.clientHeight || 0);

  			this._sizeChanged = false;
  		}
  		return this._size.clone();
  	},

  	// @method getPixelBounds(): Bounds
  	// Returns the bounds of the current map view in projected pixel
  	// coordinates (sometimes useful in layer and overlay implementations).
  	getPixelBounds: function (center, zoom) {
  		var topLeftPoint = this._getTopLeftPoint(center, zoom);
  		return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
  	},

  	// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
  	// the map pane? "left point of the map layer" can be confusing, specially
  	// since there can be negative offsets.
  	// @method getPixelOrigin(): Point
  	// Returns the projected pixel coordinates of the top left point of
  	// the map layer (useful in custom layer and overlay implementations).
  	getPixelOrigin: function () {
  		this._checkIfLoaded();
  		return this._pixelOrigin;
  	},

  	// @method getPixelWorldBounds(zoom?: Number): Bounds
  	// Returns the world's bounds in pixel coordinates for zoom level `zoom`.
  	// If `zoom` is omitted, the map's current zoom level is used.
  	getPixelWorldBounds: function (zoom) {
  		return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
  	},

  	// @section Other Methods

  	// @method getPane(pane: String|HTMLElement): HTMLElement
  	// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
  	getPane: function (pane) {
  		return typeof pane === 'string' ? this._panes[pane] : pane;
  	},

  	// @method getPanes(): Object
  	// Returns a plain object containing the names of all [panes](#map-pane) as keys and
  	// the panes as values.
  	getPanes: function () {
  		return this._panes;
  	},

  	// @method getContainer: HTMLElement
  	// Returns the HTML element that contains the map.
  	getContainer: function () {
  		return this._container;
  	},


  	// @section Conversion Methods

  	// @method getZoomScale(toZoom: Number, fromZoom: Number): Number
  	// Returns the scale factor to be applied to a map transition from zoom level
  	// `fromZoom` to `toZoom`. Used internally to help with zoom animations.
  	getZoomScale: function (toZoom, fromZoom) {
  		// TODO replace with universal implementation after refactoring projections
  		var crs = this.options.crs;
  		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
  		return crs.scale(toZoom) / crs.scale(fromZoom);
  	},

  	// @method getScaleZoom(scale: Number, fromZoom: Number): Number
  	// Returns the zoom level that the map would end up at, if it is at `fromZoom`
  	// level and everything is scaled by a factor of `scale`. Inverse of
  	// [`getZoomScale`](#map-getZoomScale).
  	getScaleZoom: function (scale, fromZoom) {
  		var crs = this.options.crs;
  		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
  		var zoom = crs.zoom(scale * crs.scale(fromZoom));
  		return isNaN(zoom) ? Infinity : zoom;
  	},

  	// @method project(latlng: LatLng, zoom: Number): Point
  	// Projects a geographical coordinate `LatLng` according to the projection
  	// of the map's CRS, then scales it according to `zoom` and the CRS's
  	// `Transformation`. The result is pixel coordinate relative to
  	// the CRS origin.
  	project: function (latlng, zoom) {
  		zoom = zoom === undefined ? this._zoom : zoom;
  		return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);
  	},

  	// @method unproject(point: Point, zoom: Number): LatLng
  	// Inverse of [`project`](#map-project).
  	unproject: function (point, zoom) {
  		zoom = zoom === undefined ? this._zoom : zoom;
  		return this.options.crs.pointToLatLng(toPoint(point), zoom);
  	},

  	// @method layerPointToLatLng(point: Point): LatLng
  	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
  	// returns the corresponding geographical coordinate (for the current zoom level).
  	layerPointToLatLng: function (point) {
  		var projectedPoint = toPoint(point).add(this.getPixelOrigin());
  		return this.unproject(projectedPoint);
  	},

  	// @method latLngToLayerPoint(latlng: LatLng): Point
  	// Given a geographical coordinate, returns the corresponding pixel coordinate
  	// relative to the [origin pixel](#map-getpixelorigin).
  	latLngToLayerPoint: function (latlng) {
  		var projectedPoint = this.project(toLatLng(latlng))._round();
  		return projectedPoint._subtract(this.getPixelOrigin());
  	},

  	// @method wrapLatLng(latlng: LatLng): LatLng
  	// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
  	// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
  	// CRS's bounds.
  	// By default this means longitude is wrapped around the dateline so its
  	// value is between -180 and +180 degrees.
  	wrapLatLng: function (latlng) {
  		return this.options.crs.wrapLatLng(toLatLng(latlng));
  	},

  	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
  	// Returns a `LatLngBounds` with the same size as the given one, ensuring that
  	// its center is within the CRS's bounds.
  	// By default this means the center longitude is wrapped around the dateline so its
  	// value is between -180 and +180 degrees, and the majority of the bounds
  	// overlaps the CRS's bounds.
  	wrapLatLngBounds: function (latlng) {
  		return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
  	},

  	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
  	// Returns the distance between two geographical coordinates according to
  	// the map's CRS. By default this measures distance in meters.
  	distance: function (latlng1, latlng2) {
  		return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
  	},

  	// @method containerPointToLayerPoint(point: Point): Point
  	// Given a pixel coordinate relative to the map container, returns the corresponding
  	// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
  	containerPointToLayerPoint: function (point) { // (Point)
  		return toPoint(point).subtract(this._getMapPanePos());
  	},

  	// @method layerPointToContainerPoint(point: Point): Point
  	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
  	// returns the corresponding pixel coordinate relative to the map container.
  	layerPointToContainerPoint: function (point) { // (Point)
  		return toPoint(point).add(this._getMapPanePos());
  	},

  	// @method containerPointToLatLng(point: Point): LatLng
  	// Given a pixel coordinate relative to the map container, returns
  	// the corresponding geographical coordinate (for the current zoom level).
  	containerPointToLatLng: function (point) {
  		var layerPoint = this.containerPointToLayerPoint(toPoint(point));
  		return this.layerPointToLatLng(layerPoint);
  	},

  	// @method latLngToContainerPoint(latlng: LatLng): Point
  	// Given a geographical coordinate, returns the corresponding pixel coordinate
  	// relative to the map container.
  	latLngToContainerPoint: function (latlng) {
  		return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
  	},

  	// @method mouseEventToContainerPoint(ev: MouseEvent): Point
  	// Given a MouseEvent object, returns the pixel coordinate relative to the
  	// map container where the event took place.
  	mouseEventToContainerPoint: function (e) {
  		return getMousePosition(e, this._container);
  	},

  	// @method mouseEventToLayerPoint(ev: MouseEvent): Point
  	// Given a MouseEvent object, returns the pixel coordinate relative to
  	// the [origin pixel](#map-getpixelorigin) where the event took place.
  	mouseEventToLayerPoint: function (e) {
  		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
  	},

  	// @method mouseEventToLatLng(ev: MouseEvent): LatLng
  	// Given a MouseEvent object, returns geographical coordinate where the
  	// event took place.
  	mouseEventToLatLng: function (e) { // (MouseEvent)
  		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
  	},


  	// map initialization methods

  	_initContainer: function (id) {
  		var container = this._container = get(id);

  		if (!container) {
  			throw new Error('Map container not found.');
  		} else if (container._leaflet_id) {
  			throw new Error('Map container is already initialized.');
  		}

  		on(container, 'scroll', this._onScroll, this);
  		this._containerId = stamp(container);
  	},

  	_initLayout: function () {
  		var container = this._container;

  		this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;

  		addClass(container, 'leaflet-container' +
  			(Browser.touch ? ' leaflet-touch' : '') +
  			(Browser.retina ? ' leaflet-retina' : '') +
  			(Browser.ielt9 ? ' leaflet-oldie' : '') +
  			(Browser.safari ? ' leaflet-safari' : '') +
  			(this._fadeAnimated ? ' leaflet-fade-anim' : ''));

  		var position = getStyle(container, 'position');

  		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed' && position !== 'sticky') {
  			container.style.position = 'relative';
  		}

  		this._initPanes();

  		if (this._initControlPos) {
  			this._initControlPos();
  		}
  	},

  	_initPanes: function () {
  		var panes = this._panes = {};
  		this._paneRenderers = {};

  		// @section
  		//
  		// Panes are DOM elements used to control the ordering of layers on the map. You
  		// can access panes with [`map.getPane`](#map-getpane) or
  		// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
  		// [`map.createPane`](#map-createpane) method.
  		//
  		// Every map has the following default panes that differ only in zIndex.
  		//
  		// @pane mapPane: HTMLElement = 'auto'
  		// Pane that contains all other map panes

  		this._mapPane = this.createPane('mapPane', this._container);
  		setPosition(this._mapPane, new Point(0, 0));

  		// @pane tilePane: HTMLElement = 200
  		// Pane for `GridLayer`s and `TileLayer`s
  		this.createPane('tilePane');
  		// @pane overlayPane: HTMLElement = 400
  		// Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s
  		this.createPane('overlayPane');
  		// @pane shadowPane: HTMLElement = 500
  		// Pane for overlay shadows (e.g. `Marker` shadows)
  		this.createPane('shadowPane');
  		// @pane markerPane: HTMLElement = 600
  		// Pane for `Icon`s of `Marker`s
  		this.createPane('markerPane');
  		// @pane tooltipPane: HTMLElement = 650
  		// Pane for `Tooltip`s.
  		this.createPane('tooltipPane');
  		// @pane popupPane: HTMLElement = 700
  		// Pane for `Popup`s.
  		this.createPane('popupPane');

  		if (!this.options.markerZoomAnimation) {
  			addClass(panes.markerPane, 'leaflet-zoom-hide');
  			addClass(panes.shadowPane, 'leaflet-zoom-hide');
  		}
  	},


  	// private methods that modify map state

  	// @section Map state change events
  	_resetView: function (center, zoom, noMoveStart) {
  		setPosition(this._mapPane, new Point(0, 0));

  		var loading = !this._loaded;
  		this._loaded = true;
  		zoom = this._limitZoom(zoom);

  		this.fire('viewprereset');

  		var zoomChanged = this._zoom !== zoom;
  		this
  			._moveStart(zoomChanged, noMoveStart)
  			._move(center, zoom)
  			._moveEnd(zoomChanged);

  		// @event viewreset: Event
  		// Fired when the map needs to redraw its content (this usually happens
  		// on map zoom or load). Very useful for creating custom overlays.
  		this.fire('viewreset');

  		// @event load: Event
  		// Fired when the map is initialized (when its center and zoom are set
  		// for the first time).
  		if (loading) {
  			this.fire('load');
  		}
  	},

  	_moveStart: function (zoomChanged, noMoveStart) {
  		// @event zoomstart: Event
  		// Fired when the map zoom is about to change (e.g. before zoom animation).
  		// @event movestart: Event
  		// Fired when the view of the map starts changing (e.g. user starts dragging the map).
  		if (zoomChanged) {
  			this.fire('zoomstart');
  		}
  		if (!noMoveStart) {
  			this.fire('movestart');
  		}
  		return this;
  	},

  	_move: function (center, zoom, data, supressEvent) {
  		if (zoom === undefined) {
  			zoom = this._zoom;
  		}
  		var zoomChanged = this._zoom !== zoom;

  		this._zoom = zoom;
  		this._lastCenter = center;
  		this._pixelOrigin = this._getNewPixelOrigin(center);

  		if (!supressEvent) {
  			// @event zoom: Event
  			// Fired repeatedly during any change in zoom level,
  			// including zoom and fly animations.
  			if (zoomChanged || (data && data.pinch)) {	// Always fire 'zoom' if pinching because #3530
  				this.fire('zoom', data);
  			}

  			// @event move: Event
  			// Fired repeatedly during any movement of the map,
  			// including pan and fly animations.
  			this.fire('move', data);
  		} else if (data && data.pinch) {	// Always fire 'zoom' if pinching because #3530
  			this.fire('zoom', data);
  		}
  		return this;
  	},

  	_moveEnd: function (zoomChanged) {
  		// @event zoomend: Event
  		// Fired when the map zoom changed, after any animations.
  		if (zoomChanged) {
  			this.fire('zoomend');
  		}

  		// @event moveend: Event
  		// Fired when the center of the map stops changing
  		// (e.g. user stopped dragging the map or after non-centered zoom).
  		return this.fire('moveend');
  	},

  	_stop: function () {
  		cancelAnimFrame(this._flyToFrame);
  		if (this._panAnim) {
  			this._panAnim.stop();
  		}
  		return this;
  	},

  	_rawPanBy: function (offset) {
  		setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
  	},

  	_getZoomSpan: function () {
  		return this.getMaxZoom() - this.getMinZoom();
  	},

  	_panInsideMaxBounds: function () {
  		if (!this._enforcingBounds) {
  			this.panInsideBounds(this.options.maxBounds);
  		}
  	},

  	_checkIfLoaded: function () {
  		if (!this._loaded) {
  			throw new Error('Set map center and zoom first.');
  		}
  	},

  	// DOM event handling

  	// @section Interaction events
  	_initEvents: function (remove) {
  		this._targets = {};
  		this._targets[stamp(this._container)] = this;

  		var onOff = remove ? off : on;

  		// @event click: MouseEvent
  		// Fired when the user clicks (or taps) the map.
  		// @event dblclick: MouseEvent
  		// Fired when the user double-clicks (or double-taps) the map.
  		// @event mousedown: MouseEvent
  		// Fired when the user pushes the mouse button on the map.
  		// @event mouseup: MouseEvent
  		// Fired when the user releases the mouse button on the map.
  		// @event mouseover: MouseEvent
  		// Fired when the mouse enters the map.
  		// @event mouseout: MouseEvent
  		// Fired when the mouse leaves the map.
  		// @event mousemove: MouseEvent
  		// Fired while the mouse moves over the map.
  		// @event contextmenu: MouseEvent
  		// Fired when the user pushes the right mouse button on the map, prevents
  		// default browser context menu from showing if there are listeners on
  		// this event. Also fired on mobile when the user holds a single touch
  		// for a second (also called long press).
  		// @event keypress: KeyboardEvent
  		// Fired when the user presses a key from the keyboard that produces a character value while the map is focused.
  		// @event keydown: KeyboardEvent
  		// Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,
  		// the `keydown` event is fired for keys that produce a character value and for keys
  		// that do not produce a character value.
  		// @event keyup: KeyboardEvent
  		// Fired when the user releases a key from the keyboard while the map is focused.
  		onOff(this._container, 'click dblclick mousedown mouseup ' +
  			'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);

  		if (this.options.trackResize) {
  			onOff(window, 'resize', this._onResize, this);
  		}

  		if (Browser.any3d && this.options.transform3DLimit) {
  			(remove ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);
  		}
  	},

  	_onResize: function () {
  		cancelAnimFrame(this._resizeRequest);
  		this._resizeRequest = requestAnimFrame(
  		        function () { this.invalidateSize({debounceMoveend: true}); }, this);
  	},

  	_onScroll: function () {
  		this._container.scrollTop  = 0;
  		this._container.scrollLeft = 0;
  	},

  	_onMoveEnd: function () {
  		var pos = this._getMapPanePos();
  		if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
  			// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
  			// a pixel offset on very high values, see: https://jsfiddle.net/dg6r5hhb/
  			this._resetView(this.getCenter(), this.getZoom());
  		}
  	},

  	_findEventTargets: function (e, type) {
  		var targets = [],
  		    target,
  		    isHover = type === 'mouseout' || type === 'mouseover',
  		    src = e.target || e.srcElement,
  		    dragging = false;

  		while (src) {
  			target = this._targets[stamp(src)];
  			if (target && (type === 'click' || type === 'preclick') && this._draggableMoved(target)) {
  				// Prevent firing click after you just dragged an object.
  				dragging = true;
  				break;
  			}
  			if (target && target.listens(type, true)) {
  				if (isHover && !isExternalTarget(src, e)) { break; }
  				targets.push(target);
  				if (isHover) { break; }
  			}
  			if (src === this._container) { break; }
  			src = src.parentNode;
  		}
  		if (!targets.length && !dragging && !isHover && this.listens(type, true)) {
  			targets = [this];
  		}
  		return targets;
  	},

  	_isClickDisabled: function (el) {
  		while (el && el !== this._container) {
  			if (el['_leaflet_disable_click']) { return true; }
  			el = el.parentNode;
  		}
  	},

  	_handleDOMEvent: function (e) {
  		var el = (e.target || e.srcElement);
  		if (!this._loaded || el['_leaflet_disable_events'] || e.type === 'click' && this._isClickDisabled(el)) {
  			return;
  		}

  		var type = e.type;

  		if (type === 'mousedown') {
  			// prevents outline when clicking on keyboard-focusable element
  			preventOutline(el);
  		}

  		this._fireDOMEvent(e, type);
  	},

  	_mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],

  	_fireDOMEvent: function (e, type, canvasTargets) {

  		if (e.type === 'click') {
  			// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
  			// @event preclick: MouseEvent
  			// Fired before mouse click on the map (sometimes useful when you
  			// want something to happen on click before any existing click
  			// handlers start running).
  			var synth = extend({}, e);
  			synth.type = 'preclick';
  			this._fireDOMEvent(synth, synth.type, canvasTargets);
  		}

  		// Find the layer the event is propagating from and its parents.
  		var targets = this._findEventTargets(e, type);

  		if (canvasTargets) {
  			var filtered = []; // pick only targets with listeners
  			for (var i = 0; i < canvasTargets.length; i++) {
  				if (canvasTargets[i].listens(type, true)) {
  					filtered.push(canvasTargets[i]);
  				}
  			}
  			targets = filtered.concat(targets);
  		}

  		if (!targets.length) { return; }

  		if (type === 'contextmenu') {
  			preventDefault(e);
  		}

  		var target = targets[0];
  		var data = {
  			originalEvent: e
  		};

  		if (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {
  			var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
  			data.containerPoint = isMarker ?
  				this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
  			data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
  			data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
  		}

  		for (i = 0; i < targets.length; i++) {
  			targets[i].fire(type, data, true);
  			if (data.originalEvent._stopped ||
  				(targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1)) { return; }
  		}
  	},

  	_draggableMoved: function (obj) {
  		obj = obj.dragging && obj.dragging.enabled() ? obj : this;
  		return (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());
  	},

  	_clearHandlers: function () {
  		for (var i = 0, len = this._handlers.length; i < len; i++) {
  			this._handlers[i].disable();
  		}
  	},

  	// @section Other Methods

  	// @method whenReady(fn: Function, context?: Object): this
  	// Runs the given function `fn` when the map gets initialized with
  	// a view (center and zoom) and at least one layer, or immediately
  	// if it's already initialized, optionally passing a function context.
  	whenReady: function (callback, context) {
  		if (this._loaded) {
  			callback.call(context || this, {target: this});
  		} else {
  			this.on('load', callback, context);
  		}
  		return this;
  	},


  	// private methods for getting map state

  	_getMapPanePos: function () {
  		return getPosition(this._mapPane) || new Point(0, 0);
  	},

  	_moved: function () {
  		var pos = this._getMapPanePos();
  		return pos && !pos.equals([0, 0]);
  	},

  	_getTopLeftPoint: function (center, zoom) {
  		var pixelOrigin = center && zoom !== undefined ?
  			this._getNewPixelOrigin(center, zoom) :
  			this.getPixelOrigin();
  		return pixelOrigin.subtract(this._getMapPanePos());
  	},

  	_getNewPixelOrigin: function (center, zoom) {
  		var viewHalf = this.getSize()._divideBy(2);
  		return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
  	},

  	_latLngToNewLayerPoint: function (latlng, zoom, center) {
  		var topLeft = this._getNewPixelOrigin(center, zoom);
  		return this.project(latlng, zoom)._subtract(topLeft);
  	},

  	_latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {
  		var topLeft = this._getNewPixelOrigin(center, zoom);
  		return toBounds([
  			this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft),
  			this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft),
  			this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft),
  			this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)
  		]);
  	},

  	// layer point of the current center
  	_getCenterLayerPoint: function () {
  		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
  	},

  	// offset of the specified place to the current center in pixels
  	_getCenterOffset: function (latlng) {
  		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
  	},

  	// adjust center for view to get inside bounds
  	_limitCenter: function (center, zoom, bounds) {

  		if (!bounds) { return center; }

  		var centerPoint = this.project(center, zoom),
  		    viewHalf = this.getSize().divideBy(2),
  		    viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
  		    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

  		// If offset is less than a pixel, ignore.
  		// This prevents unstable projections from getting into
  		// an infinite loop of tiny offsets.
  		if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {
  			return center;
  		}

  		return this.unproject(centerPoint.add(offset), zoom);
  	},

  	// adjust offset for view to get inside bounds
  	_limitOffset: function (offset, bounds) {
  		if (!bounds) { return offset; }

  		var viewBounds = this.getPixelBounds(),
  		    newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

  		return offset.add(this._getBoundsOffset(newBounds, bounds));
  	},

  	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
  	_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
  		var projectedMaxBounds = toBounds(
  		        this.project(maxBounds.getNorthEast(), zoom),
  		        this.project(maxBounds.getSouthWest(), zoom)
  		    ),
  		    minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
  		    maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),

  		    dx = this._rebound(minOffset.x, -maxOffset.x),
  		    dy = this._rebound(minOffset.y, -maxOffset.y);

  		return new Point(dx, dy);
  	},

  	_rebound: function (left, right) {
  		return left + right > 0 ?
  			Math.round(left - right) / 2 :
  			Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
  	},

  	_limitZoom: function (zoom) {
  		var min = this.getMinZoom(),
  		    max = this.getMaxZoom(),
  		    snap = Browser.any3d ? this.options.zoomSnap : 1;
  		if (snap) {
  			zoom = Math.round(zoom / snap) * snap;
  		}
  		return Math.max(min, Math.min(max, zoom));
  	},

  	_onPanTransitionStep: function () {
  		this.fire('move');
  	},

  	_onPanTransitionEnd: function () {
  		removeClass(this._mapPane, 'leaflet-pan-anim');
  		this.fire('moveend');
  	},

  	_tryAnimatedPan: function (center, options) {
  		// difference between the new and current centers in pixels
  		var offset = this._getCenterOffset(center)._trunc();

  		// don't animate too far unless animate: true specified in options
  		if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

  		this.panBy(offset, options);

  		return true;
  	},

  	_createAnimProxy: function () {

  		var proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');
  		this._panes.mapPane.appendChild(proxy);

  		this.on('zoomanim', function (e) {
  			var prop = TRANSFORM,
  			    transform = this._proxy.style[prop];

  			setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

  			// workaround for case when transform is the same and so transitionend event is not fired
  			if (transform === this._proxy.style[prop] && this._animatingZoom) {
  				this._onZoomTransitionEnd();
  			}
  		}, this);

  		this.on('load moveend', this._animMoveEnd, this);

  		this._on('unload', this._destroyAnimProxy, this);
  	},

  	_destroyAnimProxy: function () {
  		remove(this._proxy);
  		this.off('load moveend', this._animMoveEnd, this);
  		delete this._proxy;
  	},

  	_animMoveEnd: function () {
  		var c = this.getCenter(),
  		    z = this.getZoom();
  		setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
  	},

  	_catchTransitionEnd: function (e) {
  		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
  			this._onZoomTransitionEnd();
  		}
  	},

  	_nothingToAnimate: function () {
  		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
  	},

  	_tryAnimatedZoom: function (center, zoom, options) {

  		if (this._animatingZoom) { return true; }

  		options = options || {};

  		// don't animate if disabled, not supported or zoom difference is too large
  		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
  		        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

  		// offset is the pixel coords of the zoom origin relative to the current center
  		var scale = this.getZoomScale(zoom),
  		    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

  		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
  		if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

  		requestAnimFrame(function () {
  			this
  			    ._moveStart(true, options.noMoveStart || false)
  			    ._animateZoom(center, zoom, true);
  		}, this);

  		return true;
  	},

  	_animateZoom: function (center, zoom, startAnim, noUpdate) {
  		if (!this._mapPane) { return; }

  		if (startAnim) {
  			this._animatingZoom = true;

  			// remember what center/zoom to set after animation
  			this._animateToCenter = center;
  			this._animateToZoom = zoom;

  			addClass(this._mapPane, 'leaflet-zoom-anim');
  		}

  		// @section Other Events
  		// @event zoomanim: ZoomAnimEvent
  		// Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.
  		this.fire('zoomanim', {
  			center: center,
  			zoom: zoom,
  			noUpdate: noUpdate
  		});

  		if (!this._tempFireZoomEvent) {
  			this._tempFireZoomEvent = this._zoom !== this._animateToZoom;
  		}

  		this._move(this._animateToCenter, this._animateToZoom, undefined, true);

  		// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
  		setTimeout(bind(this._onZoomTransitionEnd, this), 250);
  	},

  	_onZoomTransitionEnd: function () {
  		if (!this._animatingZoom) { return; }

  		if (this._mapPane) {
  			removeClass(this._mapPane, 'leaflet-zoom-anim');
  		}

  		this._animatingZoom = false;

  		this._move(this._animateToCenter, this._animateToZoom, undefined, true);

  		if (this._tempFireZoomEvent) {
  			this.fire('zoom');
  		}
  		delete this._tempFireZoomEvent;

  		this.fire('move');

  		this._moveEnd(true);
  	}
  });

  // @section

  // @factory L.map(id: String, options?: Map options)
  // Instantiates a map object given the DOM ID of a `<div>` element
  // and optionally an object literal with `Map options`.
  //
  // @alternative
  // @factory L.map(el: HTMLElement, options?: Map options)
  // Instantiates a map object given an instance of a `<div>` HTML element
  // and optionally an object literal with `Map options`.
  function createMap(id, options) {
  	return new Map(id, options);
  }

  /*
   * @class Control
   * @aka L.Control
   * @inherits Class
   *
   * L.Control is a base class for implementing map controls. Handles positioning.
   * All other controls extend from this class.
   */

  var Control = Class.extend({
  	// @section
  	// @aka Control Options
  	options: {
  		// @option position: String = 'topright'
  		// The position of the control (one of the map corners). Possible values are `'topleft'`,
  		// `'topright'`, `'bottomleft'` or `'bottomright'`
  		position: 'topright'
  	},

  	initialize: function (options) {
  		setOptions(this, options);
  	},

  	/* @section
  	 * Classes extending L.Control will inherit the following methods:
  	 *
  	 * @method getPosition: string
  	 * Returns the position of the control.
  	 */
  	getPosition: function () {
  		return this.options.position;
  	},

  	// @method setPosition(position: string): this
  	// Sets the position of the control.
  	setPosition: function (position) {
  		var map = this._map;

  		if (map) {
  			map.removeControl(this);
  		}

  		this.options.position = position;

  		if (map) {
  			map.addControl(this);
  		}

  		return this;
  	},

  	// @method getContainer: HTMLElement
  	// Returns the HTMLElement that contains the control.
  	getContainer: function () {
  		return this._container;
  	},

  	// @method addTo(map: Map): this
  	// Adds the control to the given map.
  	addTo: function (map) {
  		this.remove();
  		this._map = map;

  		var container = this._container = this.onAdd(map),
  		    pos = this.getPosition(),
  		    corner = map._controlCorners[pos];

  		addClass(container, 'leaflet-control');

  		if (pos.indexOf('bottom') !== -1) {
  			corner.insertBefore(container, corner.firstChild);
  		} else {
  			corner.appendChild(container);
  		}

  		this._map.on('unload', this.remove, this);

  		return this;
  	},

  	// @method remove: this
  	// Removes the control from the map it is currently active on.
  	remove: function () {
  		if (!this._map) {
  			return this;
  		}

  		remove(this._container);

  		if (this.onRemove) {
  			this.onRemove(this._map);
  		}

  		this._map.off('unload', this.remove, this);
  		this._map = null;

  		return this;
  	},

  	_refocusOnMap: function (e) {
  		// if map exists and event is not a keyboard event
  		if (this._map && e && e.screenX > 0 && e.screenY > 0) {
  			this._map.getContainer().focus();
  		}
  	}
  });

  var control = function (options) {
  	return new Control(options);
  };

  /* @section Extension methods
   * @uninheritable
   *
   * Every control should extend from `L.Control` and (re-)implement the following methods.
   *
   * @method onAdd(map: Map): HTMLElement
   * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
   *
   * @method onRemove(map: Map)
   * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
   */

  /* @namespace Map
   * @section Methods for Layers and Controls
   */
  Map.include({
  	// @method addControl(control: Control): this
  	// Adds the given control to the map
  	addControl: function (control) {
  		control.addTo(this);
  		return this;
  	},

  	// @method removeControl(control: Control): this
  	// Removes the given control from the map
  	removeControl: function (control) {
  		control.remove();
  		return this;
  	},

  	_initControlPos: function () {
  		var corners = this._controlCorners = {},
  		    l = 'leaflet-',
  		    container = this._controlContainer =
  		            create$1('div', l + 'control-container', this._container);

  		function createCorner(vSide, hSide) {
  			var className = l + vSide + ' ' + l + hSide;

  			corners[vSide + hSide] = create$1('div', className, container);
  		}

  		createCorner('top', 'left');
  		createCorner('top', 'right');
  		createCorner('bottom', 'left');
  		createCorner('bottom', 'right');
  	},

  	_clearControlPos: function () {
  		for (var i in this._controlCorners) {
  			remove(this._controlCorners[i]);
  		}
  		remove(this._controlContainer);
  		delete this._controlCorners;
  		delete this._controlContainer;
  	}
  });

  /*
   * @class Control.Layers
   * @aka L.Control.Layers
   * @inherits Control
   *
   * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](https://leafletjs.com/examples/layers-control/)). Extends `Control`.
   *
   * @example
   *
   * ```js
   * var baseLayers = {
   * 	"Mapbox": mapbox,
   * 	"OpenStreetMap": osm
   * };
   *
   * var overlays = {
   * 	"Marker": marker,
   * 	"Roads": roadsLayer
   * };
   *
   * L.control.layers(baseLayers, overlays).addTo(map);
   * ```
   *
   * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
   *
   * ```js
   * {
   *     "<someName1>": layer1,
   *     "<someName2>": layer2
   * }
   * ```
   *
   * The layer names can contain HTML, which allows you to add additional styling to the items:
   *
   * ```js
   * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
   * ```
   */

  var Layers = Control.extend({
  	// @section
  	// @aka Control.Layers options
  	options: {
  		// @option collapsed: Boolean = true
  		// If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
  		collapsed: true,
  		position: 'topright',

  		// @option autoZIndex: Boolean = true
  		// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
  		autoZIndex: true,

  		// @option hideSingleBase: Boolean = false
  		// If `true`, the base layers in the control will be hidden when there is only one.
  		hideSingleBase: false,

  		// @option sortLayers: Boolean = false
  		// Whether to sort the layers. When `false`, layers will keep the order
  		// in which they were added to the control.
  		sortLayers: false,

  		// @option sortFunction: Function = *
  		// A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
  		// that will be used for sorting the layers, when `sortLayers` is `true`.
  		// The function receives both the `L.Layer` instances and their names, as in
  		// `sortFunction(layerA, layerB, nameA, nameB)`.
  		// By default, it sorts layers alphabetically by their name.
  		sortFunction: function (layerA, layerB, nameA, nameB) {
  			return nameA < nameB ? -1 : (nameB < nameA ? 1 : 0);
  		}
  	},

  	initialize: function (baseLayers, overlays, options) {
  		setOptions(this, options);

  		this._layerControlInputs = [];
  		this._layers = [];
  		this._lastZIndex = 0;
  		this._handlingClick = false;
  		this._preventClick = false;

  		for (var i in baseLayers) {
  			this._addLayer(baseLayers[i], i);
  		}

  		for (i in overlays) {
  			this._addLayer(overlays[i], i, true);
  		}
  	},

  	onAdd: function (map) {
  		this._initLayout();
  		this._update();

  		this._map = map;
  		map.on('zoomend', this._checkDisabledLayers, this);

  		for (var i = 0; i < this._layers.length; i++) {
  			this._layers[i].layer.on('add remove', this._onLayerChange, this);
  		}

  		return this._container;
  	},

  	addTo: function (map) {
  		Control.prototype.addTo.call(this, map);
  		// Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.
  		return this._expandIfNotCollapsed();
  	},

  	onRemove: function () {
  		this._map.off('zoomend', this._checkDisabledLayers, this);

  		for (var i = 0; i < this._layers.length; i++) {
  			this._layers[i].layer.off('add remove', this._onLayerChange, this);
  		}
  	},

  	// @method addBaseLayer(layer: Layer, name: String): this
  	// Adds a base layer (radio button entry) with the given name to the control.
  	addBaseLayer: function (layer, name) {
  		this._addLayer(layer, name);
  		return (this._map) ? this._update() : this;
  	},

  	// @method addOverlay(layer: Layer, name: String): this
  	// Adds an overlay (checkbox entry) with the given name to the control.
  	addOverlay: function (layer, name) {
  		this._addLayer(layer, name, true);
  		return (this._map) ? this._update() : this;
  	},

  	// @method removeLayer(layer: Layer): this
  	// Remove the given layer from the control.
  	removeLayer: function (layer) {
  		layer.off('add remove', this._onLayerChange, this);

  		var obj = this._getLayer(stamp(layer));
  		if (obj) {
  			this._layers.splice(this._layers.indexOf(obj), 1);
  		}
  		return (this._map) ? this._update() : this;
  	},

  	// @method expand(): this
  	// Expand the control container if collapsed.
  	expand: function () {
  		addClass(this._container, 'leaflet-control-layers-expanded');
  		this._section.style.height = null;
  		var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
  		if (acceptableHeight < this._section.clientHeight) {
  			addClass(this._section, 'leaflet-control-layers-scrollbar');
  			this._section.style.height = acceptableHeight + 'px';
  		} else {
  			removeClass(this._section, 'leaflet-control-layers-scrollbar');
  		}
  		this._checkDisabledLayers();
  		return this;
  	},

  	// @method collapse(): this
  	// Collapse the control container if expanded.
  	collapse: function () {
  		removeClass(this._container, 'leaflet-control-layers-expanded');
  		return this;
  	},

  	_initLayout: function () {
  		var className = 'leaflet-control-layers',
  		    container = this._container = create$1('div', className),
  		    collapsed = this.options.collapsed;

  		// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
  		container.setAttribute('aria-haspopup', true);

  		disableClickPropagation(container);
  		disableScrollPropagation(container);

  		var section = this._section = create$1('section', className + '-list');

  		if (collapsed) {
  			this._map.on('click', this.collapse, this);

  			on(container, {
  				mouseenter: this._expandSafely,
  				mouseleave: this.collapse
  			}, this);
  		}

  		var link = this._layersLink = create$1('a', className + '-toggle', container);
  		link.href = '#';
  		link.title = 'Layers';
  		link.setAttribute('role', 'button');

  		on(link, {
  			keydown: function (e) {
  				if (e.keyCode === 13) {
  					this._expandSafely();
  				}
  			},
  			// Certain screen readers intercept the key event and instead send a click event
  			click: function (e) {
  				preventDefault(e);
  				this._expandSafely();
  			}
  		}, this);

  		if (!collapsed) {
  			this.expand();
  		}

  		this._baseLayersList = create$1('div', className + '-base', section);
  		this._separator = create$1('div', className + '-separator', section);
  		this._overlaysList = create$1('div', className + '-overlays', section);

  		container.appendChild(section);
  	},

  	_getLayer: function (id) {
  		for (var i = 0; i < this._layers.length; i++) {

  			if (this._layers[i] && stamp(this._layers[i].layer) === id) {
  				return this._layers[i];
  			}
  		}
  	},

  	_addLayer: function (layer, name, overlay) {
  		if (this._map) {
  			layer.on('add remove', this._onLayerChange, this);
  		}

  		this._layers.push({
  			layer: layer,
  			name: name,
  			overlay: overlay
  		});

  		if (this.options.sortLayers) {
  			this._layers.sort(bind(function (a, b) {
  				return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
  			}, this));
  		}

  		if (this.options.autoZIndex && layer.setZIndex) {
  			this._lastZIndex++;
  			layer.setZIndex(this._lastZIndex);
  		}

  		this._expandIfNotCollapsed();
  	},

  	_update: function () {
  		if (!this._container) { return this; }

  		empty(this._baseLayersList);
  		empty(this._overlaysList);

  		this._layerControlInputs = [];
  		var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;

  		for (i = 0; i < this._layers.length; i++) {
  			obj = this._layers[i];
  			this._addItem(obj);
  			overlaysPresent = overlaysPresent || obj.overlay;
  			baseLayersPresent = baseLayersPresent || !obj.overlay;
  			baseLayersCount += !obj.overlay ? 1 : 0;
  		}

  		// Hide base layers section if there's only one layer.
  		if (this.options.hideSingleBase) {
  			baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
  			this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
  		}

  		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

  		return this;
  	},

  	_onLayerChange: function (e) {
  		if (!this._handlingClick) {
  			this._update();
  		}

  		var obj = this._getLayer(stamp(e.target));

  		// @namespace Map
  		// @section Layer events
  		// @event baselayerchange: LayersControlEvent
  		// Fired when the base layer is changed through the [layers control](#control-layers).
  		// @event overlayadd: LayersControlEvent
  		// Fired when an overlay is selected through the [layers control](#control-layers).
  		// @event overlayremove: LayersControlEvent
  		// Fired when an overlay is deselected through the [layers control](#control-layers).
  		// @namespace Control.Layers
  		var type = obj.overlay ?
  			(e.type === 'add' ? 'overlayadd' : 'overlayremove') :
  			(e.type === 'add' ? 'baselayerchange' : null);

  		if (type) {
  			this._map.fire(type, obj);
  		}
  	},

  	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
  	_createRadioElement: function (name, checked) {

  		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' +
  				name + '"' + (checked ? ' checked="checked"' : '') + '/>';

  		var radioFragment = document.createElement('div');
  		radioFragment.innerHTML = radioHtml;

  		return radioFragment.firstChild;
  	},

  	_addItem: function (obj) {
  		var label = document.createElement('label'),
  		    checked = this._map.hasLayer(obj.layer),
  		    input;

  		if (obj.overlay) {
  			input = document.createElement('input');
  			input.type = 'checkbox';
  			input.className = 'leaflet-control-layers-selector';
  			input.defaultChecked = checked;
  		} else {
  			input = this._createRadioElement('leaflet-base-layers_' + stamp(this), checked);
  		}

  		this._layerControlInputs.push(input);
  		input.layerId = stamp(obj.layer);

  		on(input, 'click', this._onInputClick, this);

  		var name = document.createElement('span');
  		name.innerHTML = ' ' + obj.name;

  		// Helps from preventing layer control flicker when checkboxes are disabled
  		// https://github.com/Leaflet/Leaflet/issues/2771
  		var holder = document.createElement('span');

  		label.appendChild(holder);
  		holder.appendChild(input);
  		holder.appendChild(name);

  		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
  		container.appendChild(label);

  		this._checkDisabledLayers();
  		return label;
  	},

  	_onInputClick: function () {
  		// expanding the control on mobile with a click can cause adding a layer - we don't want this
  		if (this._preventClick) {
  			return;
  		}

  		var inputs = this._layerControlInputs,
  		    input, layer;
  		var addedLayers = [],
  		    removedLayers = [];

  		this._handlingClick = true;

  		for (var i = inputs.length - 1; i >= 0; i--) {
  			input = inputs[i];
  			layer = this._getLayer(input.layerId).layer;

  			if (input.checked) {
  				addedLayers.push(layer);
  			} else if (!input.checked) {
  				removedLayers.push(layer);
  			}
  		}

  		// Bugfix issue 2318: Should remove all old layers before readding new ones
  		for (i = 0; i < removedLayers.length; i++) {
  			if (this._map.hasLayer(removedLayers[i])) {
  				this._map.removeLayer(removedLayers[i]);
  			}
  		}
  		for (i = 0; i < addedLayers.length; i++) {
  			if (!this._map.hasLayer(addedLayers[i])) {
  				this._map.addLayer(addedLayers[i]);
  			}
  		}

  		this._handlingClick = false;

  		this._refocusOnMap();
  	},

  	_checkDisabledLayers: function () {
  		var inputs = this._layerControlInputs,
  		    input,
  		    layer,
  		    zoom = this._map.getZoom();

  		for (var i = inputs.length - 1; i >= 0; i--) {
  			input = inputs[i];
  			layer = this._getLayer(input.layerId).layer;
  			input.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) ||
  			                 (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);

  		}
  	},

  	_expandIfNotCollapsed: function () {
  		if (this._map && !this.options.collapsed) {
  			this.expand();
  		}
  		return this;
  	},

  	_expandSafely: function () {
  		var section = this._section;
  		this._preventClick = true;
  		on(section, 'click', preventDefault);
  		this.expand();
  		var that = this;
  		setTimeout(function () {
  			off(section, 'click', preventDefault);
  			that._preventClick = false;
  		});
  	}

  });


  // @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
  // Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
  var layers = function (baseLayers, overlays, options) {
  	return new Layers(baseLayers, overlays, options);
  };

  /*
   * @class Control.Zoom
   * @aka L.Control.Zoom
   * @inherits Control
   *
   * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
   */

  var Zoom = Control.extend({
  	// @section
  	// @aka Control.Zoom options
  	options: {
  		position: 'topleft',

  		// @option zoomInText: String = '<span aria-hidden="true">+</span>'
  		// The text set on the 'zoom in' button.
  		zoomInText: '<span aria-hidden="true">+</span>',

  		// @option zoomInTitle: String = 'Zoom in'
  		// The title set on the 'zoom in' button.
  		zoomInTitle: 'Zoom in',

  		// @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
  		// The text set on the 'zoom out' button.
  		zoomOutText: '<span aria-hidden="true">&#x2212;</span>',

  		// @option zoomOutTitle: String = 'Zoom out'
  		// The title set on the 'zoom out' button.
  		zoomOutTitle: 'Zoom out'
  	},

  	onAdd: function (map) {
  		var zoomName = 'leaflet-control-zoom',
  		    container = create$1('div', zoomName + ' leaflet-bar'),
  		    options = this.options;

  		this._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,
  		        zoomName + '-in',  container, this._zoomIn);
  		this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,
  		        zoomName + '-out', container, this._zoomOut);

  		this._updateDisabled();
  		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

  		return container;
  	},

  	onRemove: function (map) {
  		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
  	},

  	disable: function () {
  		this._disabled = true;
  		this._updateDisabled();
  		return this;
  	},

  	enable: function () {
  		this._disabled = false;
  		this._updateDisabled();
  		return this;
  	},

  	_zoomIn: function (e) {
  		if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
  			this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
  		}
  	},

  	_zoomOut: function (e) {
  		if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
  			this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
  		}
  	},

  	_createButton: function (html, title, className, container, fn) {
  		var link = create$1('a', className, container);
  		link.innerHTML = html;
  		link.href = '#';
  		link.title = title;

  		/*
  		 * Will force screen readers like VoiceOver to read this as "Zoom in - button"
  		 */
  		link.setAttribute('role', 'button');
  		link.setAttribute('aria-label', title);

  		disableClickPropagation(link);
  		on(link, 'click', stop);
  		on(link, 'click', fn, this);
  		on(link, 'click', this._refocusOnMap, this);

  		return link;
  	},

  	_updateDisabled: function () {
  		var map = this._map,
  		    className = 'leaflet-disabled';

  		removeClass(this._zoomInButton, className);
  		removeClass(this._zoomOutButton, className);
  		this._zoomInButton.setAttribute('aria-disabled', 'false');
  		this._zoomOutButton.setAttribute('aria-disabled', 'false');

  		if (this._disabled || map._zoom === map.getMinZoom()) {
  			addClass(this._zoomOutButton, className);
  			this._zoomOutButton.setAttribute('aria-disabled', 'true');
  		}
  		if (this._disabled || map._zoom === map.getMaxZoom()) {
  			addClass(this._zoomInButton, className);
  			this._zoomInButton.setAttribute('aria-disabled', 'true');
  		}
  	}
  });

  // @namespace Map
  // @section Control options
  // @option zoomControl: Boolean = true
  // Whether a [zoom control](#control-zoom) is added to the map by default.
  Map.mergeOptions({
  	zoomControl: true
  });

  Map.addInitHook(function () {
  	if (this.options.zoomControl) {
  		// @section Controls
  		// @property zoomControl: Control.Zoom
  		// The default zoom control (only available if the
  		// [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).
  		this.zoomControl = new Zoom();
  		this.addControl(this.zoomControl);
  	}
  });

  // @namespace Control.Zoom
  // @factory L.control.zoom(options: Control.Zoom options)
  // Creates a zoom control
  var zoom = function (options) {
  	return new Zoom(options);
  };

  /*
   * @class Control.Scale
   * @aka L.Control.Scale
   * @inherits Control
   *
   * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
   *
   * @example
   *
   * ```js
   * L.control.scale().addTo(map);
   * ```
   */

  var Scale = Control.extend({
  	// @section
  	// @aka Control.Scale options
  	options: {
  		position: 'bottomleft',

  		// @option maxWidth: Number = 100
  		// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
  		maxWidth: 100,

  		// @option metric: Boolean = True
  		// Whether to show the metric scale line (m/km).
  		metric: true,

  		// @option imperial: Boolean = True
  		// Whether to show the imperial scale line (mi/ft).
  		imperial: true

  		// @option updateWhenIdle: Boolean = false
  		// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
  	},

  	onAdd: function (map) {
  		var className = 'leaflet-control-scale',
  		    container = create$1('div', className),
  		    options = this.options;

  		this._addScales(options, className + '-line', container);

  		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
  		map.whenReady(this._update, this);

  		return container;
  	},

  	onRemove: function (map) {
  		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
  	},

  	_addScales: function (options, className, container) {
  		if (options.metric) {
  			this._mScale = create$1('div', className, container);
  		}
  		if (options.imperial) {
  			this._iScale = create$1('div', className, container);
  		}
  	},

  	_update: function () {
  		var map = this._map,
  		    y = map.getSize().y / 2;

  		var maxMeters = map.distance(
  			map.containerPointToLatLng([0, y]),
  			map.containerPointToLatLng([this.options.maxWidth, y]));

  		this._updateScales(maxMeters);
  	},

  	_updateScales: function (maxMeters) {
  		if (this.options.metric && maxMeters) {
  			this._updateMetric(maxMeters);
  		}
  		if (this.options.imperial && maxMeters) {
  			this._updateImperial(maxMeters);
  		}
  	},

  	_updateMetric: function (maxMeters) {
  		var meters = this._getRoundNum(maxMeters),
  		    label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';

  		this._updateScale(this._mScale, label, meters / maxMeters);
  	},

  	_updateImperial: function (maxMeters) {
  		var maxFeet = maxMeters * 3.2808399,
  		    maxMiles, miles, feet;

  		if (maxFeet > 5280) {
  			maxMiles = maxFeet / 5280;
  			miles = this._getRoundNum(maxMiles);
  			this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);

  		} else {
  			feet = this._getRoundNum(maxFeet);
  			this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
  		}
  	},

  	_updateScale: function (scale, text, ratio) {
  		scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
  		scale.innerHTML = text;
  	},

  	_getRoundNum: function (num) {
  		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
  		    d = num / pow10;

  		d = d >= 10 ? 10 :
  		    d >= 5 ? 5 :
  		    d >= 3 ? 3 :
  		    d >= 2 ? 2 : 1;

  		return pow10 * d;
  	}
  });


  // @factory L.control.scale(options?: Control.Scale options)
  // Creates an scale control with the given options.
  var scale = function (options) {
  	return new Scale(options);
  };

  var ukrainianFlag = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>';


  /*
   * @class Control.Attribution
   * @aka L.Control.Attribution
   * @inherits Control
   *
   * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
   */

  var Attribution = Control.extend({
  	// @section
  	// @aka Control.Attribution options
  	options: {
  		position: 'bottomright',

  		// @option prefix: String|false = 'Leaflet'
  		// The HTML text shown before the attributions. Pass `false` to disable.
  		prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Browser.inlineSvg ? ukrainianFlag + ' ' : '') + 'Leaflet</a>'
  	},

  	initialize: function (options) {
  		setOptions(this, options);

  		this._attributions = {};
  	},

  	onAdd: function (map) {
  		map.attributionControl = this;
  		this._container = create$1('div', 'leaflet-control-attribution');
  		disableClickPropagation(this._container);

  		// TODO ugly, refactor
  		for (var i in map._layers) {
  			if (map._layers[i].getAttribution) {
  				this.addAttribution(map._layers[i].getAttribution());
  			}
  		}

  		this._update();

  		map.on('layeradd', this._addAttribution, this);

  		return this._container;
  	},

  	onRemove: function (map) {
  		map.off('layeradd', this._addAttribution, this);
  	},

  	_addAttribution: function (ev) {
  		if (ev.layer.getAttribution) {
  			this.addAttribution(ev.layer.getAttribution());
  			ev.layer.once('remove', function () {
  				this.removeAttribution(ev.layer.getAttribution());
  			}, this);
  		}
  	},

  	// @method setPrefix(prefix: String|false): this
  	// The HTML text shown before the attributions. Pass `false` to disable.
  	setPrefix: function (prefix) {
  		this.options.prefix = prefix;
  		this._update();
  		return this;
  	},

  	// @method addAttribution(text: String): this
  	// Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).
  	addAttribution: function (text) {
  		if (!text) { return this; }

  		if (!this._attributions[text]) {
  			this._attributions[text] = 0;
  		}
  		this._attributions[text]++;

  		this._update();

  		return this;
  	},

  	// @method removeAttribution(text: String): this
  	// Removes an attribution text.
  	removeAttribution: function (text) {
  		if (!text) { return this; }

  		if (this._attributions[text]) {
  			this._attributions[text]--;
  			this._update();
  		}

  		return this;
  	},

  	_update: function () {
  		if (!this._map) { return; }

  		var attribs = [];

  		for (var i in this._attributions) {
  			if (this._attributions[i]) {
  				attribs.push(i);
  			}
  		}

  		var prefixAndAttribs = [];

  		if (this.options.prefix) {
  			prefixAndAttribs.push(this.options.prefix);
  		}
  		if (attribs.length) {
  			prefixAndAttribs.push(attribs.join(', '));
  		}

  		this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden="true">|</span> ');
  	}
  });

  // @namespace Map
  // @section Control options
  // @option attributionControl: Boolean = true
  // Whether a [attribution control](#control-attribution) is added to the map by default.
  Map.mergeOptions({
  	attributionControl: true
  });

  Map.addInitHook(function () {
  	if (this.options.attributionControl) {
  		new Attribution().addTo(this);
  	}
  });

  // @namespace Control.Attribution
  // @factory L.control.attribution(options: Control.Attribution options)
  // Creates an attribution control.
  var attribution = function (options) {
  	return new Attribution(options);
  };

  Control.Layers = Layers;
  Control.Zoom = Zoom;
  Control.Scale = Scale;
  Control.Attribution = Attribution;

  control.layers = layers;
  control.zoom = zoom;
  control.scale = scale;
  control.attribution = attribution;

  /*
  	L.Handler is a base class for handler classes that are used internally to inject
  	interaction features like dragging to classes like Map and Marker.
  */

  // @class Handler
  // @aka L.Handler
  // Abstract class for map interaction handlers

  var Handler = Class.extend({
  	initialize: function (map) {
  		this._map = map;
  	},

  	// @method enable(): this
  	// Enables the handler
  	enable: function () {
  		if (this._enabled) { return this; }

  		this._enabled = true;
  		this.addHooks();
  		return this;
  	},

  	// @method disable(): this
  	// Disables the handler
  	disable: function () {
  		if (!this._enabled) { return this; }

  		this._enabled = false;
  		this.removeHooks();
  		return this;
  	},

  	// @method enabled(): Boolean
  	// Returns `true` if the handler is enabled
  	enabled: function () {
  		return !!this._enabled;
  	}

  	// @section Extension methods
  	// Classes inheriting from `Handler` must implement the two following methods:
  	// @method addHooks()
  	// Called when the handler is enabled, should add event hooks.
  	// @method removeHooks()
  	// Called when the handler is disabled, should remove the event hooks added previously.
  });

  // @section There is static function which can be called without instantiating L.Handler:
  // @function addTo(map: Map, name: String): this
  // Adds a new Handler to the given map with the given name.
  Handler.addTo = function (map, name) {
  	map.addHandler(name, this);
  	return this;
  };

  var Mixin = {Events: Events};

  /*
   * @class Draggable
   * @aka L.Draggable
   * @inherits Evented
   *
   * A class for making DOM elements draggable (including touch support).
   * Used internally for map and marker dragging. Only works for elements
   * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
   *
   * @example
   * ```js
   * var draggable = new L.Draggable(elementToDrag);
   * draggable.enable();
   * ```
   */

  var START = Browser.touch ? 'touchstart mousedown' : 'mousedown';

  var Draggable = Evented.extend({

  	options: {
  		// @section
  		// @aka Draggable options
  		// @option clickTolerance: Number = 3
  		// The max number of pixels a user can shift the mouse pointer during a click
  		// for it to be considered a valid click (as opposed to a mouse drag).
  		clickTolerance: 3
  	},

  	// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
  	// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
  	initialize: function (element, dragStartTarget, preventOutline, options) {
  		setOptions(this, options);

  		this._element = element;
  		this._dragStartTarget = dragStartTarget || element;
  		this._preventOutline = preventOutline;
  	},

  	// @method enable()
  	// Enables the dragging ability
  	enable: function () {
  		if (this._enabled) { return; }

  		on(this._dragStartTarget, START, this._onDown, this);

  		this._enabled = true;
  	},

  	// @method disable()
  	// Disables the dragging ability
  	disable: function () {
  		if (!this._enabled) { return; }

  		// If we're currently dragging this draggable,
  		// disabling it counts as first ending the drag.
  		if (Draggable._dragging === this) {
  			this.finishDrag(true);
  		}

  		off(this._dragStartTarget, START, this._onDown, this);

  		this._enabled = false;
  		this._moved = false;
  	},

  	_onDown: function (e) {
  		// Ignore the event if disabled; this happens in IE11
  		// under some circumstances, see #3666.
  		if (!this._enabled) { return; }

  		this._moved = false;

  		if (hasClass(this._element, 'leaflet-zoom-anim')) { return; }

  		if (e.touches && e.touches.length !== 1) {
  			// Finish dragging to avoid conflict with touchZoom
  			if (Draggable._dragging === this) {
  				this.finishDrag();
  			}
  			return;
  		}

  		if (Draggable._dragging || e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }
  		Draggable._dragging = this;  // Prevent dragging multiple objects at once.

  		if (this._preventOutline) {
  			preventOutline(this._element);
  		}

  		disableImageDrag();
  		disableTextSelection();

  		if (this._moving) { return; }

  		// @event down: Event
  		// Fired when a drag is about to start.
  		this.fire('down');

  		var first = e.touches ? e.touches[0] : e,
  		    sizedParent = getSizedParentNode(this._element);

  		this._startPoint = new Point(first.clientX, first.clientY);
  		this._startPos = getPosition(this._element);

  		// Cache the scale, so that we can continuously compensate for it during drag (_onMove).
  		this._parentScale = getScale(sizedParent);

  		var mouseevent = e.type === 'mousedown';
  		on(document, mouseevent ? 'mousemove' : 'touchmove', this._onMove, this);
  		on(document, mouseevent ? 'mouseup' : 'touchend touchcancel', this._onUp, this);
  	},

  	_onMove: function (e) {
  		// Ignore the event if disabled; this happens in IE11
  		// under some circumstances, see #3666.
  		if (!this._enabled) { return; }

  		if (e.touches && e.touches.length > 1) {
  			this._moved = true;
  			return;
  		}

  		var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
  		    offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);

  		if (!offset.x && !offset.y) { return; }
  		if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) { return; }

  		// We assume that the parent container's position, border and scale do not change for the duration of the drag.
  		// Therefore there is no need to account for the position and border (they are eliminated by the subtraction)
  		// and we can use the cached value for the scale.
  		offset.x /= this._parentScale.x;
  		offset.y /= this._parentScale.y;

  		preventDefault(e);

  		if (!this._moved) {
  			// @event dragstart: Event
  			// Fired when a drag starts
  			this.fire('dragstart');

  			this._moved = true;

  			addClass(document.body, 'leaflet-dragging');

  			this._lastTarget = e.target || e.srcElement;
  			// IE and Edge do not give the <use> element, so fetch it
  			// if necessary
  			if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
  				this._lastTarget = this._lastTarget.correspondingUseElement;
  			}
  			addClass(this._lastTarget, 'leaflet-drag-target');
  		}

  		this._newPos = this._startPos.add(offset);
  		this._moving = true;

  		this._lastEvent = e;
  		this._updatePosition();
  	},

  	_updatePosition: function () {
  		var e = {originalEvent: this._lastEvent};

  		// @event predrag: Event
  		// Fired continuously during dragging *before* each corresponding
  		// update of the element's position.
  		this.fire('predrag', e);
  		setPosition(this._element, this._newPos);

  		// @event drag: Event
  		// Fired continuously during dragging.
  		this.fire('drag', e);
  	},

  	_onUp: function () {
  		// Ignore the event if disabled; this happens in IE11
  		// under some circumstances, see #3666.
  		if (!this._enabled) { return; }
  		this.finishDrag();
  	},

  	finishDrag: function (noInertia) {
  		removeClass(document.body, 'leaflet-dragging');

  		if (this._lastTarget) {
  			removeClass(this._lastTarget, 'leaflet-drag-target');
  			this._lastTarget = null;
  		}

  		off(document, 'mousemove touchmove', this._onMove, this);
  		off(document, 'mouseup touchend touchcancel', this._onUp, this);

  		enableImageDrag();
  		enableTextSelection();

  		var fireDragend = this._moved && this._moving;

  		this._moving = false;
  		Draggable._dragging = false;

  		if (fireDragend) {
  			// @event dragend: DragEndEvent
  			// Fired when the drag ends.
  			this.fire('dragend', {
  				noInertia: noInertia,
  				distance: this._newPos.distanceTo(this._startPos)
  			});
  		}
  	}

  });

  /*
   * @namespace PolyUtil
   * Various utility functions for polygon geometries.
   */

  /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
   * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
   * Used by Leaflet to only show polygon points that are on the screen or near, increasing
   * performance. Note that polygon points needs different algorithm for clipping
   * than polyline, so there's a separate method for it.
   */
  function clipPolygon(points, bounds, round) {
  	var clippedPoints,
  	    edges = [1, 4, 2, 8],
  	    i, j, k,
  	    a, b,
  	    len, edge, p;

  	for (i = 0, len = points.length; i < len; i++) {
  		points[i]._code = _getBitCode(points[i], bounds);
  	}

  	// for each edge (left, bottom, right, top)
  	for (k = 0; k < 4; k++) {
  		edge = edges[k];
  		clippedPoints = [];

  		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
  			a = points[i];
  			b = points[j];

  			// if a is inside the clip window
  			if (!(a._code & edge)) {
  				// if b is outside the clip window (a->b goes out of screen)
  				if (b._code & edge) {
  					p = _getEdgeIntersection(b, a, edge, bounds, round);
  					p._code = _getBitCode(p, bounds);
  					clippedPoints.push(p);
  				}
  				clippedPoints.push(a);

  			// else if b is inside the clip window (a->b enters the screen)
  			} else if (!(b._code & edge)) {
  				p = _getEdgeIntersection(b, a, edge, bounds, round);
  				p._code = _getBitCode(p, bounds);
  				clippedPoints.push(p);
  			}
  		}
  		points = clippedPoints;
  	}

  	return points;
  }

  /* @function polygonCenter(latlngs: LatLng[], crs: CRS): LatLng
   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polygon.
   */
  function polygonCenter(latlngs, crs) {
  	var i, j, p1, p2, f, area, x, y, center;

  	if (!latlngs || latlngs.length === 0) {
  		throw new Error('latlngs not passed');
  	}

  	if (!isFlat(latlngs)) {
  		console.warn('latlngs are not flat! Only the first ring will be used');
  		latlngs = latlngs[0];
  	}

  	var centroidLatLng = toLatLng([0, 0]);

  	var bounds = toLatLngBounds(latlngs);
  	var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
  	// tests showed that below 1700 rounding errors are happening
  	if (areaBounds < 1700) {
  		// getting a inexact center, to move the latlngs near to [0, 0] to prevent rounding errors
  		centroidLatLng = centroid(latlngs);
  	}

  	var len = latlngs.length;
  	var points = [];
  	for (i = 0; i < len; i++) {
  		var latlng = toLatLng(latlngs[i]);
  		points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
  	}

  	area = x = y = 0;

  	// polygon centroid algorithm;
  	for (i = 0, j = len - 1; i < len; j = i++) {
  		p1 = points[i];
  		p2 = points[j];

  		f = p1.y * p2.x - p2.y * p1.x;
  		x += (p1.x + p2.x) * f;
  		y += (p1.y + p2.y) * f;
  		area += f * 3;
  	}

  	if (area === 0) {
  		// Polygon is so small that all points are on same pixel.
  		center = points[0];
  	} else {
  		center = [x / area, y / area];
  	}

  	var latlngCenter = crs.unproject(toPoint(center));
  	return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
  }

  /* @function centroid(latlngs: LatLng[]): LatLng
   * Returns the 'center of mass' of the passed LatLngs.
   */
  function centroid(coords) {
  	var latSum = 0;
  	var lngSum = 0;
  	var len = 0;
  	for (var i = 0; i < coords.length; i++) {
  		var latlng = toLatLng(coords[i]);
  		latSum += latlng.lat;
  		lngSum += latlng.lng;
  		len++;
  	}
  	return toLatLng([latSum / len, lngSum / len]);
  }

  var PolyUtil = {
    __proto__: null,
    clipPolygon: clipPolygon,
    polygonCenter: polygonCenter,
    centroid: centroid
  };

  /*
   * @namespace LineUtil
   *
   * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.
   */

  // Simplify polyline with vertex reduction and Douglas-Peucker simplification.
  // Improves rendering performance dramatically by lessening the number of points to draw.

  // @function simplify(points: Point[], tolerance: Number): Point[]
  // Dramatically reduces the number of points in a polyline while retaining
  // its shape and returns a new array of simplified points, using the
  // [Ramer-Douglas-Peucker algorithm](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm).
  // Used for a huge performance boost when processing/displaying Leaflet polylines for
  // each zoom level and also reducing visual noise. tolerance affects the amount of
  // simplification (lesser value means higher quality but slower and with more points).
  // Also released as a separated micro-library [Simplify.js](https://mourner.github.io/simplify-js/).
  function simplify(points, tolerance) {
  	if (!tolerance || !points.length) {
  		return points.slice();
  	}

  	var sqTolerance = tolerance * tolerance;

  	    // stage 1: vertex reduction
  	    points = _reducePoints(points, sqTolerance);

  	    // stage 2: Douglas-Peucker simplification
  	    points = _simplifyDP(points, sqTolerance);

  	return points;
  }

  // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
  // Returns the distance between point `p` and segment `p1` to `p2`.
  function pointToSegmentDistance(p, p1, p2) {
  	return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
  }

  // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
  // Returns the closest point from a point `p` on a segment `p1` to `p2`.
  function closestPointOnSegment(p, p1, p2) {
  	return _sqClosestPointOnSegment(p, p1, p2);
  }

  // Ramer-Douglas-Peucker simplification, see https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm
  function _simplifyDP(points, sqTolerance) {

  	var len = points.length,
  	    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
  	    markers = new ArrayConstructor(len);

  	    markers[0] = markers[len - 1] = 1;

  	_simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

  	var i,
  	    newPoints = [];

  	for (i = 0; i < len; i++) {
  		if (markers[i]) {
  			newPoints.push(points[i]);
  		}
  	}

  	return newPoints;
  }

  function _simplifyDPStep(points, markers, sqTolerance, first, last) {

  	var maxSqDist = 0,
  	index, i, sqDist;

  	for (i = first + 1; i <= last - 1; i++) {
  		sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);

  		if (sqDist > maxSqDist) {
  			index = i;
  			maxSqDist = sqDist;
  		}
  	}

  	if (maxSqDist > sqTolerance) {
  		markers[index] = 1;

  		_simplifyDPStep(points, markers, sqTolerance, first, index);
  		_simplifyDPStep(points, markers, sqTolerance, index, last);
  	}
  }

  // reduce points that are too close to each other to a single point
  function _reducePoints(points, sqTolerance) {
  	var reducedPoints = [points[0]];

  	for (var i = 1, prev = 0, len = points.length; i < len; i++) {
  		if (_sqDist(points[i], points[prev]) > sqTolerance) {
  			reducedPoints.push(points[i]);
  			prev = i;
  		}
  	}
  	if (prev < len - 1) {
  		reducedPoints.push(points[len - 1]);
  	}
  	return reducedPoints;
  }

  var _lastCode;

  // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
  // Clips the segment a to b by rectangular bounds with the
  // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
  // (modifying the segment points directly!). Used by Leaflet to only show polyline
  // points that are on the screen or near, increasing performance.
  function clipSegment(a, b, bounds, useLastCode, round) {
  	var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),
  	    codeB = _getBitCode(b, bounds),

  	    codeOut, p, newCode;

  	    // save 2nd code to avoid calculating it on the next segment
  	    _lastCode = codeB;

  	while (true) {
  		// if a,b is inside the clip window (trivial accept)
  		if (!(codeA | codeB)) {
  			return [a, b];
  		}

  		// if a,b is outside the clip window (trivial reject)
  		if (codeA & codeB) {
  			return false;
  		}

  		// other cases
  		codeOut = codeA || codeB;
  		p = _getEdgeIntersection(a, b, codeOut, bounds, round);
  		newCode = _getBitCode(p, bounds);

  		if (codeOut === codeA) {
  			a = p;
  			codeA = newCode;
  		} else {
  			b = p;
  			codeB = newCode;
  		}
  	}
  }

  function _getEdgeIntersection(a, b, code, bounds, round) {
  	var dx = b.x - a.x,
  	    dy = b.y - a.y,
  	    min = bounds.min,
  	    max = bounds.max,
  	    x, y;

  	if (code & 8) { // top
  		x = a.x + dx * (max.y - a.y) / dy;
  		y = max.y;

  	} else if (code & 4) { // bottom
  		x = a.x + dx * (min.y - a.y) / dy;
  		y = min.y;

  	} else if (code & 2) { // right
  		x = max.x;
  		y = a.y + dy * (max.x - a.x) / dx;

  	} else if (code & 1) { // left
  		x = min.x;
  		y = a.y + dy * (min.x - a.x) / dx;
  	}

  	return new Point(x, y, round);
  }

  function _getBitCode(p, bounds) {
  	var code = 0;

  	if (p.x < bounds.min.x) { // left
  		code |= 1;
  	} else if (p.x > bounds.max.x) { // right
  		code |= 2;
  	}

  	if (p.y < bounds.min.y) { // bottom
  		code |= 4;
  	} else if (p.y > bounds.max.y) { // top
  		code |= 8;
  	}

  	return code;
  }

  // square distance (to avoid unnecessary Math.sqrt calls)
  function _sqDist(p1, p2) {
  	var dx = p2.x - p1.x,
  	    dy = p2.y - p1.y;
  	return dx * dx + dy * dy;
  }

  // return closest point on segment or distance to that point
  function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
  	var x = p1.x,
  	    y = p1.y,
  	    dx = p2.x - x,
  	    dy = p2.y - y,
  	    dot = dx * dx + dy * dy,
  	    t;

  	if (dot > 0) {
  		t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

  		if (t > 1) {
  			x = p2.x;
  			y = p2.y;
  		} else if (t > 0) {
  			x += dx * t;
  			y += dy * t;
  		}
  	}

  	dx = p.x - x;
  	dy = p.y - y;

  	return sqDist ? dx * dx + dy * dy : new Point(x, y);
  }


  // @function isFlat(latlngs: LatLng[]): Boolean
  // Returns true if `latlngs` is a flat array, false is nested.
  function isFlat(latlngs) {
  	return !isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');
  }

  function _flat(latlngs) {
  	console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');
  	return isFlat(latlngs);
  }

  /* @function polylineCenter(latlngs: LatLng[], crs: CRS): LatLng
   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polyline.
   */
  function polylineCenter(latlngs, crs) {
  	var i, halfDist, segDist, dist, p1, p2, ratio, center;

  	if (!latlngs || latlngs.length === 0) {
  		throw new Error('latlngs not passed');
  	}

  	if (!isFlat(latlngs)) {
  		console.warn('latlngs are not flat! Only the first ring will be used');
  		latlngs = latlngs[0];
  	}

  	var centroidLatLng = toLatLng([0, 0]);

  	var bounds = toLatLngBounds(latlngs);
  	var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
  	// tests showed that below 1700 rounding errors are happening
  	if (areaBounds < 1700) {
  		// getting a inexact center, to move the latlngs near to [0, 0] to prevent rounding errors
  		centroidLatLng = centroid(latlngs);
  	}

  	var len = latlngs.length;
  	var points = [];
  	for (i = 0; i < len; i++) {
  		var latlng = toLatLng(latlngs[i]);
  		points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
  	}

  	for (i = 0, halfDist = 0; i < len - 1; i++) {
  		halfDist += points[i].distanceTo(points[i + 1]) / 2;
  	}

  	// The line is so small in the current view that all points are on the same pixel.
  	if (halfDist === 0) {
  		center = points[0];
  	} else {
  		for (i = 0, dist = 0; i < len - 1; i++) {
  			p1 = points[i];
  			p2 = points[i + 1];
  			segDist = p1.distanceTo(p2);
  			dist += segDist;

  			if (dist > halfDist) {
  				ratio = (dist - halfDist) / segDist;
  				center = [
  					p2.x - ratio * (p2.x - p1.x),
  					p2.y - ratio * (p2.y - p1.y)
  				];
  				break;
  			}
  		}
  	}

  	var latlngCenter = crs.unproject(toPoint(center));
  	return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
  }

  var LineUtil = {
    __proto__: null,
    simplify: simplify,
    pointToSegmentDistance: pointToSegmentDistance,
    closestPointOnSegment: closestPointOnSegment,
    clipSegment: clipSegment,
    _getEdgeIntersection: _getEdgeIntersection,
    _getBitCode: _getBitCode,
    _sqClosestPointOnSegment: _sqClosestPointOnSegment,
    isFlat: isFlat,
    _flat: _flat,
    polylineCenter: polylineCenter
  };

  /*
   * @namespace Projection
   * @section
   * Leaflet comes with a set of already defined Projections out of the box:
   *
   * @projection L.Projection.LonLat
   *
   * Equirectangular, or Plate Carree projection  the most simple projection,
   * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
   * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
   * `EPSG:4326` and `Simple` CRS.
   */

  var LonLat = {
  	project: function (latlng) {
  		return new Point(latlng.lng, latlng.lat);
  	},

  	unproject: function (point) {
  		return new LatLng(point.y, point.x);
  	},

  	bounds: new Bounds([-180, -90], [180, 90])
  };

  /*
   * @namespace Projection
   * @projection L.Projection.Mercator
   *
   * Elliptical Mercator projection  more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.
   */

  var Mercator = {
  	R: 6378137,
  	R_MINOR: 6356752.314245179,

  	bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

  	project: function (latlng) {
  		var d = Math.PI / 180,
  		    r = this.R,
  		    y = latlng.lat * d,
  		    tmp = this.R_MINOR / r,
  		    e = Math.sqrt(1 - tmp * tmp),
  		    con = e * Math.sin(y);

  		var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
  		y = -r * Math.log(Math.max(ts, 1E-10));

  		return new Point(latlng.lng * d * r, y);
  	},

  	unproject: function (point) {
  		var d = 180 / Math.PI,
  		    r = this.R,
  		    tmp = this.R_MINOR / r,
  		    e = Math.sqrt(1 - tmp * tmp),
  		    ts = Math.exp(-point.y / r),
  		    phi = Math.PI / 2 - 2 * Math.atan(ts);

  		for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
  			con = e * Math.sin(phi);
  			con = Math.pow((1 - con) / (1 + con), e / 2);
  			dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
  			phi += dphi;
  		}

  		return new LatLng(phi * d, point.x * d / r);
  	}
  };

  /*
   * @class Projection

   * An object with methods for projecting geographical coordinates of the world onto
   * a flat surface (and back). See [Map projection](https://en.wikipedia.org/wiki/Map_projection).

   * @property bounds: Bounds
   * The bounds (specified in CRS units) where the projection is valid

   * @method project(latlng: LatLng): Point
   * Projects geographical coordinates into a 2D point.
   * Only accepts actual `L.LatLng` instances, not arrays.

   * @method unproject(point: Point): LatLng
   * The inverse of `project`. Projects a 2D point into a geographical location.
   * Only accepts actual `L.Point` instances, not arrays.

   * Note that the projection instances do not inherit from Leaflet's `Class` object,
   * and can't be instantiated. Also, new classes can't inherit from them,
   * and methods can't be added to them with the `include` function.

   */

  var index = {
    __proto__: null,
    LonLat: LonLat,
    Mercator: Mercator,
    SphericalMercator: SphericalMercator
  };

  /*
   * @namespace CRS
   * @crs L.CRS.EPSG3395
   *
   * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
   */
  var EPSG3395 = extend({}, Earth, {
  	code: 'EPSG:3395',
  	projection: Mercator,

  	transformation: (function () {
  		var scale = 0.5 / (Math.PI * Mercator.R);
  		return toTransformation(scale, 0.5, -scale, 0.5);
  	}())
  });

  /*
   * @namespace CRS
   * @crs L.CRS.EPSG4326
   *
   * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
   *
   * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
   * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
   * with this CRS, ensure that there are two 256x256 pixel tiles covering the
   * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
   * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
   */

  var EPSG4326 = extend({}, Earth, {
  	code: 'EPSG:4326',
  	projection: LonLat,
  	transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
  });

  /*
   * @namespace CRS
   * @crs L.CRS.Simple
   *
   * A simple CRS that maps longitude and latitude into `x` and `y` directly.
   * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
   * axis should still be inverted (going from bottom to top). `distance()` returns
   * simple euclidean distance.
   */

  var Simple = extend({}, CRS, {
  	projection: LonLat,
  	transformation: toTransformation(1, 0, -1, 0),

  	scale: function (zoom) {
  		return Math.pow(2, zoom);
  	},

  	zoom: function (scale) {
  		return Math.log(scale) / Math.LN2;
  	},

  	distance: function (latlng1, latlng2) {
  		var dx = latlng2.lng - latlng1.lng,
  		    dy = latlng2.lat - latlng1.lat;

  		return Math.sqrt(dx * dx + dy * dy);
  	},

  	infinite: true
  });

  CRS.Earth = Earth;
  CRS.EPSG3395 = EPSG3395;
  CRS.EPSG3857 = EPSG3857;
  CRS.EPSG900913 = EPSG900913;
  CRS.EPSG4326 = EPSG4326;
  CRS.Simple = Simple;

  /*
   * @class Layer
   * @inherits Evented
   * @aka L.Layer
   * @aka ILayer
   *
   * A set of methods from the Layer base class that all Leaflet layers use.
   * Inherits all methods, options and events from `L.Evented`.
   *
   * @example
   *
   * ```js
   * var layer = L.marker(latlng).addTo(map);
   * layer.addTo(map);
   * layer.remove();
   * ```
   *
   * @event add: Event
   * Fired after the layer is added to a map
   *
   * @event remove: Event
   * Fired after the layer is removed from a map
   */


  var Layer = Evented.extend({

  	// Classes extending `L.Layer` will inherit the following options:
  	options: {
  		// @option pane: String = 'overlayPane'
  		// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
  		pane: 'overlayPane',

  		// @option attribution: String = null
  		// String to be shown in the attribution control, e.g. " OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
  		attribution: null,

  		bubblingMouseEvents: true
  	},

  	/* @section
  	 * Classes extending `L.Layer` will inherit the following methods:
  	 *
  	 * @method addTo(map: Map|LayerGroup): this
  	 * Adds the layer to the given map or layer group.
  	 */
  	addTo: function (map) {
  		map.addLayer(this);
  		return this;
  	},

  	// @method remove: this
  	// Removes the layer from the map it is currently active on.
  	remove: function () {
  		return this.removeFrom(this._map || this._mapToAdd);
  	},

  	// @method removeFrom(map: Map): this
  	// Removes the layer from the given map
  	//
  	// @alternative
  	// @method removeFrom(group: LayerGroup): this
  	// Removes the layer from the given `LayerGroup`
  	removeFrom: function (obj) {
  		if (obj) {
  			obj.removeLayer(this);
  		}
  		return this;
  	},

  	// @method getPane(name? : String): HTMLElement
  	// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
  	getPane: function (name) {
  		return this._map.getPane(name ? (this.options[name] || name) : this.options.pane);
  	},

  	addInteractiveTarget: function (targetEl) {
  		this._map._targets[stamp(targetEl)] = this;
  		return this;
  	},

  	removeInteractiveTarget: function (targetEl) {
  		delete this._map._targets[stamp(targetEl)];
  		return this;
  	},

  	// @method getAttribution: String
  	// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
  	getAttribution: function () {
  		return this.options.attribution;
  	},

  	_layerAdd: function (e) {
  		var map = e.target;

  		// check in case layer gets added and then removed before the map is ready
  		if (!map.hasLayer(this)) { return; }

  		this._map = map;
  		this._zoomAnimated = map._zoomAnimated;

  		if (this.getEvents) {
  			var events = this.getEvents();
  			map.on(events, this);
  			this.once('remove', function () {
  				map.off(events, this);
  			}, this);
  		}

  		this.onAdd(map);

  		this.fire('add');
  		map.fire('layeradd', {layer: this});
  	}
  });

  /* @section Extension methods
   * @uninheritable
   *
   * Every layer should extend from `L.Layer` and (re-)implement the following methods.
   *
   * @method onAdd(map: Map): this
   * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
   *
   * @method onRemove(map: Map): this
   * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
   *
   * @method getEvents(): Object
   * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
   *
   * @method getAttribution(): String
   * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
   *
   * @method beforeAdd(map: Map): this
   * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
   */


  /* @namespace Map
   * @section Layer events
   *
   * @event layeradd: LayerEvent
   * Fired when a new layer is added to the map.
   *
   * @event layerremove: LayerEvent
   * Fired when some layer is removed from the map
   *
   * @section Methods for Layers and Controls
   */
  Map.include({
  	// @method addLayer(layer: Layer): this
  	// Adds the given layer to the map
  	addLayer: function (layer) {
  		if (!layer._layerAdd) {
  			throw new Error('The provided object is not a Layer.');
  		}

  		var id = stamp(layer);
  		if (this._layers[id]) { return this; }
  		this._layers[id] = layer;

  		layer._mapToAdd = this;

  		if (layer.beforeAdd) {
  			layer.beforeAdd(this);
  		}

  		this.whenReady(layer._layerAdd, layer);

  		return this;
  	},

  	// @method removeLayer(layer: Layer): this
  	// Removes the given layer from the map.
  	removeLayer: function (layer) {
  		var id = stamp(layer);

  		if (!this._layers[id]) { return this; }

  		if (this._loaded) {
  			layer.onRemove(this);
  		}

  		delete this._layers[id];

  		if (this._loaded) {
  			this.fire('layerremove', {layer: layer});
  			layer.fire('remove');
  		}

  		layer._map = layer._mapToAdd = null;

  		return this;
  	},

  	// @method hasLayer(layer: Layer): Boolean
  	// Returns `true` if the given layer is currently added to the map
  	hasLayer: function (layer) {
  		return stamp(layer) in this._layers;
  	},

  	/* @method eachLayer(fn: Function, context?: Object): this
  	 * Iterates over the layers of the map, optionally specifying context of the iterator function.
  	 * ```
  	 * map.eachLayer(function(layer){
  	 *     layer.bindPopup('Hello');
  	 * });
  	 * ```
  	 */
  	eachLayer: function (method, context) {
  		for (var i in this._layers) {
  			method.call(context, this._layers[i]);
  		}
  		return this;
  	},

  	_addLayers: function (layers) {
  		layers = layers ? (isArray(layers) ? layers : [layers]) : [];

  		for (var i = 0, len = layers.length; i < len; i++) {
  			this.addLayer(layers[i]);
  		}
  	},

  	_addZoomLimit: function (layer) {
  		if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
  			this._zoomBoundLayers[stamp(layer)] = layer;
  			this._updateZoomLevels();
  		}
  	},

  	_removeZoomLimit: function (layer) {
  		var id = stamp(layer);

  		if (this._zoomBoundLayers[id]) {
  			delete this._zoomBoundLayers[id];
  			this._updateZoomLevels();
  		}
  	},

  	_updateZoomLevels: function () {
  		var minZoom = Infinity,
  		    maxZoom = -Infinity,
  		    oldZoomSpan = this._getZoomSpan();

  		for (var i in this._zoomBoundLayers) {
  			var options = this._zoomBoundLayers[i].options;

  			minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
  			maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
  		}

  		this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
  		this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

  		// @section Map state change events
  		// @event zoomlevelschange: Event
  		// Fired when the number of zoomlevels on the map is changed due
  		// to adding or removing a layer.
  		if (oldZoomSpan !== this._getZoomSpan()) {
  			this.fire('zoomlevelschange');
  		}

  		if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
  			this.setZoom(this._layersMaxZoom);
  		}
  		if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
  			this.setZoom(this._layersMinZoom);
  		}
  	}
  });

  /*
   * @class LayerGroup
   * @aka L.LayerGroup
   * @inherits Interactive layer
   *
   * Used to group several layers and handle them as one. If you add it to the map,
   * any layers added or removed from the group will be added/removed on the map as
   * well. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * L.layerGroup([marker1, marker2])
   * 	.addLayer(polyline)
   * 	.addTo(map);
   * ```
   */

  var LayerGroup = Layer.extend({

  	initialize: function (layers, options) {
  		setOptions(this, options);

  		this._layers = {};

  		var i, len;

  		if (layers) {
  			for (i = 0, len = layers.length; i < len; i++) {
  				this.addLayer(layers[i]);
  			}
  		}
  	},

  	// @method addLayer(layer: Layer): this
  	// Adds the given layer to the group.
  	addLayer: function (layer) {
  		var id = this.getLayerId(layer);

  		this._layers[id] = layer;

  		if (this._map) {
  			this._map.addLayer(layer);
  		}

  		return this;
  	},

  	// @method removeLayer(layer: Layer): this
  	// Removes the given layer from the group.
  	// @alternative
  	// @method removeLayer(id: Number): this
  	// Removes the layer with the given internal ID from the group.
  	removeLayer: function (layer) {
  		var id = layer in this._layers ? layer : this.getLayerId(layer);

  		if (this._map && this._layers[id]) {
  			this._map.removeLayer(this._layers[id]);
  		}

  		delete this._layers[id];

  		return this;
  	},

  	// @method hasLayer(layer: Layer): Boolean
  	// Returns `true` if the given layer is currently added to the group.
  	// @alternative
  	// @method hasLayer(id: Number): Boolean
  	// Returns `true` if the given internal ID is currently added to the group.
  	hasLayer: function (layer) {
  		var layerId = typeof layer === 'number' ? layer : this.getLayerId(layer);
  		return layerId in this._layers;
  	},

  	// @method clearLayers(): this
  	// Removes all the layers from the group.
  	clearLayers: function () {
  		return this.eachLayer(this.removeLayer, this);
  	},

  	// @method invoke(methodName: String, ): this
  	// Calls `methodName` on every layer contained in this group, passing any
  	// additional parameters. Has no effect if the layers contained do not
  	// implement `methodName`.
  	invoke: function (methodName) {
  		var args = Array.prototype.slice.call(arguments, 1),
  		    i, layer;

  		for (i in this._layers) {
  			layer = this._layers[i];

  			if (layer[methodName]) {
  				layer[methodName].apply(layer, args);
  			}
  		}

  		return this;
  	},

  	onAdd: function (map) {
  		this.eachLayer(map.addLayer, map);
  	},

  	onRemove: function (map) {
  		this.eachLayer(map.removeLayer, map);
  	},

  	// @method eachLayer(fn: Function, context?: Object): this
  	// Iterates over the layers of the group, optionally specifying context of the iterator function.
  	// ```js
  	// group.eachLayer(function (layer) {
  	// 	layer.bindPopup('Hello');
  	// });
  	// ```
  	eachLayer: function (method, context) {
  		for (var i in this._layers) {
  			method.call(context, this._layers[i]);
  		}
  		return this;
  	},

  	// @method getLayer(id: Number): Layer
  	// Returns the layer with the given internal ID.
  	getLayer: function (id) {
  		return this._layers[id];
  	},

  	// @method getLayers(): Layer[]
  	// Returns an array of all the layers added to the group.
  	getLayers: function () {
  		var layers = [];
  		this.eachLayer(layers.push, layers);
  		return layers;
  	},

  	// @method setZIndex(zIndex: Number): this
  	// Calls `setZIndex` on every layer contained in this group, passing the z-index.
  	setZIndex: function (zIndex) {
  		return this.invoke('setZIndex', zIndex);
  	},

  	// @method getLayerId(layer: Layer): Number
  	// Returns the internal ID for a layer
  	getLayerId: function (layer) {
  		return stamp(layer);
  	}
  });


  // @factory L.layerGroup(layers?: Layer[], options?: Object)
  // Create a layer group, optionally given an initial set of layers and an `options` object.
  var layerGroup = function (layers, options) {
  	return new LayerGroup(layers, options);
  };

  /*
   * @class FeatureGroup
   * @aka L.FeatureGroup
   * @inherits LayerGroup
   *
   * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
   *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
   *  * Events are propagated to the `FeatureGroup`, so if the group has an event
   * handler, it will handle events from any of the layers. This includes mouse events
   * and custom events.
   *  * Has `layeradd` and `layerremove` events
   *
   * @example
   *
   * ```js
   * L.featureGroup([marker1, marker2, polyline])
   * 	.bindPopup('Hello world!')
   * 	.on('click', function() { alert('Clicked on a member of the group!'); })
   * 	.addTo(map);
   * ```
   */

  var FeatureGroup = LayerGroup.extend({

  	addLayer: function (layer) {
  		if (this.hasLayer(layer)) {
  			return this;
  		}

  		layer.addEventParent(this);

  		LayerGroup.prototype.addLayer.call(this, layer);

  		// @event layeradd: LayerEvent
  		// Fired when a layer is added to this `FeatureGroup`
  		return this.fire('layeradd', {layer: layer});
  	},

  	removeLayer: function (layer) {
  		if (!this.hasLayer(layer)) {
  			return this;
  		}
  		if (layer in this._layers) {
  			layer = this._layers[layer];
  		}

  		layer.removeEventParent(this);

  		LayerGroup.prototype.removeLayer.call(this, layer);

  		// @event layerremove: LayerEvent
  		// Fired when a layer is removed from this `FeatureGroup`
  		return this.fire('layerremove', {layer: layer});
  	},

  	// @method setStyle(style: Path options): this
  	// Sets the given path options to each layer of the group that has a `setStyle` method.
  	setStyle: function (style) {
  		return this.invoke('setStyle', style);
  	},

  	// @method bringToFront(): this
  	// Brings the layer group to the top of all other layers
  	bringToFront: function () {
  		return this.invoke('bringToFront');
  	},

  	// @method bringToBack(): this
  	// Brings the layer group to the back of all other layers
  	bringToBack: function () {
  		return this.invoke('bringToBack');
  	},

  	// @method getBounds(): LatLngBounds
  	// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
  	getBounds: function () {
  		var bounds = new LatLngBounds();

  		for (var id in this._layers) {
  			var layer = this._layers[id];
  			bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
  		}
  		return bounds;
  	}
  });

  // @factory L.featureGroup(layers?: Layer[], options?: Object)
  // Create a feature group, optionally given an initial set of layers and an `options` object.
  var featureGroup = function (layers, options) {
  	return new FeatureGroup(layers, options);
  };

  /*
   * @class Icon
   * @aka L.Icon
   *
   * Represents an icon to provide when creating a marker.
   *
   * @example
   *
   * ```js
   * var myIcon = L.icon({
   *     iconUrl: 'my-icon.png',
   *     iconRetinaUrl: 'my-icon@2x.png',
   *     iconSize: [38, 95],
   *     iconAnchor: [22, 94],
   *     popupAnchor: [-3, -76],
   *     shadowUrl: 'my-icon-shadow.png',
   *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
   *     shadowSize: [68, 95],
   *     shadowAnchor: [22, 94]
   * });
   *
   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
   * ```
   *
   * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
   *
   */

  var Icon = Class.extend({

  	/* @section
  	 * @aka Icon options
  	 *
  	 * @option iconUrl: String = null
  	 * **(required)** The URL to the icon image (absolute or relative to your script path).
  	 *
  	 * @option iconRetinaUrl: String = null
  	 * The URL to a retina sized version of the icon image (absolute or relative to your
  	 * script path). Used for Retina screen devices.
  	 *
  	 * @option iconSize: Point = null
  	 * Size of the icon image in pixels.
  	 *
  	 * @option iconAnchor: Point = null
  	 * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
  	 * will be aligned so that this point is at the marker's geographical location. Centered
  	 * by default if size is specified, also can be set in CSS with negative margins.
  	 *
  	 * @option popupAnchor: Point = [0, 0]
  	 * The coordinates of the point from which popups will "open", relative to the icon anchor.
  	 *
  	 * @option tooltipAnchor: Point = [0, 0]
  	 * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
  	 *
  	 * @option shadowUrl: String = null
  	 * The URL to the icon shadow image. If not specified, no shadow image will be created.
  	 *
  	 * @option shadowRetinaUrl: String = null
  	 *
  	 * @option shadowSize: Point = null
  	 * Size of the shadow image in pixels.
  	 *
  	 * @option shadowAnchor: Point = null
  	 * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
  	 * as iconAnchor if not specified).
  	 *
  	 * @option className: String = ''
  	 * A custom class name to assign to both icon and shadow images. Empty by default.
  	 */

  	options: {
  		popupAnchor: [0, 0],
  		tooltipAnchor: [0, 0],

  		// @option crossOrigin: Boolean|String = false
  		// Whether the crossOrigin attribute will be added to the tiles.
  		// If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
  		// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
  		crossOrigin: false
  	},

  	initialize: function (options) {
  		setOptions(this, options);
  	},

  	// @method createIcon(oldIcon?: HTMLElement): HTMLElement
  	// Called internally when the icon has to be shown, returns a `<img>` HTML element
  	// styled according to the options.
  	createIcon: function (oldIcon) {
  		return this._createIcon('icon', oldIcon);
  	},

  	// @method createShadow(oldIcon?: HTMLElement): HTMLElement
  	// As `createIcon`, but for the shadow beneath it.
  	createShadow: function (oldIcon) {
  		return this._createIcon('shadow', oldIcon);
  	},

  	_createIcon: function (name, oldIcon) {
  		var src = this._getIconUrl(name);

  		if (!src) {
  			if (name === 'icon') {
  				throw new Error('iconUrl not set in Icon options (see the docs).');
  			}
  			return null;
  		}

  		var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
  		this._setIconStyles(img, name);

  		if (this.options.crossOrigin || this.options.crossOrigin === '') {
  			img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
  		}

  		return img;
  	},

  	_setIconStyles: function (img, name) {
  		var options = this.options;
  		var sizeOption = options[name + 'Size'];

  		if (typeof sizeOption === 'number') {
  			sizeOption = [sizeOption, sizeOption];
  		}

  		var size = toPoint(sizeOption),
  		    anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||
  		            size && size.divideBy(2, true));

  		img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

  		if (anchor) {
  			img.style.marginLeft = (-anchor.x) + 'px';
  			img.style.marginTop  = (-anchor.y) + 'px';
  		}

  		if (size) {
  			img.style.width  = size.x + 'px';
  			img.style.height = size.y + 'px';
  		}
  	},

  	_createImg: function (src, el) {
  		el = el || document.createElement('img');
  		el.src = src;
  		return el;
  	},

  	_getIconUrl: function (name) {
  		return Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
  	}
  });


  // @factory L.icon(options: Icon options)
  // Creates an icon instance with the given options.
  function icon(options) {
  	return new Icon(options);
  }

  /*
   * @miniclass Icon.Default (Icon)
   * @aka L.Icon.Default
   * @section
   *
   * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
   * no icon is specified. Points to the blue marker image distributed with Leaflet
   * releases.
   *
   * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
   * (which is a set of `Icon options`).
   *
   * If you want to _completely_ replace the default icon, override the
   * `L.Marker.prototype.options.icon` with your own icon instead.
   */

  var IconDefault = Icon.extend({

  	options: {
  		iconUrl:       'marker-icon.png',
  		iconRetinaUrl: 'marker-icon-2x.png',
  		shadowUrl:     'marker-shadow.png',
  		iconSize:    [25, 41],
  		iconAnchor:  [12, 41],
  		popupAnchor: [1, -34],
  		tooltipAnchor: [16, -28],
  		shadowSize:  [41, 41]
  	},

  	_getIconUrl: function (name) {
  		if (typeof IconDefault.imagePath !== 'string') {	// Deprecated, backwards-compatibility only
  			IconDefault.imagePath = this._detectIconPath();
  		}

  		// @option imagePath: String
  		// `Icon.Default` will try to auto-detect the location of the
  		// blue icon images. If you are placing these images in a non-standard
  		// way, set this option to point to the right path.
  		return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
  	},

  	_stripUrl: function (path) {	// separate function to use in tests
  		var strip = function (str, re, idx) {
  			var match = re.exec(str);
  			return match && match[idx];
  		};
  		path = strip(path, /^url\((['"])?(.+)\1\)$/, 2);
  		return path && strip(path, /^(.*)marker-icon\.png$/, 1);
  	},

  	_detectIconPath: function () {
  		var el = create$1('div',  'leaflet-default-icon-path', document.body);
  		var path = getStyle(el, 'background-image') ||
  		           getStyle(el, 'backgroundImage');	// IE8

  		document.body.removeChild(el);
  		path = this._stripUrl(path);
  		if (path) { return path; }
  		var link = document.querySelector('link[href$="leaflet.css"]');
  		if (!link) { return ''; }
  		return link.href.substring(0, link.href.length - 'leaflet.css'.length - 1);
  	}
  });

  /*
   * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
   */


  /* @namespace Marker
   * @section Interaction handlers
   *
   * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
   *
   * ```js
   * marker.dragging.disable();
   * ```
   *
   * @property dragging: Handler
   * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).
   */

  var MarkerDrag = Handler.extend({
  	initialize: function (marker) {
  		this._marker = marker;
  	},

  	addHooks: function () {
  		var icon = this._marker._icon;

  		if (!this._draggable) {
  			this._draggable = new Draggable(icon, icon, true);
  		}

  		this._draggable.on({
  			dragstart: this._onDragStart,
  			predrag: this._onPreDrag,
  			drag: this._onDrag,
  			dragend: this._onDragEnd
  		}, this).enable();

  		addClass(icon, 'leaflet-marker-draggable');
  	},

  	removeHooks: function () {
  		this._draggable.off({
  			dragstart: this._onDragStart,
  			predrag: this._onPreDrag,
  			drag: this._onDrag,
  			dragend: this._onDragEnd
  		}, this).disable();

  		if (this._marker._icon) {
  			removeClass(this._marker._icon, 'leaflet-marker-draggable');
  		}
  	},

  	moved: function () {
  		return this._draggable && this._draggable._moved;
  	},

  	_adjustPan: function (e) {
  		var marker = this._marker,
  		    map = marker._map,
  		    speed = this._marker.options.autoPanSpeed,
  		    padding = this._marker.options.autoPanPadding,
  		    iconPos = getPosition(marker._icon),
  		    bounds = map.getPixelBounds(),
  		    origin = map.getPixelOrigin();

  		var panBounds = toBounds(
  			bounds.min._subtract(origin).add(padding),
  			bounds.max._subtract(origin).subtract(padding)
  		);

  		if (!panBounds.contains(iconPos)) {
  			// Compute incremental movement
  			var movement = toPoint(
  				(Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) -
  				(Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),

  				(Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) -
  				(Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
  			).multiplyBy(speed);

  			map.panBy(movement, {animate: false});

  			this._draggable._newPos._add(movement);
  			this._draggable._startPos._add(movement);

  			setPosition(marker._icon, this._draggable._newPos);
  			this._onDrag(e);

  			this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
  		}
  	},

  	_onDragStart: function () {
  		// @section Dragging events
  		// @event dragstart: Event
  		// Fired when the user starts dragging the marker.

  		// @event movestart: Event
  		// Fired when the marker starts moving (because of dragging).

  		this._oldLatLng = this._marker.getLatLng();

  		// When using ES6 imports it could not be set when `Popup` was not imported as well
  		this._marker.closePopup && this._marker.closePopup();

  		this._marker
  			.fire('movestart')
  			.fire('dragstart');
  	},

  	_onPreDrag: function (e) {
  		if (this._marker.options.autoPan) {
  			cancelAnimFrame(this._panRequest);
  			this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
  		}
  	},

  	_onDrag: function (e) {
  		var marker = this._marker,
  		    shadow = marker._shadow,
  		    iconPos = getPosition(marker._icon),
  		    latlng = marker._map.layerPointToLatLng(iconPos);

  		// update shadow position
  		if (shadow) {
  			setPosition(shadow, iconPos);
  		}

  		marker._latlng = latlng;
  		e.latlng = latlng;
  		e.oldLatLng = this._oldLatLng;

  		// @event drag: Event
  		// Fired repeatedly while the user drags the marker.
  		marker
  		    .fire('move', e)
  		    .fire('drag', e);
  	},

  	_onDragEnd: function (e) {
  		// @event dragend: DragEndEvent
  		// Fired when the user stops dragging the marker.

  		 cancelAnimFrame(this._panRequest);

  		// @event moveend: Event
  		// Fired when the marker stops moving (because of dragging).
  		delete this._oldLatLng;
  		this._marker
  		    .fire('moveend')
  		    .fire('dragend', e);
  	}
  });

  /*
   * @class Marker
   * @inherits Interactive layer
   * @aka L.Marker
   * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * L.marker([50.5, 30.5]).addTo(map);
   * ```
   */

  var Marker = Layer.extend({

  	// @section
  	// @aka Marker options
  	options: {
  		// @option icon: Icon = *
  		// Icon instance to use for rendering the marker.
  		// See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
  		// If not specified, a common instance of `L.Icon.Default` is used.
  		icon: new IconDefault(),

  		// Option inherited from "Interactive layer" abstract class
  		interactive: true,

  		// @option keyboard: Boolean = true
  		// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
  		keyboard: true,

  		// @option title: String = ''
  		// Text for the browser tooltip that appear on marker hover (no tooltip by default).
  		// [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
  		title: '',

  		// @option alt: String = 'Marker'
  		// Text for the `alt` attribute of the icon image.
  		// [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
  		alt: 'Marker',

  		// @option zIndexOffset: Number = 0
  		// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
  		zIndexOffset: 0,

  		// @option opacity: Number = 1.0
  		// The opacity of the marker.
  		opacity: 1,

  		// @option riseOnHover: Boolean = false
  		// If `true`, the marker will get on top of others when you hover the mouse over it.
  		riseOnHover: false,

  		// @option riseOffset: Number = 250
  		// The z-index offset used for the `riseOnHover` feature.
  		riseOffset: 250,

  		// @option pane: String = 'markerPane'
  		// `Map pane` where the markers icon will be added.
  		pane: 'markerPane',

  		// @option shadowPane: String = 'shadowPane'
  		// `Map pane` where the markers shadow will be added.
  		shadowPane: 'shadowPane',

  		// @option bubblingMouseEvents: Boolean = false
  		// When `true`, a mouse event on this marker will trigger the same event on the map
  		// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
  		bubblingMouseEvents: false,

  		// @option autoPanOnFocus: Boolean = true
  		// When `true`, the map will pan whenever the marker is focused (via
  		// e.g. pressing `tab` on the keyboard) to ensure the marker is
  		// visible within the map's bounds
  		autoPanOnFocus: true,

  		// @section Draggable marker options
  		// @option draggable: Boolean = false
  		// Whether the marker is draggable with mouse/touch or not.
  		draggable: false,

  		// @option autoPan: Boolean = false
  		// Whether to pan the map when dragging this marker near its edge or not.
  		autoPan: false,

  		// @option autoPanPadding: Point = Point(50, 50)
  		// Distance (in pixels to the left/right and to the top/bottom) of the
  		// map edge to start panning the map.
  		autoPanPadding: [50, 50],

  		// @option autoPanSpeed: Number = 10
  		// Number of pixels the map should pan by.
  		autoPanSpeed: 10
  	},

  	/* @section
  	 *
  	 * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
  	 */

  	initialize: function (latlng, options) {
  		setOptions(this, options);
  		this._latlng = toLatLng(latlng);
  	},

  	onAdd: function (map) {
  		this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

  		if (this._zoomAnimated) {
  			map.on('zoomanim', this._animateZoom, this);
  		}

  		this._initIcon();
  		this.update();
  	},

  	onRemove: function (map) {
  		if (this.dragging && this.dragging.enabled()) {
  			this.options.draggable = true;
  			this.dragging.removeHooks();
  		}
  		delete this.dragging;

  		if (this._zoomAnimated) {
  			map.off('zoomanim', this._animateZoom, this);
  		}

  		this._removeIcon();
  		this._removeShadow();
  	},

  	getEvents: function () {
  		return {
  			zoom: this.update,
  			viewreset: this.update
  		};
  	},

  	// @method getLatLng: LatLng
  	// Returns the current geographical position of the marker.
  	getLatLng: function () {
  		return this._latlng;
  	},

  	// @method setLatLng(latlng: LatLng): this
  	// Changes the marker position to the given point.
  	setLatLng: function (latlng) {
  		var oldLatLng = this._latlng;
  		this._latlng = toLatLng(latlng);
  		this.update();

  		// @event move: Event
  		// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
  		return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
  	},

  	// @method setZIndexOffset(offset: Number): this
  	// Changes the [zIndex offset](#marker-zindexoffset) of the marker.
  	setZIndexOffset: function (offset) {
  		this.options.zIndexOffset = offset;
  		return this.update();
  	},

  	// @method getIcon: Icon
  	// Returns the current icon used by the marker
  	getIcon: function () {
  		return this.options.icon;
  	},

  	// @method setIcon(icon: Icon): this
  	// Changes the marker icon.
  	setIcon: function (icon) {

  		this.options.icon = icon;

  		if (this._map) {
  			this._initIcon();
  			this.update();
  		}

  		if (this._popup) {
  			this.bindPopup(this._popup, this._popup.options);
  		}

  		return this;
  	},

  	getElement: function () {
  		return this._icon;
  	},

  	update: function () {

  		if (this._icon && this._map) {
  			var pos = this._map.latLngToLayerPoint(this._latlng).round();
  			this._setPos(pos);
  		}

  		return this;
  	},

  	_initIcon: function () {
  		var options = this.options,
  		    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

  		var icon = options.icon.createIcon(this._icon),
  		    addIcon = false;

  		// if we're not reusing the icon, remove the old one and init new one
  		if (icon !== this._icon) {
  			if (this._icon) {
  				this._removeIcon();
  			}
  			addIcon = true;

  			if (options.title) {
  				icon.title = options.title;
  			}

  			if (icon.tagName === 'IMG') {
  				icon.alt = options.alt || '';
  			}
  		}

  		addClass(icon, classToAdd);

  		if (options.keyboard) {
  			icon.tabIndex = '0';
  			icon.setAttribute('role', 'button');
  		}

  		this._icon = icon;

  		if (options.riseOnHover) {
  			this.on({
  				mouseover: this._bringToFront,
  				mouseout: this._resetZIndex
  			});
  		}

  		if (this.options.autoPanOnFocus) {
  			on(icon, 'focus', this._panOnFocus, this);
  		}

  		var newShadow = options.icon.createShadow(this._shadow),
  		    addShadow = false;

  		if (newShadow !== this._shadow) {
  			this._removeShadow();
  			addShadow = true;
  		}

  		if (newShadow) {
  			addClass(newShadow, classToAdd);
  			newShadow.alt = '';
  		}
  		this._shadow = newShadow;


  		if (options.opacity < 1) {
  			this._updateOpacity();
  		}


  		if (addIcon) {
  			this.getPane().appendChild(this._icon);
  		}
  		this._initInteraction();
  		if (newShadow && addShadow) {
  			this.getPane(options.shadowPane).appendChild(this._shadow);
  		}
  	},

  	_removeIcon: function () {
  		if (this.options.riseOnHover) {
  			this.off({
  				mouseover: this._bringToFront,
  				mouseout: this._resetZIndex
  			});
  		}

  		if (this.options.autoPanOnFocus) {
  			off(this._icon, 'focus', this._panOnFocus, this);
  		}

  		remove(this._icon);
  		this.removeInteractiveTarget(this._icon);

  		this._icon = null;
  	},

  	_removeShadow: function () {
  		if (this._shadow) {
  			remove(this._shadow);
  		}
  		this._shadow = null;
  	},

  	_setPos: function (pos) {

  		if (this._icon) {
  			setPosition(this._icon, pos);
  		}

  		if (this._shadow) {
  			setPosition(this._shadow, pos);
  		}

  		this._zIndex = pos.y + this.options.zIndexOffset;

  		this._resetZIndex();
  	},

  	_updateZIndex: function (offset) {
  		if (this._icon) {
  			this._icon.style.zIndex = this._zIndex + offset;
  		}
  	},

  	_animateZoom: function (opt) {
  		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

  		this._setPos(pos);
  	},

  	_initInteraction: function () {

  		if (!this.options.interactive) { return; }

  		addClass(this._icon, 'leaflet-interactive');

  		this.addInteractiveTarget(this._icon);

  		if (MarkerDrag) {
  			var draggable = this.options.draggable;
  			if (this.dragging) {
  				draggable = this.dragging.enabled();
  				this.dragging.disable();
  			}

  			this.dragging = new MarkerDrag(this);

  			if (draggable) {
  				this.dragging.enable();
  			}
  		}
  	},

  	// @method setOpacity(opacity: Number): this
  	// Changes the opacity of the marker.
  	setOpacity: function (opacity) {
  		this.options.opacity = opacity;
  		if (this._map) {
  			this._updateOpacity();
  		}

  		return this;
  	},

  	_updateOpacity: function () {
  		var opacity = this.options.opacity;

  		if (this._icon) {
  			setOpacity(this._icon, opacity);
  		}

  		if (this._shadow) {
  			setOpacity(this._shadow, opacity);
  		}
  	},

  	_bringToFront: function () {
  		this._updateZIndex(this.options.riseOffset);
  	},

  	_resetZIndex: function () {
  		this._updateZIndex(0);
  	},

  	_panOnFocus: function () {
  		var map = this._map;
  		if (!map) { return; }

  		var iconOpts = this.options.icon.options;
  		var size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);
  		var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);

  		map.panInside(this._latlng, {
  			paddingTopLeft: anchor,
  			paddingBottomRight: size.subtract(anchor)
  		});
  	},

  	_getPopupAnchor: function () {
  		return this.options.icon.options.popupAnchor;
  	},

  	_getTooltipAnchor: function () {
  		return this.options.icon.options.tooltipAnchor;
  	}
  });


  // factory L.marker(latlng: LatLng, options? : Marker options)

  // @factory L.marker(latlng: LatLng, options? : Marker options)
  // Instantiates a Marker object given a geographical point and optionally an options object.
  function marker(latlng, options) {
  	return new Marker(latlng, options);
  }

  /*
   * @class Path
   * @aka L.Path
   * @inherits Interactive layer
   *
   * An abstract class that contains options and constants shared between vector
   * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
   */

  var Path = Layer.extend({

  	// @section
  	// @aka Path options
  	options: {
  		// @option stroke: Boolean = true
  		// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
  		stroke: true,

  		// @option color: String = '#3388ff'
  		// Stroke color
  		color: '#3388ff',

  		// @option weight: Number = 3
  		// Stroke width in pixels
  		weight: 3,

  		// @option opacity: Number = 1.0
  		// Stroke opacity
  		opacity: 1,

  		// @option lineCap: String= 'round'
  		// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
  		lineCap: 'round',

  		// @option lineJoin: String = 'round'
  		// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
  		lineJoin: 'round',

  		// @option dashArray: String = null
  		// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
  		dashArray: null,

  		// @option dashOffset: String = null
  		// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
  		dashOffset: null,

  		// @option fill: Boolean = depends
  		// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
  		fill: false,

  		// @option fillColor: String = *
  		// Fill color. Defaults to the value of the [`color`](#path-color) option
  		fillColor: null,

  		// @option fillOpacity: Number = 0.2
  		// Fill opacity.
  		fillOpacity: 0.2,

  		// @option fillRule: String = 'evenodd'
  		// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
  		fillRule: 'evenodd',

  		// className: '',

  		// Option inherited from "Interactive layer" abstract class
  		interactive: true,

  		// @option bubblingMouseEvents: Boolean = true
  		// When `true`, a mouse event on this path will trigger the same event on the map
  		// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
  		bubblingMouseEvents: true
  	},

  	beforeAdd: function (map) {
  		// Renderer is set here because we need to call renderer.getEvents
  		// before this.getEvents.
  		this._renderer = map.getRenderer(this);
  	},

  	onAdd: function () {
  		this._renderer._initPath(this);
  		this._reset();
  		this._renderer._addPath(this);
  	},

  	onRemove: function () {
  		this._renderer._removePath(this);
  	},

  	// @method redraw(): this
  	// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
  	redraw: function () {
  		if (this._map) {
  			this._renderer._updatePath(this);
  		}
  		return this;
  	},

  	// @method setStyle(style: Path options): this
  	// Changes the appearance of a Path based on the options in the `Path options` object.
  	setStyle: function (style) {
  		setOptions(this, style);
  		if (this._renderer) {
  			this._renderer._updateStyle(this);
  			if (this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, 'weight')) {
  				this._updateBounds();
  			}
  		}
  		return this;
  	},

  	// @method bringToFront(): this
  	// Brings the layer to the top of all path layers.
  	bringToFront: function () {
  		if (this._renderer) {
  			this._renderer._bringToFront(this);
  		}
  		return this;
  	},

  	// @method bringToBack(): this
  	// Brings the layer to the bottom of all path layers.
  	bringToBack: function () {
  		if (this._renderer) {
  			this._renderer._bringToBack(this);
  		}
  		return this;
  	},

  	getElement: function () {
  		return this._path;
  	},

  	_reset: function () {
  		// defined in child classes
  		this._project();
  		this._update();
  	},

  	_clickTolerance: function () {
  		// used when doing hit detection for Canvas layers
  		return (this.options.stroke ? this.options.weight / 2 : 0) +
  		  (this._renderer.options.tolerance || 0);
  	}
  });

  /*
   * @class CircleMarker
   * @aka L.CircleMarker
   * @inherits Path
   *
   * A circle of a fixed size with radius specified in pixels. Extends `Path`.
   */

  var CircleMarker = Path.extend({

  	// @section
  	// @aka CircleMarker options
  	options: {
  		fill: true,

  		// @option radius: Number = 10
  		// Radius of the circle marker, in pixels
  		radius: 10
  	},

  	initialize: function (latlng, options) {
  		setOptions(this, options);
  		this._latlng = toLatLng(latlng);
  		this._radius = this.options.radius;
  	},

  	// @method setLatLng(latLng: LatLng): this
  	// Sets the position of a circle marker to a new location.
  	setLatLng: function (latlng) {
  		var oldLatLng = this._latlng;
  		this._latlng = toLatLng(latlng);
  		this.redraw();

  		// @event move: Event
  		// Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
  		return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
  	},

  	// @method getLatLng(): LatLng
  	// Returns the current geographical position of the circle marker
  	getLatLng: function () {
  		return this._latlng;
  	},

  	// @method setRadius(radius: Number): this
  	// Sets the radius of a circle marker. Units are in pixels.
  	setRadius: function (radius) {
  		this.options.radius = this._radius = radius;
  		return this.redraw();
  	},

  	// @method getRadius(): Number
  	// Returns the current radius of the circle
  	getRadius: function () {
  		return this._radius;
  	},

  	setStyle : function (options) {
  		var radius = options && options.radius || this._radius;
  		Path.prototype.setStyle.call(this, options);
  		this.setRadius(radius);
  		return this;
  	},

  	_project: function () {
  		this._point = this._map.latLngToLayerPoint(this._latlng);
  		this._updateBounds();
  	},

  	_updateBounds: function () {
  		var r = this._radius,
  		    r2 = this._radiusY || r,
  		    w = this._clickTolerance(),
  		    p = [r + w, r2 + w];
  		this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
  	},

  	_update: function () {
  		if (this._map) {
  			this._updatePath();
  		}
  	},

  	_updatePath: function () {
  		this._renderer._updateCircle(this);
  	},

  	_empty: function () {
  		return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
  	},

  	// Needed by the `Canvas` renderer for interactivity
  	_containsPoint: function (p) {
  		return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
  	}
  });


  // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
  // Instantiates a circle marker object given a geographical point, and an optional options object.
  function circleMarker(latlng, options) {
  	return new CircleMarker(latlng, options);
  }

  /*
   * @class Circle
   * @aka L.Circle
   * @inherits CircleMarker
   *
   * A class for drawing circle overlays on a map. Extends `CircleMarker`.
   *
   * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
   *
   * @example
   *
   * ```js
   * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
   * ```
   */

  var Circle = CircleMarker.extend({

  	initialize: function (latlng, options, legacyOptions) {
  		if (typeof options === 'number') {
  			// Backwards compatibility with 0.7.x factory (latlng, radius, options?)
  			options = extend({}, legacyOptions, {radius: options});
  		}
  		setOptions(this, options);
  		this._latlng = toLatLng(latlng);

  		if (isNaN(this.options.radius)) { throw new Error('Circle radius cannot be NaN'); }

  		// @section
  		// @aka Circle options
  		// @option radius: Number; Radius of the circle, in meters.
  		this._mRadius = this.options.radius;
  	},

  	// @method setRadius(radius: Number): this
  	// Sets the radius of a circle. Units are in meters.
  	setRadius: function (radius) {
  		this._mRadius = radius;
  		return this.redraw();
  	},

  	// @method getRadius(): Number
  	// Returns the current radius of a circle. Units are in meters.
  	getRadius: function () {
  		return this._mRadius;
  	},

  	// @method getBounds(): LatLngBounds
  	// Returns the `LatLngBounds` of the path.
  	getBounds: function () {
  		var half = [this._radius, this._radiusY || this._radius];

  		return new LatLngBounds(
  			this._map.layerPointToLatLng(this._point.subtract(half)),
  			this._map.layerPointToLatLng(this._point.add(half)));
  	},

  	setStyle: Path.prototype.setStyle,

  	_project: function () {

  		var lng = this._latlng.lng,
  		    lat = this._latlng.lat,
  		    map = this._map,
  		    crs = map.options.crs;

  		if (crs.distance === Earth.distance) {
  			var d = Math.PI / 180,
  			    latR = (this._mRadius / Earth.R) / d,
  			    top = map.project([lat + latR, lng]),
  			    bottom = map.project([lat - latR, lng]),
  			    p = top.add(bottom).divideBy(2),
  			    lat2 = map.unproject(p).lat,
  			    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /
  			            (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

  			if (isNaN(lngR) || lngR === 0) {
  				lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
  			}

  			this._point = p.subtract(map.getPixelOrigin());
  			this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;
  			this._radiusY = p.y - top.y;

  		} else {
  			var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

  			this._point = map.latLngToLayerPoint(this._latlng);
  			this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
  		}

  		this._updateBounds();
  	}
  });

  // @factory L.circle(latlng: LatLng, options?: Circle options)
  // Instantiates a circle object given a geographical point, and an options object
  // which contains the circle radius.
  // @alternative
  // @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
  // Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
  // Do not use in new applications or plugins.
  function circle(latlng, options, legacyOptions) {
  	return new Circle(latlng, options, legacyOptions);
  }

  /*
   * @class Polyline
   * @aka L.Polyline
   * @inherits Path
   *
   * A class for drawing polyline overlays on a map. Extends `Path`.
   *
   * @example
   *
   * ```js
   * // create a red polyline from an array of LatLng points
   * var latlngs = [
   * 	[45.51, -122.68],
   * 	[37.77, -122.43],
   * 	[34.04, -118.2]
   * ];
   *
   * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
   *
   * // zoom the map to the polyline
   * map.fitBounds(polyline.getBounds());
   * ```
   *
   * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
   *
   * ```js
   * // create a red polyline from an array of arrays of LatLng points
   * var latlngs = [
   * 	[[45.51, -122.68],
   * 	 [37.77, -122.43],
   * 	 [34.04, -118.2]],
   * 	[[40.78, -73.91],
   * 	 [41.83, -87.62],
   * 	 [32.76, -96.72]]
   * ];
   * ```
   */


  var Polyline = Path.extend({

  	// @section
  	// @aka Polyline options
  	options: {
  		// @option smoothFactor: Number = 1.0
  		// How much to simplify the polyline on each zoom level. More means
  		// better performance and smoother look, and less means more accurate representation.
  		smoothFactor: 1.0,

  		// @option noClip: Boolean = false
  		// Disable polyline clipping.
  		noClip: false
  	},

  	initialize: function (latlngs, options) {
  		setOptions(this, options);
  		this._setLatLngs(latlngs);
  	},

  	// @method getLatLngs(): LatLng[]
  	// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
  	getLatLngs: function () {
  		return this._latlngs;
  	},

  	// @method setLatLngs(latlngs: LatLng[]): this
  	// Replaces all the points in the polyline with the given array of geographical points.
  	setLatLngs: function (latlngs) {
  		this._setLatLngs(latlngs);
  		return this.redraw();
  	},

  	// @method isEmpty(): Boolean
  	// Returns `true` if the Polyline has no LatLngs.
  	isEmpty: function () {
  		return !this._latlngs.length;
  	},

  	// @method closestLayerPoint(p: Point): Point
  	// Returns the point closest to `p` on the Polyline.
  	closestLayerPoint: function (p) {
  		var minDistance = Infinity,
  		    minPoint = null,
  		    closest = _sqClosestPointOnSegment,
  		    p1, p2;

  		for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
  			var points = this._parts[j];

  			for (var i = 1, len = points.length; i < len; i++) {
  				p1 = points[i - 1];
  				p2 = points[i];

  				var sqDist = closest(p, p1, p2, true);

  				if (sqDist < minDistance) {
  					minDistance = sqDist;
  					minPoint = closest(p, p1, p2);
  				}
  			}
  		}
  		if (minPoint) {
  			minPoint.distance = Math.sqrt(minDistance);
  		}
  		return minPoint;
  	},

  	// @method getCenter(): LatLng
  	// Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
  	getCenter: function () {
  		// throws error when not yet added to map as this center calculation requires projected coordinates
  		if (!this._map) {
  			throw new Error('Must add layer to map before using getCenter()');
  		}
  		return polylineCenter(this._defaultShape(), this._map.options.crs);
  	},

  	// @method getBounds(): LatLngBounds
  	// Returns the `LatLngBounds` of the path.
  	getBounds: function () {
  		return this._bounds;
  	},

  	// @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
  	// Adds a given point to the polyline. By default, adds to the first ring of
  	// the polyline in case of a multi-polyline, but can be overridden by passing
  	// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
  	addLatLng: function (latlng, latlngs) {
  		latlngs = latlngs || this._defaultShape();
  		latlng = toLatLng(latlng);
  		latlngs.push(latlng);
  		this._bounds.extend(latlng);
  		return this.redraw();
  	},

  	_setLatLngs: function (latlngs) {
  		this._bounds = new LatLngBounds();
  		this._latlngs = this._convertLatLngs(latlngs);
  	},

  	_defaultShape: function () {
  		return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
  	},

  	// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
  	_convertLatLngs: function (latlngs) {
  		var result = [],
  		    flat = isFlat(latlngs);

  		for (var i = 0, len = latlngs.length; i < len; i++) {
  			if (flat) {
  				result[i] = toLatLng(latlngs[i]);
  				this._bounds.extend(result[i]);
  			} else {
  				result[i] = this._convertLatLngs(latlngs[i]);
  			}
  		}

  		return result;
  	},

  	_project: function () {
  		var pxBounds = new Bounds();
  		this._rings = [];
  		this._projectLatlngs(this._latlngs, this._rings, pxBounds);

  		if (this._bounds.isValid() && pxBounds.isValid()) {
  			this._rawPxBounds = pxBounds;
  			this._updateBounds();
  		}
  	},

  	_updateBounds: function () {
  		var w = this._clickTolerance(),
  		    p = new Point(w, w);

  		if (!this._rawPxBounds) {
  			return;
  		}

  		this._pxBounds = new Bounds([
  			this._rawPxBounds.min.subtract(p),
  			this._rawPxBounds.max.add(p)
  		]);
  	},

  	// recursively turns latlngs into a set of rings with projected coordinates
  	_projectLatlngs: function (latlngs, result, projectedBounds) {
  		var flat = latlngs[0] instanceof LatLng,
  		    len = latlngs.length,
  		    i, ring;

  		if (flat) {
  			ring = [];
  			for (i = 0; i < len; i++) {
  				ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
  				projectedBounds.extend(ring[i]);
  			}
  			result.push(ring);
  		} else {
  			for (i = 0; i < len; i++) {
  				this._projectLatlngs(latlngs[i], result, projectedBounds);
  			}
  		}
  	},

  	// clip polyline by renderer bounds so that we have less to render for performance
  	_clipPoints: function () {
  		var bounds = this._renderer._bounds;

  		this._parts = [];
  		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
  			return;
  		}

  		if (this.options.noClip) {
  			this._parts = this._rings;
  			return;
  		}

  		var parts = this._parts,
  		    i, j, k, len, len2, segment, points;

  		for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
  			points = this._rings[i];

  			for (j = 0, len2 = points.length; j < len2 - 1; j++) {
  				segment = clipSegment(points[j], points[j + 1], bounds, j, true);

  				if (!segment) { continue; }

  				parts[k] = parts[k] || [];
  				parts[k].push(segment[0]);

  				// if segment goes out of screen, or it's the last one, it's the end of the line part
  				if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {
  					parts[k].push(segment[1]);
  					k++;
  				}
  			}
  		}
  	},

  	// simplify each clipped part of the polyline for performance
  	_simplifyPoints: function () {
  		var parts = this._parts,
  		    tolerance = this.options.smoothFactor;

  		for (var i = 0, len = parts.length; i < len; i++) {
  			parts[i] = simplify(parts[i], tolerance);
  		}
  	},

  	_update: function () {
  		if (!this._map) { return; }

  		this._clipPoints();
  		this._simplifyPoints();
  		this._updatePath();
  	},

  	_updatePath: function () {
  		this._renderer._updatePoly(this);
  	},

  	// Needed by the `Canvas` renderer for interactivity
  	_containsPoint: function (p, closed) {
  		var i, j, k, len, len2, part,
  		    w = this._clickTolerance();

  		if (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }

  		// hit detection for polylines
  		for (i = 0, len = this._parts.length; i < len; i++) {
  			part = this._parts[i];

  			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
  				if (!closed && (j === 0)) { continue; }

  				if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
  					return true;
  				}
  			}
  		}
  		return false;
  	}
  });

  // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
  // Instantiates a polyline object given an array of geographical points and
  // optionally an options object. You can create a `Polyline` object with
  // multiple separate lines (`MultiPolyline`) by passing an array of arrays
  // of geographic points.
  function polyline(latlngs, options) {
  	return new Polyline(latlngs, options);
  }

  // Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.
  Polyline._flat = _flat;

  /*
   * @class Polygon
   * @aka L.Polygon
   * @inherits Polyline
   *
   * A class for drawing polygon overlays on a map. Extends `Polyline`.
   *
   * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one  it's better to filter out such points.
   *
   *
   * @example
   *
   * ```js
   * // create a red polygon from an array of LatLng points
   * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];
   *
   * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
   *
   * // zoom the map to the polygon
   * map.fitBounds(polygon.getBounds());
   * ```
   *
   * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
   *
   * ```js
   * var latlngs = [
   *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
   *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
   * ];
   * ```
   *
   * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
   *
   * ```js
   * var latlngs = [
   *   [ // first polygon
   *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
   *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
   *   ],
   *   [ // second polygon
   *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]
   *   ]
   * ];
   * ```
   */

  var Polygon = Polyline.extend({

  	options: {
  		fill: true
  	},

  	isEmpty: function () {
  		return !this._latlngs.length || !this._latlngs[0].length;
  	},

  	// @method getCenter(): LatLng
  	// Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.
  	getCenter: function () {
  		// throws error when not yet added to map as this center calculation requires projected coordinates
  		if (!this._map) {
  			throw new Error('Must add layer to map before using getCenter()');
  		}
  		return polygonCenter(this._defaultShape(), this._map.options.crs);
  	},

  	_convertLatLngs: function (latlngs) {
  		var result = Polyline.prototype._convertLatLngs.call(this, latlngs),
  		    len = result.length;

  		// remove last point if it equals first one
  		if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
  			result.pop();
  		}
  		return result;
  	},

  	_setLatLngs: function (latlngs) {
  		Polyline.prototype._setLatLngs.call(this, latlngs);
  		if (isFlat(this._latlngs)) {
  			this._latlngs = [this._latlngs];
  		}
  	},

  	_defaultShape: function () {
  		return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
  	},

  	_clipPoints: function () {
  		// polygons need a different clipping algorithm so we redefine that

  		var bounds = this._renderer._bounds,
  		    w = this.options.weight,
  		    p = new Point(w, w);

  		// increase clip padding by stroke width to avoid stroke on clip edges
  		bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));

  		this._parts = [];
  		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
  			return;
  		}

  		if (this.options.noClip) {
  			this._parts = this._rings;
  			return;
  		}

  		for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
  			clipped = clipPolygon(this._rings[i], bounds, true);
  			if (clipped.length) {
  				this._parts.push(clipped);
  			}
  		}
  	},

  	_updatePath: function () {
  		this._renderer._updatePoly(this, true);
  	},

  	// Needed by the `Canvas` renderer for interactivity
  	_containsPoint: function (p) {
  		var inside = false,
  		    part, p1, p2, i, j, k, len, len2;

  		if (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }

  		// ray casting algorithm for detecting if point is in polygon
  		for (i = 0, len = this._parts.length; i < len; i++) {
  			part = this._parts[i];

  			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
  				p1 = part[j];
  				p2 = part[k];

  				if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
  					inside = !inside;
  				}
  			}
  		}

  		// also check if it's on polygon stroke
  		return inside || Polyline.prototype._containsPoint.call(this, p, true);
  	}

  });


  // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
  function polygon(latlngs, options) {
  	return new Polygon(latlngs, options);
  }

  /*
   * @class GeoJSON
   * @aka L.GeoJSON
   * @inherits FeatureGroup
   *
   * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
   * GeoJSON data and display it on the map. Extends `FeatureGroup`.
   *
   * @example
   *
   * ```js
   * L.geoJSON(data, {
   * 	style: function (feature) {
   * 		return {color: feature.properties.color};
   * 	}
   * }).bindPopup(function (layer) {
   * 	return layer.feature.properties.description;
   * }).addTo(map);
   * ```
   */

  var GeoJSON = FeatureGroup.extend({

  	/* @section
  	 * @aka GeoJSON options
  	 *
  	 * @option pointToLayer: Function = *
  	 * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
  	 * called when data is added, passing the GeoJSON point feature and its `LatLng`.
  	 * The default is to spawn a default `Marker`:
  	 * ```js
  	 * function(geoJsonPoint, latlng) {
  	 * 	return L.marker(latlng);
  	 * }
  	 * ```
  	 *
  	 * @option style: Function = *
  	 * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
  	 * called internally when data is added.
  	 * The default value is to not override any defaults:
  	 * ```js
  	 * function (geoJsonFeature) {
  	 * 	return {}
  	 * }
  	 * ```
  	 *
  	 * @option onEachFeature: Function = *
  	 * A `Function` that will be called once for each created `Feature`, after it has
  	 * been created and styled. Useful for attaching events and popups to features.
  	 * The default is to do nothing with the newly created layers:
  	 * ```js
  	 * function (feature, layer) {}
  	 * ```
  	 *
  	 * @option filter: Function = *
  	 * A `Function` that will be used to decide whether to include a feature or not.
  	 * The default is to include all features:
  	 * ```js
  	 * function (geoJsonFeature) {
  	 * 	return true;
  	 * }
  	 * ```
  	 * Note: dynamically changing the `filter` option will have effect only on newly
  	 * added data. It will _not_ re-evaluate already included features.
  	 *
  	 * @option coordsToLatLng: Function = *
  	 * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
  	 * The default is the `coordsToLatLng` static method.
  	 *
  	 * @option markersInheritOptions: Boolean = false
  	 * Whether default Markers for "Point" type Features inherit from group options.
  	 */

  	initialize: function (geojson, options) {
  		setOptions(this, options);

  		this._layers = {};

  		if (geojson) {
  			this.addData(geojson);
  		}
  	},

  	// @method addData( <GeoJSON> data ): this
  	// Adds a GeoJSON object to the layer.
  	addData: function (geojson) {
  		var features = isArray(geojson) ? geojson : geojson.features,
  		    i, len, feature;

  		if (features) {
  			for (i = 0, len = features.length; i < len; i++) {
  				// only add this if geometry or geometries are set and not null
  				feature = features[i];
  				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
  					this.addData(feature);
  				}
  			}
  			return this;
  		}

  		var options = this.options;

  		if (options.filter && !options.filter(geojson)) { return this; }

  		var layer = geometryToLayer(geojson, options);
  		if (!layer) {
  			return this;
  		}
  		layer.feature = asFeature(geojson);

  		layer.defaultOptions = layer.options;
  		this.resetStyle(layer);

  		if (options.onEachFeature) {
  			options.onEachFeature(geojson, layer);
  		}

  		return this.addLayer(layer);
  	},

  	// @method resetStyle( <Path> layer? ): this
  	// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
  	// If `layer` is omitted, the style of all features in the current layer is reset.
  	resetStyle: function (layer) {
  		if (layer === undefined) {
  			return this.eachLayer(this.resetStyle, this);
  		}
  		// reset any custom styles
  		layer.options = extend({}, layer.defaultOptions);
  		this._setLayerStyle(layer, this.options.style);
  		return this;
  	},

  	// @method setStyle( <Function> style ): this
  	// Changes styles of GeoJSON vector layers with the given style function.
  	setStyle: function (style) {
  		return this.eachLayer(function (layer) {
  			this._setLayerStyle(layer, style);
  		}, this);
  	},

  	_setLayerStyle: function (layer, style) {
  		if (layer.setStyle) {
  			if (typeof style === 'function') {
  				style = style(layer.feature);
  			}
  			layer.setStyle(style);
  		}
  	}
  });

  // @section
  // There are several static functions which can be called without instantiating L.GeoJSON:

  // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
  // Creates a `Layer` from a given GeoJSON feature. Can use a custom
  // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
  // functions if provided as options.
  function geometryToLayer(geojson, options) {

  	var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
  	    coords = geometry ? geometry.coordinates : null,
  	    layers = [],
  	    pointToLayer = options && options.pointToLayer,
  	    _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,
  	    latlng, latlngs, i, len;

  	if (!coords && !geometry) {
  		return null;
  	}

  	switch (geometry.type) {
  	case 'Point':
  		latlng = _coordsToLatLng(coords);
  		return _pointToLayer(pointToLayer, geojson, latlng, options);

  	case 'MultiPoint':
  		for (i = 0, len = coords.length; i < len; i++) {
  			latlng = _coordsToLatLng(coords[i]);
  			layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));
  		}
  		return new FeatureGroup(layers);

  	case 'LineString':
  	case 'MultiLineString':
  		latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);
  		return new Polyline(latlngs, options);

  	case 'Polygon':
  	case 'MultiPolygon':
  		latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);
  		return new Polygon(latlngs, options);

  	case 'GeometryCollection':
  		for (i = 0, len = geometry.geometries.length; i < len; i++) {
  			var geoLayer = geometryToLayer({
  				geometry: geometry.geometries[i],
  				type: 'Feature',
  				properties: geojson.properties
  			}, options);

  			if (geoLayer) {
  				layers.push(geoLayer);
  			}
  		}
  		return new FeatureGroup(layers);

  	case 'FeatureCollection':
  		for (i = 0, len = geometry.features.length; i < len; i++) {
  			var featureLayer = geometryToLayer(geometry.features[i], options);

  			if (featureLayer) {
  				layers.push(featureLayer);
  			}
  		}
  		return new FeatureGroup(layers);

  	default:
  		throw new Error('Invalid GeoJSON object.');
  	}
  }

  function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
  	return pointToLayerFn ?
  		pointToLayerFn(geojson, latlng) :
  		new Marker(latlng, options && options.markersInheritOptions && options);
  }

  // @function coordsToLatLng(coords: Array): LatLng
  // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
  // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
  function coordsToLatLng(coords) {
  	return new LatLng(coords[1], coords[0], coords[2]);
  }

  // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
  // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
  // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
  // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
  function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
  	var latlngs = [];

  	for (var i = 0, len = coords.length, latlng; i < len; i++) {
  		latlng = levelsDeep ?
  			coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) :
  			(_coordsToLatLng || coordsToLatLng)(coords[i]);

  		latlngs.push(latlng);
  	}

  	return latlngs;
  }

  // @function latLngToCoords(latlng: LatLng, precision?: Number|false): Array
  // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.
  function latLngToCoords(latlng, precision) {
  	latlng = toLatLng(latlng);
  	return latlng.alt !== undefined ?
  		[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] :
  		[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
  }

  // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean, precision?: Number|false): Array
  // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
  // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.
  function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
  	var coords = [];

  	for (var i = 0, len = latlngs.length; i < len; i++) {
  		// Check for flat arrays required to ensure unbalanced arrays are correctly converted in recursion
  		coords.push(levelsDeep ?
  			latLngsToCoords(latlngs[i], isFlat(latlngs[i]) ? 0 : levelsDeep - 1, closed, precision) :
  			latLngToCoords(latlngs[i], precision));
  	}

  	if (!levelsDeep && closed && coords.length > 0) {
  		coords.push(coords[0].slice());
  	}

  	return coords;
  }

  function getFeature(layer, newGeometry) {
  	return layer.feature ?
  		extend({}, layer.feature, {geometry: newGeometry}) :
  		asFeature(newGeometry);
  }

  // @function asFeature(geojson: Object): Object
  // Normalize GeoJSON geometries/features into GeoJSON features.
  function asFeature(geojson) {
  	if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {
  		return geojson;
  	}

  	return {
  		type: 'Feature',
  		properties: {},
  		geometry: geojson
  	};
  }

  var PointToGeoJSON = {
  	toGeoJSON: function (precision) {
  		return getFeature(this, {
  			type: 'Point',
  			coordinates: latLngToCoords(this.getLatLng(), precision)
  		});
  	}
  };

  // @namespace Marker
  // @section Other methods
  // @method toGeoJSON(precision?: Number|false): Object
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).
  Marker.include(PointToGeoJSON);

  // @namespace CircleMarker
  // @method toGeoJSON(precision?: Number|false): Object
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
  Circle.include(PointToGeoJSON);
  CircleMarker.include(PointToGeoJSON);


  // @namespace Polyline
  // @method toGeoJSON(precision?: Number|false): Object
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
  Polyline.include({
  	toGeoJSON: function (precision) {
  		var multi = !isFlat(this._latlngs);

  		var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);

  		return getFeature(this, {
  			type: (multi ? 'Multi' : '') + 'LineString',
  			coordinates: coords
  		});
  	}
  });

  // @namespace Polygon
  // @method toGeoJSON(precision?: Number|false): Object
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
  Polygon.include({
  	toGeoJSON: function (precision) {
  		var holes = !isFlat(this._latlngs),
  		    multi = holes && !isFlat(this._latlngs[0]);

  		var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);

  		if (!holes) {
  			coords = [coords];
  		}

  		return getFeature(this, {
  			type: (multi ? 'Multi' : '') + 'Polygon',
  			coordinates: coords
  		});
  	}
  });


  // @namespace LayerGroup
  LayerGroup.include({
  	toMultiPoint: function (precision) {
  		var coords = [];

  		this.eachLayer(function (layer) {
  			coords.push(layer.toGeoJSON(precision).geometry.coordinates);
  		});

  		return getFeature(this, {
  			type: 'MultiPoint',
  			coordinates: coords
  		});
  	},

  	// @method toGeoJSON(precision?: Number|false): Object
  	// Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
  	// Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
  	toGeoJSON: function (precision) {

  		var type = this.feature && this.feature.geometry && this.feature.geometry.type;

  		if (type === 'MultiPoint') {
  			return this.toMultiPoint(precision);
  		}

  		var isGeometryCollection = type === 'GeometryCollection',
  		    jsons = [];

  		this.eachLayer(function (layer) {
  			if (layer.toGeoJSON) {
  				var json = layer.toGeoJSON(precision);
  				if (isGeometryCollection) {
  					jsons.push(json.geometry);
  				} else {
  					var feature = asFeature(json);
  					// Squash nested feature collections
  					if (feature.type === 'FeatureCollection') {
  						jsons.push.apply(jsons, feature.features);
  					} else {
  						jsons.push(feature);
  					}
  				}
  			}
  		});

  		if (isGeometryCollection) {
  			return getFeature(this, {
  				geometries: jsons,
  				type: 'GeometryCollection'
  			});
  		}

  		return {
  			type: 'FeatureCollection',
  			features: jsons
  		};
  	}
  });

  // @namespace GeoJSON
  // @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
  // Creates a GeoJSON layer. Optionally accepts an object in
  // [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map
  // (you can alternatively add it later with `addData` method) and an `options` object.
  function geoJSON(geojson, options) {
  	return new GeoJSON(geojson, options);
  }

  // Backward compatibility.
  var geoJson = geoJSON;

  /*
   * @class ImageOverlay
   * @aka L.ImageOverlay
   * @inherits Interactive layer
   *
   * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * var imageUrl = 'https://maps.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
   * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
   * L.imageOverlay(imageUrl, imageBounds).addTo(map);
   * ```
   */

  var ImageOverlay = Layer.extend({

  	// @section
  	// @aka ImageOverlay options
  	options: {
  		// @option opacity: Number = 1.0
  		// The opacity of the image overlay.
  		opacity: 1,

  		// @option alt: String = ''
  		// Text for the `alt` attribute of the image (useful for accessibility).
  		alt: '',

  		// @option interactive: Boolean = false
  		// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
  		interactive: false,

  		// @option crossOrigin: Boolean|String = false
  		// Whether the crossOrigin attribute will be added to the image.
  		// If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
  		// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
  		crossOrigin: false,

  		// @option errorOverlayUrl: String = ''
  		// URL to the overlay image to show in place of the overlay that failed to load.
  		errorOverlayUrl: '',

  		// @option zIndex: Number = 1
  		// The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
  		zIndex: 1,

  		// @option className: String = ''
  		// A custom class name to assign to the image. Empty by default.
  		className: ''
  	},

  	initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
  		this._url = url;
  		this._bounds = toLatLngBounds(bounds);

  		setOptions(this, options);
  	},

  	onAdd: function () {
  		if (!this._image) {
  			this._initImage();

  			if (this.options.opacity < 1) {
  				this._updateOpacity();
  			}
  		}

  		if (this.options.interactive) {
  			addClass(this._image, 'leaflet-interactive');
  			this.addInteractiveTarget(this._image);
  		}

  		this.getPane().appendChild(this._image);
  		this._reset();
  	},

  	onRemove: function () {
  		remove(this._image);
  		if (this.options.interactive) {
  			this.removeInteractiveTarget(this._image);
  		}
  	},

  	// @method setOpacity(opacity: Number): this
  	// Sets the opacity of the overlay.
  	setOpacity: function (opacity) {
  		this.options.opacity = opacity;

  		if (this._image) {
  			this._updateOpacity();
  		}
  		return this;
  	},

  	setStyle: function (styleOpts) {
  		if (styleOpts.opacity) {
  			this.setOpacity(styleOpts.opacity);
  		}
  		return this;
  	},

  	// @method bringToFront(): this
  	// Brings the layer to the top of all overlays.
  	bringToFront: function () {
  		if (this._map) {
  			toFront(this._image);
  		}
  		return this;
  	},

  	// @method bringToBack(): this
  	// Brings the layer to the bottom of all overlays.
  	bringToBack: function () {
  		if (this._map) {
  			toBack(this._image);
  		}
  		return this;
  	},

  	// @method setUrl(url: String): this
  	// Changes the URL of the image.
  	setUrl: function (url) {
  		this._url = url;

  		if (this._image) {
  			this._image.src = url;
  		}
  		return this;
  	},

  	// @method setBounds(bounds: LatLngBounds): this
  	// Update the bounds that this ImageOverlay covers
  	setBounds: function (bounds) {
  		this._bounds = toLatLngBounds(bounds);

  		if (this._map) {
  			this._reset();
  		}
  		return this;
  	},

  	getEvents: function () {
  		var events = {
  			zoom: this._reset,
  			viewreset: this._reset
  		};

  		if (this._zoomAnimated) {
  			events.zoomanim = this._animateZoom;
  		}

  		return events;
  	},

  	// @method setZIndex(value: Number): this
  	// Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
  	setZIndex: function (value) {
  		this.options.zIndex = value;
  		this._updateZIndex();
  		return this;
  	},

  	// @method getBounds(): LatLngBounds
  	// Get the bounds that this ImageOverlay covers
  	getBounds: function () {
  		return this._bounds;
  	},

  	// @method getElement(): HTMLElement
  	// Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
  	// used by this overlay.
  	getElement: function () {
  		return this._image;
  	},

  	_initImage: function () {
  		var wasElementSupplied = this._url.tagName === 'IMG';
  		var img = this._image = wasElementSupplied ? this._url : create$1('img');

  		addClass(img, 'leaflet-image-layer');
  		if (this._zoomAnimated) { addClass(img, 'leaflet-zoom-animated'); }
  		if (this.options.className) { addClass(img, this.options.className); }

  		img.onselectstart = falseFn;
  		img.onmousemove = falseFn;

  		// @event load: Event
  		// Fired when the ImageOverlay layer has loaded its image
  		img.onload = bind(this.fire, this, 'load');
  		img.onerror = bind(this._overlayOnError, this, 'error');

  		if (this.options.crossOrigin || this.options.crossOrigin === '') {
  			img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
  		}

  		if (this.options.zIndex) {
  			this._updateZIndex();
  		}

  		if (wasElementSupplied) {
  			this._url = img.src;
  			return;
  		}

  		img.src = this._url;
  		img.alt = this.options.alt;
  	},

  	_animateZoom: function (e) {
  		var scale = this._map.getZoomScale(e.zoom),
  		    offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;

  		setTransform(this._image, offset, scale);
  	},

  	_reset: function () {
  		var image = this._image,
  		    bounds = new Bounds(
  		        this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
  		        this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
  		    size = bounds.getSize();

  		setPosition(image, bounds.min);

  		image.style.width  = size.x + 'px';
  		image.style.height = size.y + 'px';
  	},

  	_updateOpacity: function () {
  		setOpacity(this._image, this.options.opacity);
  	},

  	_updateZIndex: function () {
  		if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {
  			this._image.style.zIndex = this.options.zIndex;
  		}
  	},

  	_overlayOnError: function () {
  		// @event error: Event
  		// Fired when the ImageOverlay layer fails to load its image
  		this.fire('error');

  		var errorUrl = this.options.errorOverlayUrl;
  		if (errorUrl && this._url !== errorUrl) {
  			this._url = errorUrl;
  			this._image.src = errorUrl;
  		}
  	},

  	// @method getCenter(): LatLng
  	// Returns the center of the ImageOverlay.
  	getCenter: function () {
  		return this._bounds.getCenter();
  	}
  });

  // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
  // Instantiates an image overlay object given the URL of the image and the
  // geographical bounds it is tied to.
  var imageOverlay = function (url, bounds, options) {
  	return new ImageOverlay(url, bounds, options);
  };

  /*
   * @class VideoOverlay
   * @aka L.VideoOverlay
   * @inherits ImageOverlay
   *
   * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.
   *
   * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)
   * HTML5 element.
   *
   * @example
   *
   * ```js
   * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',
   * 	videoBounds = [[ 32, -130], [ 13, -100]];
   * L.videoOverlay(videoUrl, videoBounds ).addTo(map);
   * ```
   */

  var VideoOverlay = ImageOverlay.extend({

  	// @section
  	// @aka VideoOverlay options
  	options: {
  		// @option autoplay: Boolean = true
  		// Whether the video starts playing automatically when loaded.
  		// On some browsers autoplay will only work with `muted: true`
  		autoplay: true,

  		// @option loop: Boolean = true
  		// Whether the video will loop back to the beginning when played.
  		loop: true,

  		// @option keepAspectRatio: Boolean = true
  		// Whether the video will save aspect ratio after the projection.
  		// Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
  		keepAspectRatio: true,

  		// @option muted: Boolean = false
  		// Whether the video starts on mute when loaded.
  		muted: false,

  		// @option playsInline: Boolean = true
  		// Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
  		playsInline: true
  	},

  	_initImage: function () {
  		var wasElementSupplied = this._url.tagName === 'VIDEO';
  		var vid = this._image = wasElementSupplied ? this._url : create$1('video');

  		addClass(vid, 'leaflet-image-layer');
  		if (this._zoomAnimated) { addClass(vid, 'leaflet-zoom-animated'); }
  		if (this.options.className) { addClass(vid, this.options.className); }

  		vid.onselectstart = falseFn;
  		vid.onmousemove = falseFn;

  		// @event load: Event
  		// Fired when the video has finished loading the first frame
  		vid.onloadeddata = bind(this.fire, this, 'load');

  		if (wasElementSupplied) {
  			var sourceElements = vid.getElementsByTagName('source');
  			var sources = [];
  			for (var j = 0; j < sourceElements.length; j++) {
  				sources.push(sourceElements[j].src);
  			}

  			this._url = (sourceElements.length > 0) ? sources : [vid.src];
  			return;
  		}

  		if (!isArray(this._url)) { this._url = [this._url]; }

  		if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, 'objectFit')) {
  			vid.style['objectFit'] = 'fill';
  		}
  		vid.autoplay = !!this.options.autoplay;
  		vid.loop = !!this.options.loop;
  		vid.muted = !!this.options.muted;
  		vid.playsInline = !!this.options.playsInline;
  		for (var i = 0; i < this._url.length; i++) {
  			var source = create$1('source');
  			source.src = this._url[i];
  			vid.appendChild(source);
  		}
  	}

  	// @method getElement(): HTMLVideoElement
  	// Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
  	// used by this overlay.
  });


  // @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)
  // Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the
  // geographical bounds it is tied to.

  function videoOverlay(video, bounds, options) {
  	return new VideoOverlay(video, bounds, options);
  }

  /*
   * @class SVGOverlay
   * @aka L.SVGOverlay
   * @inherits ImageOverlay
   *
   * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.
   *
   * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.
   *
   * @example
   *
   * ```js
   * var svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
   * svgElement.setAttribute('xmlns', "http://www.w3.org/2000/svg");
   * svgElement.setAttribute('viewBox', "0 0 200 200");
   * svgElement.innerHTML = '<rect width="200" height="200"/><rect x="75" y="23" width="50" height="50" style="fill:red"/><rect x="75" y="123" width="50" height="50" style="fill:#0013ff"/>';
   * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];
   * L.svgOverlay(svgElement, svgElementBounds).addTo(map);
   * ```
   */

  var SVGOverlay = ImageOverlay.extend({
  	_initImage: function () {
  		var el = this._image = this._url;

  		addClass(el, 'leaflet-image-layer');
  		if (this._zoomAnimated) { addClass(el, 'leaflet-zoom-animated'); }
  		if (this.options.className) { addClass(el, this.options.className); }

  		el.onselectstart = falseFn;
  		el.onmousemove = falseFn;
  	}

  	// @method getElement(): SVGElement
  	// Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
  	// used by this overlay.
  });


  // @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)
  // Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.
  // A viewBox attribute is required on the SVG element to zoom in and out properly.

  function svgOverlay(el, bounds, options) {
  	return new SVGOverlay(el, bounds, options);
  }

  /*
   * @class DivOverlay
   * @inherits Interactive layer
   * @aka L.DivOverlay
   * Base model for L.Popup and L.Tooltip. Inherit from it for custom overlays like plugins.
   */

  // @namespace DivOverlay
  var DivOverlay = Layer.extend({

  	// @section
  	// @aka DivOverlay options
  	options: {
  		// @option interactive: Boolean = false
  		// If true, the popup/tooltip will listen to the mouse events.
  		interactive: false,

  		// @option offset: Point = Point(0, 0)
  		// The offset of the overlay position.
  		offset: [0, 0],

  		// @option className: String = ''
  		// A custom CSS class name to assign to the overlay.
  		className: '',

  		// @option pane: String = undefined
  		// `Map pane` where the overlay will be added.
  		pane: undefined,

  		// @option content: String|HTMLElement|Function = ''
  		// Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be
  		// passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.
  		content: ''
  	},

  	initialize: function (options, source) {
  		if (options && (options instanceof LatLng || isArray(options))) {
  			this._latlng = toLatLng(options);
  			setOptions(this, source);
  		} else {
  			setOptions(this, options);
  			this._source = source;
  		}
  		if (this.options.content) {
  			this._content = this.options.content;
  		}
  	},

  	// @method openOn(map: Map): this
  	// Adds the overlay to the map.
  	// Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
  	openOn: function (map) {
  		map = arguments.length ? map : this._source._map; // experimental, not the part of public api
  		if (!map.hasLayer(this)) {
  			map.addLayer(this);
  		}
  		return this;
  	},

  	// @method close(): this
  	// Closes the overlay.
  	// Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
  	// and `layer.closePopup()`/`.closeTooltip()`.
  	close: function () {
  		if (this._map) {
  			this._map.removeLayer(this);
  		}
  		return this;
  	},

  	// @method toggle(layer?: Layer): this
  	// Opens or closes the overlay bound to layer depending on its current state.
  	// Argument may be omitted only for overlay bound to layer.
  	// Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
  	toggle: function (layer) {
  		if (this._map) {
  			this.close();
  		} else {
  			if (arguments.length) {
  				this._source = layer;
  			} else {
  				layer = this._source;
  			}
  			this._prepareOpen();

  			// open the overlay on the map
  			this.openOn(layer._map);
  		}
  		return this;
  	},

  	onAdd: function (map) {
  		this._zoomAnimated = map._zoomAnimated;

  		if (!this._container) {
  			this._initLayout();
  		}

  		if (map._fadeAnimated) {
  			setOpacity(this._container, 0);
  		}

  		clearTimeout(this._removeTimeout);
  		this.getPane().appendChild(this._container);
  		this.update();

  		if (map._fadeAnimated) {
  			setOpacity(this._container, 1);
  		}

  		this.bringToFront();

  		if (this.options.interactive) {
  			addClass(this._container, 'leaflet-interactive');
  			this.addInteractiveTarget(this._container);
  		}
  	},

  	onRemove: function (map) {
  		if (map._fadeAnimated) {
  			setOpacity(this._container, 0);
  			this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);
  		} else {
  			remove(this._container);
  		}

  		if (this.options.interactive) {
  			removeClass(this._container, 'leaflet-interactive');
  			this.removeInteractiveTarget(this._container);
  		}
  	},

  	// @namespace DivOverlay
  	// @method getLatLng: LatLng
  	// Returns the geographical point of the overlay.
  	getLatLng: function () {
  		return this._latlng;
  	},

  	// @method setLatLng(latlng: LatLng): this
  	// Sets the geographical point where the overlay will open.
  	setLatLng: function (latlng) {
  		this._latlng = toLatLng(latlng);
  		if (this._map) {
  			this._updatePosition();
  			this._adjustPan();
  		}
  		return this;
  	},

  	// @method getContent: String|HTMLElement
  	// Returns the content of the overlay.
  	getContent: function () {
  		return this._content;
  	},

  	// @method setContent(htmlContent: String|HTMLElement|Function): this
  	// Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
  	// The function should return a `String` or `HTMLElement` to be used in the overlay.
  	setContent: function (content) {
  		this._content = content;
  		this.update();
  		return this;
  	},

  	// @method getElement: String|HTMLElement
  	// Returns the HTML container of the overlay.
  	getElement: function () {
  		return this._container;
  	},

  	// @method update: null
  	// Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
  	update: function () {
  		if (!this._map) { return; }

  		this._container.style.visibility = 'hidden';

  		this._updateContent();
  		this._updateLayout();
  		this._updatePosition();

  		this._container.style.visibility = '';

  		this._adjustPan();
  	},

  	getEvents: function () {
  		var events = {
  			zoom: this._updatePosition,
  			viewreset: this._updatePosition
  		};

  		if (this._zoomAnimated) {
  			events.zoomanim = this._animateZoom;
  		}
  		return events;
  	},

  	// @method isOpen: Boolean
  	// Returns `true` when the overlay is visible on the map.
  	isOpen: function () {
  		return !!this._map && this._map.hasLayer(this);
  	},

  	// @method bringToFront: this
  	// Brings this overlay in front of other overlays (in the same map pane).
  	bringToFront: function () {
  		if (this._map) {
  			toFront(this._container);
  		}
  		return this;
  	},

  	// @method bringToBack: this
  	// Brings this overlay to the back of other overlays (in the same map pane).
  	bringToBack: function () {
  		if (this._map) {
  			toBack(this._container);
  		}
  		return this;
  	},

  	// prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
  	_prepareOpen: function (latlng) {
  		var source = this._source;
  		if (!source._map) { return false; }

  		if (source instanceof FeatureGroup) {
  			source = null;
  			var layers = this._source._layers;
  			for (var id in layers) {
  				if (layers[id]._map) {
  					source = layers[id];
  					break;
  				}
  			}
  			if (!source) { return false; } // Unable to get source layer.

  			// set overlay source to this layer
  			this._source = source;
  		}

  		if (!latlng) {
  			if (source.getCenter) {
  				latlng = source.getCenter();
  			} else if (source.getLatLng) {
  				latlng = source.getLatLng();
  			} else if (source.getBounds) {
  				latlng = source.getBounds().getCenter();
  			} else {
  				throw new Error('Unable to get source layer LatLng.');
  			}
  		}
  		this.setLatLng(latlng);

  		if (this._map) {
  			// update the overlay (content, layout, etc...)
  			this.update();
  		}

  		return true;
  	},

  	_updateContent: function () {
  		if (!this._content) { return; }

  		var node = this._contentNode;
  		var content = (typeof this._content === 'function') ? this._content(this._source || this) : this._content;

  		if (typeof content === 'string') {
  			node.innerHTML = content;
  		} else {
  			while (node.hasChildNodes()) {
  				node.removeChild(node.firstChild);
  			}
  			node.appendChild(content);
  		}

  		// @namespace DivOverlay
  		// @section DivOverlay events
  		// @event contentupdate: Event
  		// Fired when the content of the overlay is updated
  		this.fire('contentupdate');
  	},

  	_updatePosition: function () {
  		if (!this._map) { return; }

  		var pos = this._map.latLngToLayerPoint(this._latlng),
  		    offset = toPoint(this.options.offset),
  		    anchor = this._getAnchor();

  		if (this._zoomAnimated) {
  			setPosition(this._container, pos.add(anchor));
  		} else {
  			offset = offset.add(pos).add(anchor);
  		}

  		var bottom = this._containerBottom = -offset.y,
  		    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

  		// bottom position the overlay in case the height of the overlay changes (images loading etc)
  		this._container.style.bottom = bottom + 'px';
  		this._container.style.left = left + 'px';
  	},

  	_getAnchor: function () {
  		return [0, 0];
  	}

  });

  Map.include({
  	_initOverlay: function (OverlayClass, content, latlng, options) {
  		var overlay = content;
  		if (!(overlay instanceof OverlayClass)) {
  			overlay = new OverlayClass(options).setContent(content);
  		}
  		if (latlng) {
  			overlay.setLatLng(latlng);
  		}
  		return overlay;
  	}
  });


  Layer.include({
  	_initOverlay: function (OverlayClass, old, content, options) {
  		var overlay = content;
  		if (overlay instanceof OverlayClass) {
  			setOptions(overlay, options);
  			overlay._source = this;
  		} else {
  			overlay = (old && !options) ? old : new OverlayClass(options, this);
  			overlay.setContent(content);
  		}
  		return overlay;
  	}
  });

  /*
   * @class Popup
   * @inherits DivOverlay
   * @aka L.Popup
   * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
   * open popups while making sure that only one popup is open at one time
   * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
   *
   * @example
   *
   * If you want to just bind a popup to marker click and then open it, it's really easy:
   *
   * ```js
   * marker.bindPopup(popupContent).openPopup();
   * ```
   * Path overlays like polylines also have a `bindPopup` method.
   *
   * A popup can be also standalone:
   *
   * ```js
   * var popup = L.popup()
   * 	.setLatLng(latlng)
   * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
   * 	.openOn(map);
   * ```
   * or
   * ```js
   * var popup = L.popup(latlng, {content: '<p>Hello world!<br />This is a nice popup.</p>')
   * 	.openOn(map);
   * ```
   */


  // @namespace Popup
  var Popup = DivOverlay.extend({

  	// @section
  	// @aka Popup options
  	options: {
  		// @option pane: String = 'popupPane'
  		// `Map pane` where the popup will be added.
  		pane: 'popupPane',

  		// @option offset: Point = Point(0, 7)
  		// The offset of the popup position.
  		offset: [0, 7],

  		// @option maxWidth: Number = 300
  		// Max width of the popup, in pixels.
  		maxWidth: 300,

  		// @option minWidth: Number = 50
  		// Min width of the popup, in pixels.
  		minWidth: 50,

  		// @option maxHeight: Number = null
  		// If set, creates a scrollable container of the given height
  		// inside a popup if its content exceeds it.
  		// The scrollable container can be styled using the
  		// `leaflet-popup-scrolled` CSS class selector.
  		maxHeight: null,

  		// @option autoPan: Boolean = true
  		// Set it to `false` if you don't want the map to do panning animation
  		// to fit the opened popup.
  		autoPan: true,

  		// @option autoPanPaddingTopLeft: Point = null
  		// The margin between the popup and the top left corner of the map
  		// view after autopanning was performed.
  		autoPanPaddingTopLeft: null,

  		// @option autoPanPaddingBottomRight: Point = null
  		// The margin between the popup and the bottom right corner of the map
  		// view after autopanning was performed.
  		autoPanPaddingBottomRight: null,

  		// @option autoPanPadding: Point = Point(5, 5)
  		// Equivalent of setting both top left and bottom right autopan padding to the same value.
  		autoPanPadding: [5, 5],

  		// @option keepInView: Boolean = false
  		// Set it to `true` if you want to prevent users from panning the popup
  		// off of the screen while it is open.
  		keepInView: false,

  		// @option closeButton: Boolean = true
  		// Controls the presence of a close button in the popup.
  		closeButton: true,

  		// @option autoClose: Boolean = true
  		// Set it to `false` if you want to override the default behavior of
  		// the popup closing when another popup is opened.
  		autoClose: true,

  		// @option closeOnEscapeKey: Boolean = true
  		// Set it to `false` if you want to override the default behavior of
  		// the ESC key for closing of the popup.
  		closeOnEscapeKey: true,

  		// @option closeOnClick: Boolean = *
  		// Set it if you want to override the default behavior of the popup closing when user clicks
  		// on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.

  		// @option className: String = ''
  		// A custom CSS class name to assign to the popup.
  		className: ''
  	},

  	// @namespace Popup
  	// @method openOn(map: Map): this
  	// Alternative to `map.openPopup(popup)`.
  	// Adds the popup to the map and closes the previous one.
  	openOn: function (map) {
  		map = arguments.length ? map : this._source._map; // experimental, not the part of public api

  		if (!map.hasLayer(this) && map._popup && map._popup.options.autoClose) {
  			map.removeLayer(map._popup);
  		}
  		map._popup = this;

  		return DivOverlay.prototype.openOn.call(this, map);
  	},

  	onAdd: function (map) {
  		DivOverlay.prototype.onAdd.call(this, map);

  		// @namespace Map
  		// @section Popup events
  		// @event popupopen: PopupEvent
  		// Fired when a popup is opened in the map
  		map.fire('popupopen', {popup: this});

  		if (this._source) {
  			// @namespace Layer
  			// @section Popup events
  			// @event popupopen: PopupEvent
  			// Fired when a popup bound to this layer is opened
  			this._source.fire('popupopen', {popup: this}, true);
  			// For non-path layers, we toggle the popup when clicking
  			// again the layer, so prevent the map to reopen it.
  			if (!(this._source instanceof Path)) {
  				this._source.on('preclick', stopPropagation);
  			}
  		}
  	},

  	onRemove: function (map) {
  		DivOverlay.prototype.onRemove.call(this, map);

  		// @namespace Map
  		// @section Popup events
  		// @event popupclose: PopupEvent
  		// Fired when a popup in the map is closed
  		map.fire('popupclose', {popup: this});

  		if (this._source) {
  			// @namespace Layer
  			// @section Popup events
  			// @event popupclose: PopupEvent
  			// Fired when a popup bound to this layer is closed
  			this._source.fire('popupclose', {popup: this}, true);
  			if (!(this._source instanceof Path)) {
  				this._source.off('preclick', stopPropagation);
  			}
  		}
  	},

  	getEvents: function () {
  		var events = DivOverlay.prototype.getEvents.call(this);

  		if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
  			events.preclick = this.close;
  		}

  		if (this.options.keepInView) {
  			events.moveend = this._adjustPan;
  		}

  		return events;
  	},

  	_initLayout: function () {
  		var prefix = 'leaflet-popup',
  		    container = this._container = create$1('div',
  			prefix + ' ' + (this.options.className || '') +
  			' leaflet-zoom-animated');

  		var wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);
  		this._contentNode = create$1('div', prefix + '-content', wrapper);

  		disableClickPropagation(container);
  		disableScrollPropagation(this._contentNode);
  		on(container, 'contextmenu', stopPropagation);

  		this._tipContainer = create$1('div', prefix + '-tip-container', container);
  		this._tip = create$1('div', prefix + '-tip', this._tipContainer);

  		if (this.options.closeButton) {
  			var closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);
  			closeButton.setAttribute('role', 'button'); // overrides the implicit role=link of <a> elements #7399
  			closeButton.setAttribute('aria-label', 'Close popup');
  			closeButton.href = '#close';
  			closeButton.innerHTML = '<span aria-hidden="true">&#215;</span>';

  			on(closeButton, 'click', function (ev) {
  				preventDefault(ev);
  				this.close();
  			}, this);
  		}
  	},

  	_updateLayout: function () {
  		var container = this._contentNode,
  		    style = container.style;

  		style.width = '';
  		style.whiteSpace = 'nowrap';

  		var width = container.offsetWidth;
  		width = Math.min(width, this.options.maxWidth);
  		width = Math.max(width, this.options.minWidth);

  		style.width = (width + 1) + 'px';
  		style.whiteSpace = '';

  		style.height = '';

  		var height = container.offsetHeight,
  		    maxHeight = this.options.maxHeight,
  		    scrolledClass = 'leaflet-popup-scrolled';

  		if (maxHeight && height > maxHeight) {
  			style.height = maxHeight + 'px';
  			addClass(container, scrolledClass);
  		} else {
  			removeClass(container, scrolledClass);
  		}

  		this._containerWidth = this._container.offsetWidth;
  	},

  	_animateZoom: function (e) {
  		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
  		    anchor = this._getAnchor();
  		setPosition(this._container, pos.add(anchor));
  	},

  	_adjustPan: function () {
  		if (!this.options.autoPan) { return; }
  		if (this._map._panAnim) { this._map._panAnim.stop(); }

  		// We can endlessly recurse if keepInView is set and the view resets.
  		// Let's guard against that by exiting early if we're responding to our own autopan.
  		if (this._autopanning) {
  			this._autopanning = false;
  			return;
  		}

  		var map = this._map,
  		    marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,
  		    containerHeight = this._container.offsetHeight + marginBottom,
  		    containerWidth = this._containerWidth,
  		    layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);

  		layerPos._add(getPosition(this._container));

  		var containerPos = map.layerPointToContainerPoint(layerPos),
  		    padding = toPoint(this.options.autoPanPadding),
  		    paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),
  		    paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),
  		    size = map.getSize(),
  		    dx = 0,
  		    dy = 0;

  		if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
  			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
  		}
  		if (containerPos.x - dx - paddingTL.x < 0) { // left
  			dx = containerPos.x - paddingTL.x;
  		}
  		if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
  			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
  		}
  		if (containerPos.y - dy - paddingTL.y < 0) { // top
  			dy = containerPos.y - paddingTL.y;
  		}

  		// @namespace Map
  		// @section Popup events
  		// @event autopanstart: Event
  		// Fired when the map starts autopanning when opening a popup.
  		if (dx || dy) {
  			// Track that we're autopanning, as this function will be re-ran on moveend
  			if (this.options.keepInView) {
  				this._autopanning = true;
  			}

  			map
  			    .fire('autopanstart')
  			    .panBy([dx, dy]);
  		}
  	},

  	_getAnchor: function () {
  		// Where should we anchor the popup on the source layer?
  		return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
  	}

  });

  // @namespace Popup
  // @factory L.popup(options?: Popup options, source?: Layer)
  // Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
  // @alternative
  // @factory L.popup(latlng: LatLng, options?: Popup options)
  // Instantiates a `Popup` object given `latlng` where the popup will open and an optional `options` object that describes its appearance and location.
  var popup = function (options, source) {
  	return new Popup(options, source);
  };


  /* @namespace Map
   * @section Interaction Options
   * @option closePopupOnClick: Boolean = true
   * Set it to `false` if you don't want popups to close when user clicks the map.
   */
  Map.mergeOptions({
  	closePopupOnClick: true
  });


  // @namespace Map
  // @section Methods for Layers and Controls
  Map.include({
  	// @method openPopup(popup: Popup): this
  	// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
  	// @alternative
  	// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
  	// Creates a popup with the specified content and options and opens it in the given point on a map.
  	openPopup: function (popup, latlng, options) {
  		this._initOverlay(Popup, popup, latlng, options)
  		  .openOn(this);

  		return this;
  	},

  	// @method closePopup(popup?: Popup): this
  	// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
  	closePopup: function (popup) {
  		popup = arguments.length ? popup : this._popup;
  		if (popup) {
  			popup.close();
  		}
  		return this;
  	}
  });

  /*
   * @namespace Layer
   * @section Popup methods example
   *
   * All layers share a set of methods convenient for binding popups to it.
   *
   * ```js
   * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
   * layer.openPopup();
   * layer.closePopup();
   * ```
   *
   * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
   */

  // @section Popup methods
  Layer.include({

  	// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
  	// Binds a popup to the layer with the passed `content` and sets up the
  	// necessary event listeners. If a `Function` is passed it will receive
  	// the layer as the first argument and should return a `String` or `HTMLElement`.
  	bindPopup: function (content, options) {
  		this._popup = this._initOverlay(Popup, this._popup, content, options);
  		if (!this._popupHandlersAdded) {
  			this.on({
  				click: this._openPopup,
  				keypress: this._onKeyPress,
  				remove: this.closePopup,
  				move: this._movePopup
  			});
  			this._popupHandlersAdded = true;
  		}

  		return this;
  	},

  	// @method unbindPopup(): this
  	// Removes the popup previously bound with `bindPopup`.
  	unbindPopup: function () {
  		if (this._popup) {
  			this.off({
  				click: this._openPopup,
  				keypress: this._onKeyPress,
  				remove: this.closePopup,
  				move: this._movePopup
  			});
  			this._popupHandlersAdded = false;
  			this._popup = null;
  		}
  		return this;
  	},

  	// @method openPopup(latlng?: LatLng): this
  	// Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
  	openPopup: function (latlng) {
  		if (this._popup) {
  			if (!(this instanceof FeatureGroup)) {
  				this._popup._source = this;
  			}
  			if (this._popup._prepareOpen(latlng || this._latlng)) {
  				// open the popup on the map
  				this._popup.openOn(this._map);
  			}
  		}
  		return this;
  	},

  	// @method closePopup(): this
  	// Closes the popup bound to this layer if it is open.
  	closePopup: function () {
  		if (this._popup) {
  			this._popup.close();
  		}
  		return this;
  	},

  	// @method togglePopup(): this
  	// Opens or closes the popup bound to this layer depending on its current state.
  	togglePopup: function () {
  		if (this._popup) {
  			this._popup.toggle(this);
  		}
  		return this;
  	},

  	// @method isPopupOpen(): boolean
  	// Returns `true` if the popup bound to this layer is currently open.
  	isPopupOpen: function () {
  		return (this._popup ? this._popup.isOpen() : false);
  	},

  	// @method setPopupContent(content: String|HTMLElement|Popup): this
  	// Sets the content of the popup bound to this layer.
  	setPopupContent: function (content) {
  		if (this._popup) {
  			this._popup.setContent(content);
  		}
  		return this;
  	},

  	// @method getPopup(): Popup
  	// Returns the popup bound to this layer.
  	getPopup: function () {
  		return this._popup;
  	},

  	_openPopup: function (e) {
  		if (!this._popup || !this._map) {
  			return;
  		}
  		// prevent map click
  		stop(e);

  		var target = e.layer || e.target;
  		if (this._popup._source === target && !(target instanceof Path)) {
  			// treat it like a marker and figure out
  			// if we should toggle it open/closed
  			if (this._map.hasLayer(this._popup)) {
  				this.closePopup();
  			} else {
  				this.openPopup(e.latlng);
  			}
  			return;
  		}
  		this._popup._source = target;
  		this.openPopup(e.latlng);
  	},

  	_movePopup: function (e) {
  		this._popup.setLatLng(e.latlng);
  	},

  	_onKeyPress: function (e) {
  		if (e.originalEvent.keyCode === 13) {
  			this._openPopup(e);
  		}
  	}
  });

  /*
   * @class Tooltip
   * @inherits DivOverlay
   * @aka L.Tooltip
   * Used to display small texts on top of map layers.
   *
   * @example
   * If you want to just bind a tooltip to marker:
   *
   * ```js
   * marker.bindTooltip("my tooltip text").openTooltip();
   * ```
   * Path overlays like polylines also have a `bindTooltip` method.
   *
   * A tooltip can be also standalone:
   *
   * ```js
   * var tooltip = L.tooltip()
   * 	.setLatLng(latlng)
   * 	.setContent('Hello world!<br />This is a nice tooltip.')
   * 	.addTo(map);
   * ```
   * or
   * ```js
   * var tooltip = L.tooltip(latlng, {content: 'Hello world!<br />This is a nice tooltip.'})
   * 	.addTo(map);
   * ```
   *
   *
   * Note about tooltip offset. Leaflet takes two options in consideration
   * for computing tooltip offsetting:
   * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
   *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
   *   move it to the bottom. Negatives will move to the left and top.
   * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
   *   should adapt this value if you use a custom icon.
   */


  // @namespace Tooltip
  var Tooltip = DivOverlay.extend({

  	// @section
  	// @aka Tooltip options
  	options: {
  		// @option pane: String = 'tooltipPane'
  		// `Map pane` where the tooltip will be added.
  		pane: 'tooltipPane',

  		// @option offset: Point = Point(0, 0)
  		// Optional offset of the tooltip position.
  		offset: [0, 0],

  		// @option direction: String = 'auto'
  		// Direction where to open the tooltip. Possible values are: `right`, `left`,
  		// `top`, `bottom`, `center`, `auto`.
  		// `auto` will dynamically switch between `right` and `left` according to the tooltip
  		// position on the map.
  		direction: 'auto',

  		// @option permanent: Boolean = false
  		// Whether to open the tooltip permanently or only on mouseover.
  		permanent: false,

  		// @option sticky: Boolean = false
  		// If true, the tooltip will follow the mouse instead of being fixed at the feature center.
  		sticky: false,

  		// @option opacity: Number = 0.9
  		// Tooltip container opacity.
  		opacity: 0.9
  	},

  	onAdd: function (map) {
  		DivOverlay.prototype.onAdd.call(this, map);
  		this.setOpacity(this.options.opacity);

  		// @namespace Map
  		// @section Tooltip events
  		// @event tooltipopen: TooltipEvent
  		// Fired when a tooltip is opened in the map.
  		map.fire('tooltipopen', {tooltip: this});

  		if (this._source) {
  			this.addEventParent(this._source);

  			// @namespace Layer
  			// @section Tooltip events
  			// @event tooltipopen: TooltipEvent
  			// Fired when a tooltip bound to this layer is opened.
  			this._source.fire('tooltipopen', {tooltip: this}, true);
  		}
  	},

  	onRemove: function (map) {
  		DivOverlay.prototype.onRemove.call(this, map);

  		// @namespace Map
  		// @section Tooltip events
  		// @event tooltipclose: TooltipEvent
  		// Fired when a tooltip in the map is closed.
  		map.fire('tooltipclose', {tooltip: this});

  		if (this._source) {
  			this.removeEventParent(this._source);

  			// @namespace Layer
  			// @section Tooltip events
  			// @event tooltipclose: TooltipEvent
  			// Fired when a tooltip bound to this layer is closed.
  			this._source.fire('tooltipclose', {tooltip: this}, true);
  		}
  	},

  	getEvents: function () {
  		var events = DivOverlay.prototype.getEvents.call(this);

  		if (!this.options.permanent) {
  			events.preclick = this.close;
  		}

  		return events;
  	},

  	_initLayout: function () {
  		var prefix = 'leaflet-tooltip',
  		    className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

  		this._contentNode = this._container = create$1('div', className);

  		this._container.setAttribute('role', 'tooltip');
  		this._container.setAttribute('id', 'leaflet-tooltip-' + stamp(this));
  	},

  	_updateLayout: function () {},

  	_adjustPan: function () {},

  	_setPosition: function (pos) {
  		var subX, subY,
  		    map = this._map,
  		    container = this._container,
  		    centerPoint = map.latLngToContainerPoint(map.getCenter()),
  		    tooltipPoint = map.layerPointToContainerPoint(pos),
  		    direction = this.options.direction,
  		    tooltipWidth = container.offsetWidth,
  		    tooltipHeight = container.offsetHeight,
  		    offset = toPoint(this.options.offset),
  		    anchor = this._getAnchor();

  		if (direction === 'top') {
  			subX = tooltipWidth / 2;
  			subY = tooltipHeight;
  		} else if (direction === 'bottom') {
  			subX = tooltipWidth / 2;
  			subY = 0;
  		} else if (direction === 'center') {
  			subX = tooltipWidth / 2;
  			subY = tooltipHeight / 2;
  		} else if (direction === 'right') {
  			subX = 0;
  			subY = tooltipHeight / 2;
  		} else if (direction === 'left') {
  			subX = tooltipWidth;
  			subY = tooltipHeight / 2;
  		} else if (tooltipPoint.x < centerPoint.x) {
  			direction = 'right';
  			subX = 0;
  			subY = tooltipHeight / 2;
  		} else {
  			direction = 'left';
  			subX = tooltipWidth + (offset.x + anchor.x) * 2;
  			subY = tooltipHeight / 2;
  		}

  		pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);

  		removeClass(container, 'leaflet-tooltip-right');
  		removeClass(container, 'leaflet-tooltip-left');
  		removeClass(container, 'leaflet-tooltip-top');
  		removeClass(container, 'leaflet-tooltip-bottom');
  		addClass(container, 'leaflet-tooltip-' + direction);
  		setPosition(container, pos);
  	},

  	_updatePosition: function () {
  		var pos = this._map.latLngToLayerPoint(this._latlng);
  		this._setPosition(pos);
  	},

  	setOpacity: function (opacity) {
  		this.options.opacity = opacity;

  		if (this._container) {
  			setOpacity(this._container, opacity);
  		}
  	},

  	_animateZoom: function (e) {
  		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
  		this._setPosition(pos);
  	},

  	_getAnchor: function () {
  		// Where should we anchor the tooltip on the source layer?
  		return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
  	}

  });

  // @namespace Tooltip
  // @factory L.tooltip(options?: Tooltip options, source?: Layer)
  // Instantiates a `Tooltip` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
  // @alternative
  // @factory L.tooltip(latlng: LatLng, options?: Tooltip options)
  // Instantiates a `Tooltip` object given `latlng` where the tooltip will open and an optional `options` object that describes its appearance and location.
  var tooltip = function (options, source) {
  	return new Tooltip(options, source);
  };

  // @namespace Map
  // @section Methods for Layers and Controls
  Map.include({

  	// @method openTooltip(tooltip: Tooltip): this
  	// Opens the specified tooltip.
  	// @alternative
  	// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
  	// Creates a tooltip with the specified content and options and open it.
  	openTooltip: function (tooltip, latlng, options) {
  		this._initOverlay(Tooltip, tooltip, latlng, options)
  		  .openOn(this);

  		return this;
  	},

  	// @method closeTooltip(tooltip: Tooltip): this
  	// Closes the tooltip given as parameter.
  	closeTooltip: function (tooltip) {
  		tooltip.close();
  		return this;
  	}

  });

  /*
   * @namespace Layer
   * @section Tooltip methods example
   *
   * All layers share a set of methods convenient for binding tooltips to it.
   *
   * ```js
   * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
   * layer.openTooltip();
   * layer.closeTooltip();
   * ```
   */

  // @section Tooltip methods
  Layer.include({

  	// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
  	// Binds a tooltip to the layer with the passed `content` and sets up the
  	// necessary event listeners. If a `Function` is passed it will receive
  	// the layer as the first argument and should return a `String` or `HTMLElement`.
  	bindTooltip: function (content, options) {

  		if (this._tooltip && this.isTooltipOpen()) {
  			this.unbindTooltip();
  		}

  		this._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options);
  		this._initTooltipInteractions();

  		if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
  			this.openTooltip();
  		}

  		return this;
  	},

  	// @method unbindTooltip(): this
  	// Removes the tooltip previously bound with `bindTooltip`.
  	unbindTooltip: function () {
  		if (this._tooltip) {
  			this._initTooltipInteractions(true);
  			this.closeTooltip();
  			this._tooltip = null;
  		}
  		return this;
  	},

  	_initTooltipInteractions: function (remove) {
  		if (!remove && this._tooltipHandlersAdded) { return; }
  		var onOff = remove ? 'off' : 'on',
  		    events = {
  			remove: this.closeTooltip,
  			move: this._moveTooltip
  		    };
  		if (!this._tooltip.options.permanent) {
  			events.mouseover = this._openTooltip;
  			events.mouseout = this.closeTooltip;
  			events.click = this._openTooltip;
  			if (this._map) {
  				this._addFocusListeners();
  			} else {
  				events.add = this._addFocusListeners;
  			}
  		} else {
  			events.add = this._openTooltip;
  		}
  		if (this._tooltip.options.sticky) {
  			events.mousemove = this._moveTooltip;
  		}
  		this[onOff](events);
  		this._tooltipHandlersAdded = !remove;
  	},

  	// @method openTooltip(latlng?: LatLng): this
  	// Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
  	openTooltip: function (latlng) {
  		if (this._tooltip) {
  			if (!(this instanceof FeatureGroup)) {
  				this._tooltip._source = this;
  			}
  			if (this._tooltip._prepareOpen(latlng)) {
  				// open the tooltip on the map
  				this._tooltip.openOn(this._map);

  				if (this.getElement) {
  					this._setAriaDescribedByOnLayer(this);
  				} else if (this.eachLayer) {
  					this.eachLayer(this._setAriaDescribedByOnLayer, this);
  				}
  			}
  		}
  		return this;
  	},

  	// @method closeTooltip(): this
  	// Closes the tooltip bound to this layer if it is open.
  	closeTooltip: function () {
  		if (this._tooltip) {
  			return this._tooltip.close();
  		}
  	},

  	// @method toggleTooltip(): this
  	// Opens or closes the tooltip bound to this layer depending on its current state.
  	toggleTooltip: function () {
  		if (this._tooltip) {
  			this._tooltip.toggle(this);
  		}
  		return this;
  	},

  	// @method isTooltipOpen(): boolean
  	// Returns `true` if the tooltip bound to this layer is currently open.
  	isTooltipOpen: function () {
  		return this._tooltip.isOpen();
  	},

  	// @method setTooltipContent(content: String|HTMLElement|Tooltip): this
  	// Sets the content of the tooltip bound to this layer.
  	setTooltipContent: function (content) {
  		if (this._tooltip) {
  			this._tooltip.setContent(content);
  		}
  		return this;
  	},

  	// @method getTooltip(): Tooltip
  	// Returns the tooltip bound to this layer.
  	getTooltip: function () {
  		return this._tooltip;
  	},

  	_addFocusListeners: function () {
  		if (this.getElement) {
  			this._addFocusListenersOnLayer(this);
  		} else if (this.eachLayer) {
  			this.eachLayer(this._addFocusListenersOnLayer, this);
  		}
  	},

  	_addFocusListenersOnLayer: function (layer) {
  		var el = typeof layer.getElement === 'function' && layer.getElement();
  		if (el) {
  			on(el, 'focus', function () {
  				this._tooltip._source = layer;
  				this.openTooltip();
  			}, this);
  			on(el, 'blur', this.closeTooltip, this);
  		}
  	},

  	_setAriaDescribedByOnLayer: function (layer) {
  		var el = typeof layer.getElement === 'function' && layer.getElement();
  		if (el) {
  			el.setAttribute('aria-describedby', this._tooltip._container.id);
  		}
  	},


  	_openTooltip: function (e) {
  		if (!this._tooltip || !this._map) {
  			return;
  		}

  		// If the map is moving, we will show the tooltip after it's done.
  		if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
  			this._openOnceFlag = true;
  			var that = this;
  			this._map.once('moveend', function () {
  				that._openOnceFlag = false;
  				that._openTooltip(e);
  			});
  			return;
  		}

  		this._tooltip._source = e.layer || e.target;

  		this.openTooltip(this._tooltip.options.sticky ? e.latlng : undefined);
  	},

  	_moveTooltip: function (e) {
  		var latlng = e.latlng, containerPoint, layerPoint;
  		if (this._tooltip.options.sticky && e.originalEvent) {
  			containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
  			layerPoint = this._map.containerPointToLayerPoint(containerPoint);
  			latlng = this._map.layerPointToLatLng(layerPoint);
  		}
  		this._tooltip.setLatLng(latlng);
  	}
  });

  /*
   * @class DivIcon
   * @aka L.DivIcon
   * @inherits Icon
   *
   * Represents a lightweight icon for markers that uses a simple `<div>`
   * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
   *
   * @example
   * ```js
   * var myIcon = L.divIcon({className: 'my-div-icon'});
   * // you can set .my-div-icon styles in CSS
   *
   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
   * ```
   *
   * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
   */

  var DivIcon = Icon.extend({
  	options: {
  		// @section
  		// @aka DivIcon options
  		iconSize: [12, 12], // also can be set through CSS

  		// iconAnchor: (Point),
  		// popupAnchor: (Point),

  		// @option html: String|HTMLElement = ''
  		// Custom HTML code to put inside the div element, empty by default. Alternatively,
  		// an instance of `HTMLElement`.
  		html: false,

  		// @option bgPos: Point = [0, 0]
  		// Optional relative position of the background, in pixels
  		bgPos: null,

  		className: 'leaflet-div-icon'
  	},

  	createIcon: function (oldIcon) {
  		var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
  		    options = this.options;

  		if (options.html instanceof Element) {
  			empty(div);
  			div.appendChild(options.html);
  		} else {
  			div.innerHTML = options.html !== false ? options.html : '';
  		}

  		if (options.bgPos) {
  			var bgPos = toPoint(options.bgPos);
  			div.style.backgroundPosition = (-bgPos.x) + 'px ' + (-bgPos.y) + 'px';
  		}
  		this._setIconStyles(div, 'icon');

  		return div;
  	},

  	createShadow: function () {
  		return null;
  	}
  });

  // @factory L.divIcon(options: DivIcon options)
  // Creates a `DivIcon` instance with the given options.
  function divIcon(options) {
  	return new DivIcon(options);
  }

  Icon.Default = IconDefault;

  /*
   * @class GridLayer
   * @inherits Layer
   * @aka L.GridLayer
   *
   * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
   * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
   *
   *
   * @section Synchronous usage
   * @example
   *
   * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
   *
   * ```js
   * var CanvasLayer = L.GridLayer.extend({
   *     createTile: function(coords){
   *         // create a <canvas> element for drawing
   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
   *
   *         // setup tile width and height according to the options
   *         var size = this.getTileSize();
   *         tile.width = size.x;
   *         tile.height = size.y;
   *
   *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
   *         var ctx = tile.getContext('2d');
   *
   *         // return the tile so it can be rendered on screen
   *         return tile;
   *     }
   * });
   * ```
   *
   * @section Asynchronous usage
   * @example
   *
   * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
   *
   * ```js
   * var CanvasLayer = L.GridLayer.extend({
   *     createTile: function(coords, done){
   *         var error;
   *
   *         // create a <canvas> element for drawing
   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
   *
   *         // setup tile width and height according to the options
   *         var size = this.getTileSize();
   *         tile.width = size.x;
   *         tile.height = size.y;
   *
   *         // draw something asynchronously and pass the tile to the done() callback
   *         setTimeout(function() {
   *             done(error, tile);
   *         }, 1000);
   *
   *         return tile;
   *     }
   * });
   * ```
   *
   * @section
   */


  var GridLayer = Layer.extend({

  	// @section
  	// @aka GridLayer options
  	options: {
  		// @option tileSize: Number|Point = 256
  		// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
  		tileSize: 256,

  		// @option opacity: Number = 1.0
  		// Opacity of the tiles. Can be used in the `createTile()` function.
  		opacity: 1,

  		// @option updateWhenIdle: Boolean = (depends)
  		// Load new tiles only when panning ends.
  		// `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
  		// `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
  		// [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
  		updateWhenIdle: Browser.mobile,

  		// @option updateWhenZooming: Boolean = true
  		// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
  		updateWhenZooming: true,

  		// @option updateInterval: Number = 200
  		// Tiles will not update more than once every `updateInterval` milliseconds when panning.
  		updateInterval: 200,

  		// @option zIndex: Number = 1
  		// The explicit zIndex of the tile layer.
  		zIndex: 1,

  		// @option bounds: LatLngBounds = undefined
  		// If set, tiles will only be loaded inside the set `LatLngBounds`.
  		bounds: null,

  		// @option minZoom: Number = 0
  		// The minimum zoom level down to which this layer will be displayed (inclusive).
  		minZoom: 0,

  		// @option maxZoom: Number = undefined
  		// The maximum zoom level up to which this layer will be displayed (inclusive).
  		maxZoom: undefined,

  		// @option maxNativeZoom: Number = undefined
  		// Maximum zoom number the tile source has available. If it is specified,
  		// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
  		// from `maxNativeZoom` level and auto-scaled.
  		maxNativeZoom: undefined,

  		// @option minNativeZoom: Number = undefined
  		// Minimum zoom number the tile source has available. If it is specified,
  		// the tiles on all zoom levels lower than `minNativeZoom` will be loaded
  		// from `minNativeZoom` level and auto-scaled.
  		minNativeZoom: undefined,

  		// @option noWrap: Boolean = false
  		// Whether the layer is wrapped around the antimeridian. If `true`, the
  		// GridLayer will only be displayed once at low zoom levels. Has no
  		// effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
  		// in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
  		// tiles outside the CRS limits.
  		noWrap: false,

  		// @option pane: String = 'tilePane'
  		// `Map pane` where the grid layer will be added.
  		pane: 'tilePane',

  		// @option className: String = ''
  		// A custom class name to assign to the tile layer. Empty by default.
  		className: '',

  		// @option keepBuffer: Number = 2
  		// When panning the map, keep this many rows and columns of tiles before unloading them.
  		keepBuffer: 2
  	},

  	initialize: function (options) {
  		setOptions(this, options);
  	},

  	onAdd: function () {
  		this._initContainer();

  		this._levels = {};
  		this._tiles = {};

  		this._resetView(); // implicit _update() call
  	},

  	beforeAdd: function (map) {
  		map._addZoomLimit(this);
  	},

  	onRemove: function (map) {
  		this._removeAllTiles();
  		remove(this._container);
  		map._removeZoomLimit(this);
  		this._container = null;
  		this._tileZoom = undefined;
  	},

  	// @method bringToFront: this
  	// Brings the tile layer to the top of all tile layers.
  	bringToFront: function () {
  		if (this._map) {
  			toFront(this._container);
  			this._setAutoZIndex(Math.max);
  		}
  		return this;
  	},

  	// @method bringToBack: this
  	// Brings the tile layer to the bottom of all tile layers.
  	bringToBack: function () {
  		if (this._map) {
  			toBack(this._container);
  			this._setAutoZIndex(Math.min);
  		}
  		return this;
  	},

  	// @method getContainer: HTMLElement
  	// Returns the HTML element that contains the tiles for this layer.
  	getContainer: function () {
  		return this._container;
  	},

  	// @method setOpacity(opacity: Number): this
  	// Changes the [opacity](#gridlayer-opacity) of the grid layer.
  	setOpacity: function (opacity) {
  		this.options.opacity = opacity;
  		this._updateOpacity();
  		return this;
  	},

  	// @method setZIndex(zIndex: Number): this
  	// Changes the [zIndex](#gridlayer-zindex) of the grid layer.
  	setZIndex: function (zIndex) {
  		this.options.zIndex = zIndex;
  		this._updateZIndex();

  		return this;
  	},

  	// @method isLoading: Boolean
  	// Returns `true` if any tile in the grid layer has not finished loading.
  	isLoading: function () {
  		return this._loading;
  	},

  	// @method redraw: this
  	// Causes the layer to clear all the tiles and request them again.
  	redraw: function () {
  		if (this._map) {
  			this._removeAllTiles();
  			var tileZoom = this._clampZoom(this._map.getZoom());
  			if (tileZoom !== this._tileZoom) {
  				this._tileZoom = tileZoom;
  				this._updateLevels();
  			}
  			this._update();
  		}
  		return this;
  	},

  	getEvents: function () {
  		var events = {
  			viewprereset: this._invalidateAll,
  			viewreset: this._resetView,
  			zoom: this._resetView,
  			moveend: this._onMoveEnd
  		};

  		if (!this.options.updateWhenIdle) {
  			// update tiles on move, but not more often than once per given interval
  			if (!this._onMove) {
  				this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
  			}

  			events.move = this._onMove;
  		}

  		if (this._zoomAnimated) {
  			events.zoomanim = this._animateZoom;
  		}

  		return events;
  	},

  	// @section Extension methods
  	// Layers extending `GridLayer` shall reimplement the following method.
  	// @method createTile(coords: Object, done?: Function): HTMLElement
  	// Called only internally, must be overridden by classes extending `GridLayer`.
  	// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
  	// is specified, it must be called when the tile has finished loading and drawing.
  	createTile: function () {
  		return document.createElement('div');
  	},

  	// @section
  	// @method getTileSize: Point
  	// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
  	getTileSize: function () {
  		var s = this.options.tileSize;
  		return s instanceof Point ? s : new Point(s, s);
  	},

  	_updateZIndex: function () {
  		if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
  			this._container.style.zIndex = this.options.zIndex;
  		}
  	},

  	_setAutoZIndex: function (compare) {
  		// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

  		var layers = this.getPane().children,
  		    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

  		for (var i = 0, len = layers.length, zIndex; i < len; i++) {

  			zIndex = layers[i].style.zIndex;

  			if (layers[i] !== this._container && zIndex) {
  				edgeZIndex = compare(edgeZIndex, +zIndex);
  			}
  		}

  		if (isFinite(edgeZIndex)) {
  			this.options.zIndex = edgeZIndex + compare(-1, 1);
  			this._updateZIndex();
  		}
  	},

  	_updateOpacity: function () {
  		if (!this._map) { return; }

  		// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
  		if (Browser.ielt9) { return; }

  		setOpacity(this._container, this.options.opacity);

  		var now = +new Date(),
  		    nextFrame = false,
  		    willPrune = false;

  		for (var key in this._tiles) {
  			var tile = this._tiles[key];
  			if (!tile.current || !tile.loaded) { continue; }

  			var fade = Math.min(1, (now - tile.loaded) / 200);

  			setOpacity(tile.el, fade);
  			if (fade < 1) {
  				nextFrame = true;
  			} else {
  				if (tile.active) {
  					willPrune = true;
  				} else {
  					this._onOpaqueTile(tile);
  				}
  				tile.active = true;
  			}
  		}

  		if (willPrune && !this._noPrune) { this._pruneTiles(); }

  		if (nextFrame) {
  			cancelAnimFrame(this._fadeFrame);
  			this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
  		}
  	},

  	_onOpaqueTile: falseFn,

  	_initContainer: function () {
  		if (this._container) { return; }

  		this._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));
  		this._updateZIndex();

  		if (this.options.opacity < 1) {
  			this._updateOpacity();
  		}

  		this.getPane().appendChild(this._container);
  	},

  	_updateLevels: function () {

  		var zoom = this._tileZoom,
  		    maxZoom = this.options.maxZoom;

  		if (zoom === undefined) { return undefined; }

  		for (var z in this._levels) {
  			z = Number(z);
  			if (this._levels[z].el.children.length || z === zoom) {
  				this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
  				this._onUpdateLevel(z);
  			} else {
  				remove(this._levels[z].el);
  				this._removeTilesAtZoom(z);
  				this._onRemoveLevel(z);
  				delete this._levels[z];
  			}
  		}

  		var level = this._levels[zoom],
  		    map = this._map;

  		if (!level) {
  			level = this._levels[zoom] = {};

  			level.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
  			level.el.style.zIndex = maxZoom;

  			level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
  			level.zoom = zoom;

  			this._setZoomTransform(level, map.getCenter(), map.getZoom());

  			// force the browser to consider the newly added element for transition
  			falseFn(level.el.offsetWidth);

  			this._onCreateLevel(level);
  		}

  		this._level = level;

  		return level;
  	},

  	_onUpdateLevel: falseFn,

  	_onRemoveLevel: falseFn,

  	_onCreateLevel: falseFn,

  	_pruneTiles: function () {
  		if (!this._map) {
  			return;
  		}

  		var key, tile;

  		var zoom = this._map.getZoom();
  		if (zoom > this.options.maxZoom ||
  			zoom < this.options.minZoom) {
  			this._removeAllTiles();
  			return;
  		}

  		for (key in this._tiles) {
  			tile = this._tiles[key];
  			tile.retain = tile.current;
  		}

  		for (key in this._tiles) {
  			tile = this._tiles[key];
  			if (tile.current && !tile.active) {
  				var coords = tile.coords;
  				if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
  					this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
  				}
  			}
  		}

  		for (key in this._tiles) {
  			if (!this._tiles[key].retain) {
  				this._removeTile(key);
  			}
  		}
  	},

  	_removeTilesAtZoom: function (zoom) {
  		for (var key in this._tiles) {
  			if (this._tiles[key].coords.z !== zoom) {
  				continue;
  			}
  			this._removeTile(key);
  		}
  	},

  	_removeAllTiles: function () {
  		for (var key in this._tiles) {
  			this._removeTile(key);
  		}
  	},

  	_invalidateAll: function () {
  		for (var z in this._levels) {
  			remove(this._levels[z].el);
  			this._onRemoveLevel(Number(z));
  			delete this._levels[z];
  		}
  		this._removeAllTiles();

  		this._tileZoom = undefined;
  	},

  	_retainParent: function (x, y, z, minZoom) {
  		var x2 = Math.floor(x / 2),
  		    y2 = Math.floor(y / 2),
  		    z2 = z - 1,
  		    coords2 = new Point(+x2, +y2);
  		coords2.z = +z2;

  		var key = this._tileCoordsToKey(coords2),
  		    tile = this._tiles[key];

  		if (tile && tile.active) {
  			tile.retain = true;
  			return true;

  		} else if (tile && tile.loaded) {
  			tile.retain = true;
  		}

  		if (z2 > minZoom) {
  			return this._retainParent(x2, y2, z2, minZoom);
  		}

  		return false;
  	},

  	_retainChildren: function (x, y, z, maxZoom) {

  		for (var i = 2 * x; i < 2 * x + 2; i++) {
  			for (var j = 2 * y; j < 2 * y + 2; j++) {

  				var coords = new Point(i, j);
  				coords.z = z + 1;

  				var key = this._tileCoordsToKey(coords),
  				    tile = this._tiles[key];

  				if (tile && tile.active) {
  					tile.retain = true;
  					continue;

  				} else if (tile && tile.loaded) {
  					tile.retain = true;
  				}

  				if (z + 1 < maxZoom) {
  					this._retainChildren(i, j, z + 1, maxZoom);
  				}
  			}
  		}
  	},

  	_resetView: function (e) {
  		var animating = e && (e.pinch || e.flyTo);
  		this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
  	},

  	_animateZoom: function (e) {
  		this._setView(e.center, e.zoom, true, e.noUpdate);
  	},

  	_clampZoom: function (zoom) {
  		var options = this.options;

  		if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {
  			return options.minNativeZoom;
  		}

  		if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {
  			return options.maxNativeZoom;
  		}

  		return zoom;
  	},

  	_setView: function (center, zoom, noPrune, noUpdate) {
  		var tileZoom = Math.round(zoom);
  		if ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||
  		    (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {
  			tileZoom = undefined;
  		} else {
  			tileZoom = this._clampZoom(tileZoom);
  		}

  		var tileZoomChanged = this.options.updateWhenZooming && (tileZoom !== this._tileZoom);

  		if (!noUpdate || tileZoomChanged) {

  			this._tileZoom = tileZoom;

  			if (this._abortLoading) {
  				this._abortLoading();
  			}

  			this._updateLevels();
  			this._resetGrid();

  			if (tileZoom !== undefined) {
  				this._update(center);
  			}

  			if (!noPrune) {
  				this._pruneTiles();
  			}

  			// Flag to prevent _updateOpacity from pruning tiles during
  			// a zoom anim or a pinch gesture
  			this._noPrune = !!noPrune;
  		}

  		this._setZoomTransforms(center, zoom);
  	},

  	_setZoomTransforms: function (center, zoom) {
  		for (var i in this._levels) {
  			this._setZoomTransform(this._levels[i], center, zoom);
  		}
  	},

  	_setZoomTransform: function (level, center, zoom) {
  		var scale = this._map.getZoomScale(zoom, level.zoom),
  		    translate = level.origin.multiplyBy(scale)
  		        .subtract(this._map._getNewPixelOrigin(center, zoom)).round();

  		if (Browser.any3d) {
  			setTransform(level.el, translate, scale);
  		} else {
  			setPosition(level.el, translate);
  		}
  	},

  	_resetGrid: function () {
  		var map = this._map,
  		    crs = map.options.crs,
  		    tileSize = this._tileSize = this.getTileSize(),
  		    tileZoom = this._tileZoom;

  		var bounds = this._map.getPixelWorldBounds(this._tileZoom);
  		if (bounds) {
  			this._globalTileRange = this._pxBoundsToTileRange(bounds);
  		}

  		this._wrapX = crs.wrapLng && !this.options.noWrap && [
  			Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
  			Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
  		];
  		this._wrapY = crs.wrapLat && !this.options.noWrap && [
  			Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
  			Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
  		];
  	},

  	_onMoveEnd: function () {
  		if (!this._map || this._map._animatingZoom) { return; }

  		this._update();
  	},

  	_getTiledPixelBounds: function (center) {
  		var map = this._map,
  		    mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
  		    scale = map.getZoomScale(mapZoom, this._tileZoom),
  		    pixelCenter = map.project(center, this._tileZoom).floor(),
  		    halfSize = map.getSize().divideBy(scale * 2);

  		return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
  	},

  	// Private method to load tiles in the grid's active zoom level according to map bounds
  	_update: function (center) {
  		var map = this._map;
  		if (!map) { return; }
  		var zoom = this._clampZoom(map.getZoom());

  		if (center === undefined) { center = map.getCenter(); }
  		if (this._tileZoom === undefined) { return; }	// if out of minzoom/maxzoom

  		var pixelBounds = this._getTiledPixelBounds(center),
  		    tileRange = this._pxBoundsToTileRange(pixelBounds),
  		    tileCenter = tileRange.getCenter(),
  		    queue = [],
  		    margin = this.options.keepBuffer,
  		    noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),
  		                              tileRange.getTopRight().add([margin, -margin]));

  		// Sanity check: panic if the tile range contains Infinity somewhere.
  		if (!(isFinite(tileRange.min.x) &&
  		      isFinite(tileRange.min.y) &&
  		      isFinite(tileRange.max.x) &&
  		      isFinite(tileRange.max.y))) { throw new Error('Attempted to load an infinite number of tiles'); }

  		for (var key in this._tiles) {
  			var c = this._tiles[key].coords;
  			if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
  				this._tiles[key].current = false;
  			}
  		}

  		// _update just loads more tiles. If the tile zoom level differs too much
  		// from the map's, let _setView reset levels and prune old tiles.
  		if (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }

  		// create a queue of coordinates to load tiles from
  		for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
  			for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
  				var coords = new Point(i, j);
  				coords.z = this._tileZoom;

  				if (!this._isValidTile(coords)) { continue; }

  				var tile = this._tiles[this._tileCoordsToKey(coords)];
  				if (tile) {
  					tile.current = true;
  				} else {
  					queue.push(coords);
  				}
  			}
  		}

  		// sort tile queue to load tiles in order of their distance to center
  		queue.sort(function (a, b) {
  			return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
  		});

  		if (queue.length !== 0) {
  			// if it's the first batch of tiles to load
  			if (!this._loading) {
  				this._loading = true;
  				// @event loading: Event
  				// Fired when the grid layer starts loading tiles.
  				this.fire('loading');
  			}

  			// create DOM fragment to append tiles in one batch
  			var fragment = document.createDocumentFragment();

  			for (i = 0; i < queue.length; i++) {
  				this._addTile(queue[i], fragment);
  			}

  			this._level.el.appendChild(fragment);
  		}
  	},

  	_isValidTile: function (coords) {
  		var crs = this._map.options.crs;

  		if (!crs.infinite) {
  			// don't load tile if it's out of bounds and not wrapped
  			var bounds = this._globalTileRange;
  			if ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||
  			    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }
  		}

  		if (!this.options.bounds) { return true; }

  		// don't load tile if it doesn't intersect the bounds in options
  		var tileBounds = this._tileCoordsToBounds(coords);
  		return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
  	},

  	_keyToBounds: function (key) {
  		return this._tileCoordsToBounds(this._keyToTileCoords(key));
  	},

  	_tileCoordsToNwSe: function (coords) {
  		var map = this._map,
  		    tileSize = this.getTileSize(),
  		    nwPoint = coords.scaleBy(tileSize),
  		    sePoint = nwPoint.add(tileSize),
  		    nw = map.unproject(nwPoint, coords.z),
  		    se = map.unproject(sePoint, coords.z);
  		return [nw, se];
  	},

  	// converts tile coordinates to its geographical bounds
  	_tileCoordsToBounds: function (coords) {
  		var bp = this._tileCoordsToNwSe(coords),
  		    bounds = new LatLngBounds(bp[0], bp[1]);

  		if (!this.options.noWrap) {
  			bounds = this._map.wrapLatLngBounds(bounds);
  		}
  		return bounds;
  	},
  	// converts tile coordinates to key for the tile cache
  	_tileCoordsToKey: function (coords) {
  		return coords.x + ':' + coords.y + ':' + coords.z;
  	},

  	// converts tile cache key to coordinates
  	_keyToTileCoords: function (key) {
  		var k = key.split(':'),
  		    coords = new Point(+k[0], +k[1]);
  		coords.z = +k[2];
  		return coords;
  	},

  	_removeTile: function (key) {
  		var tile = this._tiles[key];
  		if (!tile) { return; }

  		remove(tile.el);

  		delete this._tiles[key];

  		// @event tileunload: TileEvent
  		// Fired when a tile is removed (e.g. when a tile goes off the screen).
  		this.fire('tileunload', {
  			tile: tile.el,
  			coords: this._keyToTileCoords(key)
  		});
  	},

  	_initTile: function (tile) {
  		addClass(tile, 'leaflet-tile');

  		var tileSize = this.getTileSize();
  		tile.style.width = tileSize.x + 'px';
  		tile.style.height = tileSize.y + 'px';

  		tile.onselectstart = falseFn;
  		tile.onmousemove = falseFn;

  		// update opacity on tiles in IE7-8 because of filter inheritance problems
  		if (Browser.ielt9 && this.options.opacity < 1) {
  			setOpacity(tile, this.options.opacity);
  		}
  	},

  	_addTile: function (coords, container) {
  		var tilePos = this._getTilePos(coords),
  		    key = this._tileCoordsToKey(coords);

  		var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));

  		this._initTile(tile);

  		// if createTile is defined with a second argument ("done" callback),
  		// we know that tile is async and will be ready later; otherwise
  		if (this.createTile.length < 2) {
  			// mark tile as ready, but delay one frame for opacity animation to happen
  			requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
  		}

  		setPosition(tile, tilePos);

  		// save tile in cache
  		this._tiles[key] = {
  			el: tile,
  			coords: coords,
  			current: true
  		};

  		container.appendChild(tile);
  		// @event tileloadstart: TileEvent
  		// Fired when a tile is requested and starts loading.
  		this.fire('tileloadstart', {
  			tile: tile,
  			coords: coords
  		});
  	},

  	_tileReady: function (coords, err, tile) {
  		if (err) {
  			// @event tileerror: TileErrorEvent
  			// Fired when there is an error loading a tile.
  			this.fire('tileerror', {
  				error: err,
  				tile: tile,
  				coords: coords
  			});
  		}

  		var key = this._tileCoordsToKey(coords);

  		tile = this._tiles[key];
  		if (!tile) { return; }

  		tile.loaded = +new Date();
  		if (this._map._fadeAnimated) {
  			setOpacity(tile.el, 0);
  			cancelAnimFrame(this._fadeFrame);
  			this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
  		} else {
  			tile.active = true;
  			this._pruneTiles();
  		}

  		if (!err) {
  			addClass(tile.el, 'leaflet-tile-loaded');

  			// @event tileload: TileEvent
  			// Fired when a tile loads.
  			this.fire('tileload', {
  				tile: tile.el,
  				coords: coords
  			});
  		}

  		if (this._noTilesToLoad()) {
  			this._loading = false;
  			// @event load: Event
  			// Fired when the grid layer loaded all visible tiles.
  			this.fire('load');

  			if (Browser.ielt9 || !this._map._fadeAnimated) {
  				requestAnimFrame(this._pruneTiles, this);
  			} else {
  				// Wait a bit more than 0.2 secs (the duration of the tile fade-in)
  				// to trigger a pruning.
  				setTimeout(bind(this._pruneTiles, this), 250);
  			}
  		}
  	},

  	_getTilePos: function (coords) {
  		return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
  	},

  	_wrapCoords: function (coords) {
  		var newCoords = new Point(
  			this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
  			this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);
  		newCoords.z = coords.z;
  		return newCoords;
  	},

  	_pxBoundsToTileRange: function (bounds) {
  		var tileSize = this.getTileSize();
  		return new Bounds(
  			bounds.min.unscaleBy(tileSize).floor(),
  			bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
  	},

  	_noTilesToLoad: function () {
  		for (var key in this._tiles) {
  			if (!this._tiles[key].loaded) { return false; }
  		}
  		return true;
  	}
  });

  // @factory L.gridLayer(options?: GridLayer options)
  // Creates a new instance of GridLayer with the supplied options.
  function gridLayer(options) {
  	return new GridLayer(options);
  }

  /*
   * @class TileLayer
   * @inherits GridLayer
   * @aka L.TileLayer
   * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.
   *
   * @example
   *
   * ```js
   * L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'}).addTo(map);
   * ```
   *
   * @section URL template
   * @example
   *
   * A string of the following form:
   *
   * ```
   * 'https://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
   * ```
   *
   * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}`  zoom level, `{x}` and `{y}`  tile coordinates. `{r}` can be used to add "&commat;2x" to the URL to load retina tiles.
   *
   * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
   *
   * ```
   * L.tileLayer('https://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
   * ```
   */


  var TileLayer = GridLayer.extend({

  	// @section
  	// @aka TileLayer options
  	options: {
  		// @option minZoom: Number = 0
  		// The minimum zoom level down to which this layer will be displayed (inclusive).
  		minZoom: 0,

  		// @option maxZoom: Number = 18
  		// The maximum zoom level up to which this layer will be displayed (inclusive).
  		maxZoom: 18,

  		// @option subdomains: String|String[] = 'abc'
  		// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
  		subdomains: 'abc',

  		// @option errorTileUrl: String = ''
  		// URL to the tile image to show in place of the tile that failed to load.
  		errorTileUrl: '',

  		// @option zoomOffset: Number = 0
  		// The zoom number used in tile URLs will be offset with this value.
  		zoomOffset: 0,

  		// @option tms: Boolean = false
  		// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
  		tms: false,

  		// @option zoomReverse: Boolean = false
  		// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
  		zoomReverse: false,

  		// @option detectRetina: Boolean = false
  		// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
  		detectRetina: false,

  		// @option crossOrigin: Boolean|String = false
  		// Whether the crossOrigin attribute will be added to the tiles.
  		// If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
  		// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
  		crossOrigin: false,

  		// @option referrerPolicy: Boolean|String = false
  		// Whether the referrerPolicy attribute will be added to the tiles.
  		// If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
  		// This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
  		// (e.g. to validate an API token).
  		// Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
  		referrerPolicy: false
  	},

  	initialize: function (url, options) {

  		this._url = url;

  		options = setOptions(this, options);

  		// detecting retina displays, adjusting tileSize and zoom levels
  		if (options.detectRetina && Browser.retina && options.maxZoom > 0) {

  			options.tileSize = Math.floor(options.tileSize / 2);

  			if (!options.zoomReverse) {
  				options.zoomOffset++;
  				options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);
  			} else {
  				options.zoomOffset--;
  				options.minZoom = Math.min(options.maxZoom, options.minZoom + 1);
  			}

  			options.minZoom = Math.max(0, options.minZoom);
  		} else if (!options.zoomReverse) {
  			// make sure maxZoom is gte minZoom
  			options.maxZoom = Math.max(options.minZoom, options.maxZoom);
  		} else {
  			// make sure minZoom is lte maxZoom
  			options.minZoom = Math.min(options.maxZoom, options.minZoom);
  		}

  		if (typeof options.subdomains === 'string') {
  			options.subdomains = options.subdomains.split('');
  		}

  		this.on('tileunload', this._onTileRemove);
  	},

  	// @method setUrl(url: String, noRedraw?: Boolean): this
  	// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
  	// If the URL does not change, the layer will not be redrawn unless
  	// the noRedraw parameter is set to false.
  	setUrl: function (url, noRedraw) {
  		if (this._url === url && noRedraw === undefined) {
  			noRedraw = true;
  		}

  		this._url = url;

  		if (!noRedraw) {
  			this.redraw();
  		}
  		return this;
  	},

  	// @method createTile(coords: Object, done?: Function): HTMLElement
  	// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
  	// to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
  	// callback is called when the tile has been loaded.
  	createTile: function (coords, done) {
  		var tile = document.createElement('img');

  		on(tile, 'load', bind(this._tileOnLoad, this, done, tile));
  		on(tile, 'error', bind(this._tileOnError, this, done, tile));

  		if (this.options.crossOrigin || this.options.crossOrigin === '') {
  			tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
  		}

  		// for this new option we follow the documented behavior
  		// more closely by only setting the property when string
  		if (typeof this.options.referrerPolicy === 'string') {
  			tile.referrerPolicy = this.options.referrerPolicy;
  		}

  		// The alt attribute is set to the empty string,
  		// allowing screen readers to ignore the decorative image tiles.
  		// https://www.w3.org/WAI/tutorials/images/decorative/
  		// https://www.w3.org/TR/html-aria/#el-img-empty-alt
  		tile.alt = '';

  		tile.src = this.getTileUrl(coords);

  		return tile;
  	},

  	// @section Extension methods
  	// @uninheritable
  	// Layers extending `TileLayer` might reimplement the following method.
  	// @method getTileUrl(coords: Object): String
  	// Called only internally, returns the URL for a tile given its coordinates.
  	// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
  	getTileUrl: function (coords) {
  		var data = {
  			r: Browser.retina ? '@2x' : '',
  			s: this._getSubdomain(coords),
  			x: coords.x,
  			y: coords.y,
  			z: this._getZoomForUrl()
  		};
  		if (this._map && !this._map.options.crs.infinite) {
  			var invertedY = this._globalTileRange.max.y - coords.y;
  			if (this.options.tms) {
  				data['y'] = invertedY;
  			}
  			data['-y'] = invertedY;
  		}

  		return template(this._url, extend(data, this.options));
  	},

  	_tileOnLoad: function (done, tile) {
  		// For https://github.com/Leaflet/Leaflet/issues/3332
  		if (Browser.ielt9) {
  			setTimeout(bind(done, this, null, tile), 0);
  		} else {
  			done(null, tile);
  		}
  	},

  	_tileOnError: function (done, tile, e) {
  		var errorUrl = this.options.errorTileUrl;
  		if (errorUrl && tile.getAttribute('src') !== errorUrl) {
  			tile.src = errorUrl;
  		}
  		done(e, tile);
  	},

  	_onTileRemove: function (e) {
  		e.tile.onload = null;
  	},

  	_getZoomForUrl: function () {
  		var zoom = this._tileZoom,
  		maxZoom = this.options.maxZoom,
  		zoomReverse = this.options.zoomReverse,
  		zoomOffset = this.options.zoomOffset;

  		if (zoomReverse) {
  			zoom = maxZoom - zoom;
  		}

  		return zoom + zoomOffset;
  	},

  	_getSubdomain: function (tilePoint) {
  		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
  		return this.options.subdomains[index];
  	},

  	// stops loading all tiles in the background layer
  	_abortLoading: function () {
  		var i, tile;
  		for (i in this._tiles) {
  			if (this._tiles[i].coords.z !== this._tileZoom) {
  				tile = this._tiles[i].el;

  				tile.onload = falseFn;
  				tile.onerror = falseFn;

  				if (!tile.complete) {
  					tile.src = emptyImageUrl;
  					var coords = this._tiles[i].coords;
  					remove(tile);
  					delete this._tiles[i];
  					// @event tileabort: TileEvent
  					// Fired when a tile was loading but is now not wanted.
  					this.fire('tileabort', {
  						tile: tile,
  						coords: coords
  					});
  				}
  			}
  		}
  	},

  	_removeTile: function (key) {
  		var tile = this._tiles[key];
  		if (!tile) { return; }

  		// Cancels any pending http requests associated with the tile
  		tile.el.setAttribute('src', emptyImageUrl);

  		return GridLayer.prototype._removeTile.call(this, key);
  	},

  	_tileReady: function (coords, err, tile) {
  		if (!this._map || (tile && tile.getAttribute('src') === emptyImageUrl)) {
  			return;
  		}

  		return GridLayer.prototype._tileReady.call(this, coords, err, tile);
  	}
  });


  // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
  // Instantiates a tile layer object given a `URL template` and optionally an options object.

  function tileLayer(url, options) {
  	return new TileLayer(url, options);
  }

  /*
   * @class TileLayer.WMS
   * @inherits TileLayer
   * @aka L.TileLayer.WMS
   * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
   *
   * @example
   *
   * ```js
   * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
   * 	layers: 'nexrad-n0r-900913',
   * 	format: 'image/png',
   * 	transparent: true,
   * 	attribution: "Weather data  2012 IEM Nexrad"
   * });
   * ```
   */

  var TileLayerWMS = TileLayer.extend({

  	// @section
  	// @aka TileLayer.WMS options
  	// If any custom options not documented here are used, they will be sent to the
  	// WMS server as extra parameters in each request URL. This can be useful for
  	// [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
  	defaultWmsParams: {
  		service: 'WMS',
  		request: 'GetMap',

  		// @option layers: String = ''
  		// **(required)** Comma-separated list of WMS layers to show.
  		layers: '',

  		// @option styles: String = ''
  		// Comma-separated list of WMS styles.
  		styles: '',

  		// @option format: String = 'image/jpeg'
  		// WMS image format (use `'image/png'` for layers with transparency).
  		format: 'image/jpeg',

  		// @option transparent: Boolean = false
  		// If `true`, the WMS service will return images with transparency.
  		transparent: false,

  		// @option version: String = '1.1.1'
  		// Version of the WMS service to use
  		version: '1.1.1'
  	},

  	options: {
  		// @option crs: CRS = null
  		// Coordinate Reference System to use for the WMS requests, defaults to
  		// map CRS. Don't change this if you're not sure what it means.
  		crs: null,

  		// @option uppercase: Boolean = false
  		// If `true`, WMS request parameter keys will be uppercase.
  		uppercase: false
  	},

  	initialize: function (url, options) {

  		this._url = url;

  		var wmsParams = extend({}, this.defaultWmsParams);

  		// all keys that are not TileLayer options go to WMS params
  		for (var i in options) {
  			if (!(i in this.options)) {
  				wmsParams[i] = options[i];
  			}
  		}

  		options = setOptions(this, options);

  		var realRetina = options.detectRetina && Browser.retina ? 2 : 1;
  		var tileSize = this.getTileSize();
  		wmsParams.width = tileSize.x * realRetina;
  		wmsParams.height = tileSize.y * realRetina;

  		this.wmsParams = wmsParams;
  	},

  	onAdd: function (map) {

  		this._crs = this.options.crs || map.options.crs;
  		this._wmsVersion = parseFloat(this.wmsParams.version);

  		var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
  		this.wmsParams[projectionKey] = this._crs.code;

  		TileLayer.prototype.onAdd.call(this, map);
  	},

  	getTileUrl: function (coords) {

  		var tileBounds = this._tileCoordsToNwSe(coords),
  		    crs = this._crs,
  		    bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),
  		    min = bounds.min,
  		    max = bounds.max,
  		    bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ?
  		    [min.y, min.x, max.y, max.x] :
  		    [min.x, min.y, max.x, max.y]).join(','),
  		    url = TileLayer.prototype.getTileUrl.call(this, coords);
  		return url +
  			getParamString(this.wmsParams, url, this.options.uppercase) +
  			(this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
  	},

  	// @method setParams(params: Object, noRedraw?: Boolean): this
  	// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
  	setParams: function (params, noRedraw) {

  		extend(this.wmsParams, params);

  		if (!noRedraw) {
  			this.redraw();
  		}

  		return this;
  	}
  });


  // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
  // Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
  function tileLayerWMS(url, options) {
  	return new TileLayerWMS(url, options);
  }

  TileLayer.WMS = TileLayerWMS;
  tileLayer.wms = tileLayerWMS;

  /*
   * @class Renderer
   * @inherits Layer
   * @aka L.Renderer
   *
   * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
   * DOM container of the renderer, its bounds, and its zoom animation.
   *
   * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
   * itself can be added or removed to the map. All paths use a renderer, which can
   * be implicit (the map will decide the type of renderer and use it automatically)
   * or explicit (using the [`renderer`](#path-renderer) option of the path).
   *
   * Do not use this class directly, use `SVG` and `Canvas` instead.
   *
   * @event update: Event
   * Fired when the renderer updates its bounds, center and zoom, for example when
   * its map has moved
   */

  var Renderer = Layer.extend({

  	// @section
  	// @aka Renderer options
  	options: {
  		// @option padding: Number = 0.1
  		// How much to extend the clip area around the map view (relative to its size)
  		// e.g. 0.1 would be 10% of map view in each direction
  		padding: 0.1
  	},

  	initialize: function (options) {
  		setOptions(this, options);
  		stamp(this);
  		this._layers = this._layers || {};
  	},

  	onAdd: function () {
  		if (!this._container) {
  			this._initContainer(); // defined by renderer implementations

  			// always keep transform-origin as 0 0
  			addClass(this._container, 'leaflet-zoom-animated');
  		}

  		this.getPane().appendChild(this._container);
  		this._update();
  		this.on('update', this._updatePaths, this);
  	},

  	onRemove: function () {
  		this.off('update', this._updatePaths, this);
  		this._destroyContainer();
  	},

  	getEvents: function () {
  		var events = {
  			viewreset: this._reset,
  			zoom: this._onZoom,
  			moveend: this._update,
  			zoomend: this._onZoomEnd
  		};
  		if (this._zoomAnimated) {
  			events.zoomanim = this._onAnimZoom;
  		}
  		return events;
  	},

  	_onAnimZoom: function (ev) {
  		this._updateTransform(ev.center, ev.zoom);
  	},

  	_onZoom: function () {
  		this._updateTransform(this._map.getCenter(), this._map.getZoom());
  	},

  	_updateTransform: function (center, zoom) {
  		var scale = this._map.getZoomScale(zoom, this._zoom),
  		    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
  		    currentCenterPoint = this._map.project(this._center, zoom),

  		    topLeftOffset = viewHalf.multiplyBy(-scale).add(currentCenterPoint)
  				  .subtract(this._map._getNewPixelOrigin(center, zoom));

  		if (Browser.any3d) {
  			setTransform(this._container, topLeftOffset, scale);
  		} else {
  			setPosition(this._container, topLeftOffset);
  		}
  	},

  	_reset: function () {
  		this._update();
  		this._updateTransform(this._center, this._zoom);

  		for (var id in this._layers) {
  			this._layers[id]._reset();
  		}
  	},

  	_onZoomEnd: function () {
  		for (var id in this._layers) {
  			this._layers[id]._project();
  		}
  	},

  	_updatePaths: function () {
  		for (var id in this._layers) {
  			this._layers[id]._update();
  		}
  	},

  	_update: function () {
  		// Update pixel bounds of renderer container (for positioning/sizing/clipping later)
  		// Subclasses are responsible of firing the 'update' event.
  		var p = this.options.padding,
  		    size = this._map.getSize(),
  		    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

  		this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());

  		this._center = this._map.getCenter();
  		this._zoom = this._map.getZoom();
  	}
  });

  /*
   * @class Canvas
   * @inherits Renderer
   * @aka L.Canvas
   *
   * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
   * Inherits `Renderer`.
   *
   * Due to [technical limitations](https://caniuse.com/canvas), Canvas is not
   * available in all web browsers, notably IE8, and overlapping geometries might
   * not display properly in some edge cases.
   *
   * @example
   *
   * Use Canvas by default for all paths in the map:
   *
   * ```js
   * var map = L.map('map', {
   * 	renderer: L.canvas()
   * });
   * ```
   *
   * Use a Canvas renderer with extra padding for specific vector geometries:
   *
   * ```js
   * var map = L.map('map');
   * var myRenderer = L.canvas({ padding: 0.5 });
   * var line = L.polyline( coordinates, { renderer: myRenderer } );
   * var circle = L.circle( center, { renderer: myRenderer } );
   * ```
   */

  var Canvas = Renderer.extend({

  	// @section
  	// @aka Canvas options
  	options: {
  		// @option tolerance: Number = 0
  		// How much to extend the click tolerance around a path/object on the map.
  		tolerance: 0
  	},

  	getEvents: function () {
  		var events = Renderer.prototype.getEvents.call(this);
  		events.viewprereset = this._onViewPreReset;
  		return events;
  	},

  	_onViewPreReset: function () {
  		// Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once
  		this._postponeUpdatePaths = true;
  	},

  	onAdd: function () {
  		Renderer.prototype.onAdd.call(this);

  		// Redraw vectors since canvas is cleared upon removal,
  		// in case of removing the renderer itself from the map.
  		this._draw();
  	},

  	_initContainer: function () {
  		var container = this._container = document.createElement('canvas');

  		on(container, 'mousemove', this._onMouseMove, this);
  		on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);
  		on(container, 'mouseout', this._handleMouseOut, this);
  		container['_leaflet_disable_events'] = true;

  		this._ctx = container.getContext('2d');
  	},

  	_destroyContainer: function () {
  		cancelAnimFrame(this._redrawRequest);
  		delete this._ctx;
  		remove(this._container);
  		off(this._container);
  		delete this._container;
  	},

  	_updatePaths: function () {
  		if (this._postponeUpdatePaths) { return; }

  		var layer;
  		this._redrawBounds = null;
  		for (var id in this._layers) {
  			layer = this._layers[id];
  			layer._update();
  		}
  		this._redraw();
  	},

  	_update: function () {
  		if (this._map._animatingZoom && this._bounds) { return; }

  		Renderer.prototype._update.call(this);

  		var b = this._bounds,
  		    container = this._container,
  		    size = b.getSize(),
  		    m = Browser.retina ? 2 : 1;

  		setPosition(container, b.min);

  		// set canvas size (also clearing it); use double size on retina
  		container.width = m * size.x;
  		container.height = m * size.y;
  		container.style.width = size.x + 'px';
  		container.style.height = size.y + 'px';

  		if (Browser.retina) {
  			this._ctx.scale(2, 2);
  		}

  		// translate so we use the same path coordinates after canvas element moves
  		this._ctx.translate(-b.min.x, -b.min.y);

  		// Tell paths to redraw themselves
  		this.fire('update');
  	},

  	_reset: function () {
  		Renderer.prototype._reset.call(this);

  		if (this._postponeUpdatePaths) {
  			this._postponeUpdatePaths = false;
  			this._updatePaths();
  		}
  	},

  	_initPath: function (layer) {
  		this._updateDashArray(layer);
  		this._layers[stamp(layer)] = layer;

  		var order = layer._order = {
  			layer: layer,
  			prev: this._drawLast,
  			next: null
  		};
  		if (this._drawLast) { this._drawLast.next = order; }
  		this._drawLast = order;
  		this._drawFirst = this._drawFirst || this._drawLast;
  	},

  	_addPath: function (layer) {
  		this._requestRedraw(layer);
  	},

  	_removePath: function (layer) {
  		var order = layer._order;
  		var next = order.next;
  		var prev = order.prev;

  		if (next) {
  			next.prev = prev;
  		} else {
  			this._drawLast = prev;
  		}
  		if (prev) {
  			prev.next = next;
  		} else {
  			this._drawFirst = next;
  		}

  		delete layer._order;

  		delete this._layers[stamp(layer)];

  		this._requestRedraw(layer);
  	},

  	_updatePath: function (layer) {
  		// Redraw the union of the layer's old pixel
  		// bounds and the new pixel bounds.
  		this._extendRedrawBounds(layer);
  		layer._project();
  		layer._update();
  		// The redraw will extend the redraw bounds
  		// with the new pixel bounds.
  		this._requestRedraw(layer);
  	},

  	_updateStyle: function (layer) {
  		this._updateDashArray(layer);
  		this._requestRedraw(layer);
  	},

  	_updateDashArray: function (layer) {
  		if (typeof layer.options.dashArray === 'string') {
  			var parts = layer.options.dashArray.split(/[, ]+/),
  			    dashArray = [],
  			    dashValue,
  			    i;
  			for (i = 0; i < parts.length; i++) {
  				dashValue = Number(parts[i]);
  				// Ignore dash array containing invalid lengths
  				if (isNaN(dashValue)) { return; }
  				dashArray.push(dashValue);
  			}
  			layer.options._dashArray = dashArray;
  		} else {
  			layer.options._dashArray = layer.options.dashArray;
  		}
  	},

  	_requestRedraw: function (layer) {
  		if (!this._map) { return; }

  		this._extendRedrawBounds(layer);
  		this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
  	},

  	_extendRedrawBounds: function (layer) {
  		if (layer._pxBounds) {
  			var padding = (layer.options.weight || 0) + 1;
  			this._redrawBounds = this._redrawBounds || new Bounds();
  			this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
  			this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
  		}
  	},

  	_redraw: function () {
  		this._redrawRequest = null;

  		if (this._redrawBounds) {
  			this._redrawBounds.min._floor();
  			this._redrawBounds.max._ceil();
  		}

  		this._clear(); // clear layers in redraw bounds
  		this._draw(); // draw layers

  		this._redrawBounds = null;
  	},

  	_clear: function () {
  		var bounds = this._redrawBounds;
  		if (bounds) {
  			var size = bounds.getSize();
  			this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
  		} else {
  			this._ctx.save();
  			this._ctx.setTransform(1, 0, 0, 1, 0, 0);
  			this._ctx.clearRect(0, 0, this._container.width, this._container.height);
  			this._ctx.restore();
  		}
  	},

  	_draw: function () {
  		var layer, bounds = this._redrawBounds;
  		this._ctx.save();
  		if (bounds) {
  			var size = bounds.getSize();
  			this._ctx.beginPath();
  			this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
  			this._ctx.clip();
  		}

  		this._drawing = true;

  		for (var order = this._drawFirst; order; order = order.next) {
  			layer = order.layer;
  			if (!bounds || (layer._pxBounds && layer._pxBounds.intersects(bounds))) {
  				layer._updatePath();
  			}
  		}

  		this._drawing = false;

  		this._ctx.restore();  // Restore state before clipping.
  	},

  	_updatePoly: function (layer, closed) {
  		if (!this._drawing) { return; }

  		var i, j, len2, p,
  		    parts = layer._parts,
  		    len = parts.length,
  		    ctx = this._ctx;

  		if (!len) { return; }

  		ctx.beginPath();

  		for (i = 0; i < len; i++) {
  			for (j = 0, len2 = parts[i].length; j < len2; j++) {
  				p = parts[i][j];
  				ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
  			}
  			if (closed) {
  				ctx.closePath();
  			}
  		}

  		this._fillStroke(ctx, layer);

  		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
  	},

  	_updateCircle: function (layer) {

  		if (!this._drawing || layer._empty()) { return; }

  		var p = layer._point,
  		    ctx = this._ctx,
  		    r = Math.max(Math.round(layer._radius), 1),
  		    s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;

  		if (s !== 1) {
  			ctx.save();
  			ctx.scale(1, s);
  		}

  		ctx.beginPath();
  		ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

  		if (s !== 1) {
  			ctx.restore();
  		}

  		this._fillStroke(ctx, layer);
  	},

  	_fillStroke: function (ctx, layer) {
  		var options = layer.options;

  		if (options.fill) {
  			ctx.globalAlpha = options.fillOpacity;
  			ctx.fillStyle = options.fillColor || options.color;
  			ctx.fill(options.fillRule || 'evenodd');
  		}

  		if (options.stroke && options.weight !== 0) {
  			if (ctx.setLineDash) {
  				ctx.setLineDash(layer.options && layer.options._dashArray || []);
  			}
  			ctx.globalAlpha = options.opacity;
  			ctx.lineWidth = options.weight;
  			ctx.strokeStyle = options.color;
  			ctx.lineCap = options.lineCap;
  			ctx.lineJoin = options.lineJoin;
  			ctx.stroke();
  		}
  	},

  	// Canvas obviously doesn't have mouse events for individual drawn objects,
  	// so we emulate that by calculating what's under the mouse on mousemove/click manually

  	_onClick: function (e) {
  		var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;

  		for (var order = this._drawFirst; order; order = order.next) {
  			layer = order.layer;
  			if (layer.options.interactive && layer._containsPoint(point)) {
  				if (!(e.type === 'click' || e.type === 'preclick') || !this._map._draggableMoved(layer)) {
  					clickedLayer = layer;
  				}
  			}
  		}
  		this._fireEvent(clickedLayer ? [clickedLayer] : false, e);
  	},

  	_onMouseMove: function (e) {
  		if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) { return; }

  		var point = this._map.mouseEventToLayerPoint(e);
  		this._handleMouseHover(e, point);
  	},


  	_handleMouseOut: function (e) {
  		var layer = this._hoveredLayer;
  		if (layer) {
  			// if we're leaving the layer, fire mouseout
  			removeClass(this._container, 'leaflet-interactive');
  			this._fireEvent([layer], e, 'mouseout');
  			this._hoveredLayer = null;
  			this._mouseHoverThrottled = false;
  		}
  	},

  	_handleMouseHover: function (e, point) {
  		if (this._mouseHoverThrottled) {
  			return;
  		}

  		var layer, candidateHoveredLayer;

  		for (var order = this._drawFirst; order; order = order.next) {
  			layer = order.layer;
  			if (layer.options.interactive && layer._containsPoint(point)) {
  				candidateHoveredLayer = layer;
  			}
  		}

  		if (candidateHoveredLayer !== this._hoveredLayer) {
  			this._handleMouseOut(e);

  			if (candidateHoveredLayer) {
  				addClass(this._container, 'leaflet-interactive'); // change cursor
  				this._fireEvent([candidateHoveredLayer], e, 'mouseover');
  				this._hoveredLayer = candidateHoveredLayer;
  			}
  		}

  		this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e);

  		this._mouseHoverThrottled = true;
  		setTimeout(bind(function () {
  			this._mouseHoverThrottled = false;
  		}, this), 32);
  	},

  	_fireEvent: function (layers, e, type) {
  		this._map._fireDOMEvent(e, type || e.type, layers);
  	},

  	_bringToFront: function (layer) {
  		var order = layer._order;

  		if (!order) { return; }

  		var next = order.next;
  		var prev = order.prev;

  		if (next) {
  			next.prev = prev;
  		} else {
  			// Already last
  			return;
  		}
  		if (prev) {
  			prev.next = next;
  		} else if (next) {
  			// Update first entry unless this is the
  			// single entry
  			this._drawFirst = next;
  		}

  		order.prev = this._drawLast;
  		this._drawLast.next = order;

  		order.next = null;
  		this._drawLast = order;

  		this._requestRedraw(layer);
  	},

  	_bringToBack: function (layer) {
  		var order = layer._order;

  		if (!order) { return; }

  		var next = order.next;
  		var prev = order.prev;

  		if (prev) {
  			prev.next = next;
  		} else {
  			// Already first
  			return;
  		}
  		if (next) {
  			next.prev = prev;
  		} else if (prev) {
  			// Update last entry unless this is the
  			// single entry
  			this._drawLast = prev;
  		}

  		order.prev = null;

  		order.next = this._drawFirst;
  		this._drawFirst.prev = order;
  		this._drawFirst = order;

  		this._requestRedraw(layer);
  	}
  });

  // @factory L.canvas(options?: Renderer options)
  // Creates a Canvas renderer with the given options.
  function canvas(options) {
  	return Browser.canvas ? new Canvas(options) : null;
  }

  /*
   * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
   */


  var vmlCreate = (function () {
  	try {
  		document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
  		return function (name) {
  			return document.createElement('<lvml:' + name + ' class="lvml">');
  		};
  	} catch (e) {
  		// Do not return fn from catch block so `e` can be garbage collected
  		// See https://github.com/Leaflet/Leaflet/pull/7279
  	}
  	return function (name) {
  		return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
  	};
  })();


  /*
   * @class SVG
   *
   *
   * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
   * with old versions of Internet Explorer.
   */

  // mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences
  var vmlMixin = {

  	_initContainer: function () {
  		this._container = create$1('div', 'leaflet-vml-container');
  	},

  	_update: function () {
  		if (this._map._animatingZoom) { return; }
  		Renderer.prototype._update.call(this);
  		this.fire('update');
  	},

  	_initPath: function (layer) {
  		var container = layer._container = vmlCreate('shape');

  		addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

  		container.coordsize = '1 1';

  		layer._path = vmlCreate('path');
  		container.appendChild(layer._path);

  		this._updateStyle(layer);
  		this._layers[stamp(layer)] = layer;
  	},

  	_addPath: function (layer) {
  		var container = layer._container;
  		this._container.appendChild(container);

  		if (layer.options.interactive) {
  			layer.addInteractiveTarget(container);
  		}
  	},

  	_removePath: function (layer) {
  		var container = layer._container;
  		remove(container);
  		layer.removeInteractiveTarget(container);
  		delete this._layers[stamp(layer)];
  	},

  	_updateStyle: function (layer) {
  		var stroke = layer._stroke,
  		    fill = layer._fill,
  		    options = layer.options,
  		    container = layer._container;

  		container.stroked = !!options.stroke;
  		container.filled = !!options.fill;

  		if (options.stroke) {
  			if (!stroke) {
  				stroke = layer._stroke = vmlCreate('stroke');
  			}
  			container.appendChild(stroke);
  			stroke.weight = options.weight + 'px';
  			stroke.color = options.color;
  			stroke.opacity = options.opacity;

  			if (options.dashArray) {
  				stroke.dashStyle = isArray(options.dashArray) ?
  				    options.dashArray.join(' ') :
  				    options.dashArray.replace(/( *, *)/g, ' ');
  			} else {
  				stroke.dashStyle = '';
  			}
  			stroke.endcap = options.lineCap.replace('butt', 'flat');
  			stroke.joinstyle = options.lineJoin;

  		} else if (stroke) {
  			container.removeChild(stroke);
  			layer._stroke = null;
  		}

  		if (options.fill) {
  			if (!fill) {
  				fill = layer._fill = vmlCreate('fill');
  			}
  			container.appendChild(fill);
  			fill.color = options.fillColor || options.color;
  			fill.opacity = options.fillOpacity;

  		} else if (fill) {
  			container.removeChild(fill);
  			layer._fill = null;
  		}
  	},

  	_updateCircle: function (layer) {
  		var p = layer._point.round(),
  		    r = Math.round(layer._radius),
  		    r2 = Math.round(layer._radiusY || r);

  		this._setPath(layer, layer._empty() ? 'M0 0' :
  			'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));
  	},

  	_setPath: function (layer, path) {
  		layer._path.v = path;
  	},

  	_bringToFront: function (layer) {
  		toFront(layer._container);
  	},

  	_bringToBack: function (layer) {
  		toBack(layer._container);
  	}
  };

  var create = Browser.vml ? vmlCreate : svgCreate;

  /*
   * @class SVG
   * @inherits Renderer
   * @aka L.SVG
   *
   * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
   * Inherits `Renderer`.
   *
   * Due to [technical limitations](https://caniuse.com/svg), SVG is not
   * available in all web browsers, notably Android 2.x and 3.x.
   *
   * Although SVG is not available on IE7 and IE8, these browsers support
   * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
   * (a now deprecated technology), and the SVG renderer will fall back to VML in
   * this case.
   *
   * @example
   *
   * Use SVG by default for all paths in the map:
   *
   * ```js
   * var map = L.map('map', {
   * 	renderer: L.svg()
   * });
   * ```
   *
   * Use a SVG renderer with extra padding for specific vector geometries:
   *
   * ```js
   * var map = L.map('map');
   * var myRenderer = L.svg({ padding: 0.5 });
   * var line = L.polyline( coordinates, { renderer: myRenderer } );
   * var circle = L.circle( center, { renderer: myRenderer } );
   * ```
   */

  var SVG = Renderer.extend({

  	_initContainer: function () {
  		this._container = create('svg');

  		// makes it possible to click through svg root; we'll reset it back in individual paths
  		this._container.setAttribute('pointer-events', 'none');

  		this._rootGroup = create('g');
  		this._container.appendChild(this._rootGroup);
  	},

  	_destroyContainer: function () {
  		remove(this._container);
  		off(this._container);
  		delete this._container;
  		delete this._rootGroup;
  		delete this._svgSize;
  	},

  	_update: function () {
  		if (this._map._animatingZoom && this._bounds) { return; }

  		Renderer.prototype._update.call(this);

  		var b = this._bounds,
  		    size = b.getSize(),
  		    container = this._container;

  		// set size of svg-container if changed
  		if (!this._svgSize || !this._svgSize.equals(size)) {
  			this._svgSize = size;
  			container.setAttribute('width', size.x);
  			container.setAttribute('height', size.y);
  		}

  		// movement: update container viewBox so that we don't have to change coordinates of individual layers
  		setPosition(container, b.min);
  		container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));

  		this.fire('update');
  	},

  	// methods below are called by vector layers implementations

  	_initPath: function (layer) {
  		var path = layer._path = create('path');

  		// @namespace Path
  		// @option className: String = null
  		// Custom class name set on an element. Only for SVG renderer.
  		if (layer.options.className) {
  			addClass(path, layer.options.className);
  		}

  		if (layer.options.interactive) {
  			addClass(path, 'leaflet-interactive');
  		}

  		this._updateStyle(layer);
  		this._layers[stamp(layer)] = layer;
  	},

  	_addPath: function (layer) {
  		if (!this._rootGroup) { this._initContainer(); }
  		this._rootGroup.appendChild(layer._path);
  		layer.addInteractiveTarget(layer._path);
  	},

  	_removePath: function (layer) {
  		remove(layer._path);
  		layer.removeInteractiveTarget(layer._path);
  		delete this._layers[stamp(layer)];
  	},

  	_updatePath: function (layer) {
  		layer._project();
  		layer._update();
  	},

  	_updateStyle: function (layer) {
  		var path = layer._path,
  		    options = layer.options;

  		if (!path) { return; }

  		if (options.stroke) {
  			path.setAttribute('stroke', options.color);
  			path.setAttribute('stroke-opacity', options.opacity);
  			path.setAttribute('stroke-width', options.weight);
  			path.setAttribute('stroke-linecap', options.lineCap);
  			path.setAttribute('stroke-linejoin', options.lineJoin);

  			if (options.dashArray) {
  				path.setAttribute('stroke-dasharray', options.dashArray);
  			} else {
  				path.removeAttribute('stroke-dasharray');
  			}

  			if (options.dashOffset) {
  				path.setAttribute('stroke-dashoffset', options.dashOffset);
  			} else {
  				path.removeAttribute('stroke-dashoffset');
  			}
  		} else {
  			path.setAttribute('stroke', 'none');
  		}

  		if (options.fill) {
  			path.setAttribute('fill', options.fillColor || options.color);
  			path.setAttribute('fill-opacity', options.fillOpacity);
  			path.setAttribute('fill-rule', options.fillRule || 'evenodd');
  		} else {
  			path.setAttribute('fill', 'none');
  		}
  	},

  	_updatePoly: function (layer, closed) {
  		this._setPath(layer, pointsToPath(layer._parts, closed));
  	},

  	_updateCircle: function (layer) {
  		var p = layer._point,
  		    r = Math.max(Math.round(layer._radius), 1),
  		    r2 = Math.max(Math.round(layer._radiusY), 1) || r,
  		    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

  		// drawing a circle with two half-arcs
  		var d = layer._empty() ? 'M0 0' :
  			'M' + (p.x - r) + ',' + p.y +
  			arc + (r * 2) + ',0 ' +
  			arc + (-r * 2) + ',0 ';

  		this._setPath(layer, d);
  	},

  	_setPath: function (layer, path) {
  		layer._path.setAttribute('d', path);
  	},

  	// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
  	_bringToFront: function (layer) {
  		toFront(layer._path);
  	},

  	_bringToBack: function (layer) {
  		toBack(layer._path);
  	}
  });

  if (Browser.vml) {
  	SVG.include(vmlMixin);
  }

  // @namespace SVG
  // @factory L.svg(options?: Renderer options)
  // Creates a SVG renderer with the given options.
  function svg(options) {
  	return Browser.svg || Browser.vml ? new SVG(options) : null;
  }

  Map.include({
  	// @namespace Map; @method getRenderer(layer: Path): Renderer
  	// Returns the instance of `Renderer` that should be used to render the given
  	// `Path`. It will ensure that the `renderer` options of the map and paths
  	// are respected, and that the renderers do exist on the map.
  	getRenderer: function (layer) {
  		// @namespace Path; @option renderer: Renderer
  		// Use this specific instance of `Renderer` for this path. Takes
  		// precedence over the map's [default renderer](#map-renderer).
  		var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

  		if (!renderer) {
  			renderer = this._renderer = this._createRenderer();
  		}

  		if (!this.hasLayer(renderer)) {
  			this.addLayer(renderer);
  		}
  		return renderer;
  	},

  	_getPaneRenderer: function (name) {
  		if (name === 'overlayPane' || name === undefined) {
  			return false;
  		}

  		var renderer = this._paneRenderers[name];
  		if (renderer === undefined) {
  			renderer = this._createRenderer({pane: name});
  			this._paneRenderers[name] = renderer;
  		}
  		return renderer;
  	},

  	_createRenderer: function (options) {
  		// @namespace Map; @option preferCanvas: Boolean = false
  		// Whether `Path`s should be rendered on a `Canvas` renderer.
  		// By default, all `Path`s are rendered in a `SVG` renderer.
  		return (this.options.preferCanvas && canvas(options)) || svg(options);
  	}
  });

  /*
   * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
   */

  /*
   * @class Rectangle
   * @aka L.Rectangle
   * @inherits Polygon
   *
   * A class for drawing rectangle overlays on a map. Extends `Polygon`.
   *
   * @example
   *
   * ```js
   * // define rectangle geographical bounds
   * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
   *
   * // create an orange rectangle
   * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
   *
   * // zoom the map to the rectangle bounds
   * map.fitBounds(bounds);
   * ```
   *
   */


  var Rectangle = Polygon.extend({
  	initialize: function (latLngBounds, options) {
  		Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
  	},

  	// @method setBounds(latLngBounds: LatLngBounds): this
  	// Redraws the rectangle with the passed bounds.
  	setBounds: function (latLngBounds) {
  		return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
  	},

  	_boundsToLatLngs: function (latLngBounds) {
  		latLngBounds = toLatLngBounds(latLngBounds);
  		return [
  			latLngBounds.getSouthWest(),
  			latLngBounds.getNorthWest(),
  			latLngBounds.getNorthEast(),
  			latLngBounds.getSouthEast()
  		];
  	}
  });


  // @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
  function rectangle(latLngBounds, options) {
  	return new Rectangle(latLngBounds, options);
  }

  SVG.create = create;
  SVG.pointsToPath = pointsToPath;

  GeoJSON.geometryToLayer = geometryToLayer;
  GeoJSON.coordsToLatLng = coordsToLatLng;
  GeoJSON.coordsToLatLngs = coordsToLatLngs;
  GeoJSON.latLngToCoords = latLngToCoords;
  GeoJSON.latLngsToCoords = latLngsToCoords;
  GeoJSON.getFeature = getFeature;
  GeoJSON.asFeature = asFeature;

  /*
   * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
   * (zoom to a selected bounding box), enabled by default.
   */

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
  	// @option boxZoom: Boolean = true
  	// Whether the map can be zoomed to a rectangular area specified by
  	// dragging the mouse while pressing the shift key.
  	boxZoom: true
  });

  var BoxZoom = Handler.extend({
  	initialize: function (map) {
  		this._map = map;
  		this._container = map._container;
  		this._pane = map._panes.overlayPane;
  		this._resetStateTimeout = 0;
  		map.on('unload', this._destroy, this);
  	},

  	addHooks: function () {
  		on(this._container, 'mousedown', this._onMouseDown, this);
  	},

  	removeHooks: function () {
  		off(this._container, 'mousedown', this._onMouseDown, this);
  	},

  	moved: function () {
  		return this._moved;
  	},

  	_destroy: function () {
  		remove(this._pane);
  		delete this._pane;
  	},

  	_resetState: function () {
  		this._resetStateTimeout = 0;
  		this._moved = false;
  	},

  	_clearDeferredResetState: function () {
  		if (this._resetStateTimeout !== 0) {
  			clearTimeout(this._resetStateTimeout);
  			this._resetStateTimeout = 0;
  		}
  	},

  	_onMouseDown: function (e) {
  		if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

  		// Clear the deferred resetState if it hasn't executed yet, otherwise it
  		// will interrupt the interaction and orphan a box element in the container.
  		this._clearDeferredResetState();
  		this._resetState();

  		disableTextSelection();
  		disableImageDrag();

  		this._startPoint = this._map.mouseEventToContainerPoint(e);

  		on(document, {
  			contextmenu: stop,
  			mousemove: this._onMouseMove,
  			mouseup: this._onMouseUp,
  			keydown: this._onKeyDown
  		}, this);
  	},

  	_onMouseMove: function (e) {
  		if (!this._moved) {
  			this._moved = true;

  			this._box = create$1('div', 'leaflet-zoom-box', this._container);
  			addClass(this._container, 'leaflet-crosshair');

  			this._map.fire('boxzoomstart');
  		}

  		this._point = this._map.mouseEventToContainerPoint(e);

  		var bounds = new Bounds(this._point, this._startPoint),
  		    size = bounds.getSize();

  		setPosition(this._box, bounds.min);

  		this._box.style.width  = size.x + 'px';
  		this._box.style.height = size.y + 'px';
  	},

  	_finish: function () {
  		if (this._moved) {
  			remove(this._box);
  			removeClass(this._container, 'leaflet-crosshair');
  		}

  		enableTextSelection();
  		enableImageDrag();

  		off(document, {
  			contextmenu: stop,
  			mousemove: this._onMouseMove,
  			mouseup: this._onMouseUp,
  			keydown: this._onKeyDown
  		}, this);
  	},

  	_onMouseUp: function (e) {
  		if ((e.which !== 1) && (e.button !== 1)) { return; }

  		this._finish();

  		if (!this._moved) { return; }
  		// Postpone to next JS tick so internal click event handling
  		// still see it as "moved".
  		this._clearDeferredResetState();
  		this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);

  		var bounds = new LatLngBounds(
  		        this._map.containerPointToLatLng(this._startPoint),
  		        this._map.containerPointToLatLng(this._point));

  		this._map
  			.fitBounds(bounds)
  			.fire('boxzoomend', {boxZoomBounds: bounds});
  	},

  	_onKeyDown: function (e) {
  		if (e.keyCode === 27) {
  			this._finish();
  			this._clearDeferredResetState();
  			this._resetState();
  		}
  	}
  });

  // @section Handlers
  // @property boxZoom: Handler
  // Box (shift-drag with mouse) zoom handler.
  Map.addInitHook('addHandler', 'boxZoom', BoxZoom);

  /*
   * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
   */

  // @namespace Map
  // @section Interaction Options

  Map.mergeOptions({
  	// @option doubleClickZoom: Boolean|String = true
  	// Whether the map can be zoomed in by double clicking on it and
  	// zoomed out by double clicking while holding shift. If passed
  	// `'center'`, double-click zoom will zoom to the center of the
  	//  view regardless of where the mouse was.
  	doubleClickZoom: true
  });

  var DoubleClickZoom = Handler.extend({
  	addHooks: function () {
  		this._map.on('dblclick', this._onDoubleClick, this);
  	},

  	removeHooks: function () {
  		this._map.off('dblclick', this._onDoubleClick, this);
  	},

  	_onDoubleClick: function (e) {
  		var map = this._map,
  		    oldZoom = map.getZoom(),
  		    delta = map.options.zoomDelta,
  		    zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

  		if (map.options.doubleClickZoom === 'center') {
  			map.setZoom(zoom);
  		} else {
  			map.setZoomAround(e.containerPoint, zoom);
  		}
  	}
  });

  // @section Handlers
  //
  // Map properties include interaction handlers that allow you to control
  // interaction behavior in runtime, enabling or disabling certain features such
  // as dragging or touch zoom (see `Handler` methods). For example:
  //
  // ```js
  // map.doubleClickZoom.disable();
  // ```
  //
  // @property doubleClickZoom: Handler
  // Double click zoom handler.
  Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);

  /*
   * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
   */

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
  	// @option dragging: Boolean = true
  	// Whether the map is draggable with mouse/touch or not.
  	dragging: true,

  	// @section Panning Inertia Options
  	// @option inertia: Boolean = *
  	// If enabled, panning of the map will have an inertia effect where
  	// the map builds momentum while dragging and continues moving in
  	// the same direction for some time. Feels especially nice on touch
  	// devices. Enabled by default.
  	inertia: true,

  	// @option inertiaDeceleration: Number = 3000
  	// The rate with which the inertial movement slows down, in pixels/second.
  	inertiaDeceleration: 3400, // px/s^2

  	// @option inertiaMaxSpeed: Number = Infinity
  	// Max speed of the inertial movement, in pixels/second.
  	inertiaMaxSpeed: Infinity, // px/s

  	// @option easeLinearity: Number = 0.2
  	easeLinearity: 0.2,

  	// TODO refactor, move to CRS
  	// @option worldCopyJump: Boolean = false
  	// With this option enabled, the map tracks when you pan to another "copy"
  	// of the world and seamlessly jumps to the original one so that all overlays
  	// like markers and vector layers are still visible.
  	worldCopyJump: false,

  	// @option maxBoundsViscosity: Number = 0.0
  	// If `maxBounds` is set, this option will control how solid the bounds
  	// are when dragging the map around. The default value of `0.0` allows the
  	// user to drag outside the bounds at normal speed, higher values will
  	// slow down map dragging outside bounds, and `1.0` makes the bounds fully
  	// solid, preventing the user from dragging outside the bounds.
  	maxBoundsViscosity: 0.0
  });

  var Drag = Handler.extend({
  	addHooks: function () {
  		if (!this._draggable) {
  			var map = this._map;

  			this._draggable = new Draggable(map._mapPane, map._container);

  			this._draggable.on({
  				dragstart: this._onDragStart,
  				drag: this._onDrag,
  				dragend: this._onDragEnd
  			}, this);

  			this._draggable.on('predrag', this._onPreDragLimit, this);
  			if (map.options.worldCopyJump) {
  				this._draggable.on('predrag', this._onPreDragWrap, this);
  				map.on('zoomend', this._onZoomEnd, this);

  				map.whenReady(this._onZoomEnd, this);
  			}
  		}
  		addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');
  		this._draggable.enable();
  		this._positions = [];
  		this._times = [];
  	},

  	removeHooks: function () {
  		removeClass(this._map._container, 'leaflet-grab');
  		removeClass(this._map._container, 'leaflet-touch-drag');
  		this._draggable.disable();
  	},

  	moved: function () {
  		return this._draggable && this._draggable._moved;
  	},

  	moving: function () {
  		return this._draggable && this._draggable._moving;
  	},

  	_onDragStart: function () {
  		var map = this._map;

  		map._stop();
  		if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
  			var bounds = toLatLngBounds(this._map.options.maxBounds);

  			this._offsetLimit = toBounds(
  				this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
  				this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1)
  					.add(this._map.getSize()));

  			this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
  		} else {
  			this._offsetLimit = null;
  		}

  		map
  		    .fire('movestart')
  		    .fire('dragstart');

  		if (map.options.inertia) {
  			this._positions = [];
  			this._times = [];
  		}
  	},

  	_onDrag: function (e) {
  		if (this._map.options.inertia) {
  			var time = this._lastTime = +new Date(),
  			    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

  			this._positions.push(pos);
  			this._times.push(time);

  			this._prunePositions(time);
  		}

  		this._map
  		    .fire('move', e)
  		    .fire('drag', e);
  	},

  	_prunePositions: function (time) {
  		while (this._positions.length > 1 && time - this._times[0] > 50) {
  			this._positions.shift();
  			this._times.shift();
  		}
  	},

  	_onZoomEnd: function () {
  		var pxCenter = this._map.getSize().divideBy(2),
  		    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

  		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
  		this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
  	},

  	_viscousLimit: function (value, threshold) {
  		return value - (value - threshold) * this._viscosity;
  	},

  	_onPreDragLimit: function () {
  		if (!this._viscosity || !this._offsetLimit) { return; }

  		var offset = this._draggable._newPos.subtract(this._draggable._startPos);

  		var limit = this._offsetLimit;
  		if (offset.x < limit.min.x) { offset.x = this._viscousLimit(offset.x, limit.min.x); }
  		if (offset.y < limit.min.y) { offset.y = this._viscousLimit(offset.y, limit.min.y); }
  		if (offset.x > limit.max.x) { offset.x = this._viscousLimit(offset.x, limit.max.x); }
  		if (offset.y > limit.max.y) { offset.y = this._viscousLimit(offset.y, limit.max.y); }

  		this._draggable._newPos = this._draggable._startPos.add(offset);
  	},

  	_onPreDragWrap: function () {
  		// TODO refactor to be able to adjust map pane position after zoom
  		var worldWidth = this._worldWidth,
  		    halfWidth = Math.round(worldWidth / 2),
  		    dx = this._initialWorldOffset,
  		    x = this._draggable._newPos.x,
  		    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
  		    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
  		    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

  		this._draggable._absPos = this._draggable._newPos.clone();
  		this._draggable._newPos.x = newX;
  	},

  	_onDragEnd: function (e) {
  		var map = this._map,
  		    options = map.options,

  		    noInertia = !options.inertia || e.noInertia || this._times.length < 2;

  		map.fire('dragend', e);

  		if (noInertia) {
  			map.fire('moveend');

  		} else {
  			this._prunePositions(+new Date());

  			var direction = this._lastPos.subtract(this._positions[0]),
  			    duration = (this._lastTime - this._times[0]) / 1000,
  			    ease = options.easeLinearity,

  			    speedVector = direction.multiplyBy(ease / duration),
  			    speed = speedVector.distanceTo([0, 0]),

  			    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
  			    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

  			    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
  			    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

  			if (!offset.x && !offset.y) {
  				map.fire('moveend');

  			} else {
  				offset = map._limitOffset(offset, map.options.maxBounds);

  				requestAnimFrame(function () {
  					map.panBy(offset, {
  						duration: decelerationDuration,
  						easeLinearity: ease,
  						noMoveStart: true,
  						animate: true
  					});
  				});
  			}
  		}
  	}
  });

  // @section Handlers
  // @property dragging: Handler
  // Map dragging handler (by both mouse and touch).
  Map.addInitHook('addHandler', 'dragging', Drag);

  /*
   * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
   */

  // @namespace Map
  // @section Keyboard Navigation Options
  Map.mergeOptions({
  	// @option keyboard: Boolean = true
  	// Makes the map focusable and allows users to navigate the map with keyboard
  	// arrows and `+`/`-` keys.
  	keyboard: true,

  	// @option keyboardPanDelta: Number = 80
  	// Amount of pixels to pan when pressing an arrow key.
  	keyboardPanDelta: 80
  });

  var Keyboard = Handler.extend({

  	keyCodes: {
  		left:    [37],
  		right:   [39],
  		down:    [40],
  		up:      [38],
  		zoomIn:  [187, 107, 61, 171],
  		zoomOut: [189, 109, 54, 173]
  	},

  	initialize: function (map) {
  		this._map = map;

  		this._setPanDelta(map.options.keyboardPanDelta);
  		this._setZoomDelta(map.options.zoomDelta);
  	},

  	addHooks: function () {
  		var container = this._map._container;

  		// make the container focusable by tabbing
  		if (container.tabIndex <= 0) {
  			container.tabIndex = '0';
  		}

  		on(container, {
  			focus: this._onFocus,
  			blur: this._onBlur,
  			mousedown: this._onMouseDown
  		}, this);

  		this._map.on({
  			focus: this._addHooks,
  			blur: this._removeHooks
  		}, this);
  	},

  	removeHooks: function () {
  		this._removeHooks();

  		off(this._map._container, {
  			focus: this._onFocus,
  			blur: this._onBlur,
  			mousedown: this._onMouseDown
  		}, this);

  		this._map.off({
  			focus: this._addHooks,
  			blur: this._removeHooks
  		}, this);
  	},

  	_onMouseDown: function () {
  		if (this._focused) { return; }

  		var body = document.body,
  		    docEl = document.documentElement,
  		    top = body.scrollTop || docEl.scrollTop,
  		    left = body.scrollLeft || docEl.scrollLeft;

  		this._map._container.focus();

  		window.scrollTo(left, top);
  	},

  	_onFocus: function () {
  		this._focused = true;
  		this._map.fire('focus');
  	},

  	_onBlur: function () {
  		this._focused = false;
  		this._map.fire('blur');
  	},

  	_setPanDelta: function (panDelta) {
  		var keys = this._panKeys = {},
  		    codes = this.keyCodes,
  		    i, len;

  		for (i = 0, len = codes.left.length; i < len; i++) {
  			keys[codes.left[i]] = [-1 * panDelta, 0];
  		}
  		for (i = 0, len = codes.right.length; i < len; i++) {
  			keys[codes.right[i]] = [panDelta, 0];
  		}
  		for (i = 0, len = codes.down.length; i < len; i++) {
  			keys[codes.down[i]] = [0, panDelta];
  		}
  		for (i = 0, len = codes.up.length; i < len; i++) {
  			keys[codes.up[i]] = [0, -1 * panDelta];
  		}
  	},

  	_setZoomDelta: function (zoomDelta) {
  		var keys = this._zoomKeys = {},
  		    codes = this.keyCodes,
  		    i, len;

  		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
  			keys[codes.zoomIn[i]] = zoomDelta;
  		}
  		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
  			keys[codes.zoomOut[i]] = -zoomDelta;
  		}
  	},

  	_addHooks: function () {
  		on(document, 'keydown', this._onKeyDown, this);
  	},

  	_removeHooks: function () {
  		off(document, 'keydown', this._onKeyDown, this);
  	},

  	_onKeyDown: function (e) {
  		if (e.altKey || e.ctrlKey || e.metaKey) { return; }

  		var key = e.keyCode,
  		    map = this._map,
  		    offset;

  		if (key in this._panKeys) {
  			if (!map._panAnim || !map._panAnim._inProgress) {
  				offset = this._panKeys[key];
  				if (e.shiftKey) {
  					offset = toPoint(offset).multiplyBy(3);
  				}

  				if (map.options.maxBounds) {
  					offset = map._limitOffset(toPoint(offset), map.options.maxBounds);
  				}

  				if (map.options.worldCopyJump) {
  					var newLatLng = map.wrapLatLng(map.unproject(map.project(map.getCenter()).add(offset)));
  					map.panTo(newLatLng);
  				} else {
  					map.panBy(offset);
  				}
  			}
  		} else if (key in this._zoomKeys) {
  			map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);

  		} else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
  			map.closePopup();

  		} else {
  			return;
  		}

  		stop(e);
  	}
  });

  // @section Handlers
  // @section Handlers
  // @property keyboard: Handler
  // Keyboard navigation handler.
  Map.addInitHook('addHandler', 'keyboard', Keyboard);

  /*
   * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
   */

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
  	// @section Mouse wheel options
  	// @option scrollWheelZoom: Boolean|String = true
  	// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
  	// it will zoom to the center of the view regardless of where the mouse was.
  	scrollWheelZoom: true,

  	// @option wheelDebounceTime: Number = 40
  	// Limits the rate at which a wheel can fire (in milliseconds). By default
  	// user can't zoom via wheel more often than once per 40 ms.
  	wheelDebounceTime: 40,

  	// @option wheelPxPerZoomLevel: Number = 60
  	// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
  	// mean a change of one full zoom level. Smaller values will make wheel-zooming
  	// faster (and vice versa).
  	wheelPxPerZoomLevel: 60
  });

  var ScrollWheelZoom = Handler.extend({
  	addHooks: function () {
  		on(this._map._container, 'wheel', this._onWheelScroll, this);

  		this._delta = 0;
  	},

  	removeHooks: function () {
  		off(this._map._container, 'wheel', this._onWheelScroll, this);
  	},

  	_onWheelScroll: function (e) {
  		var delta = getWheelDelta(e);

  		var debounce = this._map.options.wheelDebounceTime;

  		this._delta += delta;
  		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

  		if (!this._startTime) {
  			this._startTime = +new Date();
  		}

  		var left = Math.max(debounce - (+new Date() - this._startTime), 0);

  		clearTimeout(this._timer);
  		this._timer = setTimeout(bind(this._performZoom, this), left);

  		stop(e);
  	},

  	_performZoom: function () {
  		var map = this._map,
  		    zoom = map.getZoom(),
  		    snap = this._map.options.zoomSnap || 0;

  		map._stop(); // stop panning and fly animations if any

  		// map the delta with a sigmoid function to -4..4 range leaning on -1..1
  		var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
  		    d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
  		    d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
  		    delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

  		this._delta = 0;
  		this._startTime = null;

  		if (!delta) { return; }

  		if (map.options.scrollWheelZoom === 'center') {
  			map.setZoom(zoom + delta);
  		} else {
  			map.setZoomAround(this._lastMousePos, zoom + delta);
  		}
  	}
  });

  // @section Handlers
  // @property scrollWheelZoom: Handler
  // Scroll wheel zoom handler.
  Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);

  /*
   * L.Map.TapHold is used to simulate `contextmenu` event on long hold,
   * which otherwise is not fired by mobile Safari.
   */

  var tapHoldDelay = 600;

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
  	// @section Touch interaction options
  	// @option tapHold: Boolean
  	// Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
  	tapHold: Browser.touchNative && Browser.safari && Browser.mobile,

  	// @option tapTolerance: Number = 15
  	// The max number of pixels a user can shift his finger during touch
  	// for it to be considered a valid tap.
  	tapTolerance: 15
  });

  var TapHold = Handler.extend({
  	addHooks: function () {
  		on(this._map._container, 'touchstart', this._onDown, this);
  	},

  	removeHooks: function () {
  		off(this._map._container, 'touchstart', this._onDown, this);
  	},

  	_onDown: function (e) {
  		clearTimeout(this._holdTimeout);
  		if (e.touches.length !== 1) { return; }

  		var first = e.touches[0];
  		this._startPos = this._newPos = new Point(first.clientX, first.clientY);

  		this._holdTimeout = setTimeout(bind(function () {
  			this._cancel();
  			if (!this._isTapValid()) { return; }

  			// prevent simulated mouse events https://w3c.github.io/touch-events/#mouse-events
  			on(document, 'touchend', preventDefault);
  			on(document, 'touchend touchcancel', this._cancelClickPrevent);
  			this._simulateEvent('contextmenu', first);
  		}, this), tapHoldDelay);

  		on(document, 'touchend touchcancel contextmenu', this._cancel, this);
  		on(document, 'touchmove', this._onMove, this);
  	},

  	_cancelClickPrevent: function cancelClickPrevent() {
  		off(document, 'touchend', preventDefault);
  		off(document, 'touchend touchcancel', cancelClickPrevent);
  	},

  	_cancel: function () {
  		clearTimeout(this._holdTimeout);
  		off(document, 'touchend touchcancel contextmenu', this._cancel, this);
  		off(document, 'touchmove', this._onMove, this);
  	},

  	_onMove: function (e) {
  		var first = e.touches[0];
  		this._newPos = new Point(first.clientX, first.clientY);
  	},

  	_isTapValid: function () {
  		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
  	},

  	_simulateEvent: function (type, e) {
  		var simulatedEvent = new MouseEvent(type, {
  			bubbles: true,
  			cancelable: true,
  			view: window,
  			// detail: 1,
  			screenX: e.screenX,
  			screenY: e.screenY,
  			clientX: e.clientX,
  			clientY: e.clientY,
  			// button: 2,
  			// buttons: 2
  		});

  		simulatedEvent._simulated = true;

  		e.target.dispatchEvent(simulatedEvent);
  	}
  });

  // @section Handlers
  // @property tapHold: Handler
  // Long tap handler to simulate `contextmenu` event (useful in mobile Safari).
  Map.addInitHook('addHandler', 'tapHold', TapHold);

  /*
   * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
   */

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
  	// @section Touch interaction options
  	// @option touchZoom: Boolean|String = *
  	// Whether the map can be zoomed by touch-dragging with two fingers. If
  	// passed `'center'`, it will zoom to the center of the view regardless of
  	// where the touch events (fingers) were. Enabled for touch-capable web
  	// browsers.
  	touchZoom: Browser.touch,

  	// @option bounceAtZoomLimits: Boolean = true
  	// Set it to false if you don't want the map to zoom beyond min/max zoom
  	// and then bounce back when pinch-zooming.
  	bounceAtZoomLimits: true
  });

  var TouchZoom = Handler.extend({
  	addHooks: function () {
  		addClass(this._map._container, 'leaflet-touch-zoom');
  		on(this._map._container, 'touchstart', this._onTouchStart, this);
  	},

  	removeHooks: function () {
  		removeClass(this._map._container, 'leaflet-touch-zoom');
  		off(this._map._container, 'touchstart', this._onTouchStart, this);
  	},

  	_onTouchStart: function (e) {
  		var map = this._map;
  		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

  		var p1 = map.mouseEventToContainerPoint(e.touches[0]),
  		    p2 = map.mouseEventToContainerPoint(e.touches[1]);

  		this._centerPoint = map.getSize()._divideBy(2);
  		this._startLatLng = map.containerPointToLatLng(this._centerPoint);
  		if (map.options.touchZoom !== 'center') {
  			this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
  		}

  		this._startDist = p1.distanceTo(p2);
  		this._startZoom = map.getZoom();

  		this._moved = false;
  		this._zooming = true;

  		map._stop();

  		on(document, 'touchmove', this._onTouchMove, this);
  		on(document, 'touchend touchcancel', this._onTouchEnd, this);

  		preventDefault(e);
  	},

  	_onTouchMove: function (e) {
  		if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

  		var map = this._map,
  		    p1 = map.mouseEventToContainerPoint(e.touches[0]),
  		    p2 = map.mouseEventToContainerPoint(e.touches[1]),
  		    scale = p1.distanceTo(p2) / this._startDist;

  		this._zoom = map.getScaleZoom(scale, this._startZoom);

  		if (!map.options.bounceAtZoomLimits && (
  			(this._zoom < map.getMinZoom() && scale < 1) ||
  			(this._zoom > map.getMaxZoom() && scale > 1))) {
  			this._zoom = map._limitZoom(this._zoom);
  		}

  		if (map.options.touchZoom === 'center') {
  			this._center = this._startLatLng;
  			if (scale === 1) { return; }
  		} else {
  			// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
  			var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
  			if (scale === 1 && delta.x === 0 && delta.y === 0) { return; }
  			this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
  		}

  		if (!this._moved) {
  			map._moveStart(true, false);
  			this._moved = true;
  		}

  		cancelAnimFrame(this._animRequest);

  		var moveFn = bind(map._move, map, this._center, this._zoom, {pinch: true, round: false}, undefined);
  		this._animRequest = requestAnimFrame(moveFn, this, true);

  		preventDefault(e);
  	},

  	_onTouchEnd: function () {
  		if (!this._moved || !this._zooming) {
  			this._zooming = false;
  			return;
  		}

  		this._zooming = false;
  		cancelAnimFrame(this._animRequest);

  		off(document, 'touchmove', this._onTouchMove, this);
  		off(document, 'touchend touchcancel', this._onTouchEnd, this);

  		// Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
  		if (this._map.options.zoomAnimation) {
  			this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
  		} else {
  			this._map._resetView(this._center, this._map._limitZoom(this._zoom));
  		}
  	}
  });

  // @section Handlers
  // @property touchZoom: Handler
  // Touch zoom handler.
  Map.addInitHook('addHandler', 'touchZoom', TouchZoom);

  Map.BoxZoom = BoxZoom;
  Map.DoubleClickZoom = DoubleClickZoom;
  Map.Drag = Drag;
  Map.Keyboard = Keyboard;
  Map.ScrollWheelZoom = ScrollWheelZoom;
  Map.TapHold = TapHold;
  Map.TouchZoom = TouchZoom;

  exports.Bounds = Bounds;
  exports.Browser = Browser;
  exports.CRS = CRS;
  exports.Canvas = Canvas;
  exports.Circle = Circle;
  exports.CircleMarker = CircleMarker;
  exports.Class = Class;
  exports.Control = Control;
  exports.DivIcon = DivIcon;
  exports.DivOverlay = DivOverlay;
  exports.DomEvent = DomEvent;
  exports.DomUtil = DomUtil;
  exports.Draggable = Draggable;
  exports.Evented = Evented;
  exports.FeatureGroup = FeatureGroup;
  exports.GeoJSON = GeoJSON;
  exports.GridLayer = GridLayer;
  exports.Handler = Handler;
  exports.Icon = Icon;
  exports.ImageOverlay = ImageOverlay;
  exports.LatLng = LatLng;
  exports.LatLngBounds = LatLngBounds;
  exports.Layer = Layer;
  exports.LayerGroup = LayerGroup;
  exports.LineUtil = LineUtil;
  exports.Map = Map;
  exports.Marker = Marker;
  exports.Mixin = Mixin;
  exports.Path = Path;
  exports.Point = Point;
  exports.PolyUtil = PolyUtil;
  exports.Polygon = Polygon;
  exports.Polyline = Polyline;
  exports.Popup = Popup;
  exports.PosAnimation = PosAnimation;
  exports.Projection = index;
  exports.Rectangle = Rectangle;
  exports.Renderer = Renderer;
  exports.SVG = SVG;
  exports.SVGOverlay = SVGOverlay;
  exports.TileLayer = TileLayer;
  exports.Tooltip = Tooltip;
  exports.Transformation = Transformation;
  exports.Util = Util;
  exports.VideoOverlay = VideoOverlay;
  exports.bind = bind;
  exports.bounds = toBounds;
  exports.canvas = canvas;
  exports.circle = circle;
  exports.circleMarker = circleMarker;
  exports.control = control;
  exports.divIcon = divIcon;
  exports.extend = extend;
  exports.featureGroup = featureGroup;
  exports.geoJSON = geoJSON;
  exports.geoJson = geoJson;
  exports.gridLayer = gridLayer;
  exports.icon = icon;
  exports.imageOverlay = imageOverlay;
  exports.latLng = toLatLng;
  exports.latLngBounds = toLatLngBounds;
  exports.layerGroup = layerGroup;
  exports.map = createMap;
  exports.marker = marker;
  exports.point = toPoint;
  exports.polygon = polygon;
  exports.polyline = polyline;
  exports.popup = popup;
  exports.rectangle = rectangle;
  exports.setOptions = setOptions;
  exports.stamp = stamp;
  exports.svg = svg;
  exports.svgOverlay = svgOverlay;
  exports.tileLayer = tileLayer;
  exports.tooltip = tooltip;
  exports.transformation = toTransformation;
  exports.version = version;
  exports.videoOverlay = videoOverlay;

  var oldL = window.L;
  exports.noConflict = function() {
  	window.L = oldL;
  	return this;
  };
  // Always export us to window global (see #2364)
  window.L = exports;

}));

});

createCommonjsModule(function (module) {
(function (root, factory) {
	if (typeof modules === 'object' && module.exports) {
		// define a Common JS module that relies on 'leaflet'
		module.exports = factory(leafletSrc);
	} else {
		// Assume Leaflet is loaded into global object L already
		factory(L);
	}
}(commonjsGlobal, function (L) {

	L.TileLayer.Provider = L.TileLayer.extend({
		initialize: function (arg, options) {
			var providers = L.TileLayer.Provider.providers;

			var parts = arg.split('.');

			var providerName = parts[0];
			var variantName = parts[1];

			if (!providers[providerName]) {
				throw 'No such provider (' + providerName + ')';
			}

			var provider = {
				url: providers[providerName].url,
				options: providers[providerName].options
			};

			// overwrite values in provider from variant.
			if (variantName && 'variants' in providers[providerName]) {
				if (!(variantName in providers[providerName].variants)) {
					throw 'No such variant of ' + providerName + ' (' + variantName + ')';
				}
				var variant = providers[providerName].variants[variantName];
				var variantOptions;
				if (typeof variant === 'string') {
					variantOptions = {
						variant: variant
					};
				} else {
					variantOptions = variant.options;
				}
				provider = {
					url: variant.url || provider.url,
					options: L.Util.extend({}, provider.options, variantOptions)
				};
			}

			// replace attribution placeholders with their values from toplevel provider attribution,
			// recursively
			var attributionReplacer = function (attr) {
				if (attr.indexOf('{attribution.') === -1) {
					return attr;
				}
				return attr.replace(/\{attribution.(\w*)\}/g,
					function (match, attributionName) {
						return attributionReplacer(providers[attributionName].options.attribution);
					}
				);
			};
			provider.options.attribution = attributionReplacer(provider.options.attribution);

			// Compute final options combining provider options with any user overrides
			var layerOpts = L.Util.extend({}, provider.options, options);
			L.TileLayer.prototype.initialize.call(this, provider.url, layerOpts);
		}
	});

	/**
	 * Definition of providers.
	 * see http://leafletjs.com/reference.html#tilelayer for options in the options map.
	 */

	L.TileLayer.Provider.providers = {
		OpenStreetMap: {
			url: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
			options: {
				maxZoom: 19,
				attribution:
					'&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
			},
			variants: {
				Mapnik: {},
				DE: {
					url: 'https://tile.openstreetmap.de/{z}/{x}/{y}.png',
					options: {
						maxZoom: 18
					}
				},
				CH: {
					url: 'https://tile.osm.ch/switzerland/{z}/{x}/{y}.png',
					options: {
						maxZoom: 18,
						bounds: [[45, 5], [48, 11]]
					}
				},
				France: {
					url: 'https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png',
					options: {
						maxZoom: 20,
						attribution: '&copy; OpenStreetMap France | {attribution.OpenStreetMap}'
					}
				},
				HOT: {
					url: 'https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png',
					options: {
						attribution:
							'{attribution.OpenStreetMap}, ' +
							'Tiles style by <a href="https://www.hotosm.org/" target="_blank">Humanitarian OpenStreetMap Team</a> ' +
							'hosted by <a href="https://openstreetmap.fr/" target="_blank">OpenStreetMap France</a>'
					}
				},
				BZH: {
					url: 'https://tile.openstreetmap.bzh/br/{z}/{x}/{y}.png',
					options: {
						attribution: '{attribution.OpenStreetMap}, Tiles courtesy of <a href="http://www.openstreetmap.bzh/" target="_blank">Breton OpenStreetMap Team</a>',
						bounds: [[46.2, -5.5], [50, 0.7]]
					}
				}
			}
		},
		MapTilesAPI: {
			url: 'https://maptiles.p.rapidapi.com/{variant}/{z}/{x}/{y}.png?rapidapi-key={apikey}',
			options: {
				attribution:
					'&copy; <a href="http://www.maptilesapi.com/">MapTiles API</a>, {attribution.OpenStreetMap}',
				variant: 'en/map/v1',
				// Get your own MapTiles API access token here : https://www.maptilesapi.com/
				// NB : this is a demonstration key that comes with no guarantee and not to be used in production
				apikey: '<insert your api key here>',
				maxZoom: 19
			},
			variants: {
				OSMEnglish: {
					options: {
						variant: 'en/map/v1'
					}
				},
				OSMFrancais: {
					options: {
						variant: 'fr/map/v1'
					}
				},
				OSMEspagnol: {
					options: {
						variant: 'es/map/v1'
					}
				}
			}
		},
		OpenSeaMap: {
			url: 'https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png',
			options: {
				attribution: 'Map data: &copy; <a href="http://www.openseamap.org">OpenSeaMap</a> contributors'
			}
		},
		OPNVKarte: {
			url: 'https://tileserver.memomaps.de/tilegen/{z}/{x}/{y}.png',
			options: {
				maxZoom: 18,
				attribution: 'Map <a href="https://memomaps.de/">memomaps.de</a> <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, map data {attribution.OpenStreetMap}'
			}
		},
		OpenTopoMap: {
			url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
			options: {
				maxZoom: 17,
				attribution: 'Map data: {attribution.OpenStreetMap}, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
			}
		},
		OpenRailwayMap: {
			url: 'https://{s}.tiles.openrailwaymap.org/standard/{z}/{x}/{y}.png',
			options: {
				maxZoom: 19,
				attribution: 'Map data: {attribution.OpenStreetMap} | Map style: &copy; <a href="https://www.OpenRailwayMap.org">OpenRailwayMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
			}
		},
		OpenFireMap: {
			url: 'http://openfiremap.org/hytiles/{z}/{x}/{y}.png',
			options: {
				maxZoom: 19,
				attribution: 'Map data: {attribution.OpenStreetMap} | Map style: &copy; <a href="http://www.openfiremap.org">OpenFireMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
			}
		},
		SafeCast: {
			url: 'https://s3.amazonaws.com/te512.safecast.org/{z}/{x}/{y}.png',
			options: {
				maxZoom: 16,
				attribution: 'Map data: {attribution.OpenStreetMap} | Map style: &copy; <a href="https://blog.safecast.org/about/">SafeCast</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
			}
		},
		Stadia: {
			url: 'https://tiles.stadiamaps.com/tiles/{variant}/{z}/{x}/{y}{r}.{ext}',
			options: {
				minZoom: 0,
				maxZoom: 20,
				attribution:
					'&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a> ' +
					'&copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> ' +
					'{attribution.OpenStreetMap}',
				variant: 'alidade_smooth',
				ext: 'png'
			},
			variants: {
				AlidadeSmooth: 'alidade_smooth',
				AlidadeSmoothDark: 'alidade_smooth_dark',
				OSMBright: 'osm_bright',
				Outdoors: 'outdoors',
				StamenToner: {
					options: {
						attribution:
							'&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a> ' +
							'&copy; <a href="https://www.stamen.com/" target="_blank">Stamen Design</a> ' +
							'&copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> ' +
							'{attribution.OpenStreetMap}',
						variant: 'stamen_toner'
					}
				},
				StamenTonerBackground: {
					options: {
						attribution:
							'&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a> ' +
							'&copy; <a href="https://www.stamen.com/" target="_blank">Stamen Design</a> ' +
							'&copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> ' +
							'{attribution.OpenStreetMap}',
						variant: 'stamen_toner_background'
					}
				},
				StamenTonerLines: {
					options: {
						attribution:
							'&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a> ' +
							'&copy; <a href="https://www.stamen.com/" target="_blank">Stamen Design</a> ' +
							'&copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> ' +
							'{attribution.OpenStreetMap}',
						variant: 'stamen_toner_lines'
					}
				},
				StamenTonerLabels: {
					options: {
						attribution:
							'&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a> ' +
							'&copy; <a href="https://www.stamen.com/" target="_blank">Stamen Design</a> ' +
							'&copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> ' +
							'{attribution.OpenStreetMap}',
						variant: 'stamen_toner_labels'
					}
				},
				StamenTonerLite: {
					options: {
						attribution:
							'&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a> ' +
							'&copy; <a href="https://www.stamen.com/" target="_blank">Stamen Design</a> ' +
							'&copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> ' +
							'{attribution.OpenStreetMap}',
						variant: 'stamen_toner_lite'
					}
				},
				StamenWatercolor: {
					url: 'https://tiles.stadiamaps.com/tiles/{variant}/{z}/{x}/{y}.{ext}',
					options: {
						attribution:
							'&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a> ' +
							'&copy; <a href="https://www.stamen.com/" target="_blank">Stamen Design</a> ' +
							'&copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> ' +
							'{attribution.OpenStreetMap}',
						variant: 'stamen_watercolor',
						ext: 'jpg',
						minZoom: 1,
						maxZoom: 16
					}
				},
				StamenTerrain: {
					options: {
						attribution:
							'&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a> ' +
							'&copy; <a href="https://www.stamen.com/" target="_blank">Stamen Design</a> ' +
							'&copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> ' +
							'{attribution.OpenStreetMap}',
						variant: 'stamen_terrain',
						minZoom: 0,
						maxZoom: 18
					}
				},
				StamenTerrainBackground: {
					options: {
						attribution:
							'&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a> ' +
							'&copy; <a href="https://www.stamen.com/" target="_blank">Stamen Design</a> ' +
							'&copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> ' +
							'{attribution.OpenStreetMap}',
						variant: 'stamen_terrain_background',
						minZoom: 0,
						maxZoom: 18
					}
				},
				StamenTerrainLabels: {
					options: {
						attribution:
							'&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a> ' +
							'&copy; <a href="https://www.stamen.com/" target="_blank">Stamen Design</a> ' +
							'&copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> ' +
							'{attribution.OpenStreetMap}',
						variant: 'stamen_terrain_labels',
						minZoom: 0,
						maxZoom: 18
					}
				},
				StamenTerrainLines: {
					options: {
						attribution:
							'&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a> ' +
							'&copy; <a href="https://www.stamen.com/" target="_blank">Stamen Design</a> ' +
							'&copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> ' +
							'{attribution.OpenStreetMap}',
						variant: 'stamen_terrain_lines',
						minZoom: 0,
						maxZoom: 18
					}
				}
			}
		},
		Thunderforest: {
			url: 'https://{s}.tile.thunderforest.com/{variant}/{z}/{x}/{y}.png?apikey={apikey}',
			options: {
				attribution:
					'&copy; <a href="http://www.thunderforest.com/">Thunderforest</a>, {attribution.OpenStreetMap}',
				variant: 'cycle',
				apikey: '<insert your api key here>',
				maxZoom: 22
			},
			variants: {
				OpenCycleMap: 'cycle',
				Transport: {
					options: {
						variant: 'transport'
					}
				},
				TransportDark: {
					options: {
						variant: 'transport-dark'
					}
				},
				SpinalMap: {
					options: {
						variant: 'spinal-map'
					}
				},
				Landscape: 'landscape',
				Outdoors: 'outdoors',
				Pioneer: 'pioneer',
				MobileAtlas: 'mobile-atlas',
				Neighbourhood: 'neighbourhood'
			}
		},
		CyclOSM: {
			url: 'https://{s}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png',
			options: {
				maxZoom: 20,
				attribution: '<a href="https://github.com/cyclosm/cyclosm-cartocss-style/releases" title="CyclOSM - Open Bicycle render">CyclOSM</a> | Map data: {attribution.OpenStreetMap}'
			}
		},
		Jawg: {
			url: 'https://{s}.tile.jawg.io/{variant}/{z}/{x}/{y}{r}.png?access-token={accessToken}',
			options: {
				attribution:
					'<a href="http://jawg.io" title="Tiles Courtesy of Jawg Maps" target="_blank">&copy; <b>Jawg</b>Maps</a> ' +
					'{attribution.OpenStreetMap}',
				minZoom: 0,
				maxZoom: 22,
				subdomains: 'abcd',
				variant: 'jawg-terrain',
				// Get your own Jawg access token here : https://www.jawg.io/lab/
				// NB : this is a demonstration key that comes with no guarantee
				accessToken: '<insert your access token here>',
			},
			variants: {
				Streets: 'jawg-streets',
				Terrain: 'jawg-terrain',
				Sunny: 'jawg-sunny',
				Dark: 'jawg-dark',
				Light: 'jawg-light',
				Matrix: 'jawg-matrix'
			}
		},
		MapBox: {
			url: 'https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}{r}?access_token={accessToken}',
			options: {
				attribution:
					'&copy; <a href="https://www.mapbox.com/about/maps/" target="_blank">Mapbox</a> ' +
					'{attribution.OpenStreetMap} ' +
					'<a href="https://www.mapbox.com/map-feedback/" target="_blank">Improve this map</a>',
				tileSize: 512,
				maxZoom: 18,
				zoomOffset: -1,
				id: 'mapbox/streets-v11',
				accessToken: '<insert your access token here>',
			}
		},
		MapTiler: {
			url: 'https://api.maptiler.com/maps/{variant}/{z}/{x}/{y}{r}.{ext}?key={key}',
			options: {
				attribution:
					'<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> <a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>',
				variant: 'streets',
				ext: 'png',
				key: '<insert your MapTiler Cloud API key here>',
				tileSize: 512,
				zoomOffset: -1,
				minZoom: 0,
				maxZoom: 21
			},
			variants: {
				Streets: 'streets',
				Basic: 'basic',
				Bright: 'bright',
				Pastel: 'pastel',
				Positron: 'positron',
				Hybrid: {
					options: {
						variant: 'hybrid',
						ext: 'jpg'
					}
				},
				Toner: 'toner',
				Topo: 'topo',
				Voyager: 'voyager'
			}
		},
		TomTom: {
			url: 'https://{s}.api.tomtom.com/map/1/tile/{variant}/{style}/{z}/{x}/{y}.{ext}?key={apikey}',
			options: {
				variant: 'basic',
				maxZoom: 22,
				attribution:
					'<a href="https://tomtom.com" target="_blank">&copy;  1992 - ' + new Date().getFullYear() + ' TomTom.</a> ',
				subdomains: 'abcd',
				style: 'main',
				ext: 'png',
				apikey: '<insert your API key here>',
			},
			variants: {
				Basic: 'basic',
				Hybrid: 'hybrid',
				Labels: 'labels'
			}
		},
		Esri: {
			url: 'https://server.arcgisonline.com/ArcGIS/rest/services/{variant}/MapServer/tile/{z}/{y}/{x}',
			options: {
				variant: 'World_Street_Map',
				attribution: 'Tiles &copy; Esri'
			},
			variants: {
				WorldStreetMap: {
					options: {
						attribution:
							'{attribution.Esri} &mdash; ' +
							'Source: Esri, DeLorme, NAVTEQ, USGS, Intermap, iPC, NRCAN, Esri Japan, METI, Esri China (Hong Kong), Esri (Thailand), TomTom, 2012'
					}
				},
				DeLorme: {
					options: {
						variant: 'Specialty/DeLorme_World_Base_Map',
						minZoom: 1,
						maxZoom: 11,
						attribution: '{attribution.Esri} &mdash; Copyright: &copy;2012 DeLorme'
					}
				},
				WorldTopoMap: {
					options: {
						variant: 'World_Topo_Map',
						attribution:
							'{attribution.Esri} &mdash; ' +
							'Esri, DeLorme, NAVTEQ, TomTom, Intermap, iPC, USGS, FAO, NPS, NRCAN, GeoBase, Kadaster NL, Ordnance Survey, Esri Japan, METI, Esri China (Hong Kong), and the GIS User Community'
					}
				},
				WorldImagery: {
					options: {
						variant: 'World_Imagery',
						attribution:
							'{attribution.Esri} &mdash; ' +
							'Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
					}
				},
				WorldTerrain: {
					options: {
						variant: 'World_Terrain_Base',
						maxZoom: 13,
						attribution:
							'{attribution.Esri} &mdash; ' +
							'Source: USGS, Esri, TANA, DeLorme, and NPS'
					}
				},
				WorldShadedRelief: {
					options: {
						variant: 'World_Shaded_Relief',
						maxZoom: 13,
						attribution: '{attribution.Esri} &mdash; Source: Esri'
					}
				},
				WorldPhysical: {
					options: {
						variant: 'World_Physical_Map',
						maxZoom: 8,
						attribution: '{attribution.Esri} &mdash; Source: US National Park Service'
					}
				},
				OceanBasemap: {
					options: {
						variant: 'Ocean/World_Ocean_Base',
						maxZoom: 13,
						attribution: '{attribution.Esri} &mdash; Sources: GEBCO, NOAA, CHS, OSU, UNH, CSUMB, National Geographic, DeLorme, NAVTEQ, and Esri'
					}
				},
				NatGeoWorldMap: {
					options: {
						variant: 'NatGeo_World_Map',
						maxZoom: 16,
						attribution: '{attribution.Esri} &mdash; National Geographic, Esri, DeLorme, NAVTEQ, UNEP-WCMC, USGS, NASA, ESA, METI, NRCAN, GEBCO, NOAA, iPC'
					}
				},
				WorldGrayCanvas: {
					options: {
						variant: 'Canvas/World_Light_Gray_Base',
						maxZoom: 16,
						attribution: '{attribution.Esri} &mdash; Esri, DeLorme, NAVTEQ'
					}
				}
			}
		},
		OpenWeatherMap: {
			url: 'http://{s}.tile.openweathermap.org/map/{variant}/{z}/{x}/{y}.png?appid={apiKey}',
			options: {
				maxZoom: 19,
				attribution: 'Map data &copy; <a href="http://openweathermap.org">OpenWeatherMap</a>',
				apiKey: '<insert your api key here>',
				opacity: 0.5
			},
			variants: {
				Clouds: 'clouds',
				CloudsClassic: 'clouds_cls',
				Precipitation: 'precipitation',
				PrecipitationClassic: 'precipitation_cls',
				Rain: 'rain',
				RainClassic: 'rain_cls',
				Pressure: 'pressure',
				PressureContour: 'pressure_cntr',
				Wind: 'wind',
				Temperature: 'temp',
				Snow: 'snow'
			}
		},
		HERE: {
			/*
			 * HERE maps, formerly Nokia maps.
			 * These basemaps are free, but you need an api id and app key. Please sign up at
			 * https://developer.here.com/plans
			 */
			url:
				'https://{s}.{base}.maps.api.here.com/maptile/2.1/' +
				'{type}/{mapID}/{variant}/{z}/{x}/{y}/{size}/{format}?' +
				'app_id={app_id}&app_code={app_code}&lg={language}',
			options: {
				attribution:
					'Map &copy; 1987-' + new Date().getFullYear() + ' <a href="http://developer.here.com">HERE</a>',
				subdomains: '1234',
				mapID: 'newest',
				'app_id': '<insert your app_id here>',
				'app_code': '<insert your app_code here>',
				base: 'base',
				variant: 'normal.day',
				maxZoom: 20,
				type: 'maptile',
				language: 'eng',
				format: 'png8',
				size: '256'
			},
			variants: {
				normalDay: 'normal.day',
				normalDayCustom: 'normal.day.custom',
				normalDayGrey: 'normal.day.grey',
				normalDayMobile: 'normal.day.mobile',
				normalDayGreyMobile: 'normal.day.grey.mobile',
				normalDayTransit: 'normal.day.transit',
				normalDayTransitMobile: 'normal.day.transit.mobile',
				normalDayTraffic: {
					options: {
						variant: 'normal.traffic.day',
						base: 'traffic',
						type: 'traffictile'
					}
				},
				normalNight: 'normal.night',
				normalNightMobile: 'normal.night.mobile',
				normalNightGrey: 'normal.night.grey',
				normalNightGreyMobile: 'normal.night.grey.mobile',
				normalNightTransit: 'normal.night.transit',
				normalNightTransitMobile: 'normal.night.transit.mobile',
				reducedDay: 'reduced.day',
				reducedNight: 'reduced.night',
				basicMap: {
					options: {
						type: 'basetile'
					}
				},
				mapLabels: {
					options: {
						type: 'labeltile',
						format: 'png'
					}
				},
				trafficFlow: {
					options: {
						base: 'traffic',
						type: 'flowtile'
					}
				},
				carnavDayGrey: 'carnav.day.grey',
				hybridDay: {
					options: {
						base: 'aerial',
						variant: 'hybrid.day'
					}
				},
				hybridDayMobile: {
					options: {
						base: 'aerial',
						variant: 'hybrid.day.mobile'
					}
				},
				hybridDayTransit: {
					options: {
						base: 'aerial',
						variant: 'hybrid.day.transit'
					}
				},
				hybridDayGrey: {
					options: {
						base: 'aerial',
						variant: 'hybrid.grey.day'
					}
				},
				hybridDayTraffic: {
					options: {
						variant: 'hybrid.traffic.day',
						base: 'traffic',
						type: 'traffictile'
					}
				},
				pedestrianDay: 'pedestrian.day',
				pedestrianNight: 'pedestrian.night',
				satelliteDay: {
					options: {
						base: 'aerial',
						variant: 'satellite.day'
					}
				},
				terrainDay: {
					options: {
						base: 'aerial',
						variant: 'terrain.day'
					}
				},
				terrainDayMobile: {
					options: {
						base: 'aerial',
						variant: 'terrain.day.mobile'
					}
				}
			}
		},
		HEREv3: {
			/*
			 * HERE maps API Version 3.
			 * These basemaps are free, but you need an API key. Please sign up at
			 * https://developer.here.com/plans
			 * Version 3 deprecates the app_id and app_code access in favor of apiKey
			 *
			 * Supported access methods as of 2019/12/21:
			 * @see https://developer.here.com/faqs#access-control-1--how-do-you-control-access-to-here-location-services
			 */
			url:
				'https://{s}.{base}.maps.ls.hereapi.com/maptile/2.1/' +
				'{type}/{mapID}/{variant}/{z}/{x}/{y}/{size}/{format}?' +
				'apiKey={apiKey}&lg={language}',
			options: {
				attribution:
					'Map &copy; 1987-' + new Date().getFullYear() + ' <a href="http://developer.here.com">HERE</a>',
				subdomains: '1234',
				mapID: 'newest',
				apiKey: '<insert your apiKey here>',
				base: 'base',
				variant: 'normal.day',
				maxZoom: 20,
				type: 'maptile',
				language: 'eng',
				format: 'png8',
				size: '256'
			},
			variants: {
				normalDay: 'normal.day',
				normalDayCustom: 'normal.day.custom',
				normalDayGrey: 'normal.day.grey',
				normalDayMobile: 'normal.day.mobile',
				normalDayGreyMobile: 'normal.day.grey.mobile',
				normalDayTransit: 'normal.day.transit',
				normalDayTransitMobile: 'normal.day.transit.mobile',
				normalNight: 'normal.night',
				normalNightMobile: 'normal.night.mobile',
				normalNightGrey: 'normal.night.grey',
				normalNightGreyMobile: 'normal.night.grey.mobile',
				normalNightTransit: 'normal.night.transit',
				normalNightTransitMobile: 'normal.night.transit.mobile',
				reducedDay: 'reduced.day',
				reducedNight: 'reduced.night',
				basicMap: {
					options: {
						type: 'basetile'
					}
				},
				mapLabels: {
					options: {
						type: 'labeltile',
						format: 'png'
					}
				},
				trafficFlow: {
					options: {
						base: 'traffic',
						type: 'flowtile'
					}
				},
				carnavDayGrey: 'carnav.day.grey',
				hybridDay: {
					options: {
						base: 'aerial',
						variant: 'hybrid.day'
					}
				},
				hybridDayMobile: {
					options: {
						base: 'aerial',
						variant: 'hybrid.day.mobile'
					}
				},
				hybridDayTransit: {
					options: {
						base: 'aerial',
						variant: 'hybrid.day.transit'
					}
				},
				hybridDayGrey: {
					options: {
						base: 'aerial',
						variant: 'hybrid.grey.day'
					}
				},
				pedestrianDay: 'pedestrian.day',
				pedestrianNight: 'pedestrian.night',
				satelliteDay: {
					options: {
						base: 'aerial',
						variant: 'satellite.day'
					}
				},
				terrainDay: {
					options: {
						base: 'aerial',
						variant: 'terrain.day'
					}
				},
				terrainDayMobile: {
					options: {
						base: 'aerial',
						variant: 'terrain.day.mobile'
					}
				}
			}
		},
		FreeMapSK: {
			url: 'https://{s}.freemap.sk/T/{z}/{x}/{y}.jpeg',
			options: {
				minZoom: 8,
				maxZoom: 16,
				subdomains: 'abcd',
				bounds: [[47.204642, 15.996093], [49.830896, 22.576904]],
				attribution:
					'{attribution.OpenStreetMap}, visualization CC-By-SA 2.0 <a href="http://freemap.sk">Freemap.sk</a>'
			}
		},
		MtbMap: {
			url: 'http://tile.mtbmap.cz/mtbmap_tiles/{z}/{x}/{y}.png',
			options: {
				attribution:
					'{attribution.OpenStreetMap} &amp; USGS'
			}
		},
		CartoDB: {
			url: 'https://{s}.basemaps.cartocdn.com/{variant}/{z}/{x}/{y}{r}.png',
			options: {
				attribution: '{attribution.OpenStreetMap} &copy; <a href="https://carto.com/attributions">CARTO</a>',
				subdomains: 'abcd',
				maxZoom: 20,
				variant: 'light_all'
			},
			variants: {
				Positron: 'light_all',
				PositronNoLabels: 'light_nolabels',
				PositronOnlyLabels: 'light_only_labels',
				DarkMatter: 'dark_all',
				DarkMatterNoLabels: 'dark_nolabels',
				DarkMatterOnlyLabels: 'dark_only_labels',
				Voyager: 'rastertiles/voyager',
				VoyagerNoLabels: 'rastertiles/voyager_nolabels',
				VoyagerOnlyLabels: 'rastertiles/voyager_only_labels',
				VoyagerLabelsUnder: 'rastertiles/voyager_labels_under'
			}
		},
		HikeBike: {
			url: 'https://tiles.wmflabs.org/{variant}/{z}/{x}/{y}.png',
			options: {
				maxZoom: 19,
				attribution: '{attribution.OpenStreetMap}',
				variant: 'hikebike'
			},
			variants: {
				HikeBike: {},
				HillShading: {
					options: {
						maxZoom: 15,
						variant: 'hillshading'
					}
				}
			}
		},
		BasemapAT: {
			url: 'https://mapsneu.wien.gv.at/basemap/{variant}/{type}/google3857/{z}/{y}/{x}.{format}',
			options: {
				maxZoom: 19,
				attribution: 'Datenquelle: <a href="https://www.basemap.at">basemap.at</a>',
				type: 'normal',
				format: 'png',
				bounds: [[46.358770, 8.782379], [49.037872, 17.189532]],
				variant: 'geolandbasemap'
			},
			variants: {
				basemap: {
					options: {
						maxZoom: 20, // currently only in Vienna
						variant: 'geolandbasemap'
					}
				},
				grau: 'bmapgrau',
				overlay: 'bmapoverlay',
				terrain: {
					options: {
						variant: 'bmapgelaende',
						type: 'grau',
						format: 'jpeg'
					}
				},
				surface: {
					options: {
						variant: 'bmapoberflaeche',
						type: 'grau',
						format: 'jpeg'
					}
				},
				highdpi: {
					options: {
						variant: 'bmaphidpi',
						format: 'jpeg'
					}
				},
				orthofoto: {
					options: {
						maxZoom: 20, // currently only in Vienna
						variant: 'bmaporthofoto30cm',
						format: 'jpeg'
					}
				}
			}
		},
		nlmaps: {
			url: 'https://service.pdok.nl/brt/achtergrondkaart/wmts/v2_0/{variant}/EPSG:3857/{z}/{x}/{y}.png',
			options: {
				minZoom: 6,
				maxZoom: 19,
				bounds: [[50.5, 3.25], [54, 7.6]],
				attribution: 'Kaartgegevens &copy; <a href="https://www.kadaster.nl">Kadaster</a>'
			},
			variants: {
				'standaard': 'standaard',
				'pastel': 'pastel',
				'grijs': 'grijs',
				'water': 'water',
				'luchtfoto': {
					'url': 'https://service.pdok.nl/hwh/luchtfotorgb/wmts/v1_0/Actueel_ortho25/EPSG:3857/{z}/{x}/{y}.jpeg',
				}
			}
		},
		NASAGIBS: {
			url: 'https://map1.vis.earthdata.nasa.gov/wmts-webmerc/{variant}/default/{time}/{tilematrixset}{maxZoom}/{z}/{y}/{x}.{format}',
			options: {
				attribution:
					'Imagery provided by services from the Global Imagery Browse Services (GIBS), operated by the NASA/GSFC/Earth Science Data and Information System ' +
					'(<a href="https://earthdata.nasa.gov">ESDIS</a>) with funding provided by NASA/HQ.',
				bounds: [[-85.0511287776, -179.999999975], [85.0511287776, 179.999999975]],
				minZoom: 1,
				maxZoom: 9,
				format: 'jpg',
				time: '',
				tilematrixset: 'GoogleMapsCompatible_Level'
			},
			variants: {
				ModisTerraTrueColorCR: 'MODIS_Terra_CorrectedReflectance_TrueColor',
				ModisTerraBands367CR: 'MODIS_Terra_CorrectedReflectance_Bands367',
				ViirsEarthAtNight2012: {
					options: {
						variant: 'VIIRS_CityLights_2012',
						maxZoom: 8
					}
				},
				ModisTerraLSTDay: {
					options: {
						variant: 'MODIS_Terra_Land_Surface_Temp_Day',
						format: 'png',
						maxZoom: 7,
						opacity: 0.75
					}
				},
				ModisTerraSnowCover: {
					options: {
						variant: 'MODIS_Terra_NDSI_Snow_Cover',
						format: 'png',
						maxZoom: 8,
						opacity: 0.75
					}
				},
				ModisTerraAOD: {
					options: {
						variant: 'MODIS_Terra_Aerosol',
						format: 'png',
						maxZoom: 6,
						opacity: 0.75
					}
				},
				ModisTerraChlorophyll: {
					options: {
						variant: 'MODIS_Terra_Chlorophyll_A',
						format: 'png',
						maxZoom: 7,
						opacity: 0.75
					}
				}
			}
		},
		NLS: {
			// NLS maps are copyright National library of Scotland.
			// http://maps.nls.uk/projects/api/index.html
			// Please contact NLS for anything other than non-commercial low volume usage
			//
			// Map sources: Ordnance Survey 1:1m to 1:63K, 1920s-1940s
			//   z0-9  - 1:1m
			//  z10-11 - quarter inch (1:253440)
			//  z12-18 - one inch (1:63360)
			url: 'https://nls-{s}.tileserver.com/nls/{z}/{x}/{y}.jpg',
			options: {
				attribution: '<a href="http://geo.nls.uk/maps/">National Library of Scotland Historic Maps</a>',
				bounds: [[49.6, -12], [61.7, 3]],
				minZoom: 1,
				maxZoom: 18,
				subdomains: '0123',
			}
		},
		JusticeMap: {
			// Justice Map (http://www.justicemap.org/)
			// Visualize race and income data for your community, county and country.
			// Includes tools for data journalists, bloggers and community activists.
			url: 'https://www.justicemap.org/tile/{size}/{variant}/{z}/{x}/{y}.png',
			options: {
				attribution: '<a href="http://www.justicemap.org/terms.php">Justice Map</a>',
				// one of 'county', 'tract', 'block'
				size: 'county',
				// Bounds for USA, including Alaska and Hawaii
				bounds: [[14, -180], [72, -56]]
			},
			variants: {
				income: 'income',
				americanIndian: 'indian',
				asian: 'asian',
				black: 'black',
				hispanic: 'hispanic',
				multi: 'multi',
				nonWhite: 'nonwhite',
				white: 'white',
				plurality: 'plural'
			}
		},
		GeoportailFrance: {
			url: 'https://wxs.ign.fr/{apikey}/geoportail/wmts?REQUEST=GetTile&SERVICE=WMTS&VERSION=1.0.0&STYLE={style}&TILEMATRIXSET=PM&FORMAT={format}&LAYER={variant}&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}',
			options: {
				attribution: '<a target="_blank" href="https://www.geoportail.gouv.fr/">Geoportail France</a>',
				bounds: [[-75, -180], [81, 180]],
				minZoom: 2,
				maxZoom: 18,
				// Get your own geoportail apikey here : http://professionnels.ign.fr/ign/contrats/
				// NB : 'choisirgeoportail' is a demonstration key that comes with no guarantee
				apikey: 'choisirgeoportail',
				format: 'image/png',
				style: 'normal',
				variant: 'GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2'
			},
			variants: {
				plan: 'GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2',
				parcels: {
					options: {
						variant: 'CADASTRALPARCELS.PARCELLAIRE_EXPRESS',
						style: 'PCI vecteur',
						maxZoom: 20
					}
				},
				orthos: {
					options: {
						maxZoom: 19,
						format: 'image/jpeg',
						variant: 'ORTHOIMAGERY.ORTHOPHOTOS'
					}
				}
			}
		},
		OneMapSG: {
			url: 'https://maps-{s}.onemap.sg/v3/{variant}/{z}/{x}/{y}.png',
			options: {
				variant: 'Default',
				minZoom: 11,
				maxZoom: 18,
				bounds: [[1.56073, 104.11475], [1.16, 103.502]],
				attribution: '<img src="https://docs.onemap.sg/maps/images/oneMap64-01.png" style="height:20px;width:20px;"/> New OneMap | Map data &copy; contributors, <a href="http://SLA.gov.sg">Singapore Land Authority</a>'
			},
			variants: {
				Default: 'Default',
				Night: 'Night',
				Original: 'Original',
				Grey: 'Grey',
				LandLot: 'LandLot'
			}
		},
		USGS: {
			url: 'https://basemap.nationalmap.gov/arcgis/rest/services/USGSTopo/MapServer/tile/{z}/{y}/{x}',
			options: {
				maxZoom: 20,
				attribution: 'Tiles courtesy of the <a href="https://usgs.gov/">U.S. Geological Survey</a>'
			},
			variants: {
				USTopo: {},
				USImagery: {
					url: 'https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryOnly/MapServer/tile/{z}/{y}/{x}'
				},
				USImageryTopo: {
					url: 'https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryTopo/MapServer/tile/{z}/{y}/{x}'
				}
			}
		},
		WaymarkedTrails: {
			url: 'https://tile.waymarkedtrails.org/{variant}/{z}/{x}/{y}.png',
			options: {
				maxZoom: 18,
				attribution: 'Map data: {attribution.OpenStreetMap} | Map style: &copy; <a href="https://waymarkedtrails.org">waymarkedtrails.org</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
			},
			variants: {
				hiking: 'hiking',
				cycling: 'cycling',
				mtb: 'mtb',
				slopes: 'slopes',
				riding: 'riding',
				skating: 'skating'
			}
		},
		OpenAIP: {
			url: 'https://{s}.tile.maps.openaip.net/geowebcache/service/tms/1.0.0/openaip_basemap@EPSG%3A900913@png/{z}/{x}/{y}.{ext}',
			options: {
				attribution: '<a href="https://www.openaip.net/">openAIP Data</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-NC-SA</a>)',
				ext: 'png',
				minZoom: 4,
				maxZoom: 14,
				tms: true,
				detectRetina: true,
				subdomains: '12'
			}
		},
		OpenSnowMap: {
			url: 'https://tiles.opensnowmap.org/{variant}/{z}/{x}/{y}.png',
			options: {
				minZoom: 9,
				maxZoom: 18,
				attribution: 'Map data: {attribution.OpenStreetMap} & ODbL, &copy; <a href="https://www.opensnowmap.org/iframes/data.html">www.opensnowmap.org</a> <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>'
			},
			variants: {
				pistes: 'pistes',
			}
		},
		AzureMaps: {
			url: 
				'https://atlas.microsoft.com/map/tile?api-version={apiVersion}'+
				'&tilesetId={variant}&x={x}&y={y}&zoom={z}&language={language}'+
				'&subscription-key={subscriptionKey}',
			options: {
				attribution: 'See https://docs.microsoft.com/en-us/rest/api/maps/render-v2/get-map-tile for details.',
				apiVersion: '2.0',
				variant: 'microsoft.imagery',
				subscriptionKey: '<insert your subscription key here>',
				language: 'en-US',
			},
			variants: {
				MicrosoftImagery: 'microsoft.imagery',
				MicrosoftBaseDarkGrey: 'microsoft.base.darkgrey',
				MicrosoftBaseRoad: 'microsoft.base.road',
				MicrosoftBaseHybridRoad: 'microsoft.base.hybrid.road',
				MicrosoftTerraMain: 'microsoft.terra.main',
				MicrosoftWeatherInfraredMain: {
					url: 
					'https://atlas.microsoft.com/map/tile?api-version={apiVersion}'+
					'&tilesetId={variant}&x={x}&y={y}&zoom={z}'+
					'&timeStamp={timeStamp}&language={language}' +
					'&subscription-key={subscriptionKey}',
					options: {
						timeStamp: '2021-05-08T09:03:00Z',
						attribution: 'See https://docs.microsoft.com/en-us/rest/api/maps/render-v2/get-map-tile#uri-parameters for details.',
						variant: 'microsoft.weather.infrared.main',
					},
				},
				MicrosoftWeatherRadarMain: {
					url: 
					'https://atlas.microsoft.com/map/tile?api-version={apiVersion}'+
					'&tilesetId={variant}&x={x}&y={y}&zoom={z}'+
					'&timeStamp={timeStamp}&language={language}' +
					'&subscription-key={subscriptionKey}',
					options: {
						timeStamp: '2021-05-08T09:03:00Z',
						attribution: 'See https://docs.microsoft.com/en-us/rest/api/maps/render-v2/get-map-tile#uri-parameters for details.',
						variant: 'microsoft.weather.radar.main',
					},
				}
			},
		},
		SwissFederalGeoportal: {
			url: 'https://wmts.geo.admin.ch/1.0.0/{variant}/default/current/3857/{z}/{x}/{y}.jpeg',
			options: {
				attribution: '&copy; <a href="https://www.swisstopo.admin.ch/">swisstopo</a>',
				minZoom: 2,
				maxZoom: 18,
				bounds: [[45.398181, 5.140242], [48.230651, 11.47757]]
			},
			variants: {
				NationalMapColor: 'ch.swisstopo.pixelkarte-farbe',
				NationalMapGrey: 'ch.swisstopo.pixelkarte-grau',
				SWISSIMAGE: {
					options: {
						variant: 'ch.swisstopo.swissimage',
						maxZoom: 19
					}
				}
			}
		}
	};

	L.tileLayer.provider = function (provider, options) {
		return new L.TileLayer.Provider(provider, options);
	};

	return L;
}));
});

var css_248z$1 = i$2`/* required styles */

.leaflet-pane,
.leaflet-tile,
.leaflet-marker-icon,
.leaflet-marker-shadow,
.leaflet-tile-container,
.leaflet-pane > svg,
.leaflet-pane > canvas,
.leaflet-zoom-box,
.leaflet-image-layer,
.leaflet-layer {
	position: absolute;
	left: 0;
	top: 0;
	}
.leaflet-container {
	overflow: hidden;
	}
.leaflet-tile,
.leaflet-marker-icon,
.leaflet-marker-shadow {
	-webkit-user-select: none;
	   -moz-user-select: none;
	        user-select: none;
	  -webkit-user-drag: none;
	}
/* Prevents IE11 from highlighting tiles in blue */
.leaflet-tile::-moz-selection {
	background: transparent;
}
.leaflet-tile::selection {
	background: transparent;
}
/* Safari renders non-retina tile on retina better with this, but Chrome is worse */
.leaflet-safari .leaflet-tile {
	image-rendering: -webkit-optimize-contrast;
	}
/* hack that prevents hw layers "stretching" when loading new tiles */
.leaflet-safari .leaflet-tile-container {
	width: 1600px;
	height: 1600px;
	-webkit-transform-origin: 0 0;
	}
.leaflet-marker-icon,
.leaflet-marker-shadow {
	display: block;
	}
/* .leaflet-container svg: reset svg max-width decleration shipped in Joomla! (joomla.org) 3.x */
/* .leaflet-container img: map is broken in FF if you have max-width: 100% on tiles */
.leaflet-container .leaflet-overlay-pane svg {
	max-width: none !important;
	max-height: none !important;
	}
.leaflet-container .leaflet-marker-pane img,
.leaflet-container .leaflet-shadow-pane img,
.leaflet-container .leaflet-tile-pane img,
.leaflet-container img.leaflet-image-layer,
.leaflet-container .leaflet-tile {
	max-width: none !important;
	max-height: none !important;
	width: auto;
	padding: 0;
	}

.leaflet-container img.leaflet-tile {
	/* See: https://bugs.chromium.org/p/chromium/issues/detail?id=600120 */
	mix-blend-mode: plus-lighter;
}

.leaflet-container.leaflet-touch-zoom {
	touch-action: pan-x pan-y;
	}
.leaflet-container.leaflet-touch-drag {
	/* Fallback for FF which doesn't support pinch-zoom */
	touch-action: none;
	touch-action: pinch-zoom;
}
.leaflet-container.leaflet-touch-drag.leaflet-touch-zoom {
	touch-action: none;
}
.leaflet-container {
	-webkit-tap-highlight-color: transparent;
}
.leaflet-container a {
	-webkit-tap-highlight-color: rgba(51, 181, 229, 0.4);
}
.leaflet-tile {
	filter: inherit;
	visibility: hidden;
	}
.leaflet-tile-loaded {
	visibility: inherit;
	}
.leaflet-zoom-box {
	width: 0;
	height: 0;
	box-sizing: border-box;
	z-index: 800;
	}
/* workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=888319 */
.leaflet-overlay-pane svg {
	-moz-user-select: none;
	}

.leaflet-pane         { z-index: 400; }

.leaflet-tile-pane    { z-index: 200; }
.leaflet-overlay-pane { z-index: 400; }
.leaflet-shadow-pane  { z-index: 500; }
.leaflet-marker-pane  { z-index: 600; }
.leaflet-tooltip-pane   { z-index: 650; }
.leaflet-popup-pane   { z-index: 700; }

.leaflet-map-pane canvas { z-index: 100; }
.leaflet-map-pane svg    { z-index: 200; }

.leaflet-vml-shape {
	width: 1px;
	height: 1px;
	}
.lvml {
	behavior: url(#default#VML);
	display: inline-block;
	position: absolute;
	}


/* control positioning */

.leaflet-control {
	position: relative;
	z-index: 800;
	pointer-events: visiblePainted; /* IE 9-10 doesn't have auto */
	pointer-events: auto;
	}
.leaflet-top,
.leaflet-bottom {
	position: absolute;
	z-index: 1000;
	pointer-events: none;
	}
.leaflet-top {
	top: 0;
	}
.leaflet-right {
	right: 0;
	}
.leaflet-bottom {
	bottom: 0;
	}
.leaflet-left {
	left: 0;
	}
.leaflet-control {
	float: left;
	clear: both;
	}
.leaflet-right .leaflet-control {
	float: right;
	}
.leaflet-top .leaflet-control {
	margin-top: 10px;
	}
.leaflet-bottom .leaflet-control {
	margin-bottom: 10px;
	}
.leaflet-left .leaflet-control {
	margin-left: 10px;
	}
.leaflet-right .leaflet-control {
	margin-right: 10px;
	}


/* zoom and fade animations */

.leaflet-fade-anim .leaflet-popup {
	opacity: 0;
	transition: opacity 0.2s linear;
	}
.leaflet-fade-anim .leaflet-map-pane .leaflet-popup {
	opacity: 1;
	}
.leaflet-zoom-animated {
	transform-origin: 0 0;
	}
svg.leaflet-zoom-animated {
	will-change: transform;
}

.leaflet-zoom-anim .leaflet-zoom-animated {
	transition:         transform 0.25s cubic-bezier(0,0,0.25,1);
	}
.leaflet-zoom-anim .leaflet-tile,
.leaflet-pan-anim .leaflet-tile {
	transition: none;
	}

.leaflet-zoom-anim .leaflet-zoom-hide {
	visibility: hidden;
	}


/* cursors */

.leaflet-interactive {
	cursor: pointer;
	}
.leaflet-grab {
	cursor:         grab;
	}
.leaflet-crosshair,
.leaflet-crosshair .leaflet-interactive {
	cursor: crosshair;
	}
.leaflet-popup-pane,
.leaflet-control {
	cursor: auto;
	}
.leaflet-dragging .leaflet-grab,
.leaflet-dragging .leaflet-grab .leaflet-interactive,
.leaflet-dragging .leaflet-marker-draggable {
	cursor: move;
	cursor:         grabbing;
	}

/* marker & overlays interactivity */
.leaflet-marker-icon,
.leaflet-marker-shadow,
.leaflet-image-layer,
.leaflet-pane > svg path,
.leaflet-tile-container {
	pointer-events: none;
	}

.leaflet-marker-icon.leaflet-interactive,
.leaflet-image-layer.leaflet-interactive,
.leaflet-pane > svg path.leaflet-interactive,
svg.leaflet-image-layer.leaflet-interactive path {
	pointer-events: visiblePainted; /* IE 9-10 doesn't have auto */
	pointer-events: auto;
	}

/* visual tweaks */

.leaflet-container {
	background: #ddd;
	outline-offset: 1px;
	}
.leaflet-container a {
	color: #0078A8;
	}
.leaflet-zoom-box {
	border: 2px dotted #38f;
	background: rgba(255,255,255,0.5);
	}


/* general typography */
.leaflet-container {
	font-family: "Helvetica Neue", Arial, Helvetica, sans-serif;
	font-size: 12px;
	font-size: 0.75rem;
	line-height: 1.5;
	}


/* general toolbar styles */

.leaflet-bar {
	box-shadow: 0 1px 5px rgba(0,0,0,0.65);
	border-radius: 4px;
	}
.leaflet-bar a {
	background-color: #fff;
	border-bottom: 1px solid #ccc;
	width: 26px;
	height: 26px;
	line-height: 26px;
	display: block;
	text-align: center;
	-webkit-text-decoration: none;
	text-decoration: none;
	color: black;
	}
.leaflet-bar a,
.leaflet-control-layers-toggle {
	background-position: 50% 50%;
	background-repeat: no-repeat;
	display: block;
	}
.leaflet-bar a:hover,
.leaflet-bar a:focus {
	background-color: #f4f4f4;
	}
.leaflet-bar a:first-child {
	border-top-left-radius: 4px;
	border-top-right-radius: 4px;
	}
.leaflet-bar a:last-child {
	border-bottom-left-radius: 4px;
	border-bottom-right-radius: 4px;
	border-bottom: none;
	}
.leaflet-bar a.leaflet-disabled {
	cursor: default;
	background-color: #f4f4f4;
	color: #bbb;
	}

.leaflet-touch .leaflet-bar a {
	width: 30px;
	height: 30px;
	line-height: 30px;
	}
.leaflet-touch .leaflet-bar a:first-child {
	border-top-left-radius: 2px;
	border-top-right-radius: 2px;
	}
.leaflet-touch .leaflet-bar a:last-child {
	border-bottom-left-radius: 2px;
	border-bottom-right-radius: 2px;
	}

/* zoom control */

.leaflet-control-zoom-in,
.leaflet-control-zoom-out {
	font: bold 18px 'Lucida Console', Monaco, monospace;
	text-indent: 1px;
	}

.leaflet-touch .leaflet-control-zoom-in, .leaflet-touch .leaflet-control-zoom-out  {
	font-size: 22px;
	}


/* layers control */

.leaflet-control-layers {
	box-shadow: 0 1px 5px rgba(0,0,0,0.4);
	background: #fff;
	border-radius: 5px;
	}
.leaflet-control-layers-toggle {
	background-image: url(images/layers.png);
	width: 36px;
	height: 36px;
	}
.leaflet-retina .leaflet-control-layers-toggle {
	background-image: url(images/layers-2x.png);
	background-size: 26px 26px;
	}
.leaflet-touch .leaflet-control-layers-toggle {
	width: 44px;
	height: 44px;
	}
.leaflet-control-layers .leaflet-control-layers-list,
.leaflet-control-layers-expanded .leaflet-control-layers-toggle {
	display: none;
	}
.leaflet-control-layers-expanded .leaflet-control-layers-list {
	display: block;
	position: relative;
	}
.leaflet-control-layers-expanded {
	padding: 6px 10px 6px 6px;
	color: #333;
	background: #fff;
	}
.leaflet-control-layers-scrollbar {
	overflow-y: scroll;
	overflow-x: hidden;
	padding-right: 5px;
	}
.leaflet-control-layers-selector {
	margin-top: 2px;
	position: relative;
	top: 1px;
	}
.leaflet-control-layers label {
	display: block;
	font-size: 13px;
	font-size: 1.08333em;
	}
.leaflet-control-layers-separator {
	height: 0;
	border-top: 1px solid #ddd;
	margin: 5px -10px 5px -6px;
	}

/* Default icon URLs */
.leaflet-default-icon-path { /* used only in path-guessing heuristic, see L.Icon.Default */
	background-image: url(images/marker-icon.png);
	}


/* attribution and scale controls */

.leaflet-container .leaflet-control-attribution {
	background: #fff;
	background: rgba(255, 255, 255, 0.8);
	margin: 0;
	}
.leaflet-control-attribution,
.leaflet-control-scale-line {
	padding: 0 5px;
	color: #333;
	line-height: 1.4;
	}
.leaflet-control-attribution a {
	-webkit-text-decoration: none;
	text-decoration: none;
	}
.leaflet-control-attribution a:hover,
.leaflet-control-attribution a:focus {
	-webkit-text-decoration: underline;
	text-decoration: underline;
	}
.leaflet-attribution-flag {
	display: inline !important;
	vertical-align: baseline !important;
	width: 1em;
	height: 0.6669em;
	}
.leaflet-left .leaflet-control-scale {
	margin-left: 5px;
	}
.leaflet-bottom .leaflet-control-scale {
	margin-bottom: 5px;
	}
.leaflet-control-scale-line {
	border: 2px solid #777;
	border-top: none;
	line-height: 1.1;
	padding: 2px 5px 1px;
	white-space: nowrap;
	box-sizing: border-box;
	background: rgba(255, 255, 255, 0.8);
	text-shadow: 1px 1px #fff;
	}
.leaflet-control-scale-line:not(:first-child) {
	border-top: 2px solid #777;
	border-bottom: none;
	margin-top: -2px;
	}
.leaflet-control-scale-line:not(:first-child):not(:last-child) {
	border-bottom: 2px solid #777;
	}

.leaflet-touch .leaflet-control-attribution,
.leaflet-touch .leaflet-control-layers,
.leaflet-touch .leaflet-bar {
	box-shadow: none;
	}
.leaflet-touch .leaflet-control-layers,
.leaflet-touch .leaflet-bar {
	border: 2px solid rgba(0,0,0,0.2);
	background-clip: padding-box;
	}


/* popup */

.leaflet-popup {
	position: absolute;
	text-align: center;
	margin-bottom: 20px;
	}
.leaflet-popup-content-wrapper {
	padding: 1px;
	text-align: left;
	border-radius: 12px;
	}
.leaflet-popup-content {
	margin: 13px 24px 13px 20px;
	line-height: 1.3;
	font-size: 13px;
	font-size: 1.08333em;
	min-height: 1px;
	}
.leaflet-popup-content p {
	margin: 17px 0;
	margin: 1.3em 0;
	}
.leaflet-popup-tip-container {
	width: 40px;
	height: 20px;
	position: absolute;
	left: 50%;
	margin-top: -1px;
	margin-left: -20px;
	overflow: hidden;
	pointer-events: none;
	}
.leaflet-popup-tip {
	width: 17px;
	height: 17px;
	padding: 1px;

	margin: -10px auto 0;
	pointer-events: auto;
	transform: rotate(45deg);
	}
.leaflet-popup-content-wrapper,
.leaflet-popup-tip {
	background: white;
	color: #333;
	box-shadow: 0 3px 14px rgba(0,0,0,0.4);
	}
.leaflet-container a.leaflet-popup-close-button {
	position: absolute;
	top: 0;
	right: 0;
	border: none;
	text-align: center;
	width: 24px;
	height: 24px;
	font: 16px/24px Tahoma, Verdana, sans-serif;
	color: #757575;
	-webkit-text-decoration: none;
	text-decoration: none;
	background: transparent;
	}
.leaflet-container a.leaflet-popup-close-button:hover,
.leaflet-container a.leaflet-popup-close-button:focus {
	color: #585858;
	}
.leaflet-popup-scrolled {
	overflow: auto;
	}

.leaflet-oldie .leaflet-popup-content-wrapper {
	-ms-zoom: 1;
	}
.leaflet-oldie .leaflet-popup-tip {
	width: 24px;
	margin: 0 auto;

	-ms-filter: "progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678)";
	filter: progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678);
	}

.leaflet-oldie .leaflet-control-zoom,
.leaflet-oldie .leaflet-control-layers,
.leaflet-oldie .leaflet-popup-content-wrapper,
.leaflet-oldie .leaflet-popup-tip {
	border: 1px solid #999;
	}


/* div icon */

.leaflet-div-icon {
	background: #fff;
	border: 1px solid #666;
	}


/* Tooltip */
/* Base styles for the element that has a tooltip */
.leaflet-tooltip {
	position: absolute;
	padding: 6px;
	background-color: #fff;
	border: 1px solid #fff;
	border-radius: 3px;
	color: #222;
	white-space: nowrap;
	-webkit-user-select: none;
	-moz-user-select: none;
	user-select: none;
	pointer-events: none;
	box-shadow: 0 1px 3px rgba(0,0,0,0.4);
	}
.leaflet-tooltip.leaflet-interactive {
	cursor: pointer;
	pointer-events: auto;
	}
.leaflet-tooltip-top:before,
.leaflet-tooltip-bottom:before,
.leaflet-tooltip-left:before,
.leaflet-tooltip-right:before {
	position: absolute;
	pointer-events: none;
	border: 6px solid transparent;
	background: transparent;
	content: "";
	}

/* Directions */

.leaflet-tooltip-bottom {
	margin-top: 6px;
}
.leaflet-tooltip-top {
	margin-top: -6px;
}
.leaflet-tooltip-bottom:before,
.leaflet-tooltip-top:before {
	left: 50%;
	margin-left: -6px;
	}
.leaflet-tooltip-top:before {
	bottom: 0;
	margin-bottom: -12px;
	border-top-color: #fff;
	}
.leaflet-tooltip-bottom:before {
	top: 0;
	margin-top: -12px;
	margin-left: -6px;
	border-bottom-color: #fff;
	}
.leaflet-tooltip-left {
	margin-left: -6px;
}
.leaflet-tooltip-right {
	margin-left: 6px;
}
.leaflet-tooltip-left:before,
.leaflet-tooltip-right:before {
	top: 50%;
	margin-top: -6px;
	}
.leaflet-tooltip-left:before {
	right: 0;
	margin-right: -12px;
	border-left-color: #fff;
	}
.leaflet-tooltip-right:before {
	left: 0;
	margin-left: -12px;
	border-right-color: #fff;
	}

/* Printing */

@media print {
	/* Prevent printers from removing background-images of controls. */
	.leaflet-control {
		-webkit-print-color-adjust: exact;
		print-color-adjust: exact;
		}
	}
`;
styleInject(css_248z$1);

let VehicleMap = class VehicleMap extends s {
    constructor() {
        super(...arguments);
        this.deviceTracker = '';
        this.darkMode = false;
        this.popup = false;
        this.map = null;
        this.marker = null;
        this.lat = 0;
        this.lon = 0;
        this.zoom = 15;
        this.state = '';
        this.address = {};
        this.enableAdress = false;
        this.apiKey = '';
    }
    firstUpdated() {
        this.setEntityAttribute();
    }
    updated(changedProperties) {
        if (changedProperties.has('darkMode')) {
            this.updateCSSVariables();
        }
    }
    setEntityAttribute() {
        const deviceTracker = this.hass.states[this.deviceTracker];
        if (deviceTracker) {
            this.lat = deviceTracker.attributes.latitude;
            this.lon = deviceTracker.attributes.longitude;
            this.state = deviceTracker.state;
            this.getAddress(this.lat, this.lon);
        }
        setTimeout(() => {
            this.initMap();
        }, 200);
    }
    updateCSSVariables() {
        if (this.darkMode) {
            this.style.setProperty('--map-marker-color', 'var(--accent-color)');
        }
        else {
            this.style.setProperty('--map-marker-color', 'var(--primary-color)');
        }
    }
    async getAddress(lat, lon) {
        let address = null;
        if (this.apiKey !== '') {
            address = await this.getAddressFromGoggle(lat, lon);
        }
        else {
            address = await this.getAddressFromOpenStreet(lat, lon);
        }
        if (address) {
            this.address = address;
            this.enableAdress = true;
            this.requestUpdate();
        }
        else {
            this.enableAdress = false;
        }
    }
    static get styles() {
        return [
            css_248z$1,
            i$2 `
        *:focus {
          outline: none;
        }
        :host {
          --map-marker-color: var(--primary-color);
        }
        .map-wrapper {
          width: 100%;
          height: 100%;
        }
        #map {
          height: 100%;
          width: 100%;
          background: transparent !important;
          mask-image: linear-gradient(to right, transparent 0%, black 25%, black 90%, transparent 100%),
            linear-gradient(to bottom, transparent 20%, black 35%, black 90%, transparent 100%);
          mask-composite: intersect;
        }
        .marker {
          position: relative;
          width: 46px;
          height: 46px;
        }
        .marker.dark {
          filter: brightness(0.5);
        }
        .dot {
          position: absolute;
          width: 14px;
          height: 14px;
          background-color: var(--map-marker-color);
          border-radius: 50%;
          top: 50%;
          left: 50%;
          border: 1px solid white;
          transform: translate(-50%, -50%);
          opacity: 0.6;
        }
        .shadow {
          position: absolute;
          width: 100%;
          height: 100%;
          background-image: radial-gradient(circle, var(--map-marker-color) 0%, transparent 100%);
          border-radius: 50%;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          border: none !important;
          opacity: 0.3;
        }
        .marker:hover .dot {
          opacity: 1;
        }
        .leaflet-control-container {
          display: none;
        }
        .reset-button {
          position: absolute;
          top: 15%;
          right: 1rem;
          z-index: 2;
          cursor: pointer;
          opacity: 0.5;
          &:hover {
            opacity: 1;
          }
        }
        .address {
          position: absolute;
          width: max-content;
          height: fit-content;
          top: 50%;
          left: 1rem;
          z-index: 2;
          display: flex;
          align-items: flex-start;
          justify-content: center;
          flex-direction: column;
          gap: 0.5rem;
          color: grey;
          backdrop-filter: blur(1px);
          .address-line {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            text-shadow: 0 0 black;
            span {
              font-size: 0.9rem;
            }
          }
        }
      `,
        ];
    }
    initMap() {
        var _a;
        const mapOptions = {
            dragging: true,
            zoomControl: false,
            scrollWheelZoom: true,
        };
        this.map = leafletSrc.map((_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.getElementById('map'), mapOptions).setView([this.lat, this.lon], this.zoom);
        const tileLayer = this.darkMode ? 'CartoDB.DarkMatter' : 'CartoDB.Positron';
        leafletSrc.tileLayer.provider(tileLayer).addTo(this.map);
        // Define custom icon for marker
        const customIcon = leafletSrc.divIcon({
            html: `<div class="marker">
              <div class="dot"></div>
              <div class="shadow"></div>
            </div>`,
            iconSize: [24, 24],
            iconAnchor: [12, 12],
            className: 'custom-marker',
        });
        // Add marker to map
        this.marker = leafletSrc.marker([this.lat, this.lon], { icon: customIcon }).addTo(this.map);
        // Add click event listener to marker
        if (this.popup) {
            this.marker.on('click', () => {
                this.togglePopup();
            });
        }
        this.marker.bindTooltip(this.state);
        this.updateMap();
    }
    togglePopup() {
        const event = new CustomEvent('toggle-map-popup', {
            detail: {},
            bubbles: true,
            composed: true,
        });
        this.dispatchEvent(event);
    }
    updateMap() {
        if (!this.map || !this.marker)
            return;
        const offset = this.calculateLatLngOffset(this.map, this.lat, this.lon, this.map.getSize().x / 5, 3);
        this.map.setView(offset, this.zoom);
        this.marker.setLatLng([this.lat, this.lon]);
    }
    calculateLatLngOffset(map, lat, lng, xOffset, yOffset) {
        // Convert the lat/lng to a point
        const point = map.latLngToContainerPoint([lat, lng]);
        // Apply the offset
        const newPoint = leafletSrc.point(point.x - xOffset, point.y - yOffset);
        // Convert the point back to lat/lng
        const newLatLng = map.containerPointToLatLng(newPoint);
        return [newLatLng.lat, newLatLng.lng];
    }
    render() {
        return x `
      <div class="map-wrapper">
        <div id="map" style=${this.darkMode ? 'filter: brightness(1.5);' : ''}></div>
        <div class="reset-button" @click=${this.updateMap}>
          <ha-icon icon="mdi:compass"></ha-icon>
        </div>
        ${this._renderAddress()}
      </div>
    `;
    }
    _renderAddress() {
        if (!this.enableAdress)
            return x ``;
        return x `
      <div class="address">
        <div class="address-line">
          <ha-icon icon="mdi:map-marker"></ha-icon>
          <div>
            <span>${this.address.streetNumber} ${this.address.streetName}</span><br /><span
              style="text-transform: uppercase; opacity: 0.8; letter-spacing: 1px"
              >${!this.address.sublocality ? this.address.city : this.address.sublocality}</span
            >
          </div>
        </div>
      </div>
    `;
    }
    async getAddressFromOpenStreet(lat, lon) {
        const url = `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=jsonv2`;
        try {
            const response = await fetch(url);
            const data = await response.json();
            if (response.ok) {
                // Extract address components from the response
                const address = {
                    streetNumber: data.address.house_number || '', // Retrieve street number
                    streetName: data.address.road || '',
                    sublocality: data.address.suburb || data.address.village || '',
                    city: data.address.city || data.address.town || '',
                    state: data.address.state || data.address.county || '',
                    country: data.address.country || '',
                    postcode: data.address.postcode || '',
                };
                return address;
            }
            else {
                throw new Error('Failed to fetch address OpenStreetMap');
            }
        }
        catch (error) {
            // console.error('Error fetching address:', error);
            return null;
        }
    }
    async getAddressFromGoggle(lat, lon) {
        const apiKey = this.apiKey; // Replace with your API key
        const url = `https://maps.googleapis.com/maps/api/geocode/json?latlng=${lat},${lon}&key=${apiKey}`;
        try {
            const response = await fetch(url);
            const data = await response.json();
            if (data.status === 'OK') {
                const addressComponents = data.results[0].address_components;
                let streetNumber = '';
                let streetName = '';
                let sublocality = '';
                let city = '';
                addressComponents.forEach((component) => {
                    if (component.types.includes('street_number')) {
                        streetNumber = component.long_name;
                    }
                    if (component.types.includes('route')) {
                        streetName = component.long_name;
                    }
                    if (component.types.includes('sublocality')) {
                        sublocality = component.short_name;
                    }
                    if (component.types.includes('locality')) {
                        city = component.long_name;
                    }
                    // Sometimes city might be under 'administrative_area_level_2' or 'administrative_area_level_1'
                    if (!city && component.types.includes('administrative_area_level_2')) {
                        city = component.short_name;
                    }
                    if (!city && component.types.includes('administrative_area_level_1')) {
                        city = component.short_name;
                    }
                });
                return {
                    streetNumber,
                    streetName,
                    sublocality,
                    city,
                };
            }
            else {
                throw new Error('No results found');
            }
        }
        catch (error) {
            console.error('Error fetching address:', error);
            return null;
        }
    }
};
__decorate([
    n$1({ attribute: false })
], VehicleMap.prototype, "hass", void 0);
__decorate([
    n$1({ type: String })
], VehicleMap.prototype, "deviceTracker", void 0);
__decorate([
    n$1({ type: Boolean })
], VehicleMap.prototype, "darkMode", void 0);
__decorate([
    n$1({ type: Boolean })
], VehicleMap.prototype, "popup", void 0);
__decorate([
    t$1()
], VehicleMap.prototype, "map", void 0);
__decorate([
    t$1()
], VehicleMap.prototype, "marker", void 0);
__decorate([
    t$1()
], VehicleMap.prototype, "lat", void 0);
__decorate([
    t$1()
], VehicleMap.prototype, "lon", void 0);
__decorate([
    t$1()
], VehicleMap.prototype, "zoom", void 0);
__decorate([
    t$1()
], VehicleMap.prototype, "state", void 0);
__decorate([
    t$1()
], VehicleMap.prototype, "address", void 0);
__decorate([
    t$1()
], VehicleMap.prototype, "enableAdress", void 0);
__decorate([
    t$1()
], VehicleMap.prototype, "apiKey", void 0);
VehicleMap = __decorate([
    e$1('vehicle-map')
], VehicleMap);

/**
 * SSR Window 4.0.2
 * Better handling for window object in SSR environment
 * https://github.com/nolimits4web/ssr-window
 *
 * Copyright 2021, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: December 13, 2021
 */
/* eslint-disable no-param-reassign */
function isObject$1(obj) {
  return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;
}
function extend$1(target, src) {
  if (target === void 0) {
    target = {};
  }
  if (src === void 0) {
    src = {};
  }
  Object.keys(src).forEach(key => {
    if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {
      extend$1(target[key], src[key]);
    }
  });
}
const ssrDocument = {
  body: {},
  addEventListener() {},
  removeEventListener() {},
  activeElement: {
    blur() {},
    nodeName: ''
  },
  querySelector() {
    return null;
  },
  querySelectorAll() {
    return [];
  },
  getElementById() {
    return null;
  },
  createEvent() {
    return {
      initEvent() {}
    };
  },
  createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute() {},
      getElementsByTagName() {
        return [];
      }
    };
  },
  createElementNS() {
    return {};
  },
  importNode() {
    return null;
  },
  location: {
    hash: '',
    host: '',
    hostname: '',
    href: '',
    origin: '',
    pathname: '',
    protocol: '',
    search: ''
  }
};
function getDocument() {
  const doc = typeof document !== 'undefined' ? document : {};
  extend$1(doc, ssrDocument);
  return doc;
}
const ssrWindow = {
  document: ssrDocument,
  navigator: {
    userAgent: ''
  },
  location: {
    hash: '',
    host: '',
    hostname: '',
    href: '',
    origin: '',
    pathname: '',
    protocol: '',
    search: ''
  },
  history: {
    replaceState() {},
    pushState() {},
    go() {},
    back() {}
  },
  CustomEvent: function CustomEvent() {
    return this;
  },
  addEventListener() {},
  removeEventListener() {},
  getComputedStyle() {
    return {
      getPropertyValue() {
        return '';
      }
    };
  },
  Image() {},
  Date() {},
  screen: {},
  setTimeout() {},
  clearTimeout() {},
  matchMedia() {
    return {};
  },
  requestAnimationFrame(callback) {
    if (typeof setTimeout === 'undefined') {
      callback();
      return null;
    }
    return setTimeout(callback, 0);
  },
  cancelAnimationFrame(id) {
    if (typeof setTimeout === 'undefined') {
      return;
    }
    clearTimeout(id);
  }
};
function getWindow() {
  const win = typeof window !== 'undefined' ? window : {};
  extend$1(win, ssrWindow);
  return win;
}

function classesToTokens(classes) {
  if (classes === void 0) {
    classes = '';
  }
  return classes.trim().split(' ').filter(c => !!c.trim());
}

function deleteProps(obj) {
  const object = obj;
  Object.keys(object).forEach(key => {
    try {
      object[key] = null;
    } catch (e) {
      // no getter for object
    }
    try {
      delete object[key];
    } catch (e) {
      // something got wrong
    }
  });
}
function nextTick(callback, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return setTimeout(callback, delay);
}
function now() {
  return Date.now();
}
function getComputedStyle$1(el) {
  const window = getWindow();
  let style;
  if (window.getComputedStyle) {
    style = window.getComputedStyle(el, null);
  }
  if (!style && el.currentStyle) {
    style = el.currentStyle;
  }
  if (!style) {
    style = el.style;
  }
  return style;
}
function getTranslate(el, axis) {
  if (axis === void 0) {
    axis = 'x';
  }
  const window = getWindow();
  let matrix;
  let curTransform;
  let transformMatrix;
  const curStyle = getComputedStyle$1(el);
  if (window.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;
    if (curTransform.split(',').length > 6) {
      curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
    }
    // Some old versions of Webkit choke when 'none' is passed; pass
    // empty string instead in this case
    transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
    matrix = transformMatrix.toString().split(',');
  }
  if (axis === 'x') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;
    // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
    // Normal Browsers
    else curTransform = parseFloat(matrix[4]);
  }
  if (axis === 'y') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;
    // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
    // Normal Browsers
    else curTransform = parseFloat(matrix[5]);
  }
  return curTransform || 0;
}
function isObject(o) {
  return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
}
function isNode(node) {
  // eslint-disable-next-line
  if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
    return node instanceof HTMLElement;
  }
  return node && (node.nodeType === 1 || node.nodeType === 11);
}
function extend() {
  const to = Object(arguments.length <= 0 ? undefined : arguments[0]);
  const noExtend = ['__proto__', 'constructor', 'prototype'];
  for (let i = 1; i < arguments.length; i += 1) {
    const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];
    if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
      const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);
      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== undefined && desc.enumerable) {
          if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend(to[nextKey], nextSource[nextKey]);
            }
          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            to[nextKey] = {};
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend(to[nextKey], nextSource[nextKey]);
            }
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }
  return to;
}
function setCSSProperty(el, varName, varValue) {
  el.style.setProperty(varName, varValue);
}
function animateCSSModeScroll(_ref) {
  let {
    swiper,
    targetPosition,
    side
  } = _ref;
  const window = getWindow();
  const startPosition = -swiper.translate;
  let startTime = null;
  let time;
  const duration = swiper.params.speed;
  swiper.wrapperEl.style.scrollSnapType = 'none';
  window.cancelAnimationFrame(swiper.cssModeFrameID);
  const dir = targetPosition > startPosition ? 'next' : 'prev';
  const isOutOfBound = (current, target) => {
    return dir === 'next' && current >= target || dir === 'prev' && current <= target;
  };
  const animate = () => {
    time = new Date().getTime();
    if (startTime === null) {
      startTime = time;
    }
    const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
    if (isOutOfBound(currentPosition, targetPosition)) {
      currentPosition = targetPosition;
    }
    swiper.wrapperEl.scrollTo({
      [side]: currentPosition
    });
    if (isOutOfBound(currentPosition, targetPosition)) {
      swiper.wrapperEl.style.overflow = 'hidden';
      swiper.wrapperEl.style.scrollSnapType = '';
      setTimeout(() => {
        swiper.wrapperEl.style.overflow = '';
        swiper.wrapperEl.scrollTo({
          [side]: currentPosition
        });
      });
      window.cancelAnimationFrame(swiper.cssModeFrameID);
      return;
    }
    swiper.cssModeFrameID = window.requestAnimationFrame(animate);
  };
  animate();
}
function elementChildren(element, selector) {
  if (selector === void 0) {
    selector = '';
  }
  return [...element.children].filter(el => el.matches(selector));
}
function showWarning(text) {
  try {
    console.warn(text);
    return;
  } catch (err) {
    // err
  }
}
function createElement(tag, classes) {
  if (classes === void 0) {
    classes = [];
  }
  const el = document.createElement(tag);
  el.classList.add(...(Array.isArray(classes) ? classes : classesToTokens(classes)));
  return el;
}
function elementPrevAll(el, selector) {
  const prevEls = [];
  while (el.previousElementSibling) {
    const prev = el.previousElementSibling; // eslint-disable-line
    if (selector) {
      if (prev.matches(selector)) prevEls.push(prev);
    } else prevEls.push(prev);
    el = prev;
  }
  return prevEls;
}
function elementNextAll(el, selector) {
  const nextEls = [];
  while (el.nextElementSibling) {
    const next = el.nextElementSibling; // eslint-disable-line
    if (selector) {
      if (next.matches(selector)) nextEls.push(next);
    } else nextEls.push(next);
    el = next;
  }
  return nextEls;
}
function elementStyle(el, prop) {
  const window = getWindow();
  return window.getComputedStyle(el, null).getPropertyValue(prop);
}
function elementIndex(el) {
  let child = el;
  let i;
  if (child) {
    i = 0;
    // eslint-disable-next-line
    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1) i += 1;
    }
    return i;
  }
  return undefined;
}
function elementParents(el, selector) {
  const parents = []; // eslint-disable-line
  let parent = el.parentElement; // eslint-disable-line
  while (parent) {
    if (selector) {
      if (parent.matches(selector)) parents.push(parent);
    } else {
      parents.push(parent);
    }
    parent = parent.parentElement;
  }
  return parents;
}
function elementOuterSize(el, size, includeMargins) {
  const window = getWindow();
  if (includeMargins) {
    return el[size === 'width' ? 'offsetWidth' : 'offsetHeight'] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-right' : 'margin-top')) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-left' : 'margin-bottom'));
  }
  return el.offsetWidth;
}
function makeElementsArray(el) {
  return (Array.isArray(el) ? el : [el]).filter(e => !!e);
}

let support;
function calcSupport() {
  const window = getWindow();
  const document = getDocument();
  return {
    smoothScroll: document.documentElement && document.documentElement.style && 'scrollBehavior' in document.documentElement.style,
    touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch)
  };
}
function getSupport() {
  if (!support) {
    support = calcSupport();
  }
  return support;
}

let deviceCached;
function calcDevice(_temp) {
  let {
    userAgent
  } = _temp === void 0 ? {} : _temp;
  const support = getSupport();
  const window = getWindow();
  const platform = window.navigator.platform;
  const ua = userAgent || window.navigator.userAgent;
  const device = {
    ios: false,
    android: false
  };
  const screenWidth = window.screen.width;
  const screenHeight = window.screen.height;
  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
  let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  const windows = platform === 'Win32';
  let macos = platform === 'MacIntel';

  // iPadOs 13 fix
  const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];
  if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad) ipad = [0, 1, '13_0_0'];
    macos = false;
  }

  // Android
  if (android && !windows) {
    device.os = 'android';
    device.android = true;
  }
  if (ipad || iphone || ipod) {
    device.os = 'ios';
    device.ios = true;
  }

  // Export object
  return device;
}
function getDevice(overrides) {
  if (overrides === void 0) {
    overrides = {};
  }
  if (!deviceCached) {
    deviceCached = calcDevice(overrides);
  }
  return deviceCached;
}

let browser;
function calcBrowser() {
  const window = getWindow();
  const device = getDevice();
  let needPerspectiveFix = false;
  function isSafari() {
    const ua = window.navigator.userAgent.toLowerCase();
    return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
  }
  if (isSafari()) {
    const ua = String(window.navigator.userAgent);
    if (ua.includes('Version/')) {
      const [major, minor] = ua.split('Version/')[1].split(' ')[0].split('.').map(num => Number(num));
      needPerspectiveFix = major < 16 || major === 16 && minor < 2;
    }
  }
  const isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent);
  const isSafariBrowser = isSafari();
  const need3dFix = isSafariBrowser || isWebView && device.ios;
  return {
    isSafari: needPerspectiveFix || isSafariBrowser,
    needPerspectiveFix,
    need3dFix,
    isWebView
  };
}
function getBrowser() {
  if (!browser) {
    browser = calcBrowser();
  }
  return browser;
}

function Resize(_ref) {
  let {
    swiper,
    on,
    emit
  } = _ref;
  const window = getWindow();
  let observer = null;
  let animationFrame = null;
  const resizeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    emit('beforeResize');
    emit('resize');
  };
  const createObserver = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    observer = new ResizeObserver(entries => {
      animationFrame = window.requestAnimationFrame(() => {
        const {
          width,
          height
        } = swiper;
        let newWidth = width;
        let newHeight = height;
        entries.forEach(_ref2 => {
          let {
            contentBoxSize,
            contentRect,
            target
          } = _ref2;
          if (target && target !== swiper.el) return;
          newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
          newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
        });
        if (newWidth !== width || newHeight !== height) {
          resizeHandler();
        }
      });
    });
    observer.observe(swiper.el);
  };
  const removeObserver = () => {
    if (animationFrame) {
      window.cancelAnimationFrame(animationFrame);
    }
    if (observer && observer.unobserve && swiper.el) {
      observer.unobserve(swiper.el);
      observer = null;
    }
  };
  const orientationChangeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    emit('orientationchange');
  };
  on('init', () => {
    if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {
      createObserver();
      return;
    }
    window.addEventListener('resize', resizeHandler);
    window.addEventListener('orientationchange', orientationChangeHandler);
  });
  on('destroy', () => {
    removeObserver();
    window.removeEventListener('resize', resizeHandler);
    window.removeEventListener('orientationchange', orientationChangeHandler);
  });
}

function Observer(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const observers = [];
  const window = getWindow();
  const attach = function (target, options) {
    if (options === void 0) {
      options = {};
    }
    const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
    const observer = new ObserverFunc(mutations => {
      // The observerUpdate event should only be triggered
      // once despite the number of mutations.  Additional
      // triggers are redundant and are very costly
      if (swiper.__preventObserver__) return;
      if (mutations.length === 1) {
        emit('observerUpdate', mutations[0]);
        return;
      }
      const observerUpdate = function observerUpdate() {
        emit('observerUpdate', mutations[0]);
      };
      if (window.requestAnimationFrame) {
        window.requestAnimationFrame(observerUpdate);
      } else {
        window.setTimeout(observerUpdate, 0);
      }
    });
    observer.observe(target, {
      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
      childList: typeof options.childList === 'undefined' ? true : options.childList,
      characterData: typeof options.characterData === 'undefined' ? true : options.characterData
    });
    observers.push(observer);
  };
  const init = () => {
    if (!swiper.params.observer) return;
    if (swiper.params.observeParents) {
      const containerParents = elementParents(swiper.hostEl);
      for (let i = 0; i < containerParents.length; i += 1) {
        attach(containerParents[i]);
      }
    }
    // Observe container
    attach(swiper.hostEl, {
      childList: swiper.params.observeSlideChildren
    });

    // Observe wrapper
    attach(swiper.wrapperEl, {
      attributes: false
    });
  };
  const destroy = () => {
    observers.forEach(observer => {
      observer.disconnect();
    });
    observers.splice(0, observers.length);
  };
  extendParams({
    observer: false,
    observeParents: false,
    observeSlideChildren: false
  });
  on('init', init);
  on('destroy', destroy);
}

/* eslint-disable no-underscore-dangle */

var eventsEmitter = {
  on(events, handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (typeof handler !== 'function') return self;
    const method = priority ? 'unshift' : 'push';
    events.split(' ').forEach(event => {
      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
      self.eventsListeners[event][method](handler);
    });
    return self;
  },
  once(events, handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (typeof handler !== 'function') return self;
    function onceHandler() {
      self.off(events, onceHandler);
      if (onceHandler.__emitterProxy) {
        delete onceHandler.__emitterProxy;
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      handler.apply(self, args);
    }
    onceHandler.__emitterProxy = handler;
    return self.on(events, onceHandler, priority);
  },
  onAny(handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (typeof handler !== 'function') return self;
    const method = priority ? 'unshift' : 'push';
    if (self.eventsAnyListeners.indexOf(handler) < 0) {
      self.eventsAnyListeners[method](handler);
    }
    return self;
  },
  offAny(handler) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (!self.eventsAnyListeners) return self;
    const index = self.eventsAnyListeners.indexOf(handler);
    if (index >= 0) {
      self.eventsAnyListeners.splice(index, 1);
    }
    return self;
  },
  off(events, handler) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (!self.eventsListeners) return self;
    events.split(' ').forEach(event => {
      if (typeof handler === 'undefined') {
        self.eventsListeners[event] = [];
      } else if (self.eventsListeners[event]) {
        self.eventsListeners[event].forEach((eventHandler, index) => {
          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
            self.eventsListeners[event].splice(index, 1);
          }
        });
      }
    });
    return self;
  },
  emit() {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (!self.eventsListeners) return self;
    let events;
    let data;
    let context;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
      events = args[0];
      data = args.slice(1, args.length);
      context = self;
    } else {
      events = args[0].events;
      data = args[0].data;
      context = args[0].context || self;
    }
    data.unshift(context);
    const eventsArray = Array.isArray(events) ? events : events.split(' ');
    eventsArray.forEach(event => {
      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
        self.eventsAnyListeners.forEach(eventHandler => {
          eventHandler.apply(context, [event, ...data]);
        });
      }
      if (self.eventsListeners && self.eventsListeners[event]) {
        self.eventsListeners[event].forEach(eventHandler => {
          eventHandler.apply(context, data);
        });
      }
    });
    return self;
  }
};

function updateSize() {
  const swiper = this;
  let width;
  let height;
  const el = swiper.el;
  if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
    width = swiper.params.width;
  } else {
    width = el.clientWidth;
  }
  if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
    height = swiper.params.height;
  } else {
    height = el.clientHeight;
  }
  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
    return;
  }

  // Subtract paddings
  width = width - parseInt(elementStyle(el, 'padding-left') || 0, 10) - parseInt(elementStyle(el, 'padding-right') || 0, 10);
  height = height - parseInt(elementStyle(el, 'padding-top') || 0, 10) - parseInt(elementStyle(el, 'padding-bottom') || 0, 10);
  if (Number.isNaN(width)) width = 0;
  if (Number.isNaN(height)) height = 0;
  Object.assign(swiper, {
    width,
    height,
    size: swiper.isHorizontal() ? width : height
  });
}

function updateSlides() {
  const swiper = this;
  function getDirectionPropertyValue(node, label) {
    return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);
  }
  const params = swiper.params;
  const {
    wrapperEl,
    slidesEl,
    size: swiperSize,
    rtlTranslate: rtl,
    wrongRTL
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  let snapGrid = [];
  const slidesGrid = [];
  const slidesSizesGrid = [];
  let offsetBefore = params.slidesOffsetBefore;
  if (typeof offsetBefore === 'function') {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }
  let offsetAfter = params.slidesOffsetAfter;
  if (typeof offsetAfter === 'function') {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }
  const previousSnapGridLength = swiper.snapGrid.length;
  const previousSlidesGridLength = swiper.slidesGrid.length;
  let spaceBetween = params.spaceBetween;
  let slidePosition = -offsetBefore;
  let prevSlideSize = 0;
  let index = 0;
  if (typeof swiperSize === 'undefined') {
    return;
  }
  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
  } else if (typeof spaceBetween === 'string') {
    spaceBetween = parseFloat(spaceBetween);
  }
  swiper.virtualSize = -spaceBetween;

  // reset margins
  slides.forEach(slideEl => {
    if (rtl) {
      slideEl.style.marginLeft = '';
    } else {
      slideEl.style.marginRight = '';
    }
    slideEl.style.marginBottom = '';
    slideEl.style.marginTop = '';
  });

  // reset cssMode offsets
  if (params.centeredSlides && params.cssMode) {
    setCSSProperty(wrapperEl, '--swiper-centered-offset-before', '');
    setCSSProperty(wrapperEl, '--swiper-centered-offset-after', '');
  }
  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
  if (gridEnabled) {
    swiper.grid.initSlides(slides);
  } else if (swiper.grid) {
    swiper.grid.unsetSlides();
  }

  // Calc slides
  let slideSize;
  const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {
    return typeof params.breakpoints[key].slidesPerView !== 'undefined';
  }).length > 0;
  for (let i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    let slide;
    if (slides[i]) slide = slides[i];
    if (gridEnabled) {
      swiper.grid.updateSlide(i, slide, slides);
    }
    if (slides[i] && elementStyle(slide, 'display') === 'none') continue; // eslint-disable-line

    if (params.slidesPerView === 'auto') {
      if (shouldResetSlideSize) {
        slides[i].style[swiper.getDirectionLabel('width')] = ``;
      }
      const slideStyles = getComputedStyle(slide);
      const currentTransform = slide.style.transform;
      const currentWebKitTransform = slide.style.webkitTransform;
      if (currentTransform) {
        slide.style.transform = 'none';
      }
      if (currentWebKitTransform) {
        slide.style.webkitTransform = 'none';
      }
      if (params.roundLengths) {
        slideSize = swiper.isHorizontal() ? elementOuterSize(slide, 'width', true) : elementOuterSize(slide, 'height', true);
      } else {
        // eslint-disable-next-line
        const width = getDirectionPropertyValue(slideStyles, 'width');
        const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
        const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
        const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
        const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
        const boxSizing = slideStyles.getPropertyValue('box-sizing');
        if (boxSizing && boxSizing === 'border-box') {
          slideSize = width + marginLeft + marginRight;
        } else {
          const {
            clientWidth,
            offsetWidth
          } = slide;
          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
        }
      }
      if (currentTransform) {
        slide.style.transform = currentTransform;
      }
      if (currentWebKitTransform) {
        slide.style.webkitTransform = currentWebKitTransform;
      }
      if (params.roundLengths) slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
      if (params.roundLengths) slideSize = Math.floor(slideSize);
      if (slides[i]) {
        slides[i].style[swiper.getDirectionLabel('width')] = `${slideSize}px`;
      }
    }
    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }
    slidesSizesGrid.push(slideSize);
    if (params.centeredSlides) {
      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }
    swiper.virtualSize += slideSize + spaceBetween;
    prevSlideSize = slideSize;
    index += 1;
  }
  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
    wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
  }
  if (params.setWrapperSize) {
    wrapperEl.style[swiper.getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;
  }
  if (gridEnabled) {
    swiper.grid.updateWrapperSize(slideSize, snapGrid);
  }

  // Remove last grid elements depending on width
  if (!params.centeredSlides) {
    const newSlidesGrid = [];
    for (let i = 0; i < snapGrid.length; i += 1) {
      let slidesGridItem = snapGrid[i];
      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(slidesGridItem);
      }
    }
    snapGrid = newSlidesGrid;
    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }
  if (isVirtual && params.loop) {
    const size = slidesSizesGrid[0] + spaceBetween;
    if (params.slidesPerGroup > 1) {
      const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
      const groupSize = size * params.slidesPerGroup;
      for (let i = 0; i < groups; i += 1) {
        snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
      }
    }
    for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {
      if (params.slidesPerGroup === 1) {
        snapGrid.push(snapGrid[snapGrid.length - 1] + size);
      }
      slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
      swiper.virtualSize += size;
    }
  }
  if (snapGrid.length === 0) snapGrid = [0];
  if (spaceBetween !== 0) {
    const key = swiper.isHorizontal() && rtl ? 'marginLeft' : swiper.getDirectionLabel('marginRight');
    slides.filter((_, slideIndex) => {
      if (!params.cssMode || params.loop) return true;
      if (slideIndex === slides.length - 1) {
        return false;
      }
      return true;
    }).forEach(slideEl => {
      slideEl.style[key] = `${spaceBetween}px`;
    });
  }
  if (params.centeredSlides && params.centeredSlidesBounds) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach(slideSizeValue => {
      allSlidesSize += slideSizeValue + (spaceBetween || 0);
    });
    allSlidesSize -= spaceBetween;
    const maxSnap = allSlidesSize - swiperSize;
    snapGrid = snapGrid.map(snap => {
      if (snap <= 0) return -offsetBefore;
      if (snap > maxSnap) return maxSnap + offsetAfter;
      return snap;
    });
  }
  if (params.centerInsufficientSlides) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach(slideSizeValue => {
      allSlidesSize += slideSizeValue + (spaceBetween || 0);
    });
    allSlidesSize -= spaceBetween;
    const offsetSize = (params.slidesOffsetBefore || 0) + (params.slidesOffsetAfter || 0);
    if (allSlidesSize + offsetSize < swiperSize) {
      const allSlidesOffset = (swiperSize - allSlidesSize - offsetSize) / 2;
      snapGrid.forEach((snap, snapIndex) => {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach((snap, snapIndex) => {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }
  Object.assign(swiper, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid
  });
  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
    setCSSProperty(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
    setCSSProperty(wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
    const addToSnapGrid = -swiper.snapGrid[0];
    const addToSlidesGrid = -swiper.slidesGrid[0];
    swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);
    swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);
  }
  if (slidesLength !== previousSlidesLength) {
    swiper.emit('slidesLengthChange');
  }
  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow) swiper.checkOverflow();
    swiper.emit('snapGridLengthChange');
  }
  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit('slidesGridLengthChange');
  }
  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }
  swiper.emit('slidesUpdated');
  if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {
    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
    const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
    if (slidesLength <= params.maxBackfaceHiddenSlides) {
      if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);
    } else if (hasClassBackfaceClassAdded) {
      swiper.el.classList.remove(backFaceHiddenClass);
    }
  }
}

function updateAutoHeight(speed) {
  const swiper = this;
  const activeSlides = [];
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  let newHeight = 0;
  let i;
  if (typeof speed === 'number') {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }
  const getSlideByIndex = index => {
    if (isVirtual) {
      return swiper.slides[swiper.getSlideIndexByData(index)];
    }
    return swiper.slides[index];
  };
  // Find slides currently in view
  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
    if (swiper.params.centeredSlides) {
      (swiper.visibleSlides || []).forEach(slide => {
        activeSlides.push(slide);
      });
    } else {
      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
        const index = swiper.activeIndex + i;
        if (index > swiper.slides.length && !isVirtual) break;
        activeSlides.push(getSlideByIndex(index));
      }
    }
  } else {
    activeSlides.push(getSlideByIndex(swiper.activeIndex));
  }

  // Find new height from highest slide in view
  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== 'undefined') {
      const height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  }

  // Update Height
  if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;
}

function updateSlidesOffset() {
  const swiper = this;
  const slides = swiper.slides;
  // eslint-disable-next-line
  const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
  for (let i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
  }
}

const toggleSlideClasses$1 = (slideEl, condition, className) => {
  if (condition && !slideEl.classList.contains(className)) {
    slideEl.classList.add(className);
  } else if (!condition && slideEl.classList.contains(className)) {
    slideEl.classList.remove(className);
  }
};
function updateSlidesProgress(translate) {
  if (translate === void 0) {
    translate = this && this.translate || 0;
  }
  const swiper = this;
  const params = swiper.params;
  const {
    slides,
    rtlTranslate: rtl,
    snapGrid
  } = swiper;
  if (slides.length === 0) return;
  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
  let offsetCenter = -translate;
  if (rtl) offsetCenter = translate;
  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];
  let spaceBetween = params.spaceBetween;
  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;
  } else if (typeof spaceBetween === 'string') {
    spaceBetween = parseFloat(spaceBetween);
  }
  for (let i = 0; i < slides.length; i += 1) {
    const slide = slides[i];
    let slideOffset = slide.swiperSlideOffset;
    if (params.cssMode && params.centeredSlides) {
      slideOffset -= slides[0].swiperSlideOffset;
    }
    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
    const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
    const slideBefore = -(offsetCenter - slideOffset);
    const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
    const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i];
    const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
    if (isVisible) {
      swiper.visibleSlides.push(slide);
      swiper.visibleSlidesIndexes.push(i);
    }
    toggleSlideClasses$1(slide, isVisible, params.slideVisibleClass);
    toggleSlideClasses$1(slide, isFullyVisible, params.slideFullyVisibleClass);
    slide.progress = rtl ? -slideProgress : slideProgress;
    slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
  }
}

function updateProgress(translate) {
  const swiper = this;
  if (typeof translate === 'undefined') {
    const multiplier = swiper.rtlTranslate ? -1 : 1;
    // eslint-disable-next-line
    translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
  }
  const params = swiper.params;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  let {
    progress,
    isBeginning,
    isEnd,
    progressLoop
  } = swiper;
  const wasBeginning = isBeginning;
  const wasEnd = isEnd;
  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate - swiper.minTranslate()) / translatesDiff;
    const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;
    const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;
    isBeginning = isBeginningRounded || progress <= 0;
    isEnd = isEndRounded || progress >= 1;
    if (isBeginningRounded) progress = 0;
    if (isEndRounded) progress = 1;
  }
  if (params.loop) {
    const firstSlideIndex = swiper.getSlideIndexByData(0);
    const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
    const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
    const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
    const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
    const translateAbs = Math.abs(translate);
    if (translateAbs >= firstSlideTranslate) {
      progressLoop = (translateAbs - firstSlideTranslate) / translateMax;
    } else {
      progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
    }
    if (progressLoop > 1) progressLoop -= 1;
  }
  Object.assign(swiper, {
    progress,
    progressLoop,
    isBeginning,
    isEnd
  });
  if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
  if (isBeginning && !wasBeginning) {
    swiper.emit('reachBeginning toEdge');
  }
  if (isEnd && !wasEnd) {
    swiper.emit('reachEnd toEdge');
  }
  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
    swiper.emit('fromEdge');
  }
  swiper.emit('progress', progress);
}

const toggleSlideClasses = (slideEl, condition, className) => {
  if (condition && !slideEl.classList.contains(className)) {
    slideEl.classList.add(className);
  } else if (!condition && slideEl.classList.contains(className)) {
    slideEl.classList.remove(className);
  }
};
function updateSlidesClasses() {
  const swiper = this;
  const {
    slides,
    params,
    slidesEl,
    activeIndex
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  const getFilteredSlide = selector => {
    return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
  };
  let activeSlide;
  let prevSlide;
  let nextSlide;
  if (isVirtual) {
    if (params.loop) {
      let slideIndex = activeIndex - swiper.virtual.slidesBefore;
      if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;
      if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;
      activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
    } else {
      activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`);
    }
  } else {
    if (gridEnabled) {
      activeSlide = slides.filter(slideEl => slideEl.column === activeIndex)[0];
      nextSlide = slides.filter(slideEl => slideEl.column === activeIndex + 1)[0];
      prevSlide = slides.filter(slideEl => slideEl.column === activeIndex - 1)[0];
    } else {
      activeSlide = slides[activeIndex];
    }
  }
  if (activeSlide) {
    if (!gridEnabled) {
      // Next Slide
      nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
      if (params.loop && !nextSlide) {
        nextSlide = slides[0];
      }

      // Prev Slide
      prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
      if (params.loop && !prevSlide === 0) {
        prevSlide = slides[slides.length - 1];
      }
    }
  }
  slides.forEach(slideEl => {
    toggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);
    toggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);
    toggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);
  });
  swiper.emitSlidesClasses();
}

const processLazyPreloader = (swiper, imageEl) => {
  if (!swiper || swiper.destroyed || !swiper.params) return;
  const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
  const slideEl = imageEl.closest(slideSelector());
  if (slideEl) {
    let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
    if (!lazyEl && swiper.isElement) {
      if (slideEl.shadowRoot) {
        lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
      } else {
        // init later
        requestAnimationFrame(() => {
          if (slideEl.shadowRoot) {
            lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
            if (lazyEl) lazyEl.remove();
          }
        });
      }
    }
    if (lazyEl) lazyEl.remove();
  }
};
const unlazy = (swiper, index) => {
  if (!swiper.slides[index]) return;
  const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
  if (imageEl) imageEl.removeAttribute('loading');
};
const preload = swiper => {
  if (!swiper || swiper.destroyed || !swiper.params) return;
  let amount = swiper.params.lazyPreloadPrevNext;
  const len = swiper.slides.length;
  if (!len || !amount || amount < 0) return;
  amount = Math.min(amount, len);
  const slidesPerView = swiper.params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
  const activeIndex = swiper.activeIndex;
  if (swiper.params.grid && swiper.params.grid.rows > 1) {
    const activeColumn = activeIndex;
    const preloadColumns = [activeColumn - amount];
    preloadColumns.push(...Array.from({
      length: amount
    }).map((_, i) => {
      return activeColumn + slidesPerView + i;
    }));
    swiper.slides.forEach((slideEl, i) => {
      if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);
    });
    return;
  }
  const slideIndexLastInView = activeIndex + slidesPerView - 1;
  if (swiper.params.rewind || swiper.params.loop) {
    for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {
      const realIndex = (i % len + len) % len;
      if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);
    }
  } else {
    for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {
      if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {
        unlazy(swiper, i);
      }
    }
  }
};

function getActiveIndexByTranslate(swiper) {
  const {
    slidesGrid,
    params
  } = swiper;
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  let activeIndex;
  for (let i = 0; i < slidesGrid.length; i += 1) {
    if (typeof slidesGrid[i + 1] !== 'undefined') {
      if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
        activeIndex = i;
      } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
        activeIndex = i + 1;
      }
    } else if (translate >= slidesGrid[i]) {
      activeIndex = i;
    }
  }
  // Normalize slideIndex
  if (params.normalizeSlideIndex) {
    if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
  }
  return activeIndex;
}
function updateActiveIndex(newActiveIndex) {
  const swiper = this;
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  const {
    snapGrid,
    params,
    activeIndex: previousIndex,
    realIndex: previousRealIndex,
    snapIndex: previousSnapIndex
  } = swiper;
  let activeIndex = newActiveIndex;
  let snapIndex;
  const getVirtualRealIndex = aIndex => {
    let realIndex = aIndex - swiper.virtual.slidesBefore;
    if (realIndex < 0) {
      realIndex = swiper.virtual.slides.length + realIndex;
    }
    if (realIndex >= swiper.virtual.slides.length) {
      realIndex -= swiper.virtual.slides.length;
    }
    return realIndex;
  };
  if (typeof activeIndex === 'undefined') {
    activeIndex = getActiveIndexByTranslate(swiper);
  }
  if (snapGrid.indexOf(translate) >= 0) {
    snapIndex = snapGrid.indexOf(translate);
  } else {
    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
  if (activeIndex === previousIndex && !swiper.params.loop) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit('snapIndexChange');
    }
    return;
  }
  if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
    swiper.realIndex = getVirtualRealIndex(activeIndex);
    return;
  }
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;

  // Get real index
  let realIndex;
  if (swiper.virtual && params.virtual.enabled && params.loop) {
    realIndex = getVirtualRealIndex(activeIndex);
  } else if (gridEnabled) {
    const firstSlideInColumn = swiper.slides.filter(slideEl => slideEl.column === activeIndex)[0];
    let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute('data-swiper-slide-index'), 10);
    if (Number.isNaN(activeSlideIndex)) {
      activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);
    }
    realIndex = Math.floor(activeSlideIndex / params.grid.rows);
  } else if (swiper.slides[activeIndex]) {
    const slideIndex = swiper.slides[activeIndex].getAttribute('data-swiper-slide-index');
    if (slideIndex) {
      realIndex = parseInt(slideIndex, 10);
    } else {
      realIndex = activeIndex;
    }
  } else {
    realIndex = activeIndex;
  }
  Object.assign(swiper, {
    previousSnapIndex,
    snapIndex,
    previousRealIndex,
    realIndex,
    previousIndex,
    activeIndex
  });
  if (swiper.initialized) {
    preload(swiper);
  }
  swiper.emit('activeIndexChange');
  swiper.emit('snapIndexChange');
  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
    if (previousRealIndex !== realIndex) {
      swiper.emit('realIndexChange');
    }
    swiper.emit('slideChange');
  }
}

function updateClickedSlide(el, path) {
  const swiper = this;
  const params = swiper.params;
  let slide = el.closest(`.${params.slideClass}, swiper-slide`);
  if (!slide && swiper.isElement && path && path.length > 1 && path.includes(el)) {
    [...path.slice(path.indexOf(el) + 1, path.length)].forEach(pathEl => {
      if (!slide && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {
        slide = pathEl;
      }
    });
  }
  let slideFound = false;
  let slideIndex;
  if (slide) {
    for (let i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide) {
        slideFound = true;
        slideIndex = i;
        break;
      }
    }
  }
  if (slide && slideFound) {
    swiper.clickedSlide = slide;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt(slide.getAttribute('data-swiper-slide-index'), 10);
    } else {
      swiper.clickedIndex = slideIndex;
    }
  } else {
    swiper.clickedSlide = undefined;
    swiper.clickedIndex = undefined;
    return;
  }
  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}

var update = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide
};

function getSwiperTranslate(axis) {
  if (axis === void 0) {
    axis = this.isHorizontal() ? 'x' : 'y';
  }
  const swiper = this;
  const {
    params,
    rtlTranslate: rtl,
    translate,
    wrapperEl
  } = swiper;
  if (params.virtualTranslate) {
    return rtl ? -translate : translate;
  }
  if (params.cssMode) {
    return translate;
  }
  let currentTranslate = getTranslate(wrapperEl, axis);
  currentTranslate += swiper.cssOverflowAdjustment();
  if (rtl) currentTranslate = -currentTranslate;
  return currentTranslate || 0;
}

function setTranslate(translate, byController) {
  const swiper = this;
  const {
    rtlTranslate: rtl,
    params,
    wrapperEl,
    progress
  } = swiper;
  let x = 0;
  let y = 0;
  const z = 0;
  if (swiper.isHorizontal()) {
    x = rtl ? -translate : translate;
  } else {
    y = translate;
  }
  if (params.roundLengths) {
    x = Math.floor(x);
    y = Math.floor(y);
  }
  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x : y;
  if (params.cssMode) {
    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
  } else if (!params.virtualTranslate) {
    if (swiper.isHorizontal()) {
      x -= swiper.cssOverflowAdjustment();
    } else {
      y -= swiper.cssOverflowAdjustment();
    }
    wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
  }

  // Check if we need to update progress
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== progress) {
    swiper.updateProgress(translate);
  }
  swiper.emit('setTranslate', swiper.translate, byController);
}

function minTranslate() {
  return -this.snapGrid[0];
}

function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}

function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
  if (translate === void 0) {
    translate = 0;
  }
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (translateBounds === void 0) {
    translateBounds = true;
  }
  const swiper = this;
  const {
    params,
    wrapperEl
  } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }
  const minTranslate = swiper.minTranslate();
  const maxTranslate = swiper.maxTranslate();
  let newTranslate;
  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate;

  // Update progress
  swiper.updateProgress(newTranslate);
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
    } else {
      if (!swiper.support.smoothScroll) {
        animateCSSModeScroll({
          swiper,
          targetPosition: -newTranslate,
          side: isH ? 'left' : 'top'
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? 'left' : 'top']: -newTranslate,
        behavior: 'smooth'
      });
    }
    return true;
  }
  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionEnd');
    }
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionStart');
    }
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onTranslateToWrapperTransitionEnd) {
        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.wrapperEl.removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.onTranslateToWrapperTransitionEnd = null;
          delete swiper.onTranslateToWrapperTransitionEnd;
          swiper.animating = false;
          if (runCallbacks) {
            swiper.emit('transitionEnd');
          }
        };
      }
      swiper.wrapperEl.addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
    }
  }
  return true;
}

var translate = {
  getTranslate: getSwiperTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
  translateTo
};

function setTransition(duration, byController) {
  const swiper = this;
  if (!swiper.params.cssMode) {
    swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
    swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : '';
  }
  swiper.emit('setTransition', duration, byController);
}

function transitionEmit(_ref) {
  let {
    swiper,
    runCallbacks,
    direction,
    step
  } = _ref;
  const {
    activeIndex,
    previousIndex
  } = swiper;
  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
  }
  swiper.emit(`transition${step}`);
  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit(`slideResetTransition${step}`);
      return;
    }
    swiper.emit(`slideChangeTransition${step}`);
    if (dir === 'next') {
      swiper.emit(`slideNextTransition${step}`);
    } else {
      swiper.emit(`slidePrevTransition${step}`);
    }
  }
}

function transitionStart(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    params
  } = swiper;
  if (params.cssMode) return;
  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: 'Start'
  });
}

function transitionEnd(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    params
  } = swiper;
  swiper.animating = false;
  if (params.cssMode) return;
  swiper.setTransition(0);
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: 'End'
  });
}

var transition = {
  setTransition,
  transitionStart,
  transitionEnd
};

function slideTo(index, speed, runCallbacks, internal, initial) {
  if (index === void 0) {
    index = 0;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (typeof index === 'string') {
    index = parseInt(index, 10);
  }
  const swiper = this;
  let slideIndex = index;
  if (slideIndex < 0) slideIndex = 0;
  const {
    params,
    snapGrid,
    slidesGrid,
    previousIndex,
    activeIndex,
    rtlTranslate: rtl,
    wrapperEl,
    enabled
  } = swiper;
  if (!enabled && !internal && !initial || swiper.destroyed || swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
  const translate = -snapGrid[snapIndex];
  // Normalize slideIndex
  if (params.normalizeSlideIndex) {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      const normalizedTranslate = -Math.floor(translate * 100);
      const normalizedGrid = Math.floor(slidesGrid[i] * 100);
      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
          slideIndex = i;
        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
          slideIndex = i + 1;
        }
      } else if (normalizedTranslate >= normalizedGrid) {
        slideIndex = i;
      }
    }
  }
  // Directions locks
  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {
      return false;
    }
    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) {
        return false;
      }
    }
  }
  if (slideIndex !== (previousIndex || 0) && runCallbacks) {
    swiper.emit('beforeSlideChangeStart');
  }

  // Update progress
  swiper.updateProgress(translate);
  let direction;
  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset';

  // Update Index
  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
    swiper.updateActiveIndex(slideIndex);
    // Update Height
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    swiper.updateSlidesClasses();
    if (params.effect !== 'slide') {
      swiper.setTranslate(translate);
    }
    if (direction !== 'reset') {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }
    return false;
  }
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    const t = rtl ? translate : -translate;
    if (speed === 0) {
      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      if (isVirtual) {
        swiper.wrapperEl.style.scrollSnapType = 'none';
        swiper._immediateVirtual = true;
      }
      if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
        swiper._cssModeVirtualInitialSet = true;
        requestAnimationFrame(() => {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
        });
      } else {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
      }
      if (isVirtual) {
        requestAnimationFrame(() => {
          swiper.wrapperEl.style.scrollSnapType = '';
          swiper._immediateVirtual = false;
        });
      }
    } else {
      if (!swiper.support.smoothScroll) {
        animateCSSModeScroll({
          swiper,
          targetPosition: t,
          side: isH ? 'left' : 'top'
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? 'left' : 'top']: t,
        behavior: 'smooth'
      });
    }
    return true;
  }
  swiper.setTransition(speed);
  swiper.setTranslate(translate);
  swiper.updateActiveIndex(slideIndex);
  swiper.updateSlidesClasses();
  swiper.emit('beforeTransitionStart', speed, internal);
  swiper.transitionStart(runCallbacks, direction);
  if (speed === 0) {
    swiper.transitionEnd(runCallbacks, direction);
  } else if (!swiper.animating) {
    swiper.animating = true;
    if (!swiper.onSlideToWrapperTransitionEnd) {
      swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
        if (!swiper || swiper.destroyed) return;
        if (e.target !== this) return;
        swiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
        swiper.onSlideToWrapperTransitionEnd = null;
        delete swiper.onSlideToWrapperTransitionEnd;
        swiper.transitionEnd(runCallbacks, direction);
      };
    }
    swiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
  }
  return true;
}

function slideToLoop(index, speed, runCallbacks, internal) {
  if (index === void 0) {
    index = 0;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (typeof index === 'string') {
    const indexAsNumber = parseInt(index, 10);
    index = indexAsNumber;
  }
  const swiper = this;
  if (swiper.destroyed) return;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;
  let newIndex = index;
  if (swiper.params.loop) {
    if (swiper.virtual && swiper.params.virtual.enabled) {
      // eslint-disable-next-line
      newIndex = newIndex + swiper.virtual.slidesBefore;
    } else {
      let targetSlideIndex;
      if (gridEnabled) {
        const slideIndex = newIndex * swiper.params.grid.rows;
        targetSlideIndex = swiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === slideIndex)[0].column;
      } else {
        targetSlideIndex = swiper.getSlideIndexByData(newIndex);
      }
      const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;
      const {
        centeredSlides
      } = swiper.params;
      let slidesPerView = swiper.params.slidesPerView;
      if (slidesPerView === 'auto') {
        slidesPerView = swiper.slidesPerViewDynamic();
      } else {
        slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));
        if (centeredSlides && slidesPerView % 2 === 0) {
          slidesPerView = slidesPerView + 1;
        }
      }
      let needLoopFix = cols - targetSlideIndex < slidesPerView;
      if (centeredSlides) {
        needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);
      }
      if (internal && centeredSlides && swiper.params.slidesPerView !== 'auto' && !gridEnabled) {
        needLoopFix = false;
      }
      if (needLoopFix) {
        const direction = centeredSlides ? targetSlideIndex < swiper.activeIndex ? 'prev' : 'next' : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? 'next' : 'prev';
        swiper.loopFix({
          direction,
          slideTo: true,
          activeSlideIndex: direction === 'next' ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,
          slideRealIndex: direction === 'next' ? swiper.realIndex : undefined
        });
      }
      if (gridEnabled) {
        const slideIndex = newIndex * swiper.params.grid.rows;
        newIndex = swiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === slideIndex)[0].column;
      } else {
        newIndex = swiper.getSlideIndexByData(newIndex);
      }
    }
  }
  requestAnimationFrame(() => {
    swiper.slideTo(newIndex, speed, runCallbacks, internal);
  });
  return swiper;
}

/* eslint no-unused-vars: "off" */
function slideNext(speed, runCallbacks, internal) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    enabled,
    params,
    animating
  } = swiper;
  if (!enabled || swiper.destroyed) return swiper;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  let perGroup = params.slidesPerGroup;
  if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
    perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
  }
  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding) return false;
    swiper.loopFix({
      direction: 'next'
    });
    // eslint-disable-next-line
    swiper._clientLeft = swiper.wrapperEl.clientLeft;
    if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {
      requestAnimationFrame(() => {
        swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
      });
      return true;
    }
  }
  if (params.rewind && swiper.isEnd) {
    return swiper.slideTo(0, speed, runCallbacks, internal);
  }
  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slidePrev(speed, runCallbacks, internal) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    params,
    snapGrid,
    slidesGrid,
    rtlTranslate,
    enabled,
    animating
  } = swiper;
  if (!enabled || swiper.destroyed) return swiper;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  const isVirtual = swiper.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding) return false;
    swiper.loopFix({
      direction: 'prev'
    });
    // eslint-disable-next-line
    swiper._clientLeft = swiper.wrapperEl.clientLeft;
  }
  const translate = rtlTranslate ? swiper.translate : -swiper.translate;
  function normalize(val) {
    if (val < 0) return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }
  const normalizedTranslate = normalize(translate);
  const normalizedSnapGrid = snapGrid.map(val => normalize(val));
  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
  if (typeof prevSnap === 'undefined' && params.cssMode) {
    let prevSnapIndex;
    snapGrid.forEach((snap, snapIndex) => {
      if (normalizedTranslate >= snap) {
        // prevSnap = snap;
        prevSnapIndex = snapIndex;
      }
    });
    if (typeof prevSnapIndex !== 'undefined') {
      prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
    }
  }
  let prevIndex = 0;
  if (typeof prevSnap !== 'undefined') {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
    if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
      prevIndex = Math.max(prevIndex, 0);
    }
  }
  if (params.rewind && swiper.isBeginning) {
    const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
  } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {
    requestAnimationFrame(() => {
      swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    });
    return true;
  }
  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideReset(speed, runCallbacks, internal) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  if (swiper.destroyed) return;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideToClosest(speed, runCallbacks, internal, threshold) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (threshold === void 0) {
    threshold = 0.5;
  }
  const swiper = this;
  if (swiper.destroyed) return;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  let index = swiper.activeIndex;
  const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
  const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  if (translate >= swiper.snapGrid[snapIndex]) {
    // The current translate is on or after the current snap index, so the choice
    // is between the current index and the one after it.
    const currentSnap = swiper.snapGrid[snapIndex];
    const nextSnap = swiper.snapGrid[snapIndex + 1];
    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
      index += swiper.params.slidesPerGroup;
    }
  } else {
    // The current translate is before the current snap index, so the choice
    // is between the current index and the one before it.
    const prevSnap = swiper.snapGrid[snapIndex - 1];
    const currentSnap = swiper.snapGrid[snapIndex];
    if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
      index -= swiper.params.slidesPerGroup;
    }
  }
  index = Math.max(index, 0);
  index = Math.min(index, swiper.slidesGrid.length - 1);
  return swiper.slideTo(index, speed, runCallbacks, internal);
}

function slideToClickedSlide() {
  const swiper = this;
  if (swiper.destroyed) return;
  const {
    params,
    slidesEl
  } = swiper;
  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  let slideToIndex = swiper.clickedIndex;
  let realIndex;
  const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
  if (params.loop) {
    if (swiper.animating) return;
    realIndex = parseInt(swiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);
    if (params.centeredSlides) {
      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
        swiper.loopFix();
        slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
        nextTick(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
      nextTick(() => {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}

var slide = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide
};

function loopCreate(slideRealIndex) {
  const swiper = this;
  const {
    params,
    slidesEl
  } = swiper;
  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
  const initSlides = () => {
    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
    slides.forEach((el, index) => {
      el.setAttribute('data-swiper-slide-index', index);
    });
  };
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);
  const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;
  const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;
  const addBlankSlides = amountOfSlides => {
    for (let i = 0; i < amountOfSlides; i += 1) {
      const slideEl = swiper.isElement ? createElement('swiper-slide', [params.slideBlankClass]) : createElement('div', [params.slideClass, params.slideBlankClass]);
      swiper.slidesEl.append(slideEl);
    }
  };
  if (shouldFillGroup) {
    if (params.loopAddBlankSlides) {
      const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;
      addBlankSlides(slidesToAdd);
      swiper.recalcSlides();
      swiper.updateSlides();
    } else {
      showWarning('Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)');
    }
    initSlides();
  } else if (shouldFillGrid) {
    if (params.loopAddBlankSlides) {
      const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;
      addBlankSlides(slidesToAdd);
      swiper.recalcSlides();
      swiper.updateSlides();
    } else {
      showWarning('Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)');
    }
    initSlides();
  } else {
    initSlides();
  }
  swiper.loopFix({
    slideRealIndex,
    direction: params.centeredSlides ? undefined : 'next'
  });
}

function loopFix(_temp) {
  let {
    slideRealIndex,
    slideTo = true,
    direction,
    setTranslate,
    activeSlideIndex,
    byController,
    byMousewheel
  } = _temp === void 0 ? {} : _temp;
  const swiper = this;
  if (!swiper.params.loop) return;
  swiper.emit('beforeLoopFix');
  const {
    slides,
    allowSlidePrev,
    allowSlideNext,
    slidesEl,
    params
  } = swiper;
  const {
    centeredSlides
  } = params;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;
  if (swiper.virtual && params.virtual.enabled) {
    if (slideTo) {
      if (!params.centeredSlides && swiper.snapIndex === 0) {
        swiper.slideTo(swiper.virtual.slides.length, 0, false, true);
      } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {
        swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);
      } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {
        swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
      }
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    swiper.emit('loopFix');
    return;
  }
  let slidesPerView = params.slidesPerView;
  if (slidesPerView === 'auto') {
    slidesPerView = swiper.slidesPerViewDynamic();
  } else {
    slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));
    if (centeredSlides && slidesPerView % 2 === 0) {
      slidesPerView = slidesPerView + 1;
    }
  }
  const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;
  let loopedSlides = slidesPerGroup;
  if (loopedSlides % slidesPerGroup !== 0) {
    loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;
  }
  loopedSlides += params.loopAdditionalSlides;
  swiper.loopedSlides = loopedSlides;
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  if (slides.length < slidesPerView + loopedSlides) {
    showWarning('Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters');
  } else if (gridEnabled && params.grid.fill === 'row') {
    showWarning('Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`');
  }
  const prependSlidesIndexes = [];
  const appendSlidesIndexes = [];
  let activeIndex = swiper.activeIndex;
  if (typeof activeSlideIndex === 'undefined') {
    activeSlideIndex = swiper.getSlideIndex(slides.filter(el => el.classList.contains(params.slideActiveClass))[0]);
  } else {
    activeIndex = activeSlideIndex;
  }
  const isNext = direction === 'next' || !direction;
  const isPrev = direction === 'prev' || !direction;
  let slidesPrepended = 0;
  let slidesAppended = 0;
  const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;
  const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;
  const activeColIndexWithShift = activeColIndex + (centeredSlides && typeof setTranslate === 'undefined' ? -slidesPerView / 2 + 0.5 : 0);
  // prepend last slides before start
  if (activeColIndexWithShift < loopedSlides) {
    slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);
    for (let i = 0; i < loopedSlides - activeColIndexWithShift; i += 1) {
      const index = i - Math.floor(i / cols) * cols;
      if (gridEnabled) {
        const colIndexToPrepend = cols - index - 1;
        for (let i = slides.length - 1; i >= 0; i -= 1) {
          if (slides[i].column === colIndexToPrepend) prependSlidesIndexes.push(i);
        }
        // slides.forEach((slide, slideIndex) => {
        //   if (slide.column === colIndexToPrepend) prependSlidesIndexes.push(slideIndex);
        // });
      } else {
        prependSlidesIndexes.push(cols - index - 1);
      }
    }
  } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {
    slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);
    for (let i = 0; i < slidesAppended; i += 1) {
      const index = i - Math.floor(i / cols) * cols;
      if (gridEnabled) {
        slides.forEach((slide, slideIndex) => {
          if (slide.column === index) appendSlidesIndexes.push(slideIndex);
        });
      } else {
        appendSlidesIndexes.push(index);
      }
    }
  }
  swiper.__preventObserver__ = true;
  requestAnimationFrame(() => {
    swiper.__preventObserver__ = false;
  });
  if (isPrev) {
    prependSlidesIndexes.forEach(index => {
      slides[index].swiperLoopMoveDOM = true;
      slidesEl.prepend(slides[index]);
      slides[index].swiperLoopMoveDOM = false;
    });
  }
  if (isNext) {
    appendSlidesIndexes.forEach(index => {
      slides[index].swiperLoopMoveDOM = true;
      slidesEl.append(slides[index]);
      slides[index].swiperLoopMoveDOM = false;
    });
  }
  swiper.recalcSlides();
  if (params.slidesPerView === 'auto') {
    swiper.updateSlides();
  } else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) {
    swiper.slides.forEach((slide, slideIndex) => {
      swiper.grid.updateSlide(slideIndex, slide, swiper.slides);
    });
  }
  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }
  if (slideTo) {
    if (prependSlidesIndexes.length > 0 && isPrev) {
      if (typeof slideRealIndex === 'undefined') {
        const currentSlideTranslate = swiper.slidesGrid[activeIndex];
        const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
        const diff = newSlideTranslate - currentSlideTranslate;
        if (byMousewheel) {
          swiper.setTranslate(swiper.translate - diff);
        } else {
          swiper.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);
          if (setTranslate) {
            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
          }
        }
      } else {
        if (setTranslate) {
          const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;
          swiper.slideTo(swiper.activeIndex + shift, 0, false, true);
          swiper.touchEventsData.currentTranslate = swiper.translate;
        }
      }
    } else if (appendSlidesIndexes.length > 0 && isNext) {
      if (typeof slideRealIndex === 'undefined') {
        const currentSlideTranslate = swiper.slidesGrid[activeIndex];
        const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
        const diff = newSlideTranslate - currentSlideTranslate;
        if (byMousewheel) {
          swiper.setTranslate(swiper.translate - diff);
        } else {
          swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
          if (setTranslate) {
            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
          }
        }
      } else {
        const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;
        swiper.slideTo(swiper.activeIndex - shift, 0, false, true);
      }
    }
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  if (swiper.controller && swiper.controller.control && !byController) {
    const loopParams = {
      slideRealIndex,
      direction,
      setTranslate,
      activeSlideIndex,
      byController: true
    };
    if (Array.isArray(swiper.controller.control)) {
      swiper.controller.control.forEach(c => {
        if (!c.destroyed && c.params.loop) c.loopFix({
          ...loopParams,
          slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo : false
        });
      });
    } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {
      swiper.controller.control.loopFix({
        ...loopParams,
        slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo : false
      });
    }
  }
  swiper.emit('loopFix');
}

function loopDestroy() {
  const swiper = this;
  const {
    params,
    slidesEl
  } = swiper;
  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
  swiper.recalcSlides();
  const newSlidesOrder = [];
  swiper.slides.forEach(slideEl => {
    const index = typeof slideEl.swiperSlideIndex === 'undefined' ? slideEl.getAttribute('data-swiper-slide-index') * 1 : slideEl.swiperSlideIndex;
    newSlidesOrder[index] = slideEl;
  });
  swiper.slides.forEach(slideEl => {
    slideEl.removeAttribute('data-swiper-slide-index');
  });
  newSlidesOrder.forEach(slideEl => {
    slidesEl.append(slideEl);
  });
  swiper.recalcSlides();
  swiper.slideTo(swiper.realIndex, 0);
}

var loop = {
  loopCreate,
  loopFix,
  loopDestroy
};

function setGrabCursor(moving) {
  const swiper = this;
  if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
  const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
  if (swiper.isElement) {
    swiper.__preventObserver__ = true;
  }
  el.style.cursor = 'move';
  el.style.cursor = moving ? 'grabbing' : 'grab';
  if (swiper.isElement) {
    requestAnimationFrame(() => {
      swiper.__preventObserver__ = false;
    });
  }
}

function unsetGrabCursor() {
  const swiper = this;
  if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
    return;
  }
  if (swiper.isElement) {
    swiper.__preventObserver__ = true;
  }
  swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
  if (swiper.isElement) {
    requestAnimationFrame(() => {
      swiper.__preventObserver__ = false;
    });
  }
}

var grabCursor = {
  setGrabCursor,
  unsetGrabCursor
};

// Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd
function closestElement(selector, base) {
  if (base === void 0) {
    base = this;
  }
  function __closestFrom(el) {
    if (!el || el === getDocument() || el === getWindow()) return null;
    if (el.assignedSlot) el = el.assignedSlot;
    const found = el.closest(selector);
    if (!found && !el.getRootNode) {
      return null;
    }
    return found || __closestFrom(el.getRootNode().host);
  }
  return __closestFrom(base);
}
function preventEdgeSwipe(swiper, event, startX) {
  const window = getWindow();
  const {
    params
  } = swiper;
  const edgeSwipeDetection = params.edgeSwipeDetection;
  const edgeSwipeThreshold = params.edgeSwipeThreshold;
  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
    if (edgeSwipeDetection === 'prevent') {
      event.preventDefault();
      return true;
    }
    return false;
  }
  return true;
}
function onTouchStart(event) {
  const swiper = this;
  const document = getDocument();
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  const data = swiper.touchEventsData;
  if (e.type === 'pointerdown') {
    if (data.pointerId !== null && data.pointerId !== e.pointerId) {
      return;
    }
    data.pointerId = e.pointerId;
  } else if (e.type === 'touchstart' && e.targetTouches.length === 1) {
    data.touchId = e.targetTouches[0].identifier;
  }
  if (e.type === 'touchstart') {
    // don't proceed touch event
    preventEdgeSwipe(swiper, e, e.targetTouches[0].pageX);
    return;
  }
  const {
    params,
    touches,
    enabled
  } = swiper;
  if (!enabled) return;
  if (!params.simulateTouch && e.pointerType === 'mouse') return;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }
  if (!swiper.animating && params.cssMode && params.loop) {
    swiper.loopFix();
  }
  let targetEl = e.target;
  if (params.touchEventsTarget === 'wrapper') {
    if (!swiper.wrapperEl.contains(targetEl)) return;
  }
  if ('which' in e && e.which === 3) return;
  if ('button' in e && e.button > 0) return;
  if (data.isTouched && data.isMoved) return;

  // change target el for shadow root component
  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';
  // eslint-disable-next-line
  const eventPath = e.composedPath ? e.composedPath() : e.path;
  if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {
    targetEl = eventPath[0];
  }
  const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
  const isTargetShadow = !!(e.target && e.target.shadowRoot);

  // use closestElement for shadow root element to get the actual closest for nested shadow root element
  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
    swiper.allowClick = true;
    return;
  }
  if (params.swipeHandler) {
    if (!targetEl.closest(params.swipeHandler)) return;
  }
  touches.currentX = e.pageX;
  touches.currentY = e.pageY;
  const startX = touches.currentX;
  const startY = touches.currentY;

  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

  if (!preventEdgeSwipe(swiper, e, startX)) {
    return;
  }
  Object.assign(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: undefined,
    startMoving: undefined
  });
  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = now();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = undefined;
  if (params.threshold > 0) data.allowThresholdMove = false;
  let preventDefault = true;
  if (targetEl.matches(data.focusableElements)) {
    preventDefault = false;
    if (targetEl.nodeName === 'SELECT') {
      data.isTouched = false;
    }
  }
  if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl) {
    document.activeElement.blur();
  }
  const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
  if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {
    e.preventDefault();
  }
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
    swiper.freeMode.onTouchStart();
  }
  swiper.emit('touchStart', e);
}

function onTouchMove(event) {
  const document = getDocument();
  const swiper = this;
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    enabled
  } = swiper;
  if (!enabled) return;
  if (!params.simulateTouch && event.pointerType === 'mouse') return;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  if (e.type === 'pointermove') {
    if (data.touchId !== null) return; // return from pointer if we use touch
    const id = e.pointerId;
    if (id !== data.pointerId) return;
  }
  let targetTouch;
  if (e.type === 'touchmove') {
    targetTouch = [...e.changedTouches].filter(t => t.identifier === data.touchId)[0];
    if (!targetTouch || targetTouch.identifier !== data.touchId) return;
  } else {
    targetTouch = e;
  }
  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }
    return;
  }
  const pageX = targetTouch.pageX;
  const pageY = targetTouch.pageY;
  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }
  if (!swiper.allowTouchMove) {
    if (!e.target.matches(data.focusableElements)) {
      swiper.allowClick = false;
    }
    if (data.isTouched) {
      Object.assign(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY
      });
      data.touchStartTime = now();
    }
    return;
  }
  if (params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      // Vertical
      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
      return;
    }
  }
  if (document.activeElement) {
    if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }
  if (data.allowTouchCallbacks) {
    swiper.emit('touchMove', e);
  }
  touches.previousX = touches.currentX;
  touches.previousY = touches.currentY;
  touches.currentX = pageX;
  touches.currentY = pageY;
  const diffX = touches.currentX - touches.startX;
  const diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
  if (typeof data.isScrolling === 'undefined') {
    let touchAngle;
    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
      data.isScrolling = false;
    } else {
      // eslint-disable-next-line
      if (diffX * diffX + diffY * diffY >= 25) {
        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
      }
    }
  }
  if (data.isScrolling) {
    swiper.emit('touchMoveOpposite', e);
  }
  if (typeof data.startMoving === 'undefined') {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }
  if (data.isScrolling || e.type === 'touchmove' && data.preventTouchMoveFromPointerMove) {
    data.isTouched = false;
    return;
  }
  if (!data.startMoving) {
    return;
  }
  swiper.allowClick = false;
  if (!params.cssMode && e.cancelable) {
    e.preventDefault();
  }
  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }
  let diff = swiper.isHorizontal() ? diffX : diffY;
  let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
  if (params.oneWayMovement) {
    diff = Math.abs(diff) * (rtl ? 1 : -1);
    touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
  }
  touches.diff = diff;
  diff *= params.touchRatio;
  if (rtl) {
    diff = -diff;
    touchesDiff = -touchesDiff;
  }
  const prevTouchesDirection = swiper.touchesDirection;
  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
  swiper.touchesDirection = touchesDiff > 0 ? 'prev' : 'next';
  const isLoop = swiper.params.loop && !params.cssMode;
  const allowLoopFix = swiper.touchesDirection === 'next' && swiper.allowSlideNext || swiper.touchesDirection === 'prev' && swiper.allowSlidePrev;
  if (!data.isMoved) {
    if (isLoop && allowLoopFix) {
      swiper.loopFix({
        direction: swiper.swipeDirection
      });
    }
    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);
    if (swiper.animating) {
      const evt = new window.CustomEvent('transitionend', {
        bubbles: true,
        cancelable: true,
        detail: {
          bySwiperTouchMove: true
        }
      });
      swiper.wrapperEl.dispatchEvent(evt);
    }
    data.allowMomentumBounce = false;
    // Grab Cursor
    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }
    swiper.emit('sliderFirstMove', e);
  }
  let loopFixed;
  new Date().getTime();
  if (data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
    Object.assign(touches, {
      startX: pageX,
      startY: pageY,
      currentX: pageX,
      currentY: pageY,
      startTranslate: data.currentTranslate
    });
    data.loopSwapReset = true;
    data.startTranslate = data.currentTranslate;
    return;
  }
  swiper.emit('sliderMove', e);
  data.isMoved = true;
  data.currentTranslate = diff + data.startTranslate;
  let disableParentSwiper = true;
  let resistanceRatio = params.resistanceRatio;
  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }
  if (diff > 0) {
    if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] : swiper.minTranslate())) {
      swiper.loopFix({
        direction: 'prev',
        setTranslate: true,
        activeSlideIndex: 0
      });
    }
    if (data.currentTranslate > swiper.minTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) {
        data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
      }
    }
  } else if (diff < 0) {
    if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] : swiper.maxTranslate())) {
      swiper.loopFix({
        direction: 'next',
        setTranslate: true,
        activeSlideIndex: swiper.slides.length - (params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
      });
    }
    if (data.currentTranslate < swiper.maxTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) {
        data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
      }
    }
  }
  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  }

  // Directions locks
  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
    data.currentTranslate = data.startTranslate;
  }

  // Threshold
  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }
  if (!params.followFinger || params.cssMode) return;

  // Update active index in free mode
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {
    swiper.freeMode.onTouchMove();
  }
  // Update progress
  swiper.updateProgress(data.currentTranslate);
  // Update translate
  swiper.setTranslate(data.currentTranslate);
}

function onTouchEnd(event) {
  const swiper = this;
  const data = swiper.touchEventsData;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  let targetTouch;
  const isTouchEvent = e.type === 'touchend' || e.type === 'touchcancel';
  if (!isTouchEvent) {
    if (data.touchId !== null) return; // return from pointer if we use touch
    if (e.pointerId !== data.pointerId) return;
    targetTouch = e;
  } else {
    targetTouch = [...e.changedTouches].filter(t => t.identifier === data.touchId)[0];
    if (!targetTouch || targetTouch.identifier !== data.touchId) return;
  }
  if (['pointercancel', 'pointerout', 'pointerleave', 'contextmenu'].includes(e.type)) {
    const proceed = ['pointercancel', 'contextmenu'].includes(e.type) && (swiper.browser.isSafari || swiper.browser.isWebView);
    if (!proceed) {
      return;
    }
  }
  data.pointerId = null;
  data.touchId = null;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    slidesGrid,
    enabled
  } = swiper;
  if (!enabled) return;
  if (!params.simulateTouch && e.pointerType === 'mouse') return;
  if (data.allowTouchCallbacks) {
    swiper.emit('touchEnd', e);
  }
  data.allowTouchCallbacks = false;
  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }
    data.isMoved = false;
    data.startMoving = false;
    return;
  }

  // Return Grab Cursor
  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  }

  // Time diff
  const touchEndTime = now();
  const timeDiff = touchEndTime - data.touchStartTime;

  // Tap, doubleTap, Click
  if (swiper.allowClick) {
    const pathTree = e.path || e.composedPath && e.composedPath();
    swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);
    swiper.emit('tap click', e);
    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
      swiper.emit('doubleTap doubleClick', e);
    }
  }
  data.lastClickTime = now();
  nextTick(() => {
    if (!swiper.destroyed) swiper.allowClick = true;
  });
  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;
  let currentPos;
  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }
  if (params.cssMode) {
    return;
  }
  if (params.freeMode && params.freeMode.enabled) {
    swiper.freeMode.onTouchEnd({
      currentPos
    });
    return;
  }

  // Find current slide
  const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;
  let stopIndex = 0;
  let groupSize = swiper.slidesSizesGrid[0];
  for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
    const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (typeof slidesGrid[i + increment] !== 'undefined') {
      if (swipeToLast || currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
        stopIndex = i;
        groupSize = slidesGrid[i + increment] - slidesGrid[i];
      }
    } else if (swipeToLast || currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }
  let rewindFirstIndex = null;
  let rewindLastIndex = null;
  if (params.rewind) {
    if (swiper.isBeginning) {
      rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    } else if (swiper.isEnd) {
      rewindFirstIndex = 0;
    }
  }
  // Find current slide size
  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
  if (timeDiff > params.longSwipesMs) {
    // Long touches
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === 'next') {
      if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);else swiper.slideTo(stopIndex);
    }
    if (swiper.swipeDirection === 'prev') {
      if (ratio > 1 - params.longSwipesRatio) {
        swiper.slideTo(stopIndex + increment);
      } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
        swiper.slideTo(rewindLastIndex);
      } else {
        swiper.slideTo(stopIndex);
      }
    }
  } else {
    // Short swipes
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
    if (!isNavButtonTarget) {
      if (swiper.swipeDirection === 'next') {
        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
      }
      if (swiper.swipeDirection === 'prev') {
        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
      }
    } else if (e.target === swiper.navigation.nextEl) {
      swiper.slideTo(stopIndex + increment);
    } else {
      swiper.slideTo(stopIndex);
    }
  }
}

function onResize() {
  const swiper = this;
  const {
    params,
    el
  } = swiper;
  if (el && el.offsetWidth === 0) return;

  // Breakpoints
  if (params.breakpoints) {
    swiper.setBreakpoint();
  }

  // Save locks
  const {
    allowSlideNext,
    allowSlidePrev,
    snapGrid
  } = swiper;
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

  // Disable locks on resize
  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;
  swiper.updateSize();
  swiper.updateSlides();
  swiper.updateSlidesClasses();
  const isVirtualLoop = isVirtual && params.loop;
  if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {
    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
  } else {
    if (swiper.params.loop && !isVirtual) {
      swiper.slideToLoop(swiper.realIndex, 0, false, true);
    } else {
      swiper.slideTo(swiper.activeIndex, 0, false, true);
    }
  }
  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    clearTimeout(swiper.autoplay.resizeTimeout);
    swiper.autoplay.resizeTimeout = setTimeout(() => {
      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        swiper.autoplay.resume();
      }
    }, 500);
  }
  // Return locks after resize
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}

function onClick(e) {
  const swiper = this;
  if (!swiper.enabled) return;
  if (!swiper.allowClick) {
    if (swiper.params.preventClicks) e.preventDefault();
    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
}

function onScroll() {
  const swiper = this;
  const {
    wrapperEl,
    rtlTranslate,
    enabled
  } = swiper;
  if (!enabled) return;
  swiper.previousTranslate = swiper.translate;
  if (swiper.isHorizontal()) {
    swiper.translate = -wrapperEl.scrollLeft;
  } else {
    swiper.translate = -wrapperEl.scrollTop;
  }
  // eslint-disable-next-line
  if (swiper.translate === 0) swiper.translate = 0;
  swiper.updateActiveIndex();
  swiper.updateSlidesClasses();
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== swiper.progress) {
    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
  }
  swiper.emit('setTranslate', swiper.translate, false);
}

function onLoad(e) {
  const swiper = this;
  processLazyPreloader(swiper, e.target);
  if (swiper.params.cssMode || swiper.params.slidesPerView !== 'auto' && !swiper.params.autoHeight) {
    return;
  }
  swiper.update();
}

function onDocumentTouchStart() {
  const swiper = this;
  if (swiper.documentTouchHandlerProceeded) return;
  swiper.documentTouchHandlerProceeded = true;
  if (swiper.params.touchReleaseOnEdges) {
    swiper.el.style.touchAction = 'auto';
  }
}

const events = (swiper, method) => {
  const document = getDocument();
  const {
    params,
    el,
    wrapperEl,
    device
  } = swiper;
  const capture = !!params.nested;
  const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
  const swiperMethod = method;
  if (!el || typeof el === 'string') return;

  // Touch Events
  document[domMethod]('touchstart', swiper.onDocumentTouchStart, {
    passive: false,
    capture
  });
  el[domMethod]('touchstart', swiper.onTouchStart, {
    passive: false
  });
  el[domMethod]('pointerdown', swiper.onTouchStart, {
    passive: false
  });
  document[domMethod]('touchmove', swiper.onTouchMove, {
    passive: false,
    capture
  });
  document[domMethod]('pointermove', swiper.onTouchMove, {
    passive: false,
    capture
  });
  document[domMethod]('touchend', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('pointerup', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('pointercancel', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('touchcancel', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('pointerout', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('pointerleave', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('contextmenu', swiper.onTouchEnd, {
    passive: true
  });

  // Prevent Links Clicks
  if (params.preventClicks || params.preventClicksPropagation) {
    el[domMethod]('click', swiper.onClick, true);
  }
  if (params.cssMode) {
    wrapperEl[domMethod]('scroll', swiper.onScroll);
  }

  // Resize handler
  if (params.updateOnWindowResize) {
    swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
  } else {
    swiper[swiperMethod]('observerUpdate', onResize, true);
  }

  // Images loader
  el[domMethod]('load', swiper.onLoad, {
    capture: true
  });
};
function attachEvents() {
  const swiper = this;
  const {
    params
  } = swiper;
  swiper.onTouchStart = onTouchStart.bind(swiper);
  swiper.onTouchMove = onTouchMove.bind(swiper);
  swiper.onTouchEnd = onTouchEnd.bind(swiper);
  swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);
  if (params.cssMode) {
    swiper.onScroll = onScroll.bind(swiper);
  }
  swiper.onClick = onClick.bind(swiper);
  swiper.onLoad = onLoad.bind(swiper);
  events(swiper, 'on');
}
function detachEvents() {
  const swiper = this;
  events(swiper, 'off');
}
var events$1 = {
  attachEvents,
  detachEvents
};

const isGridEnabled = (swiper, params) => {
  return swiper.grid && params.grid && params.grid.rows > 1;
};
function setBreakpoint() {
  const swiper = this;
  const {
    realIndex,
    initialized,
    params,
    el
  } = swiper;
  const breakpoints = params.breakpoints;
  if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;

  // Get breakpoint for window width and update parameters
  const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
  if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
  const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
  const breakpointParams = breakpointOnlyParams || swiper.originalParams;
  const wasMultiRow = isGridEnabled(swiper, params);
  const isMultiRow = isGridEnabled(swiper, breakpointParams);
  const wasGrabCursor = swiper.params.grabCursor;
  const isGrabCursor = breakpointParams.grabCursor;
  const wasEnabled = params.enabled;
  if (wasMultiRow && !isMultiRow) {
    el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
    swiper.emitContainerClasses();
  } else if (!wasMultiRow && isMultiRow) {
    el.classList.add(`${params.containerModifierClass}grid`);
    if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
      el.classList.add(`${params.containerModifierClass}grid-column`);
    }
    swiper.emitContainerClasses();
  }
  if (wasGrabCursor && !isGrabCursor) {
    swiper.unsetGrabCursor();
  } else if (!wasGrabCursor && isGrabCursor) {
    swiper.setGrabCursor();
  }

  // Toggle navigation, pagination, scrollbar
  ['navigation', 'pagination', 'scrollbar'].forEach(prop => {
    if (typeof breakpointParams[prop] === 'undefined') return;
    const wasModuleEnabled = params[prop] && params[prop].enabled;
    const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
    if (wasModuleEnabled && !isModuleEnabled) {
      swiper[prop].disable();
    }
    if (!wasModuleEnabled && isModuleEnabled) {
      swiper[prop].enable();
    }
  });
  const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
  const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
  const wasLoop = params.loop;
  if (directionChanged && initialized) {
    swiper.changeDirection();
  }
  extend(swiper.params, breakpointParams);
  const isEnabled = swiper.params.enabled;
  const hasLoop = swiper.params.loop;
  Object.assign(swiper, {
    allowTouchMove: swiper.params.allowTouchMove,
    allowSlideNext: swiper.params.allowSlideNext,
    allowSlidePrev: swiper.params.allowSlidePrev
  });
  if (wasEnabled && !isEnabled) {
    swiper.disable();
  } else if (!wasEnabled && isEnabled) {
    swiper.enable();
  }
  swiper.currentBreakpoint = breakpoint;
  swiper.emit('_beforeBreakpoint', breakpointParams);
  if (initialized) {
    if (needsReLoop) {
      swiper.loopDestroy();
      swiper.loopCreate(realIndex);
      swiper.updateSlides();
    } else if (!wasLoop && hasLoop) {
      swiper.loopCreate(realIndex);
      swiper.updateSlides();
    } else if (wasLoop && !hasLoop) {
      swiper.loopDestroy();
    }
  }
  swiper.emit('breakpoint', breakpointParams);
}

function getBreakpoint(breakpoints, base, containerEl) {
  if (base === void 0) {
    base = 'window';
  }
  if (!breakpoints || base === 'container' && !containerEl) return undefined;
  let breakpoint = false;
  const window = getWindow();
  const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
  const points = Object.keys(breakpoints).map(point => {
    if (typeof point === 'string' && point.indexOf('@') === 0) {
      const minRatio = parseFloat(point.substr(1));
      const value = currentHeight * minRatio;
      return {
        value,
        point
      };
    }
    return {
      value: point,
      point
    };
  });
  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
  for (let i = 0; i < points.length; i += 1) {
    const {
      point,
      value
    } = points[i];
    if (base === 'window') {
      if (window.matchMedia(`(min-width: ${value}px)`).matches) {
        breakpoint = point;
      }
    } else if (value <= containerEl.clientWidth) {
      breakpoint = point;
    }
  }
  return breakpoint || 'max';
}

var breakpoints = {
  setBreakpoint,
  getBreakpoint
};

function prepareClasses(entries, prefix) {
  const resultClasses = [];
  entries.forEach(item => {
    if (typeof item === 'object') {
      Object.keys(item).forEach(classNames => {
        if (item[classNames]) {
          resultClasses.push(prefix + classNames);
        }
      });
    } else if (typeof item === 'string') {
      resultClasses.push(prefix + item);
    }
  });
  return resultClasses;
}
function addClasses() {
  const swiper = this;
  const {
    classNames,
    params,
    rtl,
    el,
    device
  } = swiper;
  // prettier-ignore
  const suffixes = prepareClasses(['initialized', params.direction, {
    'free-mode': swiper.params.freeMode && params.freeMode.enabled
  }, {
    'autoheight': params.autoHeight
  }, {
    'rtl': rtl
  }, {
    'grid': params.grid && params.grid.rows > 1
  }, {
    'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
  }, {
    'android': device.android
  }, {
    'ios': device.ios
  }, {
    'css-mode': params.cssMode
  }, {
    'centered': params.cssMode && params.centeredSlides
  }, {
    'watch-progress': params.watchSlidesProgress
  }], params.containerModifierClass);
  classNames.push(...suffixes);
  el.classList.add(...classNames);
  swiper.emitContainerClasses();
}

function removeClasses() {
  const swiper = this;
  const {
    el,
    classNames
  } = swiper;
  if (!el || typeof el === 'string') return;
  el.classList.remove(...classNames);
  swiper.emitContainerClasses();
}

var classes = {
  addClasses,
  removeClasses
};

function checkOverflow() {
  const swiper = this;
  const {
    isLocked: wasLocked,
    params
  } = swiper;
  const {
    slidesOffsetBefore
  } = params;
  if (slidesOffsetBefore) {
    const lastSlideIndex = swiper.slides.length - 1;
    const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
    swiper.isLocked = swiper.size > lastSlideRightEdge;
  } else {
    swiper.isLocked = swiper.snapGrid.length === 1;
  }
  if (params.allowSlideNext === true) {
    swiper.allowSlideNext = !swiper.isLocked;
  }
  if (params.allowSlidePrev === true) {
    swiper.allowSlidePrev = !swiper.isLocked;
  }
  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
  }
  if (wasLocked !== swiper.isLocked) {
    swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
  }
}
var checkOverflow$1 = {
  checkOverflow
};

var defaults = {
  init: true,
  direction: 'horizontal',
  oneWayMovement: false,
  swiperElementNodeName: 'SWIPER-CONTAINER',
  touchEventsTarget: 'wrapper',
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  resizeObserver: true,
  nested: false,
  createElements: false,
  eventsPrefix: 'swiper',
  enabled: true,
  focusableElements: 'input, select, option, textarea, button, video, label',
  // Overrides
  width: null,
  height: null,
  //
  preventInteractionOnTransition: false,
  // ssr
  userAgent: null,
  url: null,
  // To support iOS's swipe-to-go-back gesture (when being used in-app).
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,
  // Autoheight
  autoHeight: false,
  // Set wrapper width
  setWrapperSize: false,
  // Virtual Translate
  virtualTranslate: false,
  // Effects
  effect: 'slide',
  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'

  // Breakpoints
  breakpoints: undefined,
  breakpointsBase: 'window',
  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  slidesPerGroupAuto: false,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0,
  // in px
  slidesOffsetAfter: 0,
  // in px
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,
  // Disable swiper and hide navigation when container not overflow
  watchOverflow: true,
  // Round length
  roundLengths: false,
  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 5,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,
  // Unique Navigation Elements
  uniqueNavElements: true,
  // Resistance
  resistance: true,
  resistanceRatio: 0.85,
  // Progress
  watchSlidesProgress: false,
  // Cursor
  grabCursor: false,
  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,
  // loop
  loop: false,
  loopAddBlankSlides: true,
  loopAdditionalSlides: 0,
  loopPreventsSliding: true,
  // rewind
  rewind: false,
  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null,
  // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: 'swiper-no-swiping',
  noSwipingSelector: null,
  // Passive Listeners
  passiveListeners: true,
  maxBackfaceHiddenSlides: 10,
  // NS
  containerModifierClass: 'swiper-',
  // NEW
  slideClass: 'swiper-slide',
  slideBlankClass: 'swiper-slide-blank',
  slideActiveClass: 'swiper-slide-active',
  slideVisibleClass: 'swiper-slide-visible',
  slideFullyVisibleClass: 'swiper-slide-fully-visible',
  slideNextClass: 'swiper-slide-next',
  slidePrevClass: 'swiper-slide-prev',
  wrapperClass: 'swiper-wrapper',
  lazyPreloaderClass: 'swiper-lazy-preloader',
  lazyPreloadPrevNext: 0,
  // Callbacks
  runCallbacksOnInit: true,
  // Internals
  _emitClasses: false
};

function moduleExtendParams(params, allModulesParams) {
  return function extendParams(obj) {
    if (obj === void 0) {
      obj = {};
    }
    const moduleParamName = Object.keys(obj)[0];
    const moduleParams = obj[moduleParamName];
    if (typeof moduleParams !== 'object' || moduleParams === null) {
      extend(allModulesParams, obj);
      return;
    }
    if (params[moduleParamName] === true) {
      params[moduleParamName] = {
        enabled: true
      };
    }
    if (moduleParamName === 'navigation' && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {
      params[moduleParamName].auto = true;
    }
    if (['pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {
      params[moduleParamName].auto = true;
    }
    if (!(moduleParamName in params && 'enabled' in moduleParams)) {
      extend(allModulesParams, obj);
      return;
    }
    if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
      params[moduleParamName].enabled = true;
    }
    if (!params[moduleParamName]) params[moduleParamName] = {
      enabled: false
    };
    extend(allModulesParams, obj);
  };
}

/* eslint no-param-reassign: "off" */
const prototypes = {
  eventsEmitter,
  update,
  translate,
  transition,
  slide,
  loop,
  grabCursor,
  events: events$1,
  breakpoints,
  checkOverflow: checkOverflow$1,
  classes
};
const extendedDefaults = {};
class Swiper {
  constructor() {
    let el;
    let params;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
      params = args[0];
    } else {
      [el, params] = args;
    }
    if (!params) params = {};
    params = extend({}, params);
    if (el && !params.el) params.el = el;
    const document = getDocument();
    if (params.el && typeof params.el === 'string' && document.querySelectorAll(params.el).length > 1) {
      const swipers = [];
      document.querySelectorAll(params.el).forEach(containerEl => {
        const newParams = extend({}, params, {
          el: containerEl
        });
        swipers.push(new Swiper(newParams));
      });
      // eslint-disable-next-line no-constructor-return
      return swipers;
    }

    // Swiper Instance
    const swiper = this;
    swiper.__swiper__ = true;
    swiper.support = getSupport();
    swiper.device = getDevice({
      userAgent: params.userAgent
    });
    swiper.browser = getBrowser();
    swiper.eventsListeners = {};
    swiper.eventsAnyListeners = [];
    swiper.modules = [...swiper.__modules__];
    if (params.modules && Array.isArray(params.modules)) {
      swiper.modules.push(...params.modules);
    }
    const allModulesParams = {};
    swiper.modules.forEach(mod => {
      mod({
        params,
        swiper,
        extendParams: moduleExtendParams(params, allModulesParams),
        on: swiper.on.bind(swiper),
        once: swiper.once.bind(swiper),
        off: swiper.off.bind(swiper),
        emit: swiper.emit.bind(swiper)
      });
    });

    // Extend defaults with modules params
    const swiperParams = extend({}, defaults, allModulesParams);

    // Extend defaults with passed params
    swiper.params = extend({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = extend({}, swiper.params);
    swiper.passedParams = extend({}, params);

    // add event listeners
    if (swiper.params && swiper.params.on) {
      Object.keys(swiper.params.on).forEach(eventName => {
        swiper.on(eventName, swiper.params.on[eventName]);
      });
    }
    if (swiper.params && swiper.params.onAny) {
      swiper.onAny(swiper.params.onAny);
    }

    // Extend Swiper
    Object.assign(swiper, {
      enabled: swiper.params.enabled,
      el,
      // Classes
      classNames: [],
      // Slides
      slides: [],
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],
      // isDirection
      isHorizontal() {
        return swiper.params.direction === 'horizontal';
      },
      isVertical() {
        return swiper.params.direction === 'vertical';
      },
      // Indexes
      activeIndex: 0,
      realIndex: 0,
      //
      isBeginning: true,
      isEnd: false,
      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,
      cssOverflowAdjustment() {
        // Returns 0 unless `translate` is > 2**23
        // Should be subtracted from css values to prevent overflow
        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
      },
      // Locks
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
      // Touch Events
      touchEventsData: {
        isTouched: undefined,
        isMoved: undefined,
        allowTouchCallbacks: undefined,
        touchStartTime: undefined,
        isScrolling: undefined,
        currentTranslate: undefined,
        startTranslate: undefined,
        allowThresholdMove: undefined,
        // Form elements to match
        focusableElements: swiper.params.focusableElements,
        // Last click time
        lastClickTime: 0,
        clickTimeout: undefined,
        // Velocities
        velocities: [],
        allowMomentumBounce: undefined,
        startMoving: undefined,
        pointerId: null,
        touchId: null
      },
      // Clicks
      allowClick: true,
      // Touches
      allowTouchMove: swiper.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      // Images
      imagesToLoad: [],
      imagesLoaded: 0
    });
    swiper.emit('_swiper');

    // Init
    if (swiper.params.init) {
      swiper.init();
    }

    // Return app instance
    // eslint-disable-next-line no-constructor-return
    return swiper;
  }
  getDirectionLabel(property) {
    if (this.isHorizontal()) {
      return property;
    }
    // prettier-ignore
    return {
      'width': 'height',
      'margin-top': 'margin-left',
      'margin-bottom ': 'margin-right',
      'margin-left': 'margin-top',
      'margin-right': 'margin-bottom',
      'padding-left': 'padding-top',
      'padding-right': 'padding-bottom',
      'marginRight': 'marginBottom'
    }[property];
  }
  getSlideIndex(slideEl) {
    const {
      slidesEl,
      params
    } = this;
    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
    const firstSlideIndex = elementIndex(slides[0]);
    return elementIndex(slideEl) - firstSlideIndex;
  }
  getSlideIndexByData(index) {
    return this.getSlideIndex(this.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === index)[0]);
  }
  recalcSlides() {
    const swiper = this;
    const {
      slidesEl,
      params
    } = swiper;
    swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
  }
  enable() {
    const swiper = this;
    if (swiper.enabled) return;
    swiper.enabled = true;
    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }
    swiper.emit('enable');
  }
  disable() {
    const swiper = this;
    if (!swiper.enabled) return;
    swiper.enabled = false;
    if (swiper.params.grabCursor) {
      swiper.unsetGrabCursor();
    }
    swiper.emit('disable');
  }
  setProgress(progress, speed) {
    const swiper = this;
    progress = Math.min(Math.max(progress, 0), 1);
    const min = swiper.minTranslate();
    const max = swiper.maxTranslate();
    const current = (max - min) * progress + min;
    swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  emitContainerClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    const cls = swiper.el.className.split(' ').filter(className => {
      return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
    });
    swiper.emit('_containerClasses', cls.join(' '));
  }
  getSlideClasses(slideEl) {
    const swiper = this;
    if (swiper.destroyed) return '';
    return slideEl.className.split(' ').filter(className => {
      return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
    }).join(' ');
  }
  emitSlidesClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    const updates = [];
    swiper.slides.forEach(slideEl => {
      const classNames = swiper.getSlideClasses(slideEl);
      updates.push({
        slideEl,
        classNames
      });
      swiper.emit('_slideClass', slideEl, classNames);
    });
    swiper.emit('_slideClasses', updates);
  }
  slidesPerViewDynamic(view, exact) {
    if (view === void 0) {
      view = 'current';
    }
    if (exact === void 0) {
      exact = false;
    }
    const swiper = this;
    const {
      params,
      slides,
      slidesGrid,
      slidesSizesGrid,
      size: swiperSize,
      activeIndex
    } = swiper;
    let spv = 1;
    if (typeof params.slidesPerView === 'number') return params.slidesPerView;
    if (params.centeredSlides) {
      let slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;
      let breakLoop;
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += Math.ceil(slides[i].swiperSlideSize);
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
      for (let i = activeIndex - 1; i >= 0; i -= 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
    } else {
      // eslint-disable-next-line
      if (view === 'current') {
        for (let i = activeIndex + 1; i < slides.length; i += 1) {
          const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      } else {
        // previous
        for (let i = activeIndex - 1; i >= 0; i -= 1) {
          const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      }
    }
    return spv;
  }
  update() {
    const swiper = this;
    if (!swiper || swiper.destroyed) return;
    const {
      snapGrid,
      params
    } = swiper;
    // Breakpoints
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }
    [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach(imageEl => {
      if (imageEl.complete) {
        processLazyPreloader(swiper, imageEl);
      }
    });
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();
    function setTranslate() {
      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    let translated;
    if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
      setTranslate();
      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {
        const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
        translated = swiper.slideTo(slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
      if (!translated) {
        setTranslate();
      }
    }
    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
    swiper.emit('update');
  }
  changeDirection(newDirection, needUpdate) {
    if (needUpdate === void 0) {
      needUpdate = true;
    }
    const swiper = this;
    const currentDirection = swiper.params.direction;
    if (!newDirection) {
      // eslint-disable-next-line
      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
    }
    if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
      return swiper;
    }
    swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
    swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
    swiper.emitContainerClasses();
    swiper.params.direction = newDirection;
    swiper.slides.forEach(slideEl => {
      if (newDirection === 'vertical') {
        slideEl.style.width = '';
      } else {
        slideEl.style.height = '';
      }
    });
    swiper.emit('changeDirection');
    if (needUpdate) swiper.update();
    return swiper;
  }
  changeLanguageDirection(direction) {
    const swiper = this;
    if (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;
    swiper.rtl = direction === 'rtl';
    swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;
    if (swiper.rtl) {
      swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
      swiper.el.dir = 'rtl';
    } else {
      swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
      swiper.el.dir = 'ltr';
    }
    swiper.update();
  }
  mount(element) {
    const swiper = this;
    if (swiper.mounted) return true;

    // Find el
    let el = element || swiper.params.el;
    if (typeof el === 'string') {
      el = document.querySelector(el);
    }
    if (!el) {
      return false;
    }
    el.swiper = swiper;
    if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) {
      swiper.isElement = true;
    }
    const getWrapperSelector = () => {
      return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
    };
    const getWrapper = () => {
      if (el && el.shadowRoot && el.shadowRoot.querySelector) {
        const res = el.shadowRoot.querySelector(getWrapperSelector());
        // Children needs to return slot items
        return res;
      }
      return elementChildren(el, getWrapperSelector())[0];
    };
    // Find Wrapper
    let wrapperEl = getWrapper();
    if (!wrapperEl && swiper.params.createElements) {
      wrapperEl = createElement('div', swiper.params.wrapperClass);
      el.append(wrapperEl);
      elementChildren(el, `.${swiper.params.slideClass}`).forEach(slideEl => {
        wrapperEl.append(slideEl);
      });
    }
    Object.assign(swiper, {
      el,
      wrapperEl,
      slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,
      hostEl: swiper.isElement ? el.parentNode.host : el,
      mounted: true,
      // RTL
      rtl: el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl',
      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl'),
      wrongRTL: elementStyle(wrapperEl, 'display') === '-webkit-box'
    });
    return true;
  }
  init(el) {
    const swiper = this;
    if (swiper.initialized) return swiper;
    const mounted = swiper.mount(el);
    if (mounted === false) return swiper;
    swiper.emit('beforeInit');

    // Set breakpoint
    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    }

    // Add Classes
    swiper.addClasses();

    // Update size
    swiper.updateSize();

    // Update slides
    swiper.updateSlides();
    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    }

    // Set Grab Cursor
    if (swiper.params.grabCursor && swiper.enabled) {
      swiper.setGrabCursor();
    }

    // Slide To Initial Slide
    if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
      swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
    }

    // Create loop
    if (swiper.params.loop) {
      swiper.loopCreate();
    }

    // Attach events
    swiper.attachEvents();
    const lazyElements = [...swiper.el.querySelectorAll('[loading="lazy"]')];
    if (swiper.isElement) {
      lazyElements.push(...swiper.hostEl.querySelectorAll('[loading="lazy"]'));
    }
    lazyElements.forEach(imageEl => {
      if (imageEl.complete) {
        processLazyPreloader(swiper, imageEl);
      } else {
        imageEl.addEventListener('load', e => {
          processLazyPreloader(swiper, e.target);
        });
      }
    });
    preload(swiper);

    // Init Flag
    swiper.initialized = true;
    preload(swiper);

    // Emit
    swiper.emit('init');
    swiper.emit('afterInit');
    return swiper;
  }
  destroy(deleteInstance, cleanStyles) {
    if (deleteInstance === void 0) {
      deleteInstance = true;
    }
    if (cleanStyles === void 0) {
      cleanStyles = true;
    }
    const swiper = this;
    const {
      params,
      el,
      wrapperEl,
      slides
    } = swiper;
    if (typeof swiper.params === 'undefined' || swiper.destroyed) {
      return null;
    }
    swiper.emit('beforeDestroy');

    // Init Flag
    swiper.initialized = false;

    // Detach events
    swiper.detachEvents();

    // Destroy loop
    if (params.loop) {
      swiper.loopDestroy();
    }

    // Cleanup styles
    if (cleanStyles) {
      swiper.removeClasses();
      if (el && typeof el !== 'string') {
        el.removeAttribute('style');
      }
      if (wrapperEl) {
        wrapperEl.removeAttribute('style');
      }
      if (slides && slides.length) {
        slides.forEach(slideEl => {
          slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
          slideEl.removeAttribute('style');
          slideEl.removeAttribute('data-swiper-slide-index');
        });
      }
    }
    swiper.emit('destroy');

    // Detach emitter events
    Object.keys(swiper.eventsListeners).forEach(eventName => {
      swiper.off(eventName);
    });
    if (deleteInstance !== false) {
      if (swiper.el && typeof swiper.el !== 'string') {
        swiper.el.swiper = null;
      }
      deleteProps(swiper);
    }
    swiper.destroyed = true;
    return null;
  }
  static extendDefaults(newDefaults) {
    extend(extendedDefaults, newDefaults);
  }
  static get extendedDefaults() {
    return extendedDefaults;
  }
  static get defaults() {
    return defaults;
  }
  static installModule(mod) {
    if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
    const modules = Swiper.prototype.__modules__;
    if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
      modules.push(mod);
    }
  }
  static use(module) {
    if (Array.isArray(module)) {
      module.forEach(m => Swiper.installModule(m));
      return Swiper;
    }
    Swiper.installModule(module);
    return Swiper;
  }
}
Object.keys(prototypes).forEach(prototypeGroup => {
  Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
  });
});
Swiper.use([Resize, Observer]);

function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
  if (swiper.params.createElements) {
    Object.keys(checkProps).forEach(key => {
      if (!params[key] && params.auto === true) {
        let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];
        if (!element) {
          element = createElement('div', checkProps[key]);
          element.className = checkProps[key];
          swiper.el.append(element);
        }
        params[key] = element;
        originalParams[key] = element;
      }
    });
  }
  return params;
}

function classesToSelector(classes) {
  if (classes === void 0) {
    classes = '';
  }
  return `.${classes.trim().replace(/([\.:!+\/])/g, '\\$1') // eslint-disable-line
  .replace(/ /g, '.')}`;
}

function Pagination(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const pfx = 'swiper-pagination';
  extendParams({
    pagination: {
      el: null,
      bulletElement: 'span',
      clickable: false,
      hideOnClick: false,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: false,
      type: 'bullets',
      // 'bullets' or 'progressbar' or 'fraction' or 'custom'
      dynamicBullets: false,
      dynamicMainBullets: 1,
      formatFractionCurrent: number => number,
      formatFractionTotal: number => number,
      bulletClass: `${pfx}-bullet`,
      bulletActiveClass: `${pfx}-bullet-active`,
      modifierClass: `${pfx}-`,
      currentClass: `${pfx}-current`,
      totalClass: `${pfx}-total`,
      hiddenClass: `${pfx}-hidden`,
      progressbarFillClass: `${pfx}-progressbar-fill`,
      progressbarOppositeClass: `${pfx}-progressbar-opposite`,
      clickableClass: `${pfx}-clickable`,
      lockClass: `${pfx}-lock`,
      horizontalClass: `${pfx}-horizontal`,
      verticalClass: `${pfx}-vertical`,
      paginationDisabledClass: `${pfx}-disabled`
    }
  });
  swiper.pagination = {
    el: null,
    bullets: []
  };
  let bulletSize;
  let dynamicBulletIndex = 0;
  function isPaginationDisabled() {
    return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;
  }
  function setSideBullets(bulletEl, position) {
    const {
      bulletActiveClass
    } = swiper.params.pagination;
    if (!bulletEl) return;
    bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];
    if (bulletEl) {
      bulletEl.classList.add(`${bulletActiveClass}-${position}`);
      bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];
      if (bulletEl) {
        bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);
      }
    }
  }
  function onBulletClick(e) {
    const bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));
    if (!bulletEl) {
      return;
    }
    e.preventDefault();
    const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;
    if (swiper.params.loop) {
      if (swiper.realIndex === index) return;
      swiper.slideToLoop(index);
    } else {
      swiper.slideTo(index);
    }
  }
  function update() {
    // Render || Update Pagination bullets/items
    const rtl = swiper.rtl;
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    let el = swiper.pagination.el;
    el = makeElementsArray(el);
    // Current/Total
    let current;
    let previousIndex;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
    if (swiper.params.loop) {
      previousIndex = swiper.previousRealIndex || 0;
      current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;
    } else if (typeof swiper.snapIndex !== 'undefined') {
      current = swiper.snapIndex;
      previousIndex = swiper.previousSnapIndex;
    } else {
      previousIndex = swiper.previousIndex || 0;
      current = swiper.activeIndex || 0;
    }
    // Types
    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
      const bullets = swiper.pagination.bullets;
      let firstIndex;
      let lastIndex;
      let midIndex;
      if (params.dynamicBullets) {
        bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? 'width' : 'height', true);
        el.forEach(subEl => {
          subEl.style[swiper.isHorizontal() ? 'width' : 'height'] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;
        });
        if (params.dynamicMainBullets > 1 && previousIndex !== undefined) {
          dynamicBulletIndex += current - (previousIndex || 0);
          if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
            dynamicBulletIndex = params.dynamicMainBullets - 1;
          } else if (dynamicBulletIndex < 0) {
            dynamicBulletIndex = 0;
          }
        }
        firstIndex = Math.max(current - dynamicBulletIndex, 0);
        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
        midIndex = (lastIndex + firstIndex) / 2;
      }
      bullets.forEach(bulletEl => {
        const classesToRemove = [...['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`)].map(s => typeof s === 'string' && s.includes(' ') ? s.split(' ') : s).flat();
        bulletEl.classList.remove(...classesToRemove);
      });
      if (el.length > 1) {
        bullets.forEach(bullet => {
          const bulletIndex = elementIndex(bullet);
          if (bulletIndex === current) {
            bullet.classList.add(...params.bulletActiveClass.split(' '));
          } else if (swiper.isElement) {
            bullet.setAttribute('part', 'bullet');
          }
          if (params.dynamicBullets) {
            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
              bullet.classList.add(...`${params.bulletActiveClass}-main`.split(' '));
            }
            if (bulletIndex === firstIndex) {
              setSideBullets(bullet, 'prev');
            }
            if (bulletIndex === lastIndex) {
              setSideBullets(bullet, 'next');
            }
          }
        });
      } else {
        const bullet = bullets[current];
        if (bullet) {
          bullet.classList.add(...params.bulletActiveClass.split(' '));
        }
        if (swiper.isElement) {
          bullets.forEach((bulletEl, bulletIndex) => {
            bulletEl.setAttribute('part', bulletIndex === current ? 'bullet-active' : 'bullet');
          });
        }
        if (params.dynamicBullets) {
          const firstDisplayedBullet = bullets[firstIndex];
          const lastDisplayedBullet = bullets[lastIndex];
          for (let i = firstIndex; i <= lastIndex; i += 1) {
            if (bullets[i]) {
              bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(' '));
            }
          }
          setSideBullets(firstDisplayedBullet, 'prev');
          setSideBullets(lastDisplayedBullet, 'next');
        }
      }
      if (params.dynamicBullets) {
        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
        const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
        const offsetProp = rtl ? 'right' : 'left';
        bullets.forEach(bullet => {
          bullet.style[swiper.isHorizontal() ? offsetProp : 'top'] = `${bulletsOffset}px`;
        });
      }
    }
    el.forEach((subEl, subElIndex) => {
      if (params.type === 'fraction') {
        subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach(fractionEl => {
          fractionEl.textContent = params.formatFractionCurrent(current + 1);
        });
        subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach(totalEl => {
          totalEl.textContent = params.formatFractionTotal(total);
        });
      }
      if (params.type === 'progressbar') {
        let progressbarDirection;
        if (params.progressbarOpposite) {
          progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
        } else {
          progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
        }
        const scale = (current + 1) / total;
        let scaleX = 1;
        let scaleY = 1;
        if (progressbarDirection === 'horizontal') {
          scaleX = scale;
        } else {
          scaleY = scale;
        }
        subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach(progressEl => {
          progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;
          progressEl.style.transitionDuration = `${swiper.params.speed}ms`;
        });
      }
      if (params.type === 'custom' && params.renderCustom) {
        subEl.innerHTML = params.renderCustom(swiper, current + 1, total);
        if (subElIndex === 0) emit('paginationRender', subEl);
      } else {
        if (subElIndex === 0) emit('paginationRender', subEl);
        emit('paginationUpdate', subEl);
      }
      if (swiper.params.watchOverflow && swiper.enabled) {
        subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);
      }
    });
  }
  function render() {
    // Render Container
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.grid && swiper.params.grid.rows > 1 ? swiper.slides.length / Math.ceil(swiper.params.grid.rows) : swiper.slides.length;
    let el = swiper.pagination.el;
    el = makeElementsArray(el);
    let paginationHTML = '';
    if (params.type === 'bullets') {
      let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
      if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {
        numberOfBullets = slidesLength;
      }
      for (let i = 0; i < numberOfBullets; i += 1) {
        if (params.renderBullet) {
          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
        } else {
          // prettier-ignore
          paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part="bullet"' : ''} class="${params.bulletClass}"></${params.bulletElement}>`;
        }
      }
    }
    if (params.type === 'fraction') {
      if (params.renderFraction) {
        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
      } else {
        paginationHTML = `<span class="${params.currentClass}"></span>` + ' / ' + `<span class="${params.totalClass}"></span>`;
      }
    }
    if (params.type === 'progressbar') {
      if (params.renderProgressbar) {
        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
      } else {
        paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
      }
    }
    swiper.pagination.bullets = [];
    el.forEach(subEl => {
      if (params.type !== 'custom') {
        subEl.innerHTML = paginationHTML || '';
      }
      if (params.type === 'bullets') {
        swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));
      }
    });
    if (params.type !== 'custom') {
      emit('paginationRender', el[0]);
    }
  }
  function init() {
    swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
      el: 'swiper-pagination'
    });
    const params = swiper.params.pagination;
    if (!params.el) return;
    let el;
    if (typeof params.el === 'string' && swiper.isElement) {
      el = swiper.el.querySelector(params.el);
    }
    if (!el && typeof params.el === 'string') {
      el = [...document.querySelectorAll(params.el)];
    }
    if (!el) {
      el = params.el;
    }
    if (!el || el.length === 0) return;
    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && Array.isArray(el) && el.length > 1) {
      el = [...swiper.el.querySelectorAll(params.el)];
      // check if it belongs to another nested Swiper
      if (el.length > 1) {
        el = el.filter(subEl => {
          if (elementParents(subEl, '.swiper')[0] !== swiper.el) return false;
          return true;
        })[0];
      }
    }
    if (Array.isArray(el) && el.length === 1) el = el[0];
    Object.assign(swiper.pagination, {
      el
    });
    el = makeElementsArray(el);
    el.forEach(subEl => {
      if (params.type === 'bullets' && params.clickable) {
        subEl.classList.add(...(params.clickableClass || '').split(' '));
      }
      subEl.classList.add(params.modifierClass + params.type);
      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
      if (params.type === 'bullets' && params.dynamicBullets) {
        subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);
        dynamicBulletIndex = 0;
        if (params.dynamicMainBullets < 1) {
          params.dynamicMainBullets = 1;
        }
      }
      if (params.type === 'progressbar' && params.progressbarOpposite) {
        subEl.classList.add(params.progressbarOppositeClass);
      }
      if (params.clickable) {
        subEl.addEventListener('click', onBulletClick);
      }
      if (!swiper.enabled) {
        subEl.classList.add(params.lockClass);
      }
    });
  }
  function destroy() {
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    let el = swiper.pagination.el;
    if (el) {
      el = makeElementsArray(el);
      el.forEach(subEl => {
        subEl.classList.remove(params.hiddenClass);
        subEl.classList.remove(params.modifierClass + params.type);
        subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
        if (params.clickable) {
          subEl.classList.remove(...(params.clickableClass || '').split(' '));
          subEl.removeEventListener('click', onBulletClick);
        }
      });
    }
    if (swiper.pagination.bullets) swiper.pagination.bullets.forEach(subEl => subEl.classList.remove(...params.bulletActiveClass.split(' ')));
  }
  on('changeDirection', () => {
    if (!swiper.pagination || !swiper.pagination.el) return;
    const params = swiper.params.pagination;
    let {
      el
    } = swiper.pagination;
    el = makeElementsArray(el);
    el.forEach(subEl => {
      subEl.classList.remove(params.horizontalClass, params.verticalClass);
      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    });
  });
  on('init', () => {
    if (swiper.params.pagination.enabled === false) {
      // eslint-disable-next-line
      disable();
    } else {
      init();
      render();
      update();
    }
  });
  on('activeIndexChange', () => {
    if (typeof swiper.snapIndex === 'undefined') {
      update();
    }
  });
  on('snapIndexChange', () => {
    update();
  });
  on('snapGridLengthChange', () => {
    render();
    update();
  });
  on('destroy', () => {
    destroy();
  });
  on('enable disable', () => {
    let {
      el
    } = swiper.pagination;
    if (el) {
      el = makeElementsArray(el);
      el.forEach(subEl => subEl.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.pagination.lockClass));
    }
  });
  on('lock unlock', () => {
    update();
  });
  on('click', (_s, e) => {
    const targetEl = e.target;
    const el = makeElementsArray(swiper.pagination.el);
    if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {
      if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
      const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);
      if (isHidden === true) {
        emit('paginationShow');
      } else {
        emit('paginationHide');
      }
      el.forEach(subEl => subEl.classList.toggle(swiper.params.pagination.hiddenClass));
    }
  });
  const enable = () => {
    swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);
    let {
      el
    } = swiper.pagination;
    if (el) {
      el = makeElementsArray(el);
      el.forEach(subEl => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));
    }
    init();
    render();
    update();
  };
  const disable = () => {
    swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);
    let {
      el
    } = swiper.pagination;
    if (el) {
      el = makeElementsArray(el);
      el.forEach(subEl => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));
    }
    destroy();
  };
  Object.assign(swiper.pagination, {
    enable,
    disable,
    render,
    update,
    init,
    destroy
  });
}

var css_248z = i$2`/**
 * Swiper 11.1.4
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * https://swiperjs.com
 *
 * Copyright 2014-2024 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: May 30, 2024
 */

/* FONT_START */
@font-face {
  font-family: 'swiper-icons';
  src: url('data:application/font-woff;charset=utf-8;base64, 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');
  font-weight: 400;
  font-style: normal;
}
/* FONT_END */
:root {
  --swiper-theme-color: #007aff;
  /*
  --swiper-preloader-color: var(--swiper-theme-color);
  --swiper-wrapper-transition-timing-function: initial;
  */
}
:host {
  position: relative;
  display: block;
  margin-left: auto;
  margin-right: auto;
  z-index: 1;
}
.swiper {
  margin-left: auto;
  margin-right: auto;
  position: relative;
  overflow: hidden;
  list-style: none;
  padding: 0;
  /* Fix of Webkit flickering */
  z-index: 1;
  display: block;
}
.swiper-vertical > .swiper-wrapper {
  flex-direction: column;
}
.swiper-wrapper {
  position: relative;
  width: 100%;
  height: 100%;
  z-index: 1;
  display: flex;
  transition-property: transform;
  transition-timing-function: ease;
  transition-timing-function: initial;
  transition-timing-function: var(--swiper-wrapper-transition-timing-function, initial);
  box-sizing: content-box;
}
.swiper-android .swiper-slide,
.swiper-ios .swiper-slide,
.swiper-wrapper {
  transform: translate3d(0px, 0, 0);
}
.swiper-horizontal {
  touch-action: pan-y;
}
.swiper-vertical {
  touch-action: pan-x;
}
.swiper-slide {
  flex-shrink: 0;
  width: 100%;
  height: 100%;
  position: relative;
  transition-property: transform;
  display: block;
}
.swiper-slide-invisible-blank {
  visibility: hidden;
}
/* Auto Height */
.swiper-autoheight,
.swiper-autoheight .swiper-slide {
  height: auto;
}
.swiper-autoheight .swiper-wrapper {
  align-items: flex-start;
  transition-property: transform, height;
}
.swiper-backface-hidden .swiper-slide {
  transform: translateZ(0);
  backface-visibility: hidden;
}
/* 3D Effects */
.swiper-3d.swiper-css-mode .swiper-wrapper {
  perspective: 1200px;
}
.swiper-3d .swiper-wrapper {
  transform-style: preserve-3d;
}
.swiper-3d {
  perspective: 1200px;
}
.swiper-3d .swiper-slide,
.swiper-3d .swiper-cube-shadow {
  transform-style: preserve-3d;
}
/* CSS Mode */
.swiper-css-mode > .swiper-wrapper {
  overflow: auto;
  scrollbar-width: none;
  /* For Firefox */
  -ms-overflow-style: none;
  /* For Internet Explorer and Edge */
}
.swiper-css-mode > .swiper-wrapper::-webkit-scrollbar {
  display: none;
}
.swiper-css-mode > .swiper-wrapper > .swiper-slide {
  scroll-snap-align: start start;
}
.swiper-css-mode.swiper-horizontal > .swiper-wrapper {
  scroll-snap-type: x mandatory;
}
.swiper-css-mode.swiper-vertical > .swiper-wrapper {
  scroll-snap-type: y mandatory;
}
.swiper-css-mode.swiper-free-mode > .swiper-wrapper {
  scroll-snap-type: none;
}
.swiper-css-mode.swiper-free-mode > .swiper-wrapper > .swiper-slide {
  scroll-snap-align: none;
}
.swiper-css-mode.swiper-centered > .swiper-wrapper::before {
  content: '';
  flex-shrink: 0;
  order: 9999;
}
.swiper-css-mode.swiper-centered > .swiper-wrapper > .swiper-slide {
  scroll-snap-align: center center;
  scroll-snap-stop: always;
}
.swiper-css-mode.swiper-centered.swiper-horizontal > .swiper-wrapper > .swiper-slide:first-child {
  margin-left: var(--swiper-centered-offset-before);
}
.swiper-css-mode.swiper-centered.swiper-horizontal > .swiper-wrapper::before {
  height: 100%;
  min-height: 1px;
  width: var(--swiper-centered-offset-after);
}
.swiper-css-mode.swiper-centered.swiper-vertical > .swiper-wrapper > .swiper-slide:first-child {
  margin-top: var(--swiper-centered-offset-before);
}
.swiper-css-mode.swiper-centered.swiper-vertical > .swiper-wrapper::before {
  width: 100%;
  min-width: 1px;
  height: var(--swiper-centered-offset-after);
}
/* Slide styles start */
/* 3D Shadows */
.swiper-3d .swiper-slide-shadow,
.swiper-3d .swiper-slide-shadow-left,
.swiper-3d .swiper-slide-shadow-right,
.swiper-3d .swiper-slide-shadow-top,
.swiper-3d .swiper-slide-shadow-bottom,
.swiper-3d .swiper-slide-shadow,
.swiper-3d .swiper-slide-shadow-left,
.swiper-3d .swiper-slide-shadow-right,
.swiper-3d .swiper-slide-shadow-top,
.swiper-3d .swiper-slide-shadow-bottom {
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 10;
}
.swiper-3d .swiper-slide-shadow {
  background: rgba(0, 0, 0, 0.15);
}
.swiper-3d .swiper-slide-shadow-left {
  background-image: linear-gradient(to left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));
}
.swiper-3d .swiper-slide-shadow-right {
  background-image: linear-gradient(to right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));
}
.swiper-3d .swiper-slide-shadow-top {
  background-image: linear-gradient(to top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));
}
.swiper-3d .swiper-slide-shadow-bottom {
  background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));
}
.swiper-lazy-preloader {
  width: 42px;
  height: 42px;
  position: absolute;
  left: 50%;
  top: 50%;
  margin-left: -21px;
  margin-top: -21px;
  z-index: 10;
  transform-origin: 50%;
  box-sizing: border-box;
  border: 4px solid #007aff;
  border: 4px solid var(--swiper-preloader-color, var(--swiper-theme-color));
  border-radius: 50%;
  border-top-color: transparent;
}
.swiper:not(.swiper-watch-progress) .swiper-lazy-preloader,
.swiper-watch-progress .swiper-slide-visible .swiper-lazy-preloader {
  animation: swiper-preloader-spin 1s infinite linear;
}
.swiper-lazy-preloader-white {
  --swiper-preloader-color: #fff;
}
.swiper-lazy-preloader-black {
  --swiper-preloader-color: #000;
}
@keyframes swiper-preloader-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
/* Slide styles end */
.swiper-virtual .swiper-slide {
  -webkit-backface-visibility: hidden;
  transform: translateZ(0);
}
.swiper-virtual.swiper-css-mode .swiper-wrapper::after {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  pointer-events: none;
}
.swiper-virtual.swiper-css-mode.swiper-horizontal .swiper-wrapper::after {
  height: 1px;
  width: var(--swiper-virtual-size);
}
.swiper-virtual.swiper-css-mode.swiper-vertical .swiper-wrapper::after {
  width: 1px;
  height: var(--swiper-virtual-size);
}
:root {
  --swiper-navigation-size: 44px;
  /*
  --swiper-navigation-top-offset: 50%;
  --swiper-navigation-sides-offset: 10px;
  --swiper-navigation-color: var(--swiper-theme-color);
  */
}
.swiper-button-prev,
.swiper-button-next {
  position: absolute;
  top: 50%;
  top: var(--swiper-navigation-top-offset, 50%);
  width: calc(44px / 44 * 27);
  width: calc(var(--swiper-navigation-size) / 44 * 27);
  height: 44px;
  height: var(--swiper-navigation-size);
  margin-top: calc(0px - (44px / 2));
  margin-top: calc(0px - (var(--swiper-navigation-size) / 2));
  z-index: 10;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #007aff;
  color: var(--swiper-navigation-color, var(--swiper-theme-color));
}
.swiper-button-prev.swiper-button-disabled,
.swiper-button-next.swiper-button-disabled {
  opacity: 0.35;
  cursor: auto;
  pointer-events: none;
}
.swiper-button-prev.swiper-button-hidden,
.swiper-button-next.swiper-button-hidden {
  opacity: 0;
  cursor: auto;
  pointer-events: none;
}
.swiper-navigation-disabled .swiper-button-prev,
.swiper-navigation-disabled .swiper-button-next {
  display: none !important;
}
.swiper-button-prev svg,
.swiper-button-next svg {
  width: 100%;
  height: 100%;
  -o-object-fit: contain;
     object-fit: contain;
  transform-origin: center;
}
.swiper-rtl .swiper-button-prev svg,
.swiper-rtl .swiper-button-next svg {
  transform: rotate(180deg);
}
.swiper-button-prev,
.swiper-rtl .swiper-button-next {
  left: 10px;
  left: var(--swiper-navigation-sides-offset, 10px);
  right: auto;
}
.swiper-button-next,
.swiper-rtl .swiper-button-prev {
  right: 10px;
  right: var(--swiper-navigation-sides-offset, 10px);
  left: auto;
}
.swiper-button-lock {
  display: none;
}
/* Navigation font start */
.swiper-button-prev:after,
.swiper-button-next:after {
  font-family: swiper-icons;
  font-size: 44px;
  font-size: var(--swiper-navigation-size);
  text-transform: none !important;
  letter-spacing: 0;
  font-feature-settings: ;
  font-variant: normal;
  font-variant: initial;
  line-height: 1;
}
.swiper-button-prev:after,
.swiper-rtl .swiper-button-next:after {
  content: 'prev';
}
.swiper-button-next,
.swiper-rtl .swiper-button-prev {
  right: 10px;
  right: var(--swiper-navigation-sides-offset, 10px);
  left: auto;
}
.swiper-button-next:after,
.swiper-rtl .swiper-button-prev:after {
  content: 'next';
}
/* Navigation font end */
:root {
  /*
  --swiper-pagination-color: var(--swiper-theme-color);
  --swiper-pagination-left: auto;
  --swiper-pagination-right: 8px;
  --swiper-pagination-bottom: 8px;
  --swiper-pagination-top: auto;
  --swiper-pagination-fraction-color: inherit;
  --swiper-pagination-progressbar-bg-color: rgba(0,0,0,0.25);
  --swiper-pagination-progressbar-size: 4px;
  --swiper-pagination-bullet-size: 8px;
  --swiper-pagination-bullet-width: 8px;
  --swiper-pagination-bullet-height: 8px;
  --swiper-pagination-bullet-border-radius: 50%;
  --swiper-pagination-bullet-inactive-color: #000;
  --swiper-pagination-bullet-inactive-opacity: 0.2;
  --swiper-pagination-bullet-opacity: 1;
  --swiper-pagination-bullet-horizontal-gap: 4px;
  --swiper-pagination-bullet-vertical-gap: 6px;
  */
}
.swiper-pagination {
  position: absolute;
  text-align: center;
  transition: 300ms opacity;
  transform: translate3d(0, 0, 0);
  z-index: 10;
}
.swiper-pagination.swiper-pagination-hidden {
  opacity: 0;
}
.swiper-pagination-disabled > .swiper-pagination,
.swiper-pagination.swiper-pagination-disabled {
  display: none !important;
}
/* Common Styles */
.swiper-pagination-fraction,
.swiper-pagination-custom,
.swiper-horizontal > .swiper-pagination-bullets,
.swiper-pagination-bullets.swiper-pagination-horizontal {
  bottom: 8px;
  bottom: var(--swiper-pagination-bottom, 8px);
  top: auto;
  top: var(--swiper-pagination-top, auto);
  left: 0;
  width: 100%;
}
/* Bullets */
.swiper-pagination-bullets-dynamic {
  overflow: hidden;
  font-size: 0;
}
.swiper-pagination-bullets-dynamic .swiper-pagination-bullet {
  transform: scale(0.33);
  position: relative;
}
.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active {
  transform: scale(1);
}
.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main {
  transform: scale(1);
}
.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev {
  transform: scale(0.66);
}
.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev {
  transform: scale(0.33);
}
.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next {
  transform: scale(0.66);
}
.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next {
  transform: scale(0.33);
}
.swiper-pagination-bullet {
  width: 8px;
  width: var(--swiper-pagination-bullet-width, var(--swiper-pagination-bullet-size, 8px));
  height: 8px;
  height: var(--swiper-pagination-bullet-height, var(--swiper-pagination-bullet-size, 8px));
  display: inline-block;
  border-radius: 50%;
  border-radius: var(--swiper-pagination-bullet-border-radius, 50%);
  background: #000;
  background: var(--swiper-pagination-bullet-inactive-color, #000);
  opacity: 0.2;
  opacity: var(--swiper-pagination-bullet-inactive-opacity, 0.2);
}
button.swiper-pagination-bullet {
  border: none;
  margin: 0;
  padding: 0;
  box-shadow: none;
  -webkit-appearance: none;
          -moz-appearance: none;
       appearance: none;
}
.swiper-pagination-clickable .swiper-pagination-bullet {
  cursor: pointer;
}
.swiper-pagination-bullet:only-child {
  display: none !important;
}
.swiper-pagination-bullet-active {
  opacity: 1;
  opacity: var(--swiper-pagination-bullet-opacity, 1);
  background: #007aff;
  background: var(--swiper-pagination-color, var(--swiper-theme-color));
}
.swiper-vertical > .swiper-pagination-bullets,
.swiper-pagination-vertical.swiper-pagination-bullets {
  right: 8px;
  right: var(--swiper-pagination-right, 8px);
  left: auto;
  left: var(--swiper-pagination-left, auto);
  top: 50%;
  transform: translate3d(0px, -50%, 0);
}
.swiper-vertical > .swiper-pagination-bullets .swiper-pagination-bullet,
.swiper-pagination-vertical.swiper-pagination-bullets .swiper-pagination-bullet {
  margin: 6px 0;
  margin: var(--swiper-pagination-bullet-vertical-gap, 6px) 0;
  display: block;
}
.swiper-vertical > .swiper-pagination-bullets.swiper-pagination-bullets-dynamic,
.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic {
  top: 50%;
  transform: translateY(-50%);
  width: 8px;
}
.swiper-vertical > .swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,
.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet {
  display: inline-block;
  transition: 200ms transform, 200ms top;
}
.swiper-horizontal > .swiper-pagination-bullets .swiper-pagination-bullet,
.swiper-pagination-horizontal.swiper-pagination-bullets .swiper-pagination-bullet {
  margin: 0 4px;
  margin: 0 var(--swiper-pagination-bullet-horizontal-gap, 4px);
}
.swiper-horizontal > .swiper-pagination-bullets.swiper-pagination-bullets-dynamic,
.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic {
  left: 50%;
  transform: translateX(-50%);
  white-space: nowrap;
}
.swiper-horizontal > .swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,
.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet {
  transition: 200ms transform, 200ms left;
}
.swiper-horizontal.swiper-rtl > .swiper-pagination-bullets-dynamic .swiper-pagination-bullet {
  transition: 200ms transform, 200ms right;
}
/* Fraction */
.swiper-pagination-fraction {
  color: inherit;
  color: var(--swiper-pagination-fraction-color, inherit);
}
/* Progress */
.swiper-pagination-progressbar {
  background: rgba(0, 0, 0, 0.25);
  background: var(--swiper-pagination-progressbar-bg-color, rgba(0, 0, 0, 0.25));
  position: absolute;
}
.swiper-pagination-progressbar .swiper-pagination-progressbar-fill {
  background: #007aff;
  background: var(--swiper-pagination-color, var(--swiper-theme-color));
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  transform: scale(0);
  transform-origin: left top;
}
.swiper-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill {
  transform-origin: right top;
}
.swiper-horizontal > .swiper-pagination-progressbar,
.swiper-pagination-progressbar.swiper-pagination-horizontal,
.swiper-vertical > .swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,
.swiper-pagination-progressbar.swiper-pagination-vertical.swiper-pagination-progressbar-opposite {
  width: 100%;
  height: 4px;
  height: var(--swiper-pagination-progressbar-size, 4px);
  left: 0;
  top: 0;
}
.swiper-vertical > .swiper-pagination-progressbar,
.swiper-pagination-progressbar.swiper-pagination-vertical,
.swiper-horizontal > .swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,
.swiper-pagination-progressbar.swiper-pagination-horizontal.swiper-pagination-progressbar-opposite {
  width: 4px;
  width: var(--swiper-pagination-progressbar-size, 4px);
  height: 100%;
  left: 0;
  top: 0;
}
.swiper-pagination-lock {
  display: none;
}
:root {
  /*
  --swiper-scrollbar-border-radius: 10px;
  --swiper-scrollbar-top: auto;
  --swiper-scrollbar-bottom: 4px;
  --swiper-scrollbar-left: auto;
  --swiper-scrollbar-right: 4px;
  --swiper-scrollbar-sides-offset: 1%;
  --swiper-scrollbar-bg-color: rgba(0, 0, 0, 0.1);
  --swiper-scrollbar-drag-bg-color: rgba(0, 0, 0, 0.5);
  --swiper-scrollbar-size: 4px;
  */
}
.swiper-scrollbar {
  border-radius: 10px;
  border-radius: var(--swiper-scrollbar-border-radius, 10px);
  position: relative;
  touch-action: none;
  background: rgba(0, 0, 0, 0.1);
  background: var(--swiper-scrollbar-bg-color, rgba(0, 0, 0, 0.1));
}
.swiper-scrollbar-disabled > .swiper-scrollbar,
.swiper-scrollbar.swiper-scrollbar-disabled {
  display: none !important;
}
.swiper-horizontal > .swiper-scrollbar,
.swiper-scrollbar.swiper-scrollbar-horizontal {
  position: absolute;
  left: 1%;
  left: var(--swiper-scrollbar-sides-offset, 1%);
  bottom: 4px;
  bottom: var(--swiper-scrollbar-bottom, 4px);
  top: auto;
  top: var(--swiper-scrollbar-top, auto);
  z-index: 50;
  height: 4px;
  height: var(--swiper-scrollbar-size, 4px);
  width: calc(100% - 2 * 1%);
  width: calc(100% - 2 * var(--swiper-scrollbar-sides-offset, 1%));
}
.swiper-vertical > .swiper-scrollbar,
.swiper-scrollbar.swiper-scrollbar-vertical {
  position: absolute;
  left: auto;
  left: var(--swiper-scrollbar-left, auto);
  right: 4px;
  right: var(--swiper-scrollbar-right, 4px);
  top: 1%;
  top: var(--swiper-scrollbar-sides-offset, 1%);
  z-index: 50;
  width: 4px;
  width: var(--swiper-scrollbar-size, 4px);
  height: calc(100% - 2 * 1%);
  height: calc(100% - 2 * var(--swiper-scrollbar-sides-offset, 1%));
}
.swiper-scrollbar-drag {
  height: 100%;
  width: 100%;
  position: relative;
  background: rgba(0, 0, 0, 0.5);
  background: var(--swiper-scrollbar-drag-bg-color, rgba(0, 0, 0, 0.5));
  border-radius: 10px;
  border-radius: var(--swiper-scrollbar-border-radius, 10px);
  left: 0;
  top: 0;
}
.swiper-scrollbar-cursor-drag {
  cursor: move;
}
.swiper-scrollbar-lock {
  display: none;
}
/* Zoom container styles start */
.swiper-zoom-container {
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  text-align: center;
}
.swiper-zoom-container > img,
.swiper-zoom-container > svg,
.swiper-zoom-container > canvas {
  max-width: 100%;
  max-height: 100%;
  -o-object-fit: contain;
     object-fit: contain;
}
/* Zoom container styles end */
.swiper-slide-zoomed {
  cursor: move;
  touch-action: none;
}
/* a11y */
.swiper .swiper-notification {
  position: absolute;
  left: 0;
  top: 0;
  pointer-events: none;
  opacity: 0;
  z-index: -1000;
}
.swiper-free-mode > .swiper-wrapper {
  transition-timing-function: ease-out;
  margin: 0 auto;
}
.swiper-grid > .swiper-wrapper {
  flex-wrap: wrap;
}
.swiper-grid-column > .swiper-wrapper {
  flex-wrap: wrap;
  flex-direction: column;
}
.swiper-fade.swiper-free-mode .swiper-slide {
  transition-timing-function: ease-out;
}
.swiper-fade .swiper-slide {
  pointer-events: none;
  transition-property: opacity;
}
.swiper-fade .swiper-slide .swiper-slide {
  pointer-events: none;
}
.swiper-fade .swiper-slide-active {
  pointer-events: auto;
}
.swiper-fade .swiper-slide-active .swiper-slide-active {
  pointer-events: auto;
}
.swiper-cube {
  overflow: visible;
}
.swiper-cube .swiper-slide {
  pointer-events: none;
  backface-visibility: hidden;
  z-index: 1;
  visibility: hidden;
  transform-origin: 0 0;
  width: 100%;
  height: 100%;
}
.swiper-cube .swiper-slide .swiper-slide {
  pointer-events: none;
}
.swiper-cube.swiper-rtl .swiper-slide {
  transform-origin: 100% 0;
}
.swiper-cube .swiper-slide-active,
.swiper-cube .swiper-slide-active .swiper-slide-active {
  pointer-events: auto;
}
.swiper-cube .swiper-slide-active,
.swiper-cube .swiper-slide-next,
.swiper-cube .swiper-slide-prev {
  pointer-events: auto;
  visibility: visible;
}
.swiper-cube .swiper-cube-shadow {
  position: absolute;
  left: 0;
  bottom: 0px;
  width: 100%;
  height: 100%;
  opacity: 0.6;
  z-index: 0;
}
.swiper-cube .swiper-cube-shadow:before {
  content: '';
  background: #000;
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  right: 0;
  filter: blur(50px);
}
.swiper-cube .swiper-slide-next + .swiper-slide {
  pointer-events: auto;
  visibility: visible;
}
/* Cube slide shadows start */
.swiper-cube .swiper-slide-shadow-cube.swiper-slide-shadow-top,
.swiper-cube .swiper-slide-shadow-cube.swiper-slide-shadow-bottom,
.swiper-cube .swiper-slide-shadow-cube.swiper-slide-shadow-left,
.swiper-cube .swiper-slide-shadow-cube.swiper-slide-shadow-right {
  z-index: 0;
  backface-visibility: hidden;
}
/* Cube slide shadows end */
.swiper-flip {
  overflow: visible;
}
.swiper-flip .swiper-slide {
  pointer-events: none;
  backface-visibility: hidden;
  z-index: 1;
}
.swiper-flip .swiper-slide .swiper-slide {
  pointer-events: none;
}
.swiper-flip .swiper-slide-active,
.swiper-flip .swiper-slide-active .swiper-slide-active {
  pointer-events: auto;
}
/* Flip slide shadows start */
.swiper-flip .swiper-slide-shadow-flip.swiper-slide-shadow-top,
.swiper-flip .swiper-slide-shadow-flip.swiper-slide-shadow-bottom,
.swiper-flip .swiper-slide-shadow-flip.swiper-slide-shadow-left,
.swiper-flip .swiper-slide-shadow-flip.swiper-slide-shadow-right {
  z-index: 0;
  backface-visibility: hidden;
}
/* Flip slide shadows end */
.swiper-creative .swiper-slide {
  backface-visibility: hidden;
  overflow: hidden;
  transition-property: transform, opacity, height;
}
.swiper-cards {
  overflow: visible;
}
.swiper-cards .swiper-slide {
  transform-origin: center bottom;
  backface-visibility: hidden;
  overflow: hidden;
}
`;
styleInject(css_248z);

let HeaderSlide = class HeaderSlide extends s {
    constructor() {
        super(...arguments);
        this.images = [];
        this.swiper = null;
    }
    firstUpdated() {
        if (!this.swiper) {
            this.initSwiper();
        }
    }
    initSwiper() {
        var _a;
        const swiperCon = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('.swiper-container');
        if (!swiperCon)
            return;
        const paginationEl = swiperCon.querySelector('.swiper-pagination');
        this.swiper = new Swiper(swiperCon, {
            modules: [Pagination],
            centeredSlides: true,
            grabCursor: true,
            speed: 500,
            roundLengths: true,
            keyboard: {
                enabled: true,
                onlyInViewport: true,
            },
            loop: true,
            slidesPerView: 1,
            pagination: {
                el: paginationEl,
                clickable: true,
            },
        });
    }
    render() {
        const images = this.images;
        if (!images || images.length === 0) {
            return x ``;
        }
        return x `
      <section id="swiper">
        <div class="swiper-container">
          <div class="swiper-wrapper">
            ${images.map((image) => x `
                <div class="swiper-slide">
                  <img src="${image}" />
                </div>
              `)}
          </div>
          <div class="swiper-pagination"></div>
        </div>
      </section>
    `;
    }
};
HeaderSlide.styles = [
    css_248z,
    i$2 `
      :host {
        --swiper-pagination-bottom: 0px;
        --swiper-theme-color: var(--primary-text-color);
      }
      section {
        display: block;
        padding: 1rem 0;
      }
      .swiper-container {
        width: 100%;
        height: 100%;
        display: block;
      }
      .swiper-slide {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        max-height: 125px;
      }
      .swiper-slide:active {
        scale: 1.02;
      }
      .swiper-slide img {
        width: 100%;
        height: 100%;
        max-height: 150px;
        object-fit: scale-down;
      }
      .swiper-pagination-bullet {
        background-color: var(--swiper-theme-color);
        transition: all 0.3s ease-in-out !important;
      }
      .swiper-pagination-bullet-active {
        width: 18px !important;
        border-radius: 1rem !important;
        opacity: 0.7;
      }
    `,
];
__decorate([
    n$1({ type: Array })
], HeaderSlide.prototype, "images", void 0);
__decorate([
    n$1({ type: Object })
], HeaderSlide.prototype, "swiper", void 0);
HeaderSlide = __decorate([
    e$1('header-slide')
], HeaderSlide);

var apexcharts_common = createCommonjsModule(function (module, exports) {
function t(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),i.push.apply(i,a);}return i}function e(e){for(var i=1;i<arguments.length;i++){var a=null!=arguments[i]?arguments[i]:{};i%2?t(Object(a),!0).forEach((function(t){o(e,t,a[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):t(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t));}));}return e}function i(t){return i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i(t)}function a(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function s(t,e){for(var i=0;i<e.length;i++){var a=e[i];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(t,a.key,a);}}function r(t,e,i){return e&&s(t.prototype,e),i&&s(t,i),t}function o(t,e,i){return e in t?Object.defineProperty(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[e]=i,t}function n(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&h(t,e);}function l(t){return l=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)},l(t)}function h(t,e){return h=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t},h(t,e)}function c(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function d(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return !1;if(Reflect.construct.sham)return !1;if("function"==typeof Proxy)return !0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return !1}}();return function(){var i,a=l(t);if(e){var s=l(this).constructor;i=Reflect.construct(a,arguments,s);}else i=a.apply(this,arguments);return function(t,e){if(e&&("object"==typeof e||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return c(t)}(this,i)}}function g(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var i=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null==i)return;var a,s,r=[],o=!0,n=!1;try{for(i=i.call(t);!(o=(a=i.next()).done)&&(r.push(a.value),!e||r.length!==e);o=!0);}catch(t){n=!0,s=t;}finally{try{o||null==i.return||i.return();}finally{if(n)throw s}}return r}(t,e)||p(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function u(t){return function(t){if(Array.isArray(t))return f(t)}(t)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(t)||p(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function p(t,e){if(t){if("string"==typeof t)return f(t,e);var i=Object.prototype.toString.call(t).slice(8,-1);return "Object"===i&&t.constructor&&(i=t.constructor.name),"Map"===i||"Set"===i?Array.from(t):"Arguments"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)?f(t,e):void 0}}function f(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,a=new Array(e);i<e;i++)a[i]=t[i];return a}var x=function(){function t(){a(this,t);}return r(t,[{key:"shadeRGBColor",value:function(t,e){var i=e.split(","),a=t<0?0:255,s=t<0?-1*t:t,r=parseInt(i[0].slice(4),10),o=parseInt(i[1],10),n=parseInt(i[2],10);return "rgb("+(Math.round((a-r)*s)+r)+","+(Math.round((a-o)*s)+o)+","+(Math.round((a-n)*s)+n)+")"}},{key:"shadeHexColor",value:function(t,e){var i=parseInt(e.slice(1),16),a=t<0?0:255,s=t<0?-1*t:t,r=i>>16,o=i>>8&255,n=255&i;return "#"+(16777216+65536*(Math.round((a-r)*s)+r)+256*(Math.round((a-o)*s)+o)+(Math.round((a-n)*s)+n)).toString(16).slice(1)}},{key:"shadeColor",value:function(e,i){return t.isColorHex(i)?this.shadeHexColor(e,i):this.shadeRGBColor(e,i)}}],[{key:"bind",value:function(t,e){return function(){return t.apply(e,arguments)}}},{key:"isObject",value:function(t){return t&&"object"===i(t)&&!Array.isArray(t)&&null!=t}},{key:"is",value:function(t,e){return Object.prototype.toString.call(e)==="[object "+t+"]"}},{key:"listToArray",value:function(t){var e,i=[];for(e=0;e<t.length;e++)i[e]=t[e];return i}},{key:"extend",value:function(t,e){var i=this;"function"!=typeof Object.assign&&(Object.assign=function(t){if(null==t)throw new TypeError("Cannot convert undefined or null to object");for(var e=Object(t),i=1;i<arguments.length;i++){var a=arguments[i];if(null!=a)for(var s in a)a.hasOwnProperty(s)&&(e[s]=a[s]);}return e});var a=Object.assign({},t);return this.isObject(t)&&this.isObject(e)&&Object.keys(e).forEach((function(s){i.isObject(e[s])&&s in t?a[s]=i.extend(t[s],e[s]):Object.assign(a,o({},s,e[s]));})),a}},{key:"extendArray",value:function(e,i){var a=[];return e.map((function(e){a.push(t.extend(i,e));})),e=a}},{key:"monthMod",value:function(t){return t%12}},{key:"clone",value:function(e){if(t.is("Array",e)){for(var a=[],s=0;s<e.length;s++)a[s]=this.clone(e[s]);return a}if(t.is("Null",e))return null;if(t.is("Date",e))return e;if("object"===i(e)){var r={};for(var o in e)e.hasOwnProperty(o)&&(r[o]=this.clone(e[o]));return r}return e}},{key:"log10",value:function(t){return Math.log(t)/Math.LN10}},{key:"roundToBase10",value:function(t){return Math.pow(10,Math.floor(Math.log10(t)))}},{key:"roundToBase",value:function(t,e){return Math.pow(e,Math.floor(Math.log(t)/Math.log(e)))}},{key:"parseNumber",value:function(t){return null===t?t:parseFloat(t)}},{key:"stripNumber",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return Number.isInteger(t)?t:parseFloat(t.toPrecision(e))}},{key:"randomId",value:function(){return (Math.random()+1).toString(36).substring(4)}},{key:"noExponents",value:function(t){var e=String(t).split(/[eE]/);if(1===e.length)return e[0];var i="",a=t<0?"-":"",s=e[0].replace(".",""),r=Number(e[1])+1;if(r<0){for(i=a+"0.";r++;)i+="0";return i+s.replace(/^-/,"")}for(r-=s.length;r--;)i+="0";return s+i}},{key:"getDimensions",value:function(t){var e=getComputedStyle(t,null),i=t.clientHeight,a=t.clientWidth;return i-=parseFloat(e.paddingTop)+parseFloat(e.paddingBottom),[a-=parseFloat(e.paddingLeft)+parseFloat(e.paddingRight),i]}},{key:"getBoundingClientRect",value:function(t){var e=t.getBoundingClientRect();return {top:e.top,right:e.right,bottom:e.bottom,left:e.left,width:t.clientWidth,height:t.clientHeight,x:e.left,y:e.top}}},{key:"getLargestStringFromArr",value:function(t){return t.reduce((function(t,e){return Array.isArray(e)&&(e=e.reduce((function(t,e){return t.length>e.length?t:e}))),t.length>e.length?t:e}),0)}},{key:"hexToRgba",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"#999999",e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.6;"#"!==t.substring(0,1)&&(t="#999999");var i=t.replace("#","");i=i.match(new RegExp("(.{"+i.length/3+"})","g"));for(var a=0;a<i.length;a++)i[a]=parseInt(1===i[a].length?i[a]+i[a]:i[a],16);return void 0!==e&&i.push(e),"rgba("+i.join(",")+")"}},{key:"getOpacityFromRGBA",value:function(t){return parseFloat(t.replace(/^.*,(.+)\)/,"$1"))}},{key:"rgb2hex",value:function(t){return (t=t.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i))&&4===t.length?"#"+("0"+parseInt(t[1],10).toString(16)).slice(-2)+("0"+parseInt(t[2],10).toString(16)).slice(-2)+("0"+parseInt(t[3],10).toString(16)).slice(-2):""}},{key:"isColorHex",value:function(t){return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(t)}},{key:"getPolygonPos",value:function(t,e){for(var i=[],a=2*Math.PI/e,s=0;s<e;s++){var r={};r.x=t*Math.sin(s*a),r.y=-t*Math.cos(s*a),i.push(r);}return i}},{key:"polarToCartesian",value:function(t,e,i,a){var s=(a-90)*Math.PI/180;return {x:t+i*Math.cos(s),y:e+i*Math.sin(s)}}},{key:"escapeString",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"x",i=t.toString().slice();return i=i.replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi,e)}},{key:"negToZero",value:function(t){return t<0?0:t}},{key:"moveIndexInArray",value:function(t,e,i){if(i>=t.length)for(var a=i-t.length+1;a--;)t.push(void 0);return t.splice(i,0,t.splice(e,1)[0]),t}},{key:"extractNumber",value:function(t){return parseFloat(t.replace(/[^\d.]*/g,""))}},{key:"findAncestor",value:function(t,e){for(;(t=t.parentElement)&&!t.classList.contains(e););return t}},{key:"setELstyles",value:function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t.style.key=e[i]);}},{key:"isNumber",value:function(t){return !isNaN(t)&&parseFloat(Number(t))===t&&!isNaN(parseInt(t,10))}},{key:"isFloat",value:function(t){return Number(t)===t&&t%1!=0}},{key:"isSafari",value:function(){return /^((?!chrome|android).)*safari/i.test(navigator.userAgent)}},{key:"isFirefox",value:function(){return navigator.userAgent.toLowerCase().indexOf("firefox")>-1}},{key:"isIE11",value:function(){if(-1!==window.navigator.userAgent.indexOf("MSIE")||window.navigator.appVersion.indexOf("Trident/")>-1)return !0}},{key:"isIE",value:function(){var t=window.navigator.userAgent,e=t.indexOf("MSIE ");if(e>0)return parseInt(t.substring(e+5,t.indexOf(".",e)),10);if(t.indexOf("Trident/")>0){var i=t.indexOf("rv:");return parseInt(t.substring(i+3,t.indexOf(".",i)),10)}var a=t.indexOf("Edge/");return a>0&&parseInt(t.substring(a+5,t.indexOf(".",a)),10)}},{key:"getGCD",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:7,a=Math.pow(10,i-Math.floor(Math.log10(Math.max(t,e))));for(t=Math.round(Math.abs(t)*a),e=Math.round(Math.abs(e)*a);e;){var s=e;e=t%e,t=s;}return t/a}},{key:"getPrimeFactors",value:function(t){for(var e=[],i=2;t>=2;)t%i==0?(e.push(i),t/=i):i++;return e}},{key:"mod",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:7,a=Math.pow(10,i-Math.floor(Math.log10(Math.max(t,e))));return (t=Math.round(Math.abs(t)*a))%(e=Math.round(Math.abs(e)*a))/a}}]),t}(),b=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w,this.setEasingFunctions();}return r(t,[{key:"setEasingFunctions",value:function(){var t;if(!this.w.globals.easing){switch(this.w.config.chart.animations.easing){case"linear":t="-";break;case"easein":t="<";break;case"easeout":t=">";break;case"easeinout":default:t="<>";break;case"swing":t=function(t){var e=1.70158;return (t-=1)*t*((e+1)*t+e)+1};break;case"bounce":t=function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375};break;case"elastic":t=function(t){return t===!!t?t:Math.pow(2,-10*t)*Math.sin((t-.075)*(2*Math.PI)/.3)+1};}this.w.globals.easing=t;}}},{key:"animateLine",value:function(t,e,i,a){t.attr(e).animate(a).attr(i);}},{key:"animateMarker",value:function(t,e,i,a,s,r){e||(e=0),t.attr({r:e,width:e,height:e}).animate(a,s).attr({r:i,width:i.width,height:i.height}).afterAll((function(){r();}));}},{key:"animateCircle",value:function(t,e,i,a,s){t.attr({r:e.r,cx:e.cx,cy:e.cy}).animate(a,s).attr({r:i.r,cx:i.cx,cy:i.cy});}},{key:"animateRect",value:function(t,e,i,a,s){t.attr(e).animate(a).attr(i).afterAll((function(){return s()}));}},{key:"animatePathsGradually",value:function(t){var e=t.el,i=t.realIndex,a=t.j,s=t.fill,r=t.pathFrom,o=t.pathTo,n=t.speed,l=t.delay,h=this.w,c=0;h.config.chart.animations.animateGradually.enabled&&(c=h.config.chart.animations.animateGradually.delay),h.config.chart.animations.dynamicAnimation.enabled&&h.globals.dataChanged&&"bar"!==h.config.chart.type&&(c=0),this.morphSVG(e,i,a,"line"!==h.config.chart.type||h.globals.comboCharts?s:"stroke",r,o,n,l*c);}},{key:"showDelayedElements",value:function(){this.w.globals.delayedElements.forEach((function(t){var e=t.el;e.classList.remove("apexcharts-element-hidden"),e.classList.add("apexcharts-hidden-element-shown");}));}},{key:"animationCompleted",value:function(t){var e=this.w;e.globals.animationEnded||(e.globals.animationEnded=!0,this.showDelayedElements(),"function"==typeof e.config.chart.events.animationEnd&&e.config.chart.events.animationEnd(this.ctx,{el:t,w:e}));}},{key:"morphSVG",value:function(t,e,i,a,s,r,o,n){var l=this,h=this.w;s||(s=t.attr("pathFrom")),r||(r=t.attr("pathTo"));var c=function(t){return "radar"===h.config.chart.type&&(o=1),"M 0 ".concat(h.globals.gridHeight)};(!s||s.indexOf("undefined")>-1||s.indexOf("NaN")>-1)&&(s=c()),(!r||r.indexOf("undefined")>-1||r.indexOf("NaN")>-1)&&(r=c()),h.globals.shouldAnimate||(o=1),t.plot(s).animate(1,h.globals.easing,n).plot(s).animate(o,h.globals.easing,n).plot(r).afterAll((function(){x.isNumber(i)?i===h.globals.series[h.globals.maxValsInArrayIndex].length-2&&h.globals.shouldAnimate&&l.animationCompleted(t):"none"!==a&&h.globals.shouldAnimate&&(!h.globals.comboCharts&&e===h.globals.series.length-1||h.globals.comboCharts)&&l.animationCompleted(t),l.showDelayedElements();}));}}]),t}(),v=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w;}return r(t,[{key:"getDefaultFilter",value:function(t,e){var i=this.w;t.unfilter(!0),(new window.SVG.Filter).size("120%","180%","-5%","-40%"),"none"!==i.config.states.normal.filter?this.applyFilter(t,e,i.config.states.normal.filter.type,i.config.states.normal.filter.value):i.config.chart.dropShadow.enabled&&this.dropShadow(t,i.config.chart.dropShadow,e);}},{key:"addNormalFilter",value:function(t,e){var i=this.w;i.config.chart.dropShadow.enabled&&!t.node.classList.contains("apexcharts-marker")&&this.dropShadow(t,i.config.chart.dropShadow,e);}},{key:"addLightenFilter",value:function(t,e,i){var a=this,s=this.w,r=i.intensity;t.unfilter(!0);new window.SVG.Filter;t.filter((function(t){var i=s.config.chart.dropShadow;(i.enabled?a.addShadow(t,e,i):t).componentTransfer({rgb:{type:"linear",slope:1.5,intercept:r}});})),t.filterer.node.setAttribute("filterUnits","userSpaceOnUse"),this._scaleFilterSize(t.filterer.node);}},{key:"addDarkenFilter",value:function(t,e,i){var a=this,s=this.w,r=i.intensity;t.unfilter(!0);new window.SVG.Filter;t.filter((function(t){var i=s.config.chart.dropShadow;(i.enabled?a.addShadow(t,e,i):t).componentTransfer({rgb:{type:"linear",slope:r}});})),t.filterer.node.setAttribute("filterUnits","userSpaceOnUse"),this._scaleFilterSize(t.filterer.node);}},{key:"applyFilter",value:function(t,e,i){var a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;switch(i){case"none":this.addNormalFilter(t,e);break;case"lighten":this.addLightenFilter(t,e,{intensity:a});break;case"darken":this.addDarkenFilter(t,e,{intensity:a});}}},{key:"addShadow",value:function(t,e,i){var a,s=this.w,r=i.blur,o=i.top,n=i.left,l=i.color,h=i.opacity;if((null===(a=s.config.chart.dropShadow.enabledOnSeries)||void 0===a?void 0:a.length)>0&&-1===s.config.chart.dropShadow.enabledOnSeries.indexOf(e))return t;var c=t.flood(Array.isArray(l)?l[e]:l,h).composite(t.sourceAlpha,"in").offset(n,o).gaussianBlur(r).merge(t.source);return t.blend(t.source,c)}},{key:"dropShadow",value:function(t,e){var i,a,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=e.top,o=e.left,n=e.blur,l=e.color,h=e.opacity,c=e.noUserSpaceOnUse,d=this.w;if(t.unfilter(!0),x.isIE()&&"radialBar"===d.config.chart.type)return t;if((null===(i=d.config.chart.dropShadow.enabledOnSeries)||void 0===i?void 0:i.length)>0&&-1===(null===(a=d.config.chart.dropShadow.enabledOnSeries)||void 0===a?void 0:a.indexOf(s)))return t;return l=Array.isArray(l)?l[s]:l,t.filter((function(t){var e=null;e=x.isSafari()||x.isFirefox()||x.isIE()?t.flood(l,h).composite(t.sourceAlpha,"in").offset(o,r).gaussianBlur(n):t.flood(l,h).composite(t.sourceAlpha,"in").offset(o,r).gaussianBlur(n).merge(t.source),t.blend(t.source,e);})),c||t.filterer.node.setAttribute("filterUnits","userSpaceOnUse"),this._scaleFilterSize(t.filterer.node),t}},{key:"setSelectionFilter",value:function(t,e,i){var a=this.w;if(void 0!==a.globals.selectedDataPoints[e]&&a.globals.selectedDataPoints[e].indexOf(i)>-1){t.node.setAttribute("selected",!0);var s=a.config.states.active.filter;"none"!==s&&this.applyFilter(t,e,s.type,s.value);}}},{key:"_scaleFilterSize",value:function(t){!function(e){for(var i in e)e.hasOwnProperty(i)&&t.setAttribute(i,e[i]);}({width:"200%",height:"200%",x:"-50%",y:"-50%"});}}]),t}(),m=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w;}return r(t,[{key:"roundPathCorners",value:function(t,e){function i(t,e,i){var s=e.x-t.x,r=e.y-t.y,o=Math.sqrt(s*s+r*r);return a(t,e,Math.min(1,i/o))}function a(t,e,i){return {x:t.x+(e.x-t.x)*i,y:t.y+(e.y-t.y)*i}}function s(t,e){t.length>2&&(t[t.length-2]=e.x,t[t.length-1]=e.y);}function r(t){return {x:parseFloat(t[t.length-2]),y:parseFloat(t[t.length-1])}}t.indexOf("NaN")>-1&&(t="");var o=t.split(/[,\s]/).reduce((function(t,e){var i=e.match("([a-zA-Z])(.+)");return i?(t.push(i[1]),t.push(i[2])):t.push(e),t}),[]).reduce((function(t,e){return parseFloat(e)==e&&t.length?t[t.length-1].push(e):t.push([e]),t}),[]),n=[];if(o.length>1){var l=r(o[0]),h=null;"Z"==o[o.length-1][0]&&o[0].length>2&&(h=["L",l.x,l.y],o[o.length-1]=h),n.push(o[0]);for(var c=1;c<o.length;c++){var d=n[n.length-1],g=o[c],u=g==h?o[1]:o[c+1];if(u&&d&&d.length>2&&"L"==g[0]&&u.length>2&&"L"==u[0]){var p,f,x=r(d),b=r(g),v=r(u);p=i(b,x,e),f=i(b,v,e),s(g,p),g.origPoint=b,n.push(g);var m=a(p,b,.5),y=a(b,f,.5),w=["C",m.x,m.y,y.x,y.y,f.x,f.y];w.origPoint=b,n.push(w);}else n.push(g);}if(h){var k=r(n[n.length-1]);n.push(["Z"]),s(n[0],k);}}else n=o;return n.reduce((function(t,e){return t+e.join(" ")+" "}),"")}},{key:"drawLine",value:function(t,e,i,a){var s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"#a8a8a8",r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,n=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"butt";return this.w.globals.dom.Paper.line().attr({x1:t,y1:e,x2:i,y2:a,stroke:s,"stroke-dasharray":r,"stroke-width":o,"stroke-linecap":n})}},{key:"drawRect",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"#fefefe",o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1,n=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,l=arguments.length>8&&void 0!==arguments[8]?arguments[8]:null,h=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,c=this.w.globals.dom.Paper.rect();return c.attr({x:t,y:e,width:i>0?i:0,height:a>0?a:0,rx:s,ry:s,opacity:o,"stroke-width":null!==n?n:0,stroke:null!==l?l:"none","stroke-dasharray":h}),c.node.setAttribute("fill",r),c}},{key:"drawPolygon",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"#e1e1e1",i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"none";return this.w.globals.dom.Paper.polygon(t).attr({fill:a,stroke:e,"stroke-width":i})}},{key:"drawCircle",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t<0&&(t=0);var i=this.w.globals.dom.Paper.circle(2*t);return null!==e&&i.attr(e),i}},{key:"drawPath",value:function(t){var e=t.d,i=void 0===e?"":e,a=t.stroke,s=void 0===a?"#a8a8a8":a,r=t.strokeWidth,o=void 0===r?1:r,n=t.fill,l=t.fillOpacity,h=void 0===l?1:l,c=t.strokeOpacity,d=void 0===c?1:c,g=t.classes,u=t.strokeLinecap,p=void 0===u?null:u,f=t.strokeDashArray,x=void 0===f?0:f,b=this.w;return null===p&&(p=b.config.stroke.lineCap),(i.indexOf("undefined")>-1||i.indexOf("NaN")>-1)&&(i="M 0 ".concat(b.globals.gridHeight)),b.globals.dom.Paper.path(i).attr({fill:n,"fill-opacity":h,stroke:s,"stroke-opacity":d,"stroke-linecap":p,"stroke-width":o,"stroke-dasharray":x,class:g})}},{key:"group",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,e=this.w.globals.dom.Paper.group();return null!==t&&e.attr(t),e}},{key:"move",value:function(t,e){var i=["M",t,e].join(" ");return i}},{key:"line",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=null;return null===i?a=[" L",t,e].join(" "):"H"===i?a=[" H",t].join(" "):"V"===i&&(a=[" V",e].join(" ")),a}},{key:"curve",value:function(t,e,i,a,s,r){var o=["C",t,e,i,a,s,r].join(" ");return o}},{key:"quadraticCurve",value:function(t,e,i,a){return ["Q",t,e,i,a].join(" ")}},{key:"arc",value:function(t,e,i,a,s,r,o){var n="A";arguments.length>7&&void 0!==arguments[7]&&arguments[7]&&(n="a");var l=[n,t,e,i,a,s,r,o].join(" ");return l}},{key:"renderPaths",value:function(t){var i,a=t.j,s=t.realIndex,r=t.pathFrom,o=t.pathTo,n=t.stroke,l=t.strokeWidth,h=t.strokeLinecap,c=t.fill,d=t.animationDelay,g=t.initialSpeed,u=t.dataChangeSpeed,p=t.className,f=t.shouldClipToGrid,x=void 0===f||f,m=t.bindEventsOnPaths,y=void 0===m||m,w=t.drawShadow,k=void 0===w||w,A=this.w,S=new v(this.ctx),C=new b(this.ctx),L=this.w.config.chart.animations.enabled,P=L&&this.w.config.chart.animations.dynamicAnimation.enabled,M=!!(L&&!A.globals.resized||P&&A.globals.dataChanged&&A.globals.shouldAnimate);M?i=r:(i=o,A.globals.animationEnded=!0);var I=A.config.stroke.dashArray,T=0;T=Array.isArray(I)?I[s]:A.config.stroke.dashArray;var z=this.drawPath({d:i,stroke:n,strokeWidth:l,fill:c,fillOpacity:1,classes:p,strokeLinecap:h,strokeDashArray:T});if(z.attr("index",s),x&&z.attr({"clip-path":"url(#gridRectMask".concat(A.globals.cuid,")")}),"none"!==A.config.states.normal.filter.type)S.getDefaultFilter(z,s);else if(A.config.chart.dropShadow.enabled&&k){var X=A.config.chart.dropShadow;S.dropShadow(z,X,s);}y&&(z.node.addEventListener("mouseenter",this.pathMouseEnter.bind(this,z)),z.node.addEventListener("mouseleave",this.pathMouseLeave.bind(this,z)),z.node.addEventListener("mousedown",this.pathMouseDown.bind(this,z))),z.attr({pathTo:o,pathFrom:r});var E={el:z,j:a,realIndex:s,pathFrom:r,pathTo:o,fill:c,strokeWidth:l,delay:d};return !L||A.globals.resized||A.globals.dataChanged?!A.globals.resized&&A.globals.dataChanged||C.showDelayedElements():C.animatePathsGradually(e(e({},E),{},{speed:g})),A.globals.dataChanged&&P&&M&&C.animatePathsGradually(e(e({},E),{},{speed:u})),z}},{key:"drawPattern",value:function(t,e,i){var a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"#a8a8a8",s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;return this.w.globals.dom.Paper.pattern(e,i,(function(r){"horizontalLines"===t?r.line(0,0,i,0).stroke({color:a,width:s+1}):"verticalLines"===t?r.line(0,0,0,e).stroke({color:a,width:s+1}):"slantedLines"===t?r.line(0,0,e,i).stroke({color:a,width:s}):"squares"===t?r.rect(e,i).fill("none").stroke({color:a,width:s}):"circles"===t&&r.circle(e).fill("none").stroke({color:a,width:s});}))}},{key:"drawGradient",value:function(t,e,i,a,s){var r,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,n=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,l=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,h=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0,c=this.w;e.length<9&&0===e.indexOf("#")&&(e=x.hexToRgba(e,a)),i.length<9&&0===i.indexOf("#")&&(i=x.hexToRgba(i,s));var d=0,g=1,u=1,p=null;null!==n&&(d=void 0!==n[0]?n[0]/100:0,g=void 0!==n[1]?n[1]/100:1,u=void 0!==n[2]?n[2]/100:1,p=void 0!==n[3]?n[3]/100:null);var f=!("donut"!==c.config.chart.type&&"pie"!==c.config.chart.type&&"polarArea"!==c.config.chart.type&&"bubble"!==c.config.chart.type);if(r=null===l||0===l.length?c.globals.dom.Paper.gradient(f?"radial":"linear",(function(t){t.at(d,e,a),t.at(g,i,s),t.at(u,i,s),null!==p&&t.at(p,e,a);})):c.globals.dom.Paper.gradient(f?"radial":"linear",(function(t){(Array.isArray(l[h])?l[h]:l).forEach((function(e){t.at(e.offset/100,e.color,e.opacity);}));})),f){var b=c.globals.gridWidth/2,v=c.globals.gridHeight/2;"bubble"!==c.config.chart.type?r.attr({gradientUnits:"userSpaceOnUse",cx:b,cy:v,r:o}):r.attr({cx:.5,cy:.5,r:.8,fx:.2,fy:.2});}else "vertical"===t?r.from(0,0).to(0,1):"diagonal"===t?r.from(0,0).to(1,1):"horizontal"===t?r.from(0,1).to(1,1):"diagonal2"===t&&r.from(1,0).to(0,1);return r}},{key:"getTextBasedOnMaxWidth",value:function(t){var e=t.text,i=t.maxWidth,a=t.fontSize,s=t.fontFamily,r=this.getTextRects(e,a,s),o=r.width/e.length,n=Math.floor(i/o);return i<r.width?e.slice(0,n-3)+"...":e}},{key:"drawText",value:function(t){var i=this,a=t.x,s=t.y,r=t.text,o=t.textAnchor,n=t.fontSize,l=t.fontFamily,h=t.fontWeight,c=t.foreColor,d=t.opacity,g=t.maxWidth,u=t.cssClass,p=void 0===u?"":u,f=t.isPlainText,x=void 0===f||f,b=t.dominantBaseline,v=void 0===b?"auto":b,m=this.w;void 0===r&&(r="");var y=r;o||(o="start"),c&&c.length||(c=m.config.chart.foreColor),l=l||m.config.chart.fontFamily,h=h||"regular";var w,k={maxWidth:g,fontSize:n=n||"11px",fontFamily:l};return Array.isArray(r)?w=m.globals.dom.Paper.text((function(t){for(var a=0;a<r.length;a++)y=r[a],g&&(y=i.getTextBasedOnMaxWidth(e({text:r[a]},k))),0===a?t.tspan(y):t.tspan(y).newLine();})):(g&&(y=this.getTextBasedOnMaxWidth(e({text:r},k))),w=x?m.globals.dom.Paper.plain(r):m.globals.dom.Paper.text((function(t){return t.tspan(y)}))),w.attr({x:a,y:s,"text-anchor":o,"dominant-baseline":v,"font-size":n,"font-family":l,"font-weight":h,fill:c,class:"apexcharts-text "+p}),w.node.style.fontFamily=l,w.node.style.opacity=d,w}},{key:"createGroupWithAttributes",value:function(t,e,i,a){var s=this.group();return i.forEach((function(t){return s.add(t)})),s.attr({class:a.class?a.class:"",cy:e,cx:t}),s}},{key:"drawPlus",value:function(t,e,i,a){var s=i/2,r=this.drawLine(t,e-s,t,e+s,a.pointStrokeColor,a.pointStrokeDashArray,a.pointStrokeWidth,a.pointStrokeLineCap),o=this.drawLine(t-s,e,t+s,e,a.pointStrokeColor,a.pointStrokeDashArray,a.pointStrokeWidth,a.pointStrokeLineCap);return this.createGroupWithAttributes(t,e,[r,o],a)}},{key:"drawX",value:function(t,e,i,a){var s=i/2,r=this.drawLine(t-s,e-s,t+s,e+s,a.pointStrokeColor,a.pointStrokeDashArray,a.pointStrokeWidth,a.pointStrokeLineCap),o=this.drawLine(t-s,e+s,t+s,e-s,a.pointStrokeColor,a.pointStrokeDashArray,a.pointStrokeWidth,a.pointStrokeLineCap);return this.createGroupWithAttributes(t,e,[r,o],a)}},{key:"drawMarker",value:function(t,e,i){t=t||0;var a=i.pSize||0,s=null;if("X"===(null==i?void 0:i.shape)||"x"===(null==i?void 0:i.shape))s=this.drawX(t,e,a,i);else if("plus"===(null==i?void 0:i.shape)||"+"===(null==i?void 0:i.shape))s=this.drawPlus(t,e,a,i);else if("square"===i.shape||"rect"===i.shape){var r=void 0===i.pRadius?a/2:i.pRadius;null!==e&&a||(a=0,r=0);var o=1.2*a+r,n=this.drawRect(o,o,o,o,r);n.attr({x:t-o/2,y:e-o/2,cx:t,cy:e,class:i.class?i.class:"",fill:i.pointFillColor,"fill-opacity":i.pointFillOpacity?i.pointFillOpacity:1,stroke:i.pointStrokeColor,"stroke-width":i.pointStrokeWidth?i.pointStrokeWidth:0,"stroke-opacity":i.pointStrokeOpacity?i.pointStrokeOpacity:1}),s=n;}else "circle"!==i.shape&&i.shape||(x.isNumber(e)||(a=0,e=0),s=this.drawCircle(a,{cx:t,cy:e,class:i.class?i.class:"",stroke:i.pointStrokeColor,fill:i.pointFillColor,"fill-opacity":i.pointFillOpacity?i.pointFillOpacity:1,"stroke-width":i.pointStrokeWidth?i.pointStrokeWidth:0,"stroke-opacity":i.pointStrokeOpacity?i.pointStrokeOpacity:1}));return s}},{key:"pathMouseEnter",value:function(t,e){var i=this.w,a=new v(this.ctx),s=parseInt(t.node.getAttribute("index"),10),r=parseInt(t.node.getAttribute("j"),10);if("function"==typeof i.config.chart.events.dataPointMouseEnter&&i.config.chart.events.dataPointMouseEnter(e,this.ctx,{seriesIndex:s,dataPointIndex:r,w:i}),this.ctx.events.fireEvent("dataPointMouseEnter",[e,this.ctx,{seriesIndex:s,dataPointIndex:r,w:i}]),("none"===i.config.states.active.filter.type||"true"!==t.node.getAttribute("selected"))&&"none"!==i.config.states.hover.filter.type&&!i.globals.isTouchDevice){var o=i.config.states.hover.filter;a.applyFilter(t,s,o.type,o.value);}}},{key:"pathMouseLeave",value:function(t,e){var i=this.w,a=new v(this.ctx),s=parseInt(t.node.getAttribute("index"),10),r=parseInt(t.node.getAttribute("j"),10);"function"==typeof i.config.chart.events.dataPointMouseLeave&&i.config.chart.events.dataPointMouseLeave(e,this.ctx,{seriesIndex:s,dataPointIndex:r,w:i}),this.ctx.events.fireEvent("dataPointMouseLeave",[e,this.ctx,{seriesIndex:s,dataPointIndex:r,w:i}]),"none"!==i.config.states.active.filter.type&&"true"===t.node.getAttribute("selected")||"none"!==i.config.states.hover.filter.type&&a.getDefaultFilter(t,s);}},{key:"pathMouseDown",value:function(t,e){var i=this.w,a=new v(this.ctx),s=parseInt(t.node.getAttribute("index"),10),r=parseInt(t.node.getAttribute("j"),10),o="false";if("true"===t.node.getAttribute("selected")){if(t.node.setAttribute("selected","false"),i.globals.selectedDataPoints[s].indexOf(r)>-1){var n=i.globals.selectedDataPoints[s].indexOf(r);i.globals.selectedDataPoints[s].splice(n,1);}}else {if(!i.config.states.active.allowMultipleDataPointsSelection&&i.globals.selectedDataPoints.length>0){i.globals.selectedDataPoints=[];var l=i.globals.dom.Paper.select(".apexcharts-series path").members,h=i.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members,c=function(t){Array.prototype.forEach.call(t,(function(t){t.node.setAttribute("selected","false"),a.getDefaultFilter(t,s);}));};c(l),c(h);}t.node.setAttribute("selected","true"),o="true",void 0===i.globals.selectedDataPoints[s]&&(i.globals.selectedDataPoints[s]=[]),i.globals.selectedDataPoints[s].push(r);}if("true"===o){var d=i.config.states.active.filter;if("none"!==d)a.applyFilter(t,s,d.type,d.value);else if("none"!==i.config.states.hover.filter&&!i.globals.isTouchDevice){var g=i.config.states.hover.filter;a.applyFilter(t,s,g.type,g.value);}}else if("none"!==i.config.states.active.filter.type)if("none"===i.config.states.hover.filter.type||i.globals.isTouchDevice)a.getDefaultFilter(t,s);else {g=i.config.states.hover.filter;a.applyFilter(t,s,g.type,g.value);}"function"==typeof i.config.chart.events.dataPointSelection&&i.config.chart.events.dataPointSelection(e,this.ctx,{selectedDataPoints:i.globals.selectedDataPoints,seriesIndex:s,dataPointIndex:r,w:i}),e&&this.ctx.events.fireEvent("dataPointSelection",[e,this.ctx,{selectedDataPoints:i.globals.selectedDataPoints,seriesIndex:s,dataPointIndex:r,w:i}]);}},{key:"rotateAroundCenter",value:function(t){var e={};return t&&"function"==typeof t.getBBox&&(e=t.getBBox()),{x:e.x+e.width/2,y:e.y+e.height/2}}},{key:"getTextRects",value:function(t,e,i,a){var s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],r=this.w,o=this.drawText({x:-200,y:-200,text:t,textAnchor:"start",fontSize:e,fontFamily:i,foreColor:"#fff",opacity:0});a&&o.attr("transform",a),r.globals.dom.Paper.add(o);var n=o.bbox();return s||(n=o.node.getBoundingClientRect()),o.remove(),{width:n.width,height:n.height}}},{key:"placeTextWithEllipsis",value:function(t,e,i){if("function"==typeof t.getComputedTextLength&&(t.textContent=e,e.length>0&&t.getComputedTextLength()>=i/1.1)){for(var a=e.length-3;a>0;a-=3)if(t.getSubStringLength(0,a)<=i/1.1)return void(t.textContent=e.substring(0,a)+"...");t.textContent=".";}}}],[{key:"setAttrs",value:function(t,e){for(var i in e)e.hasOwnProperty(i)&&t.setAttribute(i,e[i]);}}]),t}(),y=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w;}return r(t,[{key:"getStackedSeriesTotals",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=this.w,i=[];if(0===e.globals.series.length)return i;for(var a=0;a<e.globals.series[e.globals.maxValsInArrayIndex].length;a++){for(var s=0,r=0;r<e.globals.series.length;r++)void 0!==e.globals.series[r][a]&&-1===t.indexOf(r)&&(s+=e.globals.series[r][a]);i.push(s);}return i}},{key:"getSeriesTotalByIndex",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;return null===t?this.w.config.series.reduce((function(t,e){return t+e}),0):this.w.globals.series[t].reduce((function(t,e){return t+e}),0)}},{key:"getStackedSeriesTotalsByGroups",value:function(){var t=this,e=this.w,i=[];return e.globals.seriesGroups.forEach((function(a){var s=[];e.config.series.forEach((function(t,i){a.indexOf(e.globals.seriesNames[i])>-1&&s.push(i);}));var r=e.globals.series.map((function(t,e){return -1===s.indexOf(e)?e:-1})).filter((function(t){return -1!==t}));i.push(t.getStackedSeriesTotals(r));})),i}},{key:"setSeriesYAxisMappings",value:function(){var t=this.w.globals,e=this.w.config,i=[],a=[],s=[],r=t.series.length>e.yaxis.length||e.yaxis.some((function(t){return Array.isArray(t.seriesName)}));e.series.forEach((function(t,e){s.push(e),a.push(null);})),e.yaxis.forEach((function(t,e){i[e]=[];}));var o=[];e.yaxis.forEach((function(t,a){var n=!1;if(t.seriesName){var l=[];Array.isArray(t.seriesName)?l=t.seriesName:l.push(t.seriesName),l.forEach((function(t){e.series.forEach((function(e,o){if(e.name===t){var l=o;a===o||r?!r||s.indexOf(o)>-1?i[a].push([a,o]):console.warn("Series '"+e.name+"' referenced more than once in what looks like the new style. That is, when using either seriesName: [], or when there are more series than yaxes."):(i[o].push([o,a]),l=a),n=!0,-1!==(l=s.indexOf(l))&&s.splice(l,1);}}));}));}n||o.push(a);})),i=i.map((function(t,e){var i=[];return t.forEach((function(t){a[t[1]]=t[0],i.push(t[1]);})),i}));for(var n=e.yaxis.length-1,l=0;l<o.length&&(n=o[l],i[n]=[],s);l++){var h=s[0];s.shift(),i[n].push(h),a[h]=n;}s.forEach((function(t){i[n].push(t),a[t]=n;})),t.seriesYAxisMap=i.map((function(t){return t})),t.seriesYAxisReverseMap=a.map((function(t){return t})),t.seriesYAxisMap.forEach((function(t,i){t.forEach((function(t){e.series[t]&&void 0===e.series[t].group&&(e.series[t].group="apexcharts-axis-".concat(i.toString()));}));}));}},{key:"isSeriesNull",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;return 0===(null===t?this.w.config.series.filter((function(t){return null!==t})):this.w.config.series[t].data.filter((function(t){return null!==t}))).length}},{key:"seriesHaveSameValues",value:function(t){return this.w.globals.series[t].every((function(t,e,i){return t===i[0]}))}},{key:"getCategoryLabels",value:function(t){var e=this.w,i=t.slice();return e.config.xaxis.convertedCatToNumeric&&(i=t.map((function(t,i){return e.config.xaxis.labels.formatter(t-e.globals.minX+1)}))),i}},{key:"getLargestSeries",value:function(){var t=this.w;t.globals.maxValsInArrayIndex=t.globals.series.map((function(t){return t.length})).indexOf(Math.max.apply(Math,t.globals.series.map((function(t){return t.length}))));}},{key:"getLargestMarkerSize",value:function(){var t=this.w,e=0;return t.globals.markers.size.forEach((function(t){e=Math.max(e,t);})),t.config.markers.discrete&&t.config.markers.discrete.length&&t.config.markers.discrete.forEach((function(t){e=Math.max(e,t.size);})),e>0&&(e+=t.config.markers.hover.sizeOffset+1),t.globals.markers.largestSize=e,e}},{key:"getSeriesTotals",value:function(){var t=this.w;t.globals.seriesTotals=t.globals.series.map((function(t,e){var i=0;if(Array.isArray(t))for(var a=0;a<t.length;a++)i+=t[a];else i+=t;return i}));}},{key:"getSeriesTotalsXRange",value:function(t,e){var i=this.w;return i.globals.series.map((function(a,s){for(var r=0,o=0;o<a.length;o++)i.globals.seriesX[s][o]>t&&i.globals.seriesX[s][o]<e&&(r+=a[o]);return r}))}},{key:"getPercentSeries",value:function(){var t=this.w;t.globals.seriesPercent=t.globals.series.map((function(e,i){var a=[];if(Array.isArray(e))for(var s=0;s<e.length;s++){var r=t.globals.stackedSeriesTotals[s],o=0;r&&(o=100*e[s]/r),a.push(o);}else {var n=100*e/t.globals.seriesTotals.reduce((function(t,e){return t+e}),0);a.push(n);}return a}));}},{key:"getCalculatedRatios",value:function(){var t,e,i,a=this,s=this.w,r=s.globals,o=[],n=0,l=[],h=.1,c=0;if(r.yRange=[],r.isMultipleYAxis)for(var d=0;d<r.minYArr.length;d++)r.yRange.push(Math.abs(r.minYArr[d]-r.maxYArr[d])),l.push(0);else r.yRange.push(Math.abs(r.minY-r.maxY));r.xRange=Math.abs(r.maxX-r.minX),r.zRange=Math.abs(r.maxZ-r.minZ);for(var g=0;g<r.yRange.length;g++)o.push(r.yRange[g]/r.gridHeight);if(e=r.xRange/r.gridWidth,t=r.yRange/r.gridWidth,i=r.xRange/r.gridHeight,(n=r.zRange/r.gridHeight*16)||(n=1),r.minY!==Number.MIN_VALUE&&0!==Math.abs(r.minY)&&(r.hasNegs=!0),s.globals.seriesYAxisReverseMap.length>0){var u=function(t,e){var i=s.config.yaxis[s.globals.seriesYAxisReverseMap[e]],r=t<0?-1:1;return t=Math.abs(t),i.logarithmic&&(t=a.getBaseLog(i.logBase,t)),-r*t/o[e]};if(r.isMultipleYAxis){l=[];for(var p=0;p<o.length;p++)l.push(u(r.minYArr[p],p));}else (l=[]).push(u(r.minY,0)),r.minY!==Number.MIN_VALUE&&0!==Math.abs(r.minY)&&(h=-r.minY/t,c=r.minX/e);}else (l=[]).push(0),h=0,c=0;return {yRatio:o,invertedYRatio:t,zRatio:n,xRatio:e,invertedXRatio:i,baseLineInvertedY:h,baseLineY:l,baseLineX:c}}},{key:"getLogSeries",value:function(t){var e=this,i=this.w;return i.globals.seriesLog=t.map((function(t,a){var s=i.globals.seriesYAxisReverseMap[a];return i.config.yaxis[s]&&i.config.yaxis[s].logarithmic?t.map((function(t){return null===t?null:e.getLogVal(i.config.yaxis[s].logBase,t,a)})):t})),i.globals.invalidLogScale?t:i.globals.seriesLog}},{key:"getBaseLog",value:function(t,e){return Math.log(e)/Math.log(t)}},{key:"getLogVal",value:function(t,e,i){if(e<=0)return 0;var a=this.w,s=0===a.globals.minYArr[i]?-1:this.getBaseLog(t,a.globals.minYArr[i]),r=(0===a.globals.maxYArr[i]?0:this.getBaseLog(t,a.globals.maxYArr[i]))-s;return e<1?e/r:(this.getBaseLog(t,e)-s)/r}},{key:"getLogYRatios",value:function(t){var e=this,i=this.w,a=this.w.globals;return a.yLogRatio=t.slice(),a.logYRange=a.yRange.map((function(t,s){var r=i.globals.seriesYAxisReverseMap[s];if(i.config.yaxis[r]&&e.w.config.yaxis[r].logarithmic){var o,n=-Number.MAX_VALUE,l=Number.MIN_VALUE;return a.seriesLog.forEach((function(t,e){t.forEach((function(t){i.config.yaxis[e]&&i.config.yaxis[e].logarithmic&&(n=Math.max(t,n),l=Math.min(t,l));}));})),o=Math.pow(a.yRange[s],Math.abs(l-n)/a.yRange[s]),a.yLogRatio[s]=o/a.gridHeight,o}})),a.invalidLogScale?t.slice():a.yLogRatio}},{key:"drawSeriesByGroup",value:function(t,e,i,a){var s=this.w,r=[];return t.series.length>0&&e.forEach((function(e){var o=[],n=[];t.i.forEach((function(i,a){s.config.series[i].group===e&&(o.push(t.series[a]),n.push(i));})),o.length>0&&r.push(a.draw(o,i,n));})),r}}],[{key:"checkComboSeries",value:function(t,e){var i=!1,a=0,s=0;return void 0===e&&(e="line"),t.length&&void 0!==t[0].type&&t.forEach((function(t){"bar"!==t.type&&"column"!==t.type&&"candlestick"!==t.type&&"boxPlot"!==t.type||a++,void 0!==t.type&&t.type!==e&&s++;})),s>0&&(i=!0),{comboBarCount:a,comboCharts:i}}},{key:"extendArrayProps",value:function(t,e,i){var a,s,r,o,n,l;(null!==(a=e)&&void 0!==a&&a.yaxis&&(e=t.extendYAxis(e,i)),null!==(s=e)&&void 0!==s&&s.annotations)&&(e.annotations.yaxis&&(e=t.extendYAxisAnnotations(e)),null!==(r=e)&&void 0!==r&&null!==(o=r.annotations)&&void 0!==o&&o.xaxis&&(e=t.extendXAxisAnnotations(e)),null!==(n=e)&&void 0!==n&&null!==(l=n.annotations)&&void 0!==l&&l.points&&(e=t.extendPointAnnotations(e)));return e}}]),t}(),w=function(){function t(e){a(this,t),this.w=e.w,this.annoCtx=e;}return r(t,[{key:"setOrientations",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,i=this.w;if("vertical"===t.label.orientation){var a=null!==e?e:0,s=i.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(a,"']"));if(null!==s){var r=s.getBoundingClientRect();s.setAttribute("x",parseFloat(s.getAttribute("x"))-r.height+4),"top"===t.label.position?s.setAttribute("y",parseFloat(s.getAttribute("y"))+r.width):s.setAttribute("y",parseFloat(s.getAttribute("y"))-r.width);var o=this.annoCtx.graphics.rotateAroundCenter(s),n=o.x,l=o.y;s.setAttribute("transform","rotate(-90 ".concat(n," ").concat(l,")"));}}}},{key:"addBackgroundToAnno",value:function(t,e){var i=this.w;if(!t||void 0===e.label.text||void 0!==e.label.text&&!String(e.label.text).trim())return null;var a=i.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(),s=t.getBoundingClientRect(),r=e.label.style.padding.left,o=e.label.style.padding.right,n=e.label.style.padding.top,l=e.label.style.padding.bottom;"vertical"===e.label.orientation&&(n=e.label.style.padding.left,l=e.label.style.padding.right,r=e.label.style.padding.top,o=e.label.style.padding.bottom);var h=s.left-a.left-r,c=s.top-a.top-n,d=this.annoCtx.graphics.drawRect(h-i.globals.barPadForNumericAxis,c,s.width+r+o,s.height+n+l,e.label.borderRadius,e.label.style.background,1,e.label.borderWidth,e.label.borderColor,0);return e.id&&d.node.classList.add(e.id),d}},{key:"annotationsBackground",value:function(){var t=this,e=this.w,i=function(i,a,s){var r=e.globals.dom.baseEl.querySelector(".apexcharts-".concat(s,"-annotations .apexcharts-").concat(s,"-annotation-label[rel='").concat(a,"']"));if(r){var o=r.parentNode,n=t.addBackgroundToAnno(r,i);n&&(o.insertBefore(n.node,r),i.label.mouseEnter&&n.node.addEventListener("mouseenter",i.label.mouseEnter.bind(t,i)),i.label.mouseLeave&&n.node.addEventListener("mouseleave",i.label.mouseLeave.bind(t,i)),i.label.click&&n.node.addEventListener("click",i.label.click.bind(t,i)));}};e.config.annotations.xaxis.map((function(t,e){i(t,e,"xaxis");})),e.config.annotations.yaxis.map((function(t,e){i(t,e,"yaxis");})),e.config.annotations.points.map((function(t,e){i(t,e,"point");}));}},{key:"getY1Y2",value:function(t,e){var i,a="y1"===t?e.y:e.y2,s=!1,r=this.w;if(this.annoCtx.invertAxis){var o=r.globals.labels;r.config.xaxis.convertedCatToNumeric&&(o=r.globals.categoryLabels);var n=o.indexOf(a),l=r.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child("+(n+1)+")");i=l?parseFloat(l.getAttribute("y")):(r.globals.gridHeight/o.length-1)*(n+1)-r.globals.barHeight,void 0!==e.seriesIndex&&r.globals.barHeight&&(i=i-r.globals.barHeight/2*(r.globals.series.length-1)+r.globals.barHeight*e.seriesIndex);}else {var h,c=r.globals.seriesYAxisMap[e.yAxisIndex][0];if(r.config.yaxis[e.yAxisIndex].logarithmic)h=(a=new y(this.annoCtx.ctx).getLogVal(r.config.yaxis[e.yAxisIndex].logBase,a,c))/r.globals.yLogRatio[c];else h=(a-r.globals.minYArr[c])/(r.globals.yRange[c]/r.globals.gridHeight);h>r.globals.gridHeight?(h=r.globals.gridHeight,s=!0):h<0&&(h=0,s=!0),i=r.globals.gridHeight-h,!e.marker||void 0!==e.y&&null!==e.y||(i=0),r.config.yaxis[e.yAxisIndex]&&r.config.yaxis[e.yAxisIndex].reversed&&(i=h);}return "string"==typeof a&&a.indexOf("px")>-1&&(i=parseFloat(a)),{yP:i,clipped:s}}},{key:"getX1X2",value:function(t,e){var i,a="x1"===t?e.x:e.x2,s=this.w,r=this.annoCtx.invertAxis?s.globals.minY:s.globals.minX,o=this.annoCtx.invertAxis?s.globals.maxY:s.globals.maxX,n=this.annoCtx.invertAxis?s.globals.yRange[0]:s.globals.xRange,l=!1;return i=this.annoCtx.inversedReversedAxis?(o-a)/(n/s.globals.gridWidth):(a-r)/(n/s.globals.gridWidth),"category"!==s.config.xaxis.type&&!s.config.xaxis.convertedCatToNumeric||this.annoCtx.invertAxis||s.globals.dataFormatXNumeric||s.config.chart.sparkline.enabled||(i=this.getStringX(a)),"string"==typeof a&&a.indexOf("px")>-1&&(i=parseFloat(a)),null==a&&e.marker&&(i=s.globals.gridWidth),void 0!==e.seriesIndex&&s.globals.barWidth&&!this.annoCtx.invertAxis&&(i=i-s.globals.barWidth/2*(s.globals.series.length-1)+s.globals.barWidth*e.seriesIndex),i>s.globals.gridWidth?(i=s.globals.gridWidth,l=!0):i<0&&(i=0,l=!0),{x:i,clipped:l}}},{key:"getStringX",value:function(t){var e=this.w,i=t;e.config.xaxis.convertedCatToNumeric&&e.globals.categoryLabels.length&&(t=e.globals.categoryLabels.indexOf(t)+1);var a=e.globals.labels.indexOf(t),s=e.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child("+(a+1)+")");return s&&(i=parseFloat(s.getAttribute("x"))),i}}]),t}(),k=function(){function t(e){a(this,t),this.w=e.w,this.annoCtx=e,this.invertAxis=this.annoCtx.invertAxis,this.helpers=new w(this.annoCtx);}return r(t,[{key:"addXaxisAnnotation",value:function(t,e,i){var a,s=this.w,r=this.helpers.getX1X2("x1",t),o=r.x,n=r.clipped,l=!0,h=t.label.text,c=t.strokeDashArray;if(x.isNumber(o)){if(null===t.x2||void 0===t.x2){if(!n){var d=this.annoCtx.graphics.drawLine(o+t.offsetX,0+t.offsetY,o+t.offsetX,s.globals.gridHeight+t.offsetY,t.borderColor,c,t.borderWidth);e.appendChild(d.node),t.id&&d.node.classList.add(t.id);}}else {var g=this.helpers.getX1X2("x2",t);if(a=g.x,l=g.clipped,!n||!l){if(a<o){var u=o;o=a,a=u;}var p=this.annoCtx.graphics.drawRect(o+t.offsetX,0+t.offsetY,a-o,s.globals.gridHeight+t.offsetY,0,t.fillColor,t.opacity,1,t.borderColor,c);p.node.classList.add("apexcharts-annotation-rect"),p.attr("clip-path","url(#gridRectMask".concat(s.globals.cuid,")")),e.appendChild(p.node),t.id&&p.node.classList.add(t.id);}}if(!n||!l){var f=this.annoCtx.graphics.getTextRects(h,parseFloat(t.label.style.fontSize)),b="top"===t.label.position?4:"center"===t.label.position?s.globals.gridHeight/2+("vertical"===t.label.orientation?f.width/2:0):s.globals.gridHeight,v=this.annoCtx.graphics.drawText({x:o+t.label.offsetX,y:b+t.label.offsetY-("vertical"===t.label.orientation?"top"===t.label.position?f.width/2-12:-f.width/2:0),text:h,textAnchor:t.label.textAnchor,fontSize:t.label.style.fontSize,fontFamily:t.label.style.fontFamily,fontWeight:t.label.style.fontWeight,foreColor:t.label.style.color,cssClass:"apexcharts-xaxis-annotation-label ".concat(t.label.style.cssClass," ").concat(t.id?t.id:"")});v.attr({rel:i}),e.appendChild(v.node),this.annoCtx.helpers.setOrientations(t,i);}}}},{key:"drawXAxisAnnotations",value:function(){var t=this,e=this.w,i=this.annoCtx.graphics.group({class:"apexcharts-xaxis-annotations"});return e.config.annotations.xaxis.map((function(e,a){t.addXaxisAnnotation(e,i.node,a);})),i}}]),t}(),A=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w,this.months31=[1,3,5,7,8,10,12],this.months30=[2,4,6,9,11],this.daysCntOfYear=[0,31,59,90,120,151,181,212,243,273,304,334];}return r(t,[{key:"isValidDate",value:function(t){return "number"!=typeof t&&!isNaN(this.parseDate(t))}},{key:"getTimeStamp",value:function(t){return Date.parse(t)?this.w.config.xaxis.labels.datetimeUTC?new Date(new Date(t).toISOString().substr(0,25)).getTime():new Date(t).getTime():t}},{key:"getDate",value:function(t){return this.w.config.xaxis.labels.datetimeUTC?new Date(new Date(t).toUTCString()):new Date(t)}},{key:"parseDate",value:function(t){var e=Date.parse(t);if(!isNaN(e))return this.getTimeStamp(t);var i=Date.parse(t.replace(/-/g,"/").replace(/[a-z]+/gi," "));return i=this.getTimeStamp(i)}},{key:"parseDateWithTimezone",value:function(t){return Date.parse(t.replace(/-/g,"/").replace(/[a-z]+/gi," "))}},{key:"formatDate",value:function(t,e){var i=this.w.globals.locale,a=this.w.config.xaxis.labels.datetimeUTC,s=["\0"].concat(u(i.months)),r=["\x01"].concat(u(i.shortMonths)),o=["\x02"].concat(u(i.days)),n=["\x03"].concat(u(i.shortDays));function l(t,e){var i=t+"";for(e=e||2;i.length<e;)i="0"+i;return i}var h=a?t.getUTCFullYear():t.getFullYear();e=(e=(e=e.replace(/(^|[^\\])yyyy+/g,"$1"+h)).replace(/(^|[^\\])yy/g,"$1"+h.toString().substr(2,2))).replace(/(^|[^\\])y/g,"$1"+h);var c=(a?t.getUTCMonth():t.getMonth())+1;e=(e=(e=(e=e.replace(/(^|[^\\])MMMM+/g,"$1"+s[0])).replace(/(^|[^\\])MMM/g,"$1"+r[0])).replace(/(^|[^\\])MM/g,"$1"+l(c))).replace(/(^|[^\\])M/g,"$1"+c);var d=a?t.getUTCDate():t.getDate();e=(e=(e=(e=e.replace(/(^|[^\\])dddd+/g,"$1"+o[0])).replace(/(^|[^\\])ddd/g,"$1"+n[0])).replace(/(^|[^\\])dd/g,"$1"+l(d))).replace(/(^|[^\\])d/g,"$1"+d);var g=a?t.getUTCHours():t.getHours(),p=g>12?g-12:0===g?12:g;e=(e=(e=(e=e.replace(/(^|[^\\])HH+/g,"$1"+l(g))).replace(/(^|[^\\])H/g,"$1"+g)).replace(/(^|[^\\])hh+/g,"$1"+l(p))).replace(/(^|[^\\])h/g,"$1"+p);var f=a?t.getUTCMinutes():t.getMinutes();e=(e=e.replace(/(^|[^\\])mm+/g,"$1"+l(f))).replace(/(^|[^\\])m/g,"$1"+f);var x=a?t.getUTCSeconds():t.getSeconds();e=(e=e.replace(/(^|[^\\])ss+/g,"$1"+l(x))).replace(/(^|[^\\])s/g,"$1"+x);var b=a?t.getUTCMilliseconds():t.getMilliseconds();e=e.replace(/(^|[^\\])fff+/g,"$1"+l(b,3)),b=Math.round(b/10),e=e.replace(/(^|[^\\])ff/g,"$1"+l(b)),b=Math.round(b/10);var v=g<12?"AM":"PM";e=(e=(e=e.replace(/(^|[^\\])f/g,"$1"+b)).replace(/(^|[^\\])TT+/g,"$1"+v)).replace(/(^|[^\\])T/g,"$1"+v.charAt(0));var m=v.toLowerCase();e=(e=e.replace(/(^|[^\\])tt+/g,"$1"+m)).replace(/(^|[^\\])t/g,"$1"+m.charAt(0));var y=-t.getTimezoneOffset(),w=a||!y?"Z":y>0?"+":"-";if(!a){var k=(y=Math.abs(y))%60;w+=l(Math.floor(y/60))+":"+l(k);}e=e.replace(/(^|[^\\])K/g,"$1"+w);var A=(a?t.getUTCDay():t.getDay())+1;return e=(e=(e=(e=(e=e.replace(new RegExp(o[0],"g"),o[A])).replace(new RegExp(n[0],"g"),n[A])).replace(new RegExp(s[0],"g"),s[c])).replace(new RegExp(r[0],"g"),r[c])).replace(/\\(.)/g,"$1")}},{key:"getTimeUnitsfromTimestamp",value:function(t,e,i){var a=this.w;void 0!==a.config.xaxis.min&&(t=a.config.xaxis.min),void 0!==a.config.xaxis.max&&(e=a.config.xaxis.max);var s=this.getDate(t),r=this.getDate(e),o=this.formatDate(s,"yyyy MM dd HH mm ss fff").split(" "),n=this.formatDate(r,"yyyy MM dd HH mm ss fff").split(" ");return {minMillisecond:parseInt(o[6],10),maxMillisecond:parseInt(n[6],10),minSecond:parseInt(o[5],10),maxSecond:parseInt(n[5],10),minMinute:parseInt(o[4],10),maxMinute:parseInt(n[4],10),minHour:parseInt(o[3],10),maxHour:parseInt(n[3],10),minDate:parseInt(o[2],10),maxDate:parseInt(n[2],10),minMonth:parseInt(o[1],10)-1,maxMonth:parseInt(n[1],10)-1,minYear:parseInt(o[0],10),maxYear:parseInt(n[0],10)}}},{key:"isLeapYear",value:function(t){return t%4==0&&t%100!=0||t%400==0}},{key:"calculcateLastDaysOfMonth",value:function(t,e,i){return this.determineDaysOfMonths(t,e)-i}},{key:"determineDaysOfYear",value:function(t){var e=365;return this.isLeapYear(t)&&(e=366),e}},{key:"determineRemainingDaysOfYear",value:function(t,e,i){var a=this.daysCntOfYear[e]+i;return e>1&&this.isLeapYear()&&a++,a}},{key:"determineDaysOfMonths",value:function(t,e){var i=30;switch(t=x.monthMod(t),!0){case this.months30.indexOf(t)>-1:2===t&&(i=this.isLeapYear(e)?29:28);break;case this.months31.indexOf(t)>-1:default:i=31;}return i}}]),t}(),S=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w,this.tooltipKeyFormat="dd MMM";}return r(t,[{key:"xLabelFormat",value:function(t,e,i,a){var s=this.w;if("datetime"===s.config.xaxis.type&&void 0===s.config.xaxis.labels.formatter&&void 0===s.config.tooltip.x.formatter){var r=new A(this.ctx);return r.formatDate(r.getDate(e),s.config.tooltip.x.format)}return t(e,i,a)}},{key:"defaultGeneralFormatter",value:function(t){return Array.isArray(t)?t.map((function(t){return t})):t}},{key:"defaultYFormatter",value:function(t,e,i){var a=this.w;if(x.isNumber(t))if(0!==a.globals.yValueDecimal)t=t.toFixed(void 0!==e.decimalsInFloat?e.decimalsInFloat:a.globals.yValueDecimal);else {var s=t.toFixed(0);t=t==s?s:t.toFixed(1);}return t}},{key:"setLabelFormatters",value:function(){var t=this,e=this.w;return e.globals.xaxisTooltipFormatter=function(e){return t.defaultGeneralFormatter(e)},e.globals.ttKeyFormatter=function(e){return t.defaultGeneralFormatter(e)},e.globals.ttZFormatter=function(t){return t},e.globals.legendFormatter=function(e){return t.defaultGeneralFormatter(e)},void 0!==e.config.xaxis.labels.formatter?e.globals.xLabelFormatter=e.config.xaxis.labels.formatter:e.globals.xLabelFormatter=function(t){if(x.isNumber(t)){if(!e.config.xaxis.convertedCatToNumeric&&"numeric"===e.config.xaxis.type){if(x.isNumber(e.config.xaxis.decimalsInFloat))return t.toFixed(e.config.xaxis.decimalsInFloat);var i=e.globals.maxX-e.globals.minX;return i>0&&i<100?t.toFixed(1):t.toFixed(0)}if(e.globals.isBarHorizontal)if(e.globals.maxY-e.globals.minYArr<4)return t.toFixed(1);return t.toFixed(0)}return t},"function"==typeof e.config.tooltip.x.formatter?e.globals.ttKeyFormatter=e.config.tooltip.x.formatter:e.globals.ttKeyFormatter=e.globals.xLabelFormatter,"function"==typeof e.config.xaxis.tooltip.formatter&&(e.globals.xaxisTooltipFormatter=e.config.xaxis.tooltip.formatter),(Array.isArray(e.config.tooltip.y)||void 0!==e.config.tooltip.y.formatter)&&(e.globals.ttVal=e.config.tooltip.y),void 0!==e.config.tooltip.z.formatter&&(e.globals.ttZFormatter=e.config.tooltip.z.formatter),void 0!==e.config.legend.formatter&&(e.globals.legendFormatter=e.config.legend.formatter),e.config.yaxis.forEach((function(i,a){void 0!==i.labels.formatter?e.globals.yLabelFormatters[a]=i.labels.formatter:e.globals.yLabelFormatters[a]=function(s){return e.globals.xyCharts?Array.isArray(s)?s.map((function(e){return t.defaultYFormatter(e,i,a)})):t.defaultYFormatter(s,i,a):s};})),e.globals}},{key:"heatmapLabelFormatters",value:function(){var t=this.w;if("heatmap"===t.config.chart.type){t.globals.yAxisScale[0].result=t.globals.seriesNames.slice();var e=t.globals.seriesNames.reduce((function(t,e){return t.length>e.length?t:e}),0);t.globals.yAxisScale[0].niceMax=e,t.globals.yAxisScale[0].niceMin=e;}}}]),t}(),C=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w;}return r(t,[{key:"getLabel",value:function(t,e,i,a){var s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[],r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"12px",o=!(arguments.length>6&&void 0!==arguments[6])||arguments[6],n=this.w,l=void 0===t[a]?"":t[a],h=l,c=n.globals.xLabelFormatter,d=n.config.xaxis.labels.formatter,g=!1,u=new S(this.ctx),p=l;o&&(h=u.xLabelFormat(c,l,p,{i:a,dateFormatter:new A(this.ctx).formatDate,w:n}),void 0!==d&&(h=d(l,t[a],{i:a,dateFormatter:new A(this.ctx).formatDate,w:n})));var f,x;e.length>0?(f=e[a].unit,x=null,e.forEach((function(t){"month"===t.unit?x="year":"day"===t.unit?x="month":"hour"===t.unit?x="day":"minute"===t.unit&&(x="hour");})),g=x===f,i=e[a].position,h=e[a].value):"datetime"===n.config.xaxis.type&&void 0===d&&(h=""),void 0===h&&(h=""),h=Array.isArray(h)?h:h.toString();var b=new m(this.ctx),v={};v=n.globals.rotateXLabels&&o?b.getTextRects(h,parseInt(r,10),null,"rotate(".concat(n.config.xaxis.labels.rotate," 0 0)"),!1):b.getTextRects(h,parseInt(r,10));var y=!n.config.xaxis.labels.showDuplicates&&this.ctx.timeScale;return !Array.isArray(h)&&("NaN"===String(h)||s.indexOf(h)>=0&&y)&&(h=""),{x:i,text:h,textRect:v,isBold:g}}},{key:"checkLabelBasedOnTickamount",value:function(t,e,i){var a=this.w,s=a.config.xaxis.tickAmount;return "dataPoints"===s&&(s=Math.round(a.globals.gridWidth/120)),s>i||t%Math.round(i/(s+1))==0||(e.text=""),e}},{key:"checkForOverflowingLabels",value:function(t,e,i,a,s){var r=this.w;if(0===t&&r.globals.skipFirstTimelinelabel&&(e.text=""),t===i-1&&r.globals.skipLastTimelinelabel&&(e.text=""),r.config.xaxis.labels.hideOverlappingLabels&&a.length>0){var o=s[s.length-1];e.x<o.textRect.width/(r.globals.rotateXLabels?Math.abs(r.config.xaxis.labels.rotate)/12:1.01)+o.x&&(e.text="");}return e}},{key:"checkForReversedLabels",value:function(t,e){var i=this.w;return i.config.yaxis[t]&&i.config.yaxis[t].reversed&&e.reverse(),e}},{key:"yAxisAllSeriesCollapsed",value:function(t){var e=this.w.globals;return !e.seriesYAxisMap[t].some((function(t){return -1===e.collapsedSeriesIndices.indexOf(t)}))}},{key:"translateYAxisIndex",value:function(t){var e=this.w,i=e.globals,a=e.config.yaxis;return i.series.length>a.length||a.some((function(t){return Array.isArray(t.seriesName)}))?t:i.seriesYAxisReverseMap[t]}},{key:"isYAxisHidden",value:function(t){var e=this.w,i=e.config.yaxis[t];if(!i.show||this.yAxisAllSeriesCollapsed(t))return !0;if(!i.showForNullSeries){var a=e.globals.seriesYAxisMap[t],s=new y(this.ctx);return a.every((function(t){return s.isSeriesNull(t)}))}return !1}},{key:"getYAxisForeColor",value:function(t,e){var i=this.w;return Array.isArray(t)&&i.globals.yAxisScale[e]&&this.ctx.theme.pushExtraColors(t,i.globals.yAxisScale[e].result.length,!1),t}},{key:"drawYAxisTicks",value:function(t,e,i,a,s,r,o){var n=this.w,l=new m(this.ctx),h=n.globals.translateY+n.config.yaxis[s].labels.offsetY;if(n.globals.isBarHorizontal?h=0:"heatmap"===n.config.chart.type&&(h+=r/2),a.show&&e>0){!0===n.config.yaxis[s].opposite&&(t+=a.width);for(var c=e;c>=0;c--){var d=l.drawLine(t+i.offsetX-a.width+a.offsetX,h+a.offsetY,t+i.offsetX+a.offsetX,h+a.offsetY,a.color);o.add(d),h+=r;}}}}]),t}(),L=function(){function t(e){a(this,t),this.w=e.w,this.annoCtx=e,this.helpers=new w(this.annoCtx),this.axesUtils=new C(this.annoCtx);}return r(t,[{key:"addYaxisAnnotation",value:function(t,e,i){var a,s=this.w,r=t.strokeDashArray,o=this.helpers.getY1Y2("y1",t),n=o.yP,l=o.clipped,h=!0,c=!1,d=t.label.text;if(null===t.y2||void 0===t.y2){if(!l){c=!0;var g=this.annoCtx.graphics.drawLine(0+t.offsetX,n+t.offsetY,this._getYAxisAnnotationWidth(t),n+t.offsetY,t.borderColor,r,t.borderWidth);e.appendChild(g.node),t.id&&g.node.classList.add(t.id);}}else {if(a=(o=this.helpers.getY1Y2("y2",t)).yP,h=o.clipped,a>n){var u=n;n=a,a=u;}if(!l||!h){c=!0;var p=this.annoCtx.graphics.drawRect(0+t.offsetX,a+t.offsetY,this._getYAxisAnnotationWidth(t),n-a,0,t.fillColor,t.opacity,1,t.borderColor,r);p.node.classList.add("apexcharts-annotation-rect"),p.attr("clip-path","url(#gridRectMask".concat(s.globals.cuid,")")),e.appendChild(p.node),t.id&&p.node.classList.add(t.id);}}if(c){var f="right"===t.label.position?s.globals.gridWidth:"center"===t.label.position?s.globals.gridWidth/2:0,x=this.annoCtx.graphics.drawText({x:f+t.label.offsetX,y:(null!=a?a:n)+t.label.offsetY-3,text:d,textAnchor:t.label.textAnchor,fontSize:t.label.style.fontSize,fontFamily:t.label.style.fontFamily,fontWeight:t.label.style.fontWeight,foreColor:t.label.style.color,cssClass:"apexcharts-yaxis-annotation-label ".concat(t.label.style.cssClass," ").concat(t.id?t.id:"")});x.attr({rel:i}),e.appendChild(x.node);}}},{key:"_getYAxisAnnotationWidth",value:function(t){var e=this.w;e.globals.gridWidth;return (t.width.indexOf("%")>-1?e.globals.gridWidth*parseInt(t.width,10)/100:parseInt(t.width,10))+t.offsetX}},{key:"drawYAxisAnnotations",value:function(){var t=this,e=this.w,i=this.annoCtx.graphics.group({class:"apexcharts-yaxis-annotations"});return e.config.annotations.yaxis.forEach((function(e,a){e.yAxisIndex=t.axesUtils.translateYAxisIndex(e.yAxisIndex),t.axesUtils.isYAxisHidden(e.yAxisIndex)&&t.axesUtils.yAxisAllSeriesCollapsed(e.yAxisIndex)||t.addYaxisAnnotation(e,i.node,a);})),i}}]),t}(),P=function(){function t(e){a(this,t),this.w=e.w,this.annoCtx=e,this.helpers=new w(this.annoCtx);}return r(t,[{key:"addPointAnnotation",value:function(t,e,i){if(!(this.w.globals.collapsedSeriesIndices.indexOf(t.seriesIndex)>-1)){var a=this.helpers.getX1X2("x1",t),s=a.x,r=a.clipped,o=(a=this.helpers.getY1Y2("y1",t)).yP,n=a.clipped;if(x.isNumber(s)&&!n&&!r){var l={pSize:t.marker.size,pointStrokeWidth:t.marker.strokeWidth,pointFillColor:t.marker.fillColor,pointStrokeColor:t.marker.strokeColor,shape:t.marker.shape,pRadius:t.marker.radius,class:"apexcharts-point-annotation-marker ".concat(t.marker.cssClass," ").concat(t.id?t.id:"")},h=this.annoCtx.graphics.drawMarker(s+t.marker.offsetX,o+t.marker.offsetY,l);e.appendChild(h.node);var c=t.label.text?t.label.text:"",d=this.annoCtx.graphics.drawText({x:s+t.label.offsetX,y:o+t.label.offsetY-t.marker.size-parseFloat(t.label.style.fontSize)/1.6,text:c,textAnchor:t.label.textAnchor,fontSize:t.label.style.fontSize,fontFamily:t.label.style.fontFamily,fontWeight:t.label.style.fontWeight,foreColor:t.label.style.color,cssClass:"apexcharts-point-annotation-label ".concat(t.label.style.cssClass," ").concat(t.id?t.id:"")});if(d.attr({rel:i}),e.appendChild(d.node),t.customSVG.SVG){var g=this.annoCtx.graphics.group({class:"apexcharts-point-annotations-custom-svg "+t.customSVG.cssClass});g.attr({transform:"translate(".concat(s+t.customSVG.offsetX,", ").concat(o+t.customSVG.offsetY,")")}),g.node.innerHTML=t.customSVG.SVG,e.appendChild(g.node);}if(t.image.path){var u=t.image.width?t.image.width:20,p=t.image.height?t.image.height:20;h=this.annoCtx.addImage({x:s+t.image.offsetX-u/2,y:o+t.image.offsetY-p/2,width:u,height:p,path:t.image.path,appendTo:".apexcharts-point-annotations"});}t.mouseEnter&&h.node.addEventListener("mouseenter",t.mouseEnter.bind(this,t)),t.mouseLeave&&h.node.addEventListener("mouseleave",t.mouseLeave.bind(this,t)),t.click&&h.node.addEventListener("click",t.click.bind(this,t));}}}},{key:"drawPointAnnotations",value:function(){var t=this,e=this.w,i=this.annoCtx.graphics.group({class:"apexcharts-point-annotations"});return e.config.annotations.points.map((function(e,a){t.addPointAnnotation(e,i.node,a);})),i}}]),t}();var M={name:"en",options:{months:["January","February","March","April","May","June","July","August","September","October","November","December"],shortMonths:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],toolbar:{exportToSVG:"Download SVG",exportToPNG:"Download PNG",exportToCSV:"Download CSV",menu:"Menu",selection:"Selection",selectionZoom:"Selection Zoom",zoomIn:"Zoom In",zoomOut:"Zoom Out",pan:"Panning",reset:"Reset Zoom"}}},I=function(){function t(){a(this,t),this.yAxis={show:!0,showAlways:!1,showForNullSeries:!0,seriesName:void 0,opposite:!1,reversed:!1,logarithmic:!1,logBase:10,tickAmount:void 0,stepSize:void 0,forceNiceScale:!1,max:void 0,min:void 0,floating:!1,decimalsInFloat:void 0,labels:{show:!0,minWidth:0,maxWidth:160,offsetX:0,offsetY:0,align:void 0,rotate:0,padding:20,style:{colors:[],fontSize:"11px",fontWeight:400,fontFamily:void 0,cssClass:""},formatter:void 0},axisBorder:{show:!1,color:"#e0e0e0",width:1,offsetX:0,offsetY:0},axisTicks:{show:!1,color:"#e0e0e0",width:6,offsetX:0,offsetY:0},title:{text:void 0,rotate:-90,offsetY:0,offsetX:0,style:{color:void 0,fontSize:"11px",fontWeight:900,fontFamily:void 0,cssClass:""}},tooltip:{enabled:!1,offsetX:0},crosshairs:{show:!0,position:"front",stroke:{color:"#b6b6b6",width:1,dashArray:0}}},this.pointAnnotation={id:void 0,x:0,y:null,yAxisIndex:0,seriesIndex:void 0,mouseEnter:void 0,mouseLeave:void 0,click:void 0,marker:{size:4,fillColor:"#fff",strokeWidth:2,strokeColor:"#333",shape:"circle",offsetX:0,offsetY:0,radius:2,cssClass:""},label:{borderColor:"#c2c2c2",borderWidth:1,borderRadius:2,text:void 0,textAnchor:"middle",offsetX:0,offsetY:0,mouseEnter:void 0,mouseLeave:void 0,click:void 0,style:{background:"#fff",color:void 0,fontSize:"11px",fontFamily:void 0,fontWeight:400,cssClass:"",padding:{left:5,right:5,top:2,bottom:2}}},customSVG:{SVG:void 0,cssClass:void 0,offsetX:0,offsetY:0},image:{path:void 0,width:20,height:20,offsetX:0,offsetY:0}},this.yAxisAnnotation={id:void 0,y:0,y2:null,strokeDashArray:1,fillColor:"#c2c2c2",borderColor:"#c2c2c2",borderWidth:1,opacity:.3,offsetX:0,offsetY:0,width:"100%",yAxisIndex:0,label:{borderColor:"#c2c2c2",borderWidth:1,borderRadius:2,text:void 0,textAnchor:"end",position:"right",offsetX:0,offsetY:-3,mouseEnter:void 0,mouseLeave:void 0,click:void 0,style:{background:"#fff",color:void 0,fontSize:"11px",fontFamily:void 0,fontWeight:400,cssClass:"",padding:{left:5,right:5,top:2,bottom:2}}}},this.xAxisAnnotation={id:void 0,x:0,x2:null,strokeDashArray:1,fillColor:"#c2c2c2",borderColor:"#c2c2c2",borderWidth:1,opacity:.3,offsetX:0,offsetY:0,label:{borderColor:"#c2c2c2",borderWidth:1,borderRadius:2,text:void 0,textAnchor:"middle",orientation:"vertical",position:"top",offsetX:0,offsetY:0,mouseEnter:void 0,mouseLeave:void 0,click:void 0,style:{background:"#fff",color:void 0,fontSize:"11px",fontFamily:void 0,fontWeight:400,cssClass:"",padding:{left:5,right:5,top:2,bottom:2}}}},this.text={x:0,y:0,text:"",textAnchor:"start",foreColor:void 0,fontSize:"13px",fontFamily:void 0,fontWeight:400,appendTo:".apexcharts-annotations",backgroundColor:"transparent",borderColor:"#c2c2c2",borderRadius:0,borderWidth:0,paddingLeft:4,paddingRight:4,paddingTop:2,paddingBottom:2};}return r(t,[{key:"init",value:function(){return {annotations:{yaxis:[this.yAxisAnnotation],xaxis:[this.xAxisAnnotation],points:[this.pointAnnotation],texts:[],images:[],shapes:[]},chart:{animations:{enabled:!0,easing:"easeinout",speed:800,animateGradually:{delay:150,enabled:!0},dynamicAnimation:{enabled:!0,speed:350}},background:"transparent",locales:[M],defaultLocale:"en",dropShadow:{enabled:!1,enabledOnSeries:void 0,top:2,left:2,blur:4,color:"#000",opacity:.35},events:{animationEnd:void 0,beforeMount:void 0,mounted:void 0,updated:void 0,click:void 0,mouseMove:void 0,mouseLeave:void 0,xAxisLabelClick:void 0,legendClick:void 0,markerClick:void 0,selection:void 0,dataPointSelection:void 0,dataPointMouseEnter:void 0,dataPointMouseLeave:void 0,beforeZoom:void 0,beforeResetZoom:void 0,zoomed:void 0,scrolled:void 0,brushScrolled:void 0},foreColor:"#373d3f",fontFamily:"Helvetica, Arial, sans-serif",height:"auto",parentHeightOffset:15,redrawOnParentResize:!0,redrawOnWindowResize:!0,id:void 0,group:void 0,nonce:void 0,offsetX:0,offsetY:0,selection:{enabled:!1,type:"x",fill:{color:"#24292e",opacity:.1},stroke:{width:1,color:"#24292e",opacity:.4,dashArray:3},xaxis:{min:void 0,max:void 0},yaxis:{min:void 0,max:void 0}},sparkline:{enabled:!1},brush:{enabled:!1,autoScaleYaxis:!0,target:void 0,targets:void 0},stacked:!1,stackOnlyBar:!0,stackType:"normal",toolbar:{show:!0,offsetX:0,offsetY:0,tools:{download:!0,selection:!0,zoom:!0,zoomin:!0,zoomout:!0,pan:!0,reset:!0,customIcons:[]},export:{csv:{filename:void 0,columnDelimiter:",",headerCategory:"category",headerValue:"value",dateFormatter:function(t){return new Date(t).toDateString()}},png:{filename:void 0},svg:{filename:void 0}},autoSelected:"zoom"},type:"line",width:"100%",zoom:{enabled:!0,type:"x",autoScaleYaxis:!1,zoomedArea:{fill:{color:"#90CAF9",opacity:.4},stroke:{color:"#0D47A1",opacity:.4,width:1}}}},plotOptions:{line:{isSlopeChart:!1},area:{fillTo:"origin"},bar:{horizontal:!1,columnWidth:"70%",barHeight:"70%",distributed:!1,borderRadius:0,borderRadiusApplication:"around",borderRadiusWhenStacked:"last",rangeBarOverlap:!0,rangeBarGroupRows:!1,hideZeroBarsWhenGrouped:!1,isDumbbell:!1,dumbbellColors:void 0,isFunnel:!1,isFunnel3d:!0,colors:{ranges:[],backgroundBarColors:[],backgroundBarOpacity:1,backgroundBarRadius:0},dataLabels:{position:"top",maxItems:100,hideOverflowingLabels:!0,orientation:"horizontal",total:{enabled:!1,formatter:void 0,offsetX:0,offsetY:0,style:{color:"#373d3f",fontSize:"12px",fontFamily:void 0,fontWeight:600}}}},bubble:{zScaling:!0,minBubbleRadius:void 0,maxBubbleRadius:void 0},candlestick:{colors:{upward:"#00B746",downward:"#EF403C"},wick:{useFillColor:!0}},boxPlot:{colors:{upper:"#00E396",lower:"#008FFB"}},heatmap:{radius:2,enableShades:!0,shadeIntensity:.5,reverseNegativeShade:!1,distributed:!1,useFillColorAsStroke:!1,colorScale:{inverse:!1,ranges:[],min:void 0,max:void 0}},treemap:{enableShades:!0,shadeIntensity:.5,distributed:!1,reverseNegativeShade:!1,useFillColorAsStroke:!1,borderRadius:4,dataLabels:{format:"scale"},colorScale:{inverse:!1,ranges:[],min:void 0,max:void 0}},radialBar:{inverseOrder:!1,startAngle:0,endAngle:360,offsetX:0,offsetY:0,hollow:{margin:5,size:"50%",background:"transparent",image:void 0,imageWidth:150,imageHeight:150,imageOffsetX:0,imageOffsetY:0,imageClipped:!0,position:"front",dropShadow:{enabled:!1,top:0,left:0,blur:3,color:"#000",opacity:.5}},track:{show:!0,startAngle:void 0,endAngle:void 0,background:"#f2f2f2",strokeWidth:"97%",opacity:1,margin:5,dropShadow:{enabled:!1,top:0,left:0,blur:3,color:"#000",opacity:.5}},dataLabels:{show:!0,name:{show:!0,fontSize:"16px",fontFamily:void 0,fontWeight:600,color:void 0,offsetY:0,formatter:function(t){return t}},value:{show:!0,fontSize:"14px",fontFamily:void 0,fontWeight:400,color:void 0,offsetY:16,formatter:function(t){return t+"%"}},total:{show:!1,label:"Total",fontSize:"16px",fontWeight:600,fontFamily:void 0,color:void 0,formatter:function(t){return t.globals.seriesTotals.reduce((function(t,e){return t+e}),0)/t.globals.series.length+"%"}}},barLabels:{enabled:!1,margin:5,useSeriesColors:!0,fontFamily:void 0,fontWeight:600,fontSize:"16px",formatter:function(t){return t},onClick:void 0}},pie:{customScale:1,offsetX:0,offsetY:0,startAngle:0,endAngle:360,expandOnClick:!0,dataLabels:{offset:0,minAngleToShowLabel:10},donut:{size:"65%",background:"transparent",labels:{show:!1,name:{show:!0,fontSize:"16px",fontFamily:void 0,fontWeight:600,color:void 0,offsetY:-10,formatter:function(t){return t}},value:{show:!0,fontSize:"20px",fontFamily:void 0,fontWeight:400,color:void 0,offsetY:10,formatter:function(t){return t}},total:{show:!1,showAlways:!1,label:"Total",fontSize:"16px",fontWeight:400,fontFamily:void 0,color:void 0,formatter:function(t){return t.globals.seriesTotals.reduce((function(t,e){return t+e}),0)}}}}},polarArea:{rings:{strokeWidth:1,strokeColor:"#e8e8e8"},spokes:{strokeWidth:1,connectorColors:"#e8e8e8"}},radar:{size:void 0,offsetX:0,offsetY:0,polygons:{strokeWidth:1,strokeColors:"#e8e8e8",connectorColors:"#e8e8e8",fill:{colors:void 0}}}},colors:void 0,dataLabels:{enabled:!0,enabledOnSeries:void 0,formatter:function(t){return null!==t?t:""},textAnchor:"middle",distributed:!1,offsetX:0,offsetY:0,style:{fontSize:"12px",fontFamily:void 0,fontWeight:600,colors:void 0},background:{enabled:!0,foreColor:"#fff",borderRadius:2,padding:4,opacity:.9,borderWidth:1,borderColor:"#fff",dropShadow:{enabled:!1,top:1,left:1,blur:1,color:"#000",opacity:.45}},dropShadow:{enabled:!1,top:1,left:1,blur:1,color:"#000",opacity:.45}},fill:{type:"solid",colors:void 0,opacity:.85,gradient:{shade:"dark",type:"horizontal",shadeIntensity:.5,gradientToColors:void 0,inverseColors:!0,opacityFrom:1,opacityTo:1,stops:[0,50,100],colorStops:[]},image:{src:[],width:void 0,height:void 0},pattern:{style:"squares",width:6,height:6,strokeWidth:2}},forecastDataPoints:{count:0,fillOpacity:.5,strokeWidth:void 0,dashArray:4},grid:{show:!0,borderColor:"#e0e0e0",strokeDashArray:0,position:"back",xaxis:{lines:{show:!1}},yaxis:{lines:{show:!0}},row:{colors:void 0,opacity:.5},column:{colors:void 0,opacity:.5},padding:{top:0,right:10,bottom:0,left:12}},labels:[],legend:{show:!0,showForSingleSeries:!1,showForNullSeries:!0,showForZeroSeries:!0,floating:!1,position:"bottom",horizontalAlign:"center",inverseOrder:!1,fontSize:"12px",fontFamily:void 0,fontWeight:400,width:void 0,height:void 0,formatter:void 0,tooltipHoverFormatter:void 0,offsetX:-20,offsetY:4,customLegendItems:[],labels:{colors:void 0,useSeriesColors:!1},markers:{width:12,height:12,strokeWidth:0,fillColors:void 0,strokeColor:"#fff",radius:12,customHTML:void 0,offsetX:0,offsetY:0,onClick:void 0},itemMargin:{horizontal:5,vertical:2},onItemClick:{toggleDataSeries:!0},onItemHover:{highlightDataSeries:!0}},markers:{discrete:[],size:0,colors:void 0,strokeColors:"#fff",strokeWidth:2,strokeOpacity:.9,strokeDashArray:0,fillOpacity:1,shape:"circle",width:8,height:8,radius:2,offsetX:0,offsetY:0,onClick:void 0,onDblClick:void 0,showNullDataPoints:!0,hover:{size:void 0,sizeOffset:3}},noData:{text:void 0,align:"center",verticalAlign:"middle",offsetX:0,offsetY:0,style:{color:void 0,fontSize:"14px",fontFamily:void 0}},responsive:[],series:void 0,states:{normal:{filter:{type:"none",value:0}},hover:{filter:{type:"lighten",value:.1}},active:{allowMultipleDataPointsSelection:!1,filter:{type:"darken",value:.5}}},title:{text:void 0,align:"left",margin:5,offsetX:0,offsetY:0,floating:!1,style:{fontSize:"14px",fontWeight:900,fontFamily:void 0,color:void 0}},subtitle:{text:void 0,align:"left",margin:5,offsetX:0,offsetY:30,floating:!1,style:{fontSize:"12px",fontWeight:400,fontFamily:void 0,color:void 0}},stroke:{show:!0,curve:"smooth",lineCap:"butt",width:2,colors:void 0,dashArray:0,fill:{type:"solid",colors:void 0,opacity:.85,gradient:{shade:"dark",type:"horizontal",shadeIntensity:.5,gradientToColors:void 0,inverseColors:!0,opacityFrom:1,opacityTo:1,stops:[0,50,100],colorStops:[]}}},tooltip:{enabled:!0,enabledOnSeries:void 0,shared:!0,hideEmptySeries:!1,followCursor:!1,intersect:!1,inverseOrder:!1,custom:void 0,fillSeriesColor:!1,theme:"light",cssClass:"",style:{fontSize:"12px",fontFamily:void 0},onDatasetHover:{highlightDataSeries:!1},x:{show:!0,format:"dd MMM",formatter:void 0},y:{formatter:void 0,title:{formatter:function(t){return t?t+": ":""}}},z:{formatter:void 0,title:"Size: "},marker:{show:!0,fillColors:void 0},items:{display:"flex"},fixed:{enabled:!1,position:"topRight",offsetX:0,offsetY:0}},xaxis:{type:"category",categories:[],convertedCatToNumeric:!1,offsetX:0,offsetY:0,overwriteCategories:void 0,labels:{show:!0,rotate:-45,rotateAlways:!1,hideOverlappingLabels:!0,trim:!1,minHeight:void 0,maxHeight:120,showDuplicates:!0,style:{colors:[],fontSize:"12px",fontWeight:400,fontFamily:void 0,cssClass:""},offsetX:0,offsetY:0,format:void 0,formatter:void 0,datetimeUTC:!0,datetimeFormatter:{year:"yyyy",month:"MMM 'yy",day:"dd MMM",hour:"HH:mm",minute:"HH:mm:ss",second:"HH:mm:ss"}},group:{groups:[],style:{colors:[],fontSize:"12px",fontWeight:400,fontFamily:void 0,cssClass:""}},axisBorder:{show:!0,color:"#e0e0e0",width:"100%",height:1,offsetX:0,offsetY:0},axisTicks:{show:!0,color:"#e0e0e0",height:6,offsetX:0,offsetY:0},stepSize:void 0,tickAmount:void 0,tickPlacement:"on",min:void 0,max:void 0,range:void 0,floating:!1,decimalsInFloat:void 0,position:"bottom",title:{text:void 0,offsetX:0,offsetY:0,style:{color:void 0,fontSize:"12px",fontWeight:900,fontFamily:void 0,cssClass:""}},crosshairs:{show:!0,width:1,position:"back",opacity:.9,stroke:{color:"#b6b6b6",width:1,dashArray:3},fill:{type:"solid",color:"#B1B9C4",gradient:{colorFrom:"#D8E3F0",colorTo:"#BED1E6",stops:[0,100],opacityFrom:.4,opacityTo:.5}},dropShadow:{enabled:!1,left:0,top:0,blur:1,opacity:.4}},tooltip:{enabled:!0,offsetY:0,formatter:void 0,style:{fontSize:"12px",fontFamily:void 0}}},yaxis:this.yAxis,theme:{mode:"light",palette:"palette1",monochrome:{enabled:!1,color:"#008FFB",shadeTo:"light",shadeIntensity:.65}}}}}]),t}(),T=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w,this.graphics=new m(this.ctx),this.w.globals.isBarHorizontal&&(this.invertAxis=!0),this.helpers=new w(this),this.xAxisAnnotations=new k(this),this.yAxisAnnotations=new L(this),this.pointsAnnotations=new P(this),this.w.globals.isBarHorizontal&&this.w.config.yaxis[0].reversed&&(this.inversedReversedAxis=!0),this.xDivision=this.w.globals.gridWidth/this.w.globals.dataPoints;}return r(t,[{key:"drawAxesAnnotations",value:function(){var t=this.w;if(t.globals.axisCharts){for(var e=this.yAxisAnnotations.drawYAxisAnnotations(),i=this.xAxisAnnotations.drawXAxisAnnotations(),a=this.pointsAnnotations.drawPointAnnotations(),s=t.config.chart.animations.enabled,r=[e,i,a],o=[i.node,e.node,a.node],n=0;n<3;n++)t.globals.dom.elGraphical.add(r[n]),!s||t.globals.resized||t.globals.dataChanged||"scatter"!==t.config.chart.type&&"bubble"!==t.config.chart.type&&t.globals.dataPoints>1&&o[n].classList.add("apexcharts-element-hidden"),t.globals.delayedElements.push({el:o[n],index:0});this.helpers.annotationsBackground();}}},{key:"drawImageAnnos",value:function(){var t=this;this.w.config.annotations.images.map((function(e,i){t.addImage(e,i);}));}},{key:"drawTextAnnos",value:function(){var t=this;this.w.config.annotations.texts.map((function(e,i){t.addText(e,i);}));}},{key:"addXaxisAnnotation",value:function(t,e,i){this.xAxisAnnotations.addXaxisAnnotation(t,e,i);}},{key:"addYaxisAnnotation",value:function(t,e,i){this.yAxisAnnotations.addYaxisAnnotation(t,e,i);}},{key:"addPointAnnotation",value:function(t,e,i){this.pointsAnnotations.addPointAnnotation(t,e,i);}},{key:"addText",value:function(t,e){var i=t.x,a=t.y,s=t.text,r=t.textAnchor,o=t.foreColor,n=t.fontSize,l=t.fontFamily,h=t.fontWeight,c=t.cssClass,d=t.backgroundColor,g=t.borderWidth,u=t.strokeDashArray,p=t.borderRadius,f=t.borderColor,x=t.appendTo,b=void 0===x?".apexcharts-svg":x,v=t.paddingLeft,m=void 0===v?4:v,y=t.paddingRight,w=void 0===y?4:y,k=t.paddingBottom,A=void 0===k?2:k,S=t.paddingTop,C=void 0===S?2:S,L=this.w,P=this.graphics.drawText({x:i,y:a,text:s,textAnchor:r||"start",fontSize:n||"12px",fontWeight:h||"regular",fontFamily:l||L.config.chart.fontFamily,foreColor:o||L.config.chart.foreColor,cssClass:c}),M=L.globals.dom.baseEl.querySelector(b);M&&M.appendChild(P.node);var I=P.bbox();if(s){var T=this.graphics.drawRect(I.x-m,I.y-C,I.width+m+w,I.height+A+C,p,d||"transparent",1,g,f,u);M.insertBefore(T.node,P.node);}}},{key:"addImage",value:function(t,e){var i=this.w,a=t.path,s=t.x,r=void 0===s?0:s,o=t.y,n=void 0===o?0:o,l=t.width,h=void 0===l?20:l,c=t.height,d=void 0===c?20:c,g=t.appendTo,u=void 0===g?".apexcharts-svg":g,p=i.globals.dom.Paper.image(a);p.size(h,d).move(r,n);var f=i.globals.dom.baseEl.querySelector(u);return f&&f.appendChild(p.node),p}},{key:"addXaxisAnnotationExternal",value:function(t,e,i){return this.addAnnotationExternal({params:t,pushToMemory:e,context:i,type:"xaxis",contextMethod:i.addXaxisAnnotation}),i}},{key:"addYaxisAnnotationExternal",value:function(t,e,i){return this.addAnnotationExternal({params:t,pushToMemory:e,context:i,type:"yaxis",contextMethod:i.addYaxisAnnotation}),i}},{key:"addPointAnnotationExternal",value:function(t,e,i){return void 0===this.invertAxis&&(this.invertAxis=i.w.globals.isBarHorizontal),this.addAnnotationExternal({params:t,pushToMemory:e,context:i,type:"point",contextMethod:i.addPointAnnotation}),i}},{key:"addAnnotationExternal",value:function(t){var e=t.params,i=t.pushToMemory,a=t.context,s=t.type,r=t.contextMethod,o=a,n=o.w,l=n.globals.dom.baseEl.querySelector(".apexcharts-".concat(s,"-annotations")),h=l.childNodes.length+1,c=new I,d=Object.assign({},"xaxis"===s?c.xAxisAnnotation:"yaxis"===s?c.yAxisAnnotation:c.pointAnnotation),g=x.extend(d,e);switch(s){case"xaxis":this.addXaxisAnnotation(g,l,h);break;case"yaxis":this.addYaxisAnnotation(g,l,h);break;case"point":this.addPointAnnotation(g,l,h);}var u=n.globals.dom.baseEl.querySelector(".apexcharts-".concat(s,"-annotations .apexcharts-").concat(s,"-annotation-label[rel='").concat(h,"']")),p=this.helpers.addBackgroundToAnno(u,g);return p&&l.insertBefore(p.node,u),i&&n.globals.memory.methodsToExec.push({context:o,id:g.id?g.id:x.randomId(),method:r,label:"addAnnotation",params:e}),a}},{key:"clearAnnotations",value:function(t){var e=t.w,i=e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations");e.globals.memory.methodsToExec.map((function(t,i){"addText"!==t.label&&"addAnnotation"!==t.label||e.globals.memory.methodsToExec.splice(i,1);})),i=x.listToArray(i),Array.prototype.forEach.call(i,(function(t){for(;t.firstChild;)t.removeChild(t.firstChild);}));}},{key:"removeAnnotation",value:function(t,e){var i=t.w,a=i.globals.dom.baseEl.querySelectorAll(".".concat(e));a&&(i.globals.memory.methodsToExec.map((function(t,a){t.id===e&&i.globals.memory.methodsToExec.splice(a,1);})),Array.prototype.forEach.call(a,(function(t){t.parentElement.removeChild(t);})));}}]),t}(),z=function(t){var e,i=t.isTimeline,a=t.ctx,s=t.seriesIndex,r=t.dataPointIndex,o=t.y1,n=t.y2,l=t.w,h=l.globals.seriesRangeStart[s][r],c=l.globals.seriesRangeEnd[s][r],d=l.globals.labels[r],g=l.config.series[s].name?l.config.series[s].name:"",u=l.globals.ttKeyFormatter,p=l.config.tooltip.y.title.formatter,f={w:l,seriesIndex:s,dataPointIndex:r,start:h,end:c};("function"==typeof p&&(g=p(g,f)),null!==(e=l.config.series[s].data[r])&&void 0!==e&&e.x&&(d=l.config.series[s].data[r].x),i)||"datetime"===l.config.xaxis.type&&(d=new S(a).xLabelFormat(l.globals.ttKeyFormatter,d,d,{i:void 0,dateFormatter:new A(a).formatDate,w:l}));"function"==typeof u&&(d=u(d,f)),Number.isFinite(o)&&Number.isFinite(n)&&(h=o,c=n);var x="",b="",v=l.globals.colors[s];if(void 0===l.config.tooltip.x.formatter)if("datetime"===l.config.xaxis.type){var m=new A(a);x=m.formatDate(m.getDate(h),l.config.tooltip.x.format),b=m.formatDate(m.getDate(c),l.config.tooltip.x.format);}else x=h,b=c;else x=l.config.tooltip.x.formatter(h),b=l.config.tooltip.x.formatter(c);return {start:h,end:c,startVal:x,endVal:b,ylabel:d,color:v,seriesName:g}},X=function(t){var e=t.color,i=t.seriesName,a=t.ylabel,s=t.start,r=t.end,o=t.seriesIndex,n=t.dataPointIndex,l=t.ctx.tooltip.tooltipLabels.getFormatters(o);s=l.yLbFormatter(s),r=l.yLbFormatter(r);var h=l.yLbFormatter(t.w.globals.series[o][n]),c='<span class="value start-value">\n  '.concat(s,'\n  </span> <span class="separator">-</span> <span class="value end-value">\n  ').concat(r,"\n  </span>");return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: '+e+'">'+(i||"")+'</span></div><div> <span class="category">'+a+": </span> "+(t.w.globals.comboCharts?"rangeArea"===t.w.config.series[o].type||"rangeBar"===t.w.config.series[o].type?c:"<span>".concat(h,"</span>"):c)+" </div></div>"},E=function(){function t(e){a(this,t),this.opts=e;}return r(t,[{key:"hideYAxis",value:function(){this.opts.yaxis[0].show=!1,this.opts.yaxis[0].title.text="",this.opts.yaxis[0].axisBorder.show=!1,this.opts.yaxis[0].axisTicks.show=!1,this.opts.yaxis[0].floating=!0;}},{key:"line",value:function(){return {chart:{animations:{easing:"swing"}},dataLabels:{enabled:!1},stroke:{width:5,curve:"straight"},markers:{size:0,hover:{sizeOffset:6}},xaxis:{crosshairs:{width:1}}}}},{key:"sparkline",value:function(t){this.hideYAxis();return x.extend(t,{grid:{show:!1,padding:{left:0,right:0,top:0,bottom:0}},legend:{show:!1},xaxis:{labels:{show:!1},tooltip:{enabled:!1},axisBorder:{show:!1},axisTicks:{show:!1}},chart:{toolbar:{show:!1},zoom:{enabled:!1}},dataLabels:{enabled:!1}})}},{key:"slope",value:function(){return this.hideYAxis(),{chart:{toolbar:{show:!1},zoom:{enabled:!1}},dataLabels:{enabled:!0,formatter:function(t,e){var i=e.w.config.series[e.seriesIndex].name;return null!==t?i+": "+t:""},background:{enabled:!1},offsetX:-5},grid:{xaxis:{lines:{show:!0}},yaxis:{lines:{show:!1}}},xaxis:{position:"top",labels:{style:{fontSize:14,fontWeight:900}},tooltip:{enabled:!1},crosshairs:{show:!1}},markers:{size:8,hover:{sizeOffset:1}},legend:{show:!1},tooltip:{shared:!1,intersect:!0,followCursor:!0},stroke:{width:5,curve:"straight"}}}},{key:"bar",value:function(){return {chart:{stacked:!1,animations:{easing:"swing"}},plotOptions:{bar:{dataLabels:{position:"center"}}},dataLabels:{style:{colors:["#fff"]},background:{enabled:!1}},stroke:{width:0,lineCap:"round"},fill:{opacity:.85},legend:{markers:{shape:"square",radius:2,size:8}},tooltip:{shared:!1,intersect:!0},xaxis:{tooltip:{enabled:!1},tickPlacement:"between",crosshairs:{width:"barWidth",position:"back",fill:{type:"gradient"},dropShadow:{enabled:!1},stroke:{width:0}}}}}},{key:"funnel",value:function(){return this.hideYAxis(),e(e({},this.bar()),{},{chart:{animations:{easing:"linear",speed:800,animateGradually:{enabled:!1}}},plotOptions:{bar:{horizontal:!0,borderRadiusApplication:"around",borderRadius:0,dataLabels:{position:"center"}}},grid:{show:!1,padding:{left:0,right:0}},xaxis:{labels:{show:!1},tooltip:{enabled:!1},axisBorder:{show:!1},axisTicks:{show:!1}}})}},{key:"candlestick",value:function(){var t=this;return {stroke:{width:1,colors:["#333"]},fill:{opacity:1},dataLabels:{enabled:!1},tooltip:{shared:!0,custom:function(e){var i=e.seriesIndex,a=e.dataPointIndex,s=e.w;return t._getBoxTooltip(s,i,a,["Open","High","","Low","Close"],"candlestick")}},states:{active:{filter:{type:"none"}}},xaxis:{crosshairs:{width:1}}}}},{key:"boxPlot",value:function(){var t=this;return {chart:{animations:{dynamicAnimation:{enabled:!1}}},stroke:{width:1,colors:["#24292e"]},dataLabels:{enabled:!1},tooltip:{shared:!0,custom:function(e){var i=e.seriesIndex,a=e.dataPointIndex,s=e.w;return t._getBoxTooltip(s,i,a,["Minimum","Q1","Median","Q3","Maximum"],"boxPlot")}},markers:{size:5,strokeWidth:1,strokeColors:"#111"},xaxis:{crosshairs:{width:1}}}}},{key:"rangeBar",value:function(){return {chart:{animations:{animateGradually:!1}},stroke:{width:0,lineCap:"square"},plotOptions:{bar:{borderRadius:0,dataLabels:{position:"center"}}},dataLabels:{enabled:!1,formatter:function(t,e){e.ctx;var i=e.seriesIndex,a=e.dataPointIndex,s=e.w,r=function(){var t=s.globals.seriesRangeStart[i][a];return s.globals.seriesRangeEnd[i][a]-t};return s.globals.comboCharts?"rangeBar"===s.config.series[i].type||"rangeArea"===s.config.series[i].type?r():t:r()},background:{enabled:!1},style:{colors:["#fff"]}},markers:{size:10},tooltip:{shared:!1,followCursor:!0,custom:function(t){return t.w.config.plotOptions&&t.w.config.plotOptions.bar&&t.w.config.plotOptions.bar.horizontal?function(t){var i=z(e(e({},t),{},{isTimeline:!0})),a=i.color,s=i.seriesName,r=i.ylabel,o=i.startVal,n=i.endVal;return X(e(e({},t),{},{color:a,seriesName:s,ylabel:r,start:o,end:n}))}(t):function(t){var i=z(t),a=i.color,s=i.seriesName,r=i.ylabel,o=i.start,n=i.end;return X(e(e({},t),{},{color:a,seriesName:s,ylabel:r,start:o,end:n}))}(t)}},xaxis:{tickPlacement:"between",tooltip:{enabled:!1},crosshairs:{stroke:{width:0}}}}}},{key:"dumbbell",value:function(t){var e,i;return null!==(e=t.plotOptions.bar)&&void 0!==e&&e.barHeight||(t.plotOptions.bar.barHeight=2),null!==(i=t.plotOptions.bar)&&void 0!==i&&i.columnWidth||(t.plotOptions.bar.columnWidth=2),t}},{key:"area",value:function(){return {stroke:{width:4,fill:{type:"solid",gradient:{inverseColors:!1,shade:"light",type:"vertical",opacityFrom:.65,opacityTo:.5,stops:[0,100,100]}}},fill:{type:"gradient",gradient:{inverseColors:!1,shade:"light",type:"vertical",opacityFrom:.65,opacityTo:.5,stops:[0,100,100]}},markers:{size:0,hover:{sizeOffset:6}},tooltip:{followCursor:!1}}}},{key:"rangeArea",value:function(){return {stroke:{curve:"straight",width:0},fill:{type:"solid",opacity:.6},markers:{size:0},states:{hover:{filter:{type:"none"}},active:{filter:{type:"none"}}},tooltip:{intersect:!1,shared:!0,followCursor:!0,custom:function(t){return function(t){var i=z(t),a=i.color,s=i.seriesName,r=i.ylabel,o=i.start,n=i.end;return X(e(e({},t),{},{color:a,seriesName:s,ylabel:r,start:o,end:n}))}(t)}}}}},{key:"brush",value:function(t){return x.extend(t,{chart:{toolbar:{autoSelected:"selection",show:!1},zoom:{enabled:!1}},dataLabels:{enabled:!1},stroke:{width:1},tooltip:{enabled:!1},xaxis:{tooltip:{enabled:!1}}})}},{key:"stacked100",value:function(t){t.dataLabels=t.dataLabels||{},t.dataLabels.formatter=t.dataLabels.formatter||void 0;var e=t.dataLabels.formatter;return t.yaxis.forEach((function(e,i){t.yaxis[i].min=0,t.yaxis[i].max=100;})),"bar"===t.chart.type&&(t.dataLabels.formatter=e||function(t){return "number"==typeof t&&t?t.toFixed(0)+"%":t}),t}},{key:"stackedBars",value:function(){var t=this.bar();return e(e({},t),{},{plotOptions:e(e({},t.plotOptions),{},{bar:e(e({},t.plotOptions.bar),{},{borderRadiusApplication:"end",borderRadiusWhenStacked:"last"})})})}},{key:"convertCatToNumeric",value:function(t){return t.xaxis.convertedCatToNumeric=!0,t}},{key:"convertCatToNumericXaxis",value:function(t,e,i){t.xaxis.type="numeric",t.xaxis.labels=t.xaxis.labels||{},t.xaxis.labels.formatter=t.xaxis.labels.formatter||function(t){return x.isNumber(t)?Math.floor(t):t};var a=t.xaxis.labels.formatter,s=t.xaxis.categories&&t.xaxis.categories.length?t.xaxis.categories:t.labels;return i&&i.length&&(s=i.map((function(t){return Array.isArray(t)?t:String(t)}))),s&&s.length&&(t.xaxis.labels.formatter=function(t){return x.isNumber(t)?a(s[Math.floor(t)-1]):a(t)}),t.xaxis.categories=[],t.labels=[],t.xaxis.tickAmount=t.xaxis.tickAmount||"dataPoints",t}},{key:"bubble",value:function(){return {dataLabels:{style:{colors:["#fff"]}},tooltip:{shared:!1,intersect:!0},xaxis:{crosshairs:{width:0}},fill:{type:"solid",gradient:{shade:"light",inverse:!0,shadeIntensity:.55,opacityFrom:.4,opacityTo:.8}}}}},{key:"scatter",value:function(){return {dataLabels:{enabled:!1},tooltip:{shared:!1,intersect:!0},markers:{size:6,strokeWidth:1,hover:{sizeOffset:2}}}}},{key:"heatmap",value:function(){return {chart:{stacked:!1},fill:{opacity:1},dataLabels:{style:{colors:["#fff"]}},stroke:{colors:["#fff"]},tooltip:{followCursor:!0,marker:{show:!1},x:{show:!1}},legend:{position:"top",markers:{shape:"square",size:10,offsetY:2}},grid:{padding:{right:20}}}}},{key:"treemap",value:function(){return {chart:{zoom:{enabled:!1}},dataLabels:{style:{fontSize:14,fontWeight:600,colors:["#fff"]}},stroke:{show:!0,width:2,colors:["#fff"]},legend:{show:!1},fill:{gradient:{stops:[0,100]}},tooltip:{followCursor:!0,x:{show:!1}},grid:{padding:{left:0,right:0}},xaxis:{crosshairs:{show:!1},tooltip:{enabled:!1}}}}},{key:"pie",value:function(){return {chart:{toolbar:{show:!1}},plotOptions:{pie:{donut:{labels:{show:!1}}}},dataLabels:{formatter:function(t){return t.toFixed(1)+"%"},style:{colors:["#fff"]},background:{enabled:!1},dropShadow:{enabled:!0}},stroke:{colors:["#fff"]},fill:{opacity:1,gradient:{shade:"light",stops:[0,100]}},tooltip:{theme:"dark",fillSeriesColor:!0},legend:{position:"right"}}}},{key:"donut",value:function(){return {chart:{toolbar:{show:!1}},dataLabels:{formatter:function(t){return t.toFixed(1)+"%"},style:{colors:["#fff"]},background:{enabled:!1},dropShadow:{enabled:!0}},stroke:{colors:["#fff"]},fill:{opacity:1,gradient:{shade:"light",shadeIntensity:.35,stops:[80,100],opacityFrom:1,opacityTo:1}},tooltip:{theme:"dark",fillSeriesColor:!0},legend:{position:"right"}}}},{key:"polarArea",value:function(){return {chart:{toolbar:{show:!1}},dataLabels:{formatter:function(t){return t.toFixed(1)+"%"},enabled:!1},stroke:{show:!0,width:2},fill:{opacity:.7},tooltip:{theme:"dark",fillSeriesColor:!0},legend:{position:"right"}}}},{key:"radar",value:function(){return this.opts.yaxis[0].labels.offsetY=this.opts.yaxis[0].labels.offsetY?this.opts.yaxis[0].labels.offsetY:6,{dataLabels:{enabled:!1,style:{fontSize:"11px"}},stroke:{width:2},markers:{size:3,strokeWidth:1,strokeOpacity:1},fill:{opacity:.2},tooltip:{shared:!1,intersect:!0,followCursor:!0},grid:{show:!1},xaxis:{labels:{formatter:function(t){return t},style:{colors:["#a8a8a8"],fontSize:"11px"}},tooltip:{enabled:!1},crosshairs:{show:!1}}}}},{key:"radialBar",value:function(){return {chart:{animations:{dynamicAnimation:{enabled:!0,speed:800}},toolbar:{show:!1}},fill:{gradient:{shade:"dark",shadeIntensity:.4,inverseColors:!1,type:"diagonal2",opacityFrom:1,opacityTo:1,stops:[70,98,100]}},legend:{show:!1,position:"right"},tooltip:{enabled:!1,fillSeriesColor:!0}}}},{key:"_getBoxTooltip",value:function(t,e,i,a,s){var r=t.globals.seriesCandleO[e][i],o=t.globals.seriesCandleH[e][i],n=t.globals.seriesCandleM[e][i],l=t.globals.seriesCandleL[e][i],h=t.globals.seriesCandleC[e][i];return t.config.series[e].type&&t.config.series[e].type!==s?'<div class="apexcharts-custom-tooltip">\n          '.concat(t.config.series[e].name?t.config.series[e].name:"series-"+(e+1),": <strong>").concat(t.globals.series[e][i],"</strong>\n        </div>"):'<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(t.config.chart.type,'">')+"<div>".concat(a[0],': <span class="value">')+r+"</span></div>"+"<div>".concat(a[1],': <span class="value">')+o+"</span></div>"+(n?"<div>".concat(a[2],': <span class="value">')+n+"</span></div>":"")+"<div>".concat(a[3],': <span class="value">')+l+"</span></div>"+"<div>".concat(a[4],': <span class="value">')+h+"</span></div></div>"}}]),t}(),Y=function(){function t(e){a(this,t),this.opts=e;}return r(t,[{key:"init",value:function(t){var e=t.responsiveOverride,a=this.opts,s=new I,r=new E(a);this.chartType=a.chart.type,a=this.extendYAxis(a),a=this.extendAnnotations(a);var o=s.init(),n={};if(a&&"object"===i(a)){var l,h,c,d,g,u,p,f,b,v,m={};m=-1!==["line","area","bar","candlestick","boxPlot","rangeBar","rangeArea","bubble","scatter","heatmap","treemap","pie","polarArea","donut","radar","radialBar"].indexOf(a.chart.type)?r[a.chart.type]():r.line(),null!==(l=a.plotOptions)&&void 0!==l&&null!==(h=l.bar)&&void 0!==h&&h.isFunnel&&(m=r.funnel()),a.chart.stacked&&"bar"===a.chart.type&&(m=r.stackedBars()),null!==(c=a.chart.brush)&&void 0!==c&&c.enabled&&(m=r.brush(m)),null!==(d=a.plotOptions)&&void 0!==d&&null!==(g=d.line)&&void 0!==g&&g.isSlopeChart&&(m=r.slope()),a.chart.stacked&&"100%"===a.chart.stackType&&(a=r.stacked100(a)),null!==(u=a.plotOptions)&&void 0!==u&&null!==(p=u.bar)&&void 0!==p&&p.isDumbbell&&(a=r.dumbbell(a)),this.checkForDarkTheme(window.Apex),this.checkForDarkTheme(a),a.xaxis=a.xaxis||window.Apex.xaxis||{},e||(a.xaxis.convertedCatToNumeric=!1),(null!==(f=(a=this.checkForCatToNumericXAxis(this.chartType,m,a)).chart.sparkline)&&void 0!==f&&f.enabled||null!==(b=window.Apex.chart)&&void 0!==b&&null!==(v=b.sparkline)&&void 0!==v&&v.enabled)&&(m=r.sparkline(m)),n=x.extend(o,m);}var y=x.extend(n,window.Apex);return o=x.extend(y,a),o=this.handleUserInputErrors(o)}},{key:"checkForCatToNumericXAxis",value:function(t,e,i){var a,s,r=new E(i),o=("bar"===t||"boxPlot"===t)&&(null===(a=i.plotOptions)||void 0===a||null===(s=a.bar)||void 0===s?void 0:s.horizontal),n="pie"===t||"polarArea"===t||"donut"===t||"radar"===t||"radialBar"===t||"heatmap"===t,l="datetime"!==i.xaxis.type&&"numeric"!==i.xaxis.type,h=i.xaxis.tickPlacement?i.xaxis.tickPlacement:e.xaxis&&e.xaxis.tickPlacement;return o||n||!l||"between"===h||(i=r.convertCatToNumeric(i)),i}},{key:"extendYAxis",value:function(t,e){var i=new I;(void 0===t.yaxis||!t.yaxis||Array.isArray(t.yaxis)&&0===t.yaxis.length)&&(t.yaxis={}),t.yaxis.constructor!==Array&&window.Apex.yaxis&&window.Apex.yaxis.constructor!==Array&&(t.yaxis=x.extend(t.yaxis,window.Apex.yaxis)),t.yaxis.constructor!==Array?t.yaxis=[x.extend(i.yAxis,t.yaxis)]:t.yaxis=x.extendArray(t.yaxis,i.yAxis);var a=!1;t.yaxis.forEach((function(t){t.logarithmic&&(a=!0);}));var s=t.series;return e&&!s&&(s=e.config.series),a&&s.length!==t.yaxis.length&&s.length&&(t.yaxis=s.map((function(e,a){if(e.name||(s[a].name="series-".concat(a+1)),t.yaxis[a])return t.yaxis[a].seriesName=s[a].name,t.yaxis[a];var r=x.extend(i.yAxis,t.yaxis[0]);return r.show=!1,r}))),a&&s.length>1&&s.length!==t.yaxis.length&&console.warn("A multi-series logarithmic chart should have equal number of series and y-axes"),t}},{key:"extendAnnotations",value:function(t){return void 0===t.annotations&&(t.annotations={},t.annotations.yaxis=[],t.annotations.xaxis=[],t.annotations.points=[]),t=this.extendYAxisAnnotations(t),t=this.extendXAxisAnnotations(t),t=this.extendPointAnnotations(t)}},{key:"extendYAxisAnnotations",value:function(t){var e=new I;return t.annotations.yaxis=x.extendArray(void 0!==t.annotations.yaxis?t.annotations.yaxis:[],e.yAxisAnnotation),t}},{key:"extendXAxisAnnotations",value:function(t){var e=new I;return t.annotations.xaxis=x.extendArray(void 0!==t.annotations.xaxis?t.annotations.xaxis:[],e.xAxisAnnotation),t}},{key:"extendPointAnnotations",value:function(t){var e=new I;return t.annotations.points=x.extendArray(void 0!==t.annotations.points?t.annotations.points:[],e.pointAnnotation),t}},{key:"checkForDarkTheme",value:function(t){t.theme&&"dark"===t.theme.mode&&(t.tooltip||(t.tooltip={}),"light"!==t.tooltip.theme&&(t.tooltip.theme="dark"),t.chart.foreColor||(t.chart.foreColor="#f6f7f8"),t.chart.background||(t.chart.background="#424242"),t.theme.palette||(t.theme.palette="palette4"));}},{key:"handleUserInputErrors",value:function(t){var e=t;if(e.tooltip.shared&&e.tooltip.intersect)throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");if("bar"===e.chart.type&&e.plotOptions.bar.horizontal){if(e.yaxis.length>1)throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");e.yaxis[0].reversed&&(e.yaxis[0].opposite=!0),e.xaxis.tooltip.enabled=!1,e.yaxis[0].tooltip.enabled=!1,e.chart.zoom.enabled=!1;}return "bar"!==e.chart.type&&"rangeBar"!==e.chart.type||e.tooltip.shared&&"barWidth"===e.xaxis.crosshairs.width&&e.series.length>1&&(e.xaxis.crosshairs.width="tickWidth"),"candlestick"!==e.chart.type&&"boxPlot"!==e.chart.type||e.yaxis[0].reversed&&(console.warn("Reversed y-axis in ".concat(e.chart.type," chart is not supported.")),e.yaxis[0].reversed=!1),e}}]),t}(),F=function(){function t(){a(this,t);}return r(t,[{key:"initGlobalVars",value:function(t){t.series=[],t.seriesCandleO=[],t.seriesCandleH=[],t.seriesCandleM=[],t.seriesCandleL=[],t.seriesCandleC=[],t.seriesRangeStart=[],t.seriesRangeEnd=[],t.seriesRange=[],t.seriesPercent=[],t.seriesGoals=[],t.seriesX=[],t.seriesZ=[],t.seriesNames=[],t.seriesTotals=[],t.seriesLog=[],t.seriesColors=[],t.stackedSeriesTotals=[],t.seriesXvalues=[],t.seriesYvalues=[],t.labels=[],t.hasXaxisGroups=!1,t.groups=[],t.barGroups=[],t.lineGroups=[],t.areaGroups=[],t.hasSeriesGroups=!1,t.seriesGroups=[],t.categoryLabels=[],t.timescaleLabels=[],t.noLabelsProvided=!1,t.resizeTimer=null,t.selectionResizeTimer=null,t.delayedElements=[],t.pointsArray=[],t.dataLabelsRects=[],t.isXNumeric=!1,t.skipLastTimelinelabel=!1,t.skipFirstTimelinelabel=!1,t.isDataXYZ=!1,t.isMultiLineX=!1,t.isMultipleYAxis=!1,t.maxY=-Number.MAX_VALUE,t.minY=Number.MIN_VALUE,t.minYArr=[],t.maxYArr=[],t.maxX=-Number.MAX_VALUE,t.minX=Number.MAX_VALUE,t.initialMaxX=-Number.MAX_VALUE,t.initialMinX=Number.MAX_VALUE,t.maxDate=0,t.minDate=Number.MAX_VALUE,t.minZ=Number.MAX_VALUE,t.maxZ=-Number.MAX_VALUE,t.minXDiff=Number.MAX_VALUE,t.yAxisScale=[],t.xAxisScale=null,t.xAxisTicksPositions=[],t.yLabelsCoords=[],t.yTitleCoords=[],t.barPadForNumericAxis=0,t.padHorizontal=0,t.xRange=0,t.yRange=[],t.zRange=0,t.dataPoints=0,t.xTickAmount=0,t.multiAxisTickAmount=0;}},{key:"globalVars",value:function(t){return {chartID:null,cuid:null,events:{beforeMount:[],mounted:[],updated:[],clicked:[],selection:[],dataPointSelection:[],zoomed:[],scrolled:[]},colors:[],clientX:null,clientY:null,fill:{colors:[]},stroke:{colors:[]},dataLabels:{style:{colors:[]}},radarPolygons:{fill:{colors:[]}},markers:{colors:[],size:t.markers.size,largestSize:0},animationEnded:!1,isTouchDevice:"ontouchstart"in window||navigator.msMaxTouchPoints,isDirty:!1,isExecCalled:!1,initialConfig:null,initialSeries:[],lastXAxis:[],lastYAxis:[],columnSeries:null,labels:[],timescaleLabels:[],noLabelsProvided:!1,allSeriesCollapsed:!1,collapsedSeries:[],collapsedSeriesIndices:[],ancillaryCollapsedSeries:[],ancillaryCollapsedSeriesIndices:[],risingSeries:[],dataFormatXNumeric:!1,capturedSeriesIndex:-1,capturedDataPointIndex:-1,selectedDataPoints:[],goldenPadding:35,invalidLogScale:!1,ignoreYAxisIndexes:[],maxValsInArrayIndex:0,radialSize:0,selection:void 0,zoomEnabled:"zoom"===t.chart.toolbar.autoSelected&&t.chart.toolbar.tools.zoom&&t.chart.zoom.enabled,panEnabled:"pan"===t.chart.toolbar.autoSelected&&t.chart.toolbar.tools.pan,selectionEnabled:"selection"===t.chart.toolbar.autoSelected&&t.chart.toolbar.tools.selection,yaxis:null,mousedown:!1,lastClientPosition:{},visibleXRange:void 0,yValueDecimal:0,total:0,SVGNS:"http://www.w3.org/2000/svg",svgWidth:0,svgHeight:0,noData:!1,locale:{},dom:{},memory:{methodsToExec:[]},shouldAnimate:!0,skipLastTimelinelabel:!1,skipFirstTimelinelabel:!1,delayedElements:[],axisCharts:!0,isDataXYZ:!1,isSlopeChart:t.plotOptions.line.isSlopeChart,resized:!1,resizeTimer:null,comboCharts:!1,dataChanged:!1,previousPaths:[],allSeriesHasEqualX:!0,pointsArray:[],dataLabelsRects:[],lastDrawnDataLabelsIndexes:[],hasNullValues:!1,easing:null,zoomed:!1,gridWidth:0,gridHeight:0,rotateXLabels:!1,defaultLabels:!1,xLabelFormatter:void 0,yLabelFormatters:[],xaxisTooltipFormatter:void 0,ttKeyFormatter:void 0,ttVal:void 0,ttZFormatter:void 0,LINE_HEIGHT_RATIO:1.618,xAxisLabelsHeight:0,xAxisGroupLabelsHeight:0,xAxisLabelsWidth:0,yAxisLabelsWidth:0,scaleX:1,scaleY:1,translateX:0,translateY:0,translateYAxisX:[],yAxisWidths:[],translateXAxisY:0,translateXAxisX:0,tooltip:null,niceScaleAllowedMagMsd:[[1,1,2,5,5,5,10,10,10,10,10],[1,1,2,5,5,5,10,10,10,10,10]],niceScaleDefaultTicks:[1,2,4,4,6,6,6,6,6,6,6,6,6,6,6,6,6,6,12,12,12,12,12,12,12,12,12,24],seriesYAxisMap:[],seriesYAxisReverseMap:[]}}},{key:"init",value:function(t){var e=this.globalVars(t);return this.initGlobalVars(e),e.initialConfig=x.extend({},t),e.initialSeries=x.clone(t.series),e.lastXAxis=x.clone(e.initialConfig.xaxis),e.lastYAxis=x.clone(e.initialConfig.yaxis),e}}]),t}(),R=function(){function t(e){a(this,t),this.opts=e;}return r(t,[{key:"init",value:function(){var t=new Y(this.opts).init({responsiveOverride:!1});return {config:t,globals:(new F).init(t)}}}]),t}(),H=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w,this.opts=null,this.seriesIndex=0;}return r(t,[{key:"clippedImgArea",value:function(t){var e=this.w,i=e.config,a=parseInt(e.globals.gridWidth,10),s=parseInt(e.globals.gridHeight,10),r=a>s?a:s,o=t.image,n=0,l=0;void 0===t.width&&void 0===t.height?void 0!==i.fill.image.width&&void 0!==i.fill.image.height?(n=i.fill.image.width+1,l=i.fill.image.height):(n=r+1,l=r):(n=t.width,l=t.height);var h=document.createElementNS(e.globals.SVGNS,"pattern");m.setAttrs(h,{id:t.patternID,patternUnits:t.patternUnits?t.patternUnits:"userSpaceOnUse",width:n+"px",height:l+"px"});var c=document.createElementNS(e.globals.SVGNS,"image");h.appendChild(c),c.setAttributeNS(window.SVG.xlink,"href",o),m.setAttrs(c,{x:0,y:0,preserveAspectRatio:"none",width:n+"px",height:l+"px"}),c.style.opacity=t.opacity,e.globals.dom.elDefs.node.appendChild(h);}},{key:"getSeriesIndex",value:function(t){var e=this.w,i=e.config.chart.type;return ("bar"===i||"rangeBar"===i)&&e.config.plotOptions.bar.distributed||"heatmap"===i||"treemap"===i?this.seriesIndex=t.seriesNumber:this.seriesIndex=t.seriesNumber%e.globals.series.length,this.seriesIndex}},{key:"fillPath",value:function(t){var e=this.w;this.opts=t;var i,a,s,r=this.w.config;this.seriesIndex=this.getSeriesIndex(t);var o=this.getFillColors()[this.seriesIndex];void 0!==e.globals.seriesColors[this.seriesIndex]&&(o=e.globals.seriesColors[this.seriesIndex]),"function"==typeof o&&(o=o({seriesIndex:this.seriesIndex,dataPointIndex:t.dataPointIndex,value:t.value,w:e}));var n=t.fillType?t.fillType:this.getFillType(this.seriesIndex),l=Array.isArray(r.fill.opacity)?r.fill.opacity[this.seriesIndex]:r.fill.opacity;t.color&&(o=t.color),o||(o="#fff",console.warn("undefined color - ApexCharts"));var h=o;if(-1===o.indexOf("rgb")?o.length<9&&(h=x.hexToRgba(o,l)):o.indexOf("rgba")>-1&&(l=x.getOpacityFromRGBA(o)),t.opacity&&(l=t.opacity),"pattern"===n&&(a=this.handlePatternFill({fillConfig:t.fillConfig,patternFill:a,fillColor:o,fillOpacity:l,defaultColor:h})),"gradient"===n&&(s=this.handleGradientFill({fillConfig:t.fillConfig,fillColor:o,fillOpacity:l,i:this.seriesIndex})),"image"===n){var c=r.fill.image.src,d=t.patternID?t.patternID:"";this.clippedImgArea({opacity:l,image:Array.isArray(c)?t.seriesNumber<c.length?c[t.seriesNumber]:c[0]:c,width:t.width?t.width:void 0,height:t.height?t.height:void 0,patternUnits:t.patternUnits,patternID:"pattern".concat(e.globals.cuid).concat(t.seriesNumber+1).concat(d)}),i="url(#pattern".concat(e.globals.cuid).concat(t.seriesNumber+1).concat(d,")");}else i="gradient"===n?s:"pattern"===n?a:h;return t.solid&&(i=h),i}},{key:"getFillType",value:function(t){var e=this.w;return Array.isArray(e.config.fill.type)?e.config.fill.type[t]:e.config.fill.type}},{key:"getFillColors",value:function(){var t=this.w,e=t.config,i=this.opts,a=[];return t.globals.comboCharts?"line"===t.config.series[this.seriesIndex].type?Array.isArray(t.globals.stroke.colors)?a=t.globals.stroke.colors:a.push(t.globals.stroke.colors):Array.isArray(t.globals.fill.colors)?a=t.globals.fill.colors:a.push(t.globals.fill.colors):"line"===e.chart.type?Array.isArray(t.globals.stroke.colors)?a=t.globals.stroke.colors:a.push(t.globals.stroke.colors):Array.isArray(t.globals.fill.colors)?a=t.globals.fill.colors:a.push(t.globals.fill.colors),void 0!==i.fillColors&&(a=[],Array.isArray(i.fillColors)?a=i.fillColors.slice():a.push(i.fillColors)),a}},{key:"handlePatternFill",value:function(t){var e=t.fillConfig,i=t.patternFill,a=t.fillColor,s=t.fillOpacity,r=t.defaultColor,o=this.w.config.fill;e&&(o=e);var n=this.opts,l=new m(this.ctx),h=Array.isArray(o.pattern.strokeWidth)?o.pattern.strokeWidth[this.seriesIndex]:o.pattern.strokeWidth,c=a;Array.isArray(o.pattern.style)?i=void 0!==o.pattern.style[n.seriesNumber]?l.drawPattern(o.pattern.style[n.seriesNumber],o.pattern.width,o.pattern.height,c,h,s):r:i=l.drawPattern(o.pattern.style,o.pattern.width,o.pattern.height,c,h,s);return i}},{key:"handleGradientFill",value:function(t){var i=t.fillColor,a=t.fillOpacity,s=t.fillConfig,r=t.i,o=this.w.config.fill;s&&(o=e(e({},o),s));var n,l=this.opts,h=new m(this.ctx),c=new x,d=o.gradient.type,g=i,u=void 0===o.gradient.opacityFrom?a:Array.isArray(o.gradient.opacityFrom)?o.gradient.opacityFrom[r]:o.gradient.opacityFrom;g.indexOf("rgba")>-1&&(u=x.getOpacityFromRGBA(g));var p=void 0===o.gradient.opacityTo?a:Array.isArray(o.gradient.opacityTo)?o.gradient.opacityTo[r]:o.gradient.opacityTo;if(void 0===o.gradient.gradientToColors||0===o.gradient.gradientToColors.length)n="dark"===o.gradient.shade?c.shadeColor(-1*parseFloat(o.gradient.shadeIntensity),i.indexOf("rgb")>-1?x.rgb2hex(i):i):c.shadeColor(parseFloat(o.gradient.shadeIntensity),i.indexOf("rgb")>-1?x.rgb2hex(i):i);else if(o.gradient.gradientToColors[l.seriesNumber]){var f=o.gradient.gradientToColors[l.seriesNumber];n=f,f.indexOf("rgba")>-1&&(p=x.getOpacityFromRGBA(f));}else n=i;if(o.gradient.gradientFrom&&(g=o.gradient.gradientFrom),o.gradient.gradientTo&&(n=o.gradient.gradientTo),o.gradient.inverseColors){var b=g;g=n,n=b;}return g.indexOf("rgb")>-1&&(g=x.rgb2hex(g)),n.indexOf("rgb")>-1&&(n=x.rgb2hex(n)),h.drawGradient(d,g,n,u,p,l.size,o.gradient.stops,o.gradient.colorStops,r)}}]),t}(),D=function(){function t(e,i){a(this,t),this.ctx=e,this.w=e.w;}return r(t,[{key:"setGlobalMarkerSize",value:function(){var t=this.w;if(t.globals.markers.size=Array.isArray(t.config.markers.size)?t.config.markers.size:[t.config.markers.size],t.globals.markers.size.length>0){if(t.globals.markers.size.length<t.globals.series.length+1)for(var e=0;e<=t.globals.series.length;e++)void 0===t.globals.markers.size[e]&&t.globals.markers.size.push(t.globals.markers.size[0]);}else t.globals.markers.size=t.config.series.map((function(e){return t.config.markers.size}));}},{key:"plotChartMarkers",value:function(t,e,i,a){var s,r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],o=this.w,n=e,l=t,h=null,c=new m(this.ctx),d=o.config.markers.discrete&&o.config.markers.discrete.length;if((o.globals.markers.size[e]>0||r||d)&&(h=c.group({class:r||d?"":"apexcharts-series-markers"})).attr("clip-path","url(#gridRectMarkerMask".concat(o.globals.cuid,")")),Array.isArray(l.x))for(var g=0;g<l.x.length;g++){var u=i;1===i&&0===g&&(u=0),1===i&&1===g&&(u=1);var p="apexcharts-marker";if("line"!==o.config.chart.type&&"area"!==o.config.chart.type||o.globals.comboCharts||o.config.tooltip.intersect||(p+=" no-pointer-events"),(Array.isArray(o.config.markers.size)?o.globals.markers.size[e]>0:o.config.markers.size>0)||r||d){x.isNumber(l.y[g])?p+=" w".concat(x.randomId()):p="apexcharts-nullpoint";var f=this.getMarkerConfig({cssClass:p,seriesIndex:e,dataPointIndex:u});o.config.series[n].data[u]&&(o.config.series[n].data[u].fillColor&&(f.pointFillColor=o.config.series[n].data[u].fillColor),o.config.series[n].data[u].strokeColor&&(f.pointStrokeColor=o.config.series[n].data[u].strokeColor)),a&&(f.pSize=a),(l.x[g]<-o.globals.markers.largestSize||l.x[g]>o.globals.gridWidth+o.globals.markers.largestSize||l.y[g]<-o.globals.markers.largestSize||l.y[g]>o.globals.gridHeight+o.globals.markers.largestSize)&&(f.pSize=0),(s=c.drawMarker(l.x[g],l.y[g],f)).attr("rel",u),s.attr("j",u),s.attr("index",e),s.node.setAttribute("default-marker-size",f.pSize),new v(this.ctx).setSelectionFilter(s,e,u),this.addEvents(s),h&&h.add(s);}else void 0===o.globals.pointsArray[e]&&(o.globals.pointsArray[e]=[]),o.globals.pointsArray[e].push([l.x[g],l.y[g]]);}return h}},{key:"getMarkerConfig",value:function(t){var e=t.cssClass,i=t.seriesIndex,a=t.dataPointIndex,s=void 0===a?null:a,r=t.finishRadius,o=void 0===r?null:r,n=this.w,l=this.getMarkerStyle(i),h=n.globals.markers.size[i],c=n.config.markers;return null!==s&&c.discrete.length&&c.discrete.map((function(t){t.seriesIndex===i&&t.dataPointIndex===s&&(l.pointStrokeColor=t.strokeColor,l.pointFillColor=t.fillColor,h=t.size,l.pointShape=t.shape);})),{pSize:null===o?h:o,pRadius:c.radius,width:Array.isArray(c.width)?c.width[i]:c.width,height:Array.isArray(c.height)?c.height[i]:c.height,pointStrokeWidth:Array.isArray(c.strokeWidth)?c.strokeWidth[i]:c.strokeWidth,pointStrokeColor:l.pointStrokeColor,pointFillColor:l.pointFillColor,shape:l.pointShape||(Array.isArray(c.shape)?c.shape[i]:c.shape),class:e,pointStrokeOpacity:Array.isArray(c.strokeOpacity)?c.strokeOpacity[i]:c.strokeOpacity,pointStrokeDashArray:Array.isArray(c.strokeDashArray)?c.strokeDashArray[i]:c.strokeDashArray,pointFillOpacity:Array.isArray(c.fillOpacity)?c.fillOpacity[i]:c.fillOpacity,seriesIndex:i}}},{key:"addEvents",value:function(t){var e=this.w,i=new m(this.ctx);t.node.addEventListener("mouseenter",i.pathMouseEnter.bind(this.ctx,t)),t.node.addEventListener("mouseleave",i.pathMouseLeave.bind(this.ctx,t)),t.node.addEventListener("mousedown",i.pathMouseDown.bind(this.ctx,t)),t.node.addEventListener("click",e.config.markers.onClick),t.node.addEventListener("dblclick",e.config.markers.onDblClick),t.node.addEventListener("touchstart",i.pathMouseDown.bind(this.ctx,t),{passive:!0});}},{key:"getMarkerStyle",value:function(t){var e=this.w,i=e.globals.markers.colors,a=e.config.markers.strokeColor||e.config.markers.strokeColors;return {pointStrokeColor:Array.isArray(a)?a[t]:a,pointFillColor:Array.isArray(i)?i[t]:i}}}]),t}(),O=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w,this.initialAnim=this.w.config.chart.animations.enabled,this.dynamicAnim=this.initialAnim&&this.w.config.chart.animations.dynamicAnimation.enabled;}return r(t,[{key:"draw",value:function(t,e,i){var a=this.w,s=new m(this.ctx),r=i.realIndex,o=i.pointsPos,n=i.zRatio,l=i.elParent,h=s.group({class:"apexcharts-series-markers apexcharts-series-".concat(a.config.chart.type)});if(h.attr("clip-path","url(#gridRectMarkerMask".concat(a.globals.cuid,")")),Array.isArray(o.x))for(var c=0;c<o.x.length;c++){var d=e+1,g=!0;0===e&&0===c&&(d=0),0===e&&1===c&&(d=1);var u=0,p=a.globals.markers.size[r];if(n!==1/0){var f=a.config.plotOptions.bubble;p=a.globals.seriesZ[r][d],f.zScaling&&(p/=n),f.minBubbleRadius&&p<f.minBubbleRadius&&(p=f.minBubbleRadius),f.maxBubbleRadius&&p>f.maxBubbleRadius&&(p=f.maxBubbleRadius);}a.config.chart.animations.enabled||(u=p);var x=o.x[c],b=o.y[c];if(u=u||0,null!==b&&void 0!==a.globals.series[r][d]||(g=!1),g){var v=this.drawPoint(x,b,u,p,r,d,e);h.add(v);}l.add(h);}}},{key:"drawPoint",value:function(t,e,i,a,s,r,o){var n=this.w,l=s,h=new b(this.ctx),c=new v(this.ctx),d=new H(this.ctx),g=new D(this.ctx),u=new m(this.ctx),p=g.getMarkerConfig({cssClass:"apexcharts-marker",seriesIndex:l,dataPointIndex:r,finishRadius:"bubble"===n.config.chart.type||n.globals.comboCharts&&n.config.series[s]&&"bubble"===n.config.series[s].type?a:null});a=p.pSize;var f,x=d.fillPath({seriesNumber:s,dataPointIndex:r,color:p.pointFillColor,patternUnits:"objectBoundingBox",value:n.globals.series[s][o]});if("circle"===p.shape?f=u.drawCircle(i):"square"!==p.shape&&"rect"!==p.shape||(f=u.drawRect(0,0,p.width-p.pointStrokeWidth/2,p.height-p.pointStrokeWidth/2,p.pRadius)),n.config.series[l].data[r]&&n.config.series[l].data[r].fillColor&&(x=n.config.series[l].data[r].fillColor),f.attr({x:t-p.width/2-p.pointStrokeWidth/2,y:e-p.height/2-p.pointStrokeWidth/2,cx:t,cy:e,fill:x,"fill-opacity":p.pointFillOpacity,stroke:p.pointStrokeColor,r:a,"stroke-width":p.pointStrokeWidth,"stroke-dasharray":p.pointStrokeDashArray,"stroke-opacity":p.pointStrokeOpacity}),n.config.chart.dropShadow.enabled){var y=n.config.chart.dropShadow;c.dropShadow(f,y,s);}if(!this.initialAnim||n.globals.dataChanged||n.globals.resized)n.globals.animationEnded=!0;else {var w=n.config.chart.animations.speed;h.animateMarker(f,0,"circle"===p.shape?a:{width:p.width,height:p.height},w,n.globals.easing,(function(){window.setTimeout((function(){h.animationCompleted(f);}),100);}));}if(n.globals.dataChanged&&"circle"===p.shape)if(this.dynamicAnim){var k,A,S,C,L=n.config.chart.animations.dynamicAnimation.speed;null!=(C=n.globals.previousPaths[s]&&n.globals.previousPaths[s][o])&&(k=C.x,A=C.y,S=void 0!==C.r?C.r:a);for(var P=0;P<n.globals.collapsedSeries.length;P++)n.globals.collapsedSeries[P].index===s&&(L=1,a=0);0===t&&0===e&&(a=0),h.animateCircle(f,{cx:k,cy:A,r:S},{cx:t,cy:e,r:a},L,n.globals.easing);}else f.attr({r:a});return f.attr({rel:r,j:r,index:s,"default-marker-size":a}),c.setSelectionFilter(f,s,r),g.addEvents(f),f.node.classList.add("apexcharts-marker"),f}},{key:"centerTextInBubble",value:function(t){var e=this.w;return {y:t+=parseInt(e.config.dataLabels.style.fontSize,10)/4}}}]),t}(),N=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w;}return r(t,[{key:"dataLabelsCorrection",value:function(t,e,i,a,s,r,o){var n=this.w,l=!1,h=new m(this.ctx).getTextRects(i,o),c=h.width,d=h.height;e<0&&(e=0),e>n.globals.gridHeight+d&&(e=n.globals.gridHeight+d/2),void 0===n.globals.dataLabelsRects[a]&&(n.globals.dataLabelsRects[a]=[]),n.globals.dataLabelsRects[a].push({x:t,y:e,width:c,height:d});var g=n.globals.dataLabelsRects[a].length-2,u=void 0!==n.globals.lastDrawnDataLabelsIndexes[a]?n.globals.lastDrawnDataLabelsIndexes[a][n.globals.lastDrawnDataLabelsIndexes[a].length-1]:0;if(void 0!==n.globals.dataLabelsRects[a][g]){var p=n.globals.dataLabelsRects[a][u];(t>p.x+p.width||e>p.y+p.height||e+d<p.y||t+c<p.x)&&(l=!0);}return (0===s||r)&&(l=!0),{x:t,y:e,textRects:h,drawnextLabel:l}}},{key:"drawDataLabel",value:function(t){var e=this,i=t.type,a=t.pos,s=t.i,r=t.j,o=t.isRangeStart,n=t.strokeWidth,l=void 0===n?2:n,h=this.w,c=new m(this.ctx),d=h.config.dataLabels,g=0,u=0,p=r,f=null;if(-1!==h.globals.collapsedSeriesIndices.indexOf(s)||!d.enabled||!Array.isArray(a.x))return f;f=c.group({class:"apexcharts-data-labels"});for(var x=0;x<a.x.length;x++)if(g=a.x[x]+d.offsetX,u=a.y[x]+d.offsetY+l,!isNaN(g)){1===r&&0===x&&(p=0),1===r&&1===x&&(p=1);var b=h.globals.series[s][p];"rangeArea"===i&&(b=o?h.globals.seriesRangeStart[s][p]:h.globals.seriesRangeEnd[s][p]);var v="",y=function(t){return h.config.dataLabels.formatter(t,{ctx:e.ctx,seriesIndex:s,dataPointIndex:p,w:h})};if("bubble"===h.config.chart.type)v=y(b=h.globals.seriesZ[s][p]),u=a.y[x],u=new O(this.ctx).centerTextInBubble(u,s,p).y;else void 0!==b&&(v=y(b));var w=h.config.dataLabels.textAnchor;h.globals.isSlopeChart&&(w=0===p?"end":p===h.config.series[s].data.length-1?"start":"middle"),this.plotDataLabelsText({x:g,y:u,text:v,i:s,j:p,parent:f,offsetCorrection:!0,dataLabelsConfig:h.config.dataLabels,textAnchor:w});}return f}},{key:"plotDataLabelsText",value:function(t){var e=this.w,i=new m(this.ctx),a=t.x,s=t.y,r=t.i,o=t.j,n=t.text,l=t.textAnchor,h=t.fontSize,c=t.parent,d=t.dataLabelsConfig,g=t.color,u=t.alwaysDrawDataLabel,p=t.offsetCorrection;if(!(Array.isArray(e.config.dataLabels.enabledOnSeries)&&e.config.dataLabels.enabledOnSeries.indexOf(r)<0)){var f={x:a,y:s,drawnextLabel:!0,textRects:null};p&&(f=this.dataLabelsCorrection(a,s,n,r,o,u,parseInt(d.style.fontSize,10))),e.globals.zoomed||(a=f.x,s=f.y),f.textRects&&(a<-20-f.textRects.width||a>e.globals.gridWidth+f.textRects.width+30)&&(n="");var x=e.globals.dataLabels.style.colors[r];(("bar"===e.config.chart.type||"rangeBar"===e.config.chart.type)&&e.config.plotOptions.bar.distributed||e.config.dataLabels.distributed)&&(x=e.globals.dataLabels.style.colors[o]),"function"==typeof x&&(x=x({series:e.globals.series,seriesIndex:r,dataPointIndex:o,w:e})),g&&(x=g);var b=d.offsetX,y=d.offsetY;if("bar"!==e.config.chart.type&&"rangeBar"!==e.config.chart.type||(b=0,y=0),e.globals.isSlopeChart&&(0!==o&&(b=-2*d.offsetX+5),0!==o&&o!==e.config.series[r].data.length-1&&(b=0)),f.drawnextLabel){var w=i.drawText({width:100,height:parseInt(d.style.fontSize,10),x:a+b,y:s+y,foreColor:x,textAnchor:l||d.textAnchor,text:n,fontSize:h||d.style.fontSize,fontFamily:d.style.fontFamily,fontWeight:d.style.fontWeight||"normal"});if(w.attr({class:"apexcharts-datalabel",cx:a,cy:s}),d.dropShadow.enabled){var k=d.dropShadow;new v(this.ctx).dropShadow(w,k);}c.add(w),void 0===e.globals.lastDrawnDataLabelsIndexes[r]&&(e.globals.lastDrawnDataLabelsIndexes[r]=[]),e.globals.lastDrawnDataLabelsIndexes[r].push(o);}}}},{key:"addBackgroundToDataLabel",value:function(t,e){var i=this.w,a=i.config.dataLabels.background,s=a.padding,r=a.padding/2,o=e.width,n=e.height,l=new m(this.ctx).drawRect(e.x-s,e.y-r/2,o+2*s,n+r,a.borderRadius,"transparent"===i.config.chart.background?"#fff":i.config.chart.background,a.opacity,a.borderWidth,a.borderColor);a.dropShadow.enabled&&new v(this.ctx).dropShadow(l,a.dropShadow);return l}},{key:"dataLabelsBackground",value:function(){var t=this.w;if("bubble"!==t.config.chart.type)for(var e=t.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"),i=0;i<e.length;i++){var a=e[i],s=a.getBBox(),r=null;if(s.width&&s.height&&(r=this.addBackgroundToDataLabel(a,s)),r){a.parentNode.insertBefore(r.node,a);var o=a.getAttribute("fill");t.config.chart.animations.enabled&&!t.globals.resized&&!t.globals.dataChanged?r.animate().attr({fill:o}):r.attr({fill:o}),a.setAttribute("fill",t.config.dataLabels.background.foreColor);}}}},{key:"bringForward",value:function(){for(var t=this.w,e=t.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"),i=t.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"),a=0;a<e.length;a++)i&&i.insertBefore(e[a],i.nextSibling);}}]),t}(),W=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w,this.legendInactiveClass="legend-mouseover-inactive";}return r(t,[{key:"getAllSeriesEls",value:function(){return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series")}},{key:"getSeriesByName",value:function(t){return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(x.escapeString(t),"']"))}},{key:"isSeriesHidden",value:function(t){var e=this.getSeriesByName(t),i=parseInt(e.getAttribute("data:realIndex"),10);return {isHidden:e.classList.contains("apexcharts-series-collapsed"),realIndex:i}}},{key:"addCollapsedClassToSeries",value:function(t,e){var i=this.w;function a(i){for(var a=0;a<i.length;a++)i[a].index===e&&t.node.classList.add("apexcharts-series-collapsed");}a(i.globals.collapsedSeries),a(i.globals.ancillaryCollapsedSeries);}},{key:"toggleSeries",value:function(t){var e=this.isSeriesHidden(t);return this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex,e.isHidden),e.isHidden}},{key:"showSeries",value:function(t){var e=this.isSeriesHidden(t);e.isHidden&&this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex,!0);}},{key:"hideSeries",value:function(t){var e=this.isSeriesHidden(t);e.isHidden||this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex,!1);}},{key:"resetSeries",value:function(){var t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],a=this.w,s=x.clone(a.globals.initialSeries);a.globals.previousPaths=[],i?(a.globals.collapsedSeries=[],a.globals.ancillaryCollapsedSeries=[],a.globals.collapsedSeriesIndices=[],a.globals.ancillaryCollapsedSeriesIndices=[]):s=this.emptyCollapsedSeries(s),a.config.series=s,t&&(e&&(a.globals.zoomed=!1,this.ctx.updateHelpers.revertDefaultAxisMinMax()),this.ctx.updateHelpers._updateSeries(s,a.config.chart.animations.dynamicAnimation.enabled));}},{key:"emptyCollapsedSeries",value:function(t){for(var e=this.w,i=0;i<t.length;i++)e.globals.collapsedSeriesIndices.indexOf(i)>-1&&(t[i].data=[]);return t}},{key:"toggleSeriesOnHover",value:function(t,e){var i=this.w;e||(e=t.target);var a=i.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis");if("mousemove"===t.type){var s=parseInt(e.getAttribute("rel"),10)-1,r=null,o=null,n=null;if(i.globals.axisCharts||"radialBar"===i.config.chart.type)if(i.globals.axisCharts){r=i.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(s,"']")),o=i.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(s,"']"));var l=i.globals.seriesYAxisReverseMap[s];n=i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(l,"']"));}else r=i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s+1,"']"));else r=i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s+1,"'] path"));for(var h=0;h<a.length;h++)a[h].classList.add(this.legendInactiveClass);null!==r&&(i.globals.axisCharts||r.parentNode.classList.remove(this.legendInactiveClass),r.classList.remove(this.legendInactiveClass),null!==o&&o.classList.remove(this.legendInactiveClass),null!==n&&n.classList.remove(this.legendInactiveClass));}else if("mouseout"===t.type)for(var c=0;c<a.length;c++)a[c].classList.remove(this.legendInactiveClass);}},{key:"highlightRangeInSeries",value:function(t,e){var i=this,a=this.w,s=a.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"),r=function(t){for(var e=0;e<s.length;e++)s[e].classList[t](i.legendInactiveClass);};if("mousemove"===t.type){var o=parseInt(e.getAttribute("rel"),10)-1;r("add"),function(t){for(var e=0;e<s.length;e++){var a=parseInt(s[e].getAttribute("val"),10);a>=t.from&&a<=t.to&&s[e].classList.remove(i.legendInactiveClass);}}(a.config.plotOptions.heatmap.colorScale.ranges[o]);}else "mouseout"===t.type&&r("remove");}},{key:"getActiveConfigSeriesIndex",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"asc",e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],i=this.w,a=0;if(i.config.series.length>1)for(var s=i.config.series.map((function(t,a){return t.data&&t.data.length>0&&-1===i.globals.collapsedSeriesIndices.indexOf(a)&&(!i.globals.comboCharts||0===e.length||e.length&&e.indexOf(i.config.series[a].type)>-1)?a:-1})),r="asc"===t?0:s.length-1;"asc"===t?r<s.length:r>=0;"asc"===t?r++:r--)if(-1!==s[r]){a=s[r];break}return a}},{key:"getBarSeriesIndices",value:function(){return this.w.globals.comboCharts?this.w.config.series.map((function(t,e){return "bar"===t.type||"column"===t.type?e:-1})).filter((function(t){return -1!==t})):this.w.config.series.map((function(t,e){return e}))}},{key:"getPreviousPaths",value:function(){var t=this.w;function e(e,i,a){for(var s=e[i].childNodes,r={type:a,paths:[],realIndex:e[i].getAttribute("data:realIndex")},o=0;o<s.length;o++)if(s[o].hasAttribute("pathTo")){var n=s[o].getAttribute("pathTo");r.paths.push({d:n});}t.globals.previousPaths.push(r);}t.globals.previousPaths=[];["line","area","bar","rangebar","rangeArea","candlestick","radar"].forEach((function(i){for(var a,s=(a=i,t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(a,"-series .apexcharts-series"))),r=0;r<s.length;r++)e(s,r,i);})),this.handlePrevBubbleScatterPaths("bubble"),this.handlePrevBubbleScatterPaths("scatter");var i=t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t.config.chart.type," .apexcharts-series"));if(i.length>0)for(var a=function(e){for(var i=t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t.config.chart.type," .apexcharts-series[data\\:realIndex='").concat(e,"'] rect")),a=[],s=function(t){var e=function(e){return i[t].getAttribute(e)},s={x:parseFloat(e("x")),y:parseFloat(e("y")),width:parseFloat(e("width")),height:parseFloat(e("height"))};a.push({rect:s,color:i[t].getAttribute("color")});},r=0;r<i.length;r++)s(r);t.globals.previousPaths.push(a);},s=0;s<i.length;s++)a(s);t.globals.axisCharts||(t.globals.previousPaths=t.globals.series);}},{key:"handlePrevBubbleScatterPaths",value:function(t){var e=this.w,i=e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t,"-series .apexcharts-series"));if(i.length>0)for(var a=0;a<i.length;a++){for(var s=e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t,"-series .apexcharts-series[data\\:realIndex='").concat(a,"'] circle")),r=[],o=0;o<s.length;o++)r.push({x:s[o].getAttribute("cx"),y:s[o].getAttribute("cy"),r:s[o].getAttribute("r")});e.globals.previousPaths.push(r);}}},{key:"clearPreviousPaths",value:function(){var t=this.w;t.globals.previousPaths=[],t.globals.allSeriesCollapsed=!1;}},{key:"handleNoData",value:function(){var t=this.w,e=t.config.noData,i=new m(this.ctx),a=t.globals.svgWidth/2,s=t.globals.svgHeight/2,r="middle";if(t.globals.noData=!0,t.globals.animationEnded=!0,"left"===e.align?(a=10,r="start"):"right"===e.align&&(a=t.globals.svgWidth-10,r="end"),"top"===e.verticalAlign?s=50:"bottom"===e.verticalAlign&&(s=t.globals.svgHeight-50),a+=e.offsetX,s=s+parseInt(e.style.fontSize,10)+2+e.offsetY,void 0!==e.text&&""!==e.text){var o=i.drawText({x:a,y:s,text:e.text,textAnchor:r,fontSize:e.style.fontSize,fontFamily:e.style.fontFamily,foreColor:e.style.color,opacity:1,class:"apexcharts-text-nodata"});t.globals.dom.Paper.add(o);}}},{key:"setNullSeriesToZeroValues",value:function(t){for(var e=this.w,i=0;i<t.length;i++)if(0===t[i].length)for(var a=0;a<t[e.globals.maxValsInArrayIndex].length;a++)t[i].push(0);return t}},{key:"hasAllSeriesEqualX",value:function(){for(var t=!0,e=this.w,i=this.filteredSeriesX(),a=0;a<i.length-1;a++)if(i[a][0]!==i[a+1][0]){t=!1;break}return e.globals.allSeriesHasEqualX=t,t}},{key:"filteredSeriesX",value:function(){var t=this.w.globals.seriesX.map((function(t){return t.length>0?t:[]}));return t}}]),t}(),B=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w,this.twoDSeries=[],this.threeDSeries=[],this.twoDSeriesX=[],this.seriesGoals=[],this.coreUtils=new y(this.ctx);}return r(t,[{key:"isMultiFormat",value:function(){return this.isFormatXY()||this.isFormat2DArray()}},{key:"isFormatXY",value:function(){var t=this.w.config.series.slice(),e=new W(this.ctx);if(this.activeSeriesIndex=e.getActiveConfigSeriesIndex(),void 0!==t[this.activeSeriesIndex].data&&t[this.activeSeriesIndex].data.length>0&&null!==t[this.activeSeriesIndex].data[0]&&void 0!==t[this.activeSeriesIndex].data[0].x&&null!==t[this.activeSeriesIndex].data[0])return !0}},{key:"isFormat2DArray",value:function(){var t=this.w.config.series.slice(),e=new W(this.ctx);if(this.activeSeriesIndex=e.getActiveConfigSeriesIndex(),void 0!==t[this.activeSeriesIndex].data&&t[this.activeSeriesIndex].data.length>0&&void 0!==t[this.activeSeriesIndex].data[0]&&null!==t[this.activeSeriesIndex].data[0]&&t[this.activeSeriesIndex].data[0].constructor===Array)return !0}},{key:"handleFormat2DArray",value:function(t,e){for(var i=this.w.config,a=this.w.globals,s="boxPlot"===i.chart.type||"boxPlot"===i.series[e].type,r=0;r<t[e].data.length;r++)if(void 0!==t[e].data[r][1]&&(Array.isArray(t[e].data[r][1])&&4===t[e].data[r][1].length&&!s?this.twoDSeries.push(x.parseNumber(t[e].data[r][1][3])):t[e].data[r].length>=5?this.twoDSeries.push(x.parseNumber(t[e].data[r][4])):this.twoDSeries.push(x.parseNumber(t[e].data[r][1])),a.dataFormatXNumeric=!0),"datetime"===i.xaxis.type){var o=new Date(t[e].data[r][0]);o=new Date(o).getTime(),this.twoDSeriesX.push(o);}else this.twoDSeriesX.push(t[e].data[r][0]);for(var n=0;n<t[e].data.length;n++)void 0!==t[e].data[n][2]&&(this.threeDSeries.push(t[e].data[n][2]),a.isDataXYZ=!0);}},{key:"handleFormatXY",value:function(t,e){var i=this.w.config,a=this.w.globals,s=new A(this.ctx),r=e;a.collapsedSeriesIndices.indexOf(e)>-1&&(r=this.activeSeriesIndex);for(var o=0;o<t[e].data.length;o++)void 0!==t[e].data[o].y&&(Array.isArray(t[e].data[o].y)?this.twoDSeries.push(x.parseNumber(t[e].data[o].y[t[e].data[o].y.length-1])):this.twoDSeries.push(x.parseNumber(t[e].data[o].y))),void 0!==t[e].data[o].goals&&Array.isArray(t[e].data[o].goals)?(void 0===this.seriesGoals[e]&&(this.seriesGoals[e]=[]),this.seriesGoals[e].push(t[e].data[o].goals)):(void 0===this.seriesGoals[e]&&(this.seriesGoals[e]=[]),this.seriesGoals[e].push(null));for(var n=0;n<t[r].data.length;n++){var l="string"==typeof t[r].data[n].x,h=Array.isArray(t[r].data[n].x),c=!h&&!!s.isValidDate(t[r].data[n].x);if(l||c)if(l||i.xaxis.convertedCatToNumeric){var d=a.isBarHorizontal&&a.isRangeData;"datetime"!==i.xaxis.type||d?(this.fallbackToCategory=!0,this.twoDSeriesX.push(t[r].data[n].x),isNaN(t[r].data[n].x)||"category"===this.w.config.xaxis.type||"string"==typeof t[r].data[n].x||(a.isXNumeric=!0)):this.twoDSeriesX.push(s.parseDate(t[r].data[n].x));}else "datetime"===i.xaxis.type?this.twoDSeriesX.push(s.parseDate(t[r].data[n].x.toString())):(a.dataFormatXNumeric=!0,a.isXNumeric=!0,this.twoDSeriesX.push(parseFloat(t[r].data[n].x)));else h?(this.fallbackToCategory=!0,this.twoDSeriesX.push(t[r].data[n].x)):(a.isXNumeric=!0,a.dataFormatXNumeric=!0,this.twoDSeriesX.push(t[r].data[n].x));}if(t[e].data[0]&&void 0!==t[e].data[0].z){for(var g=0;g<t[e].data.length;g++)this.threeDSeries.push(t[e].data[g].z);a.isDataXYZ=!0;}}},{key:"handleRangeData",value:function(t,e){var i=this.w.globals,a={};return this.isFormat2DArray()?a=this.handleRangeDataFormat("array",t,e):this.isFormatXY()&&(a=this.handleRangeDataFormat("xy",t,e)),i.seriesRangeStart.push(void 0===a.start?[]:a.start),i.seriesRangeEnd.push(void 0===a.end?[]:a.end),i.seriesRange.push(a.rangeUniques),i.seriesRange.forEach((function(t,e){t&&t.forEach((function(t,e){t.y.forEach((function(e,i){for(var a=0;a<t.y.length;a++)if(i!==a){var s=e.y1,r=e.y2,o=t.y[a].y1;s<=t.y[a].y2&&o<=r&&(t.overlaps.indexOf(e.rangeName)<0&&t.overlaps.push(e.rangeName),t.overlaps.indexOf(t.y[a].rangeName)<0&&t.overlaps.push(t.y[a].rangeName));}}));}));})),a}},{key:"handleCandleStickBoxData",value:function(t,e){var i=this.w.globals,a={};return this.isFormat2DArray()?a=this.handleCandleStickBoxDataFormat("array",t,e):this.isFormatXY()&&(a=this.handleCandleStickBoxDataFormat("xy",t,e)),i.seriesCandleO[e]=a.o,i.seriesCandleH[e]=a.h,i.seriesCandleM[e]=a.m,i.seriesCandleL[e]=a.l,i.seriesCandleC[e]=a.c,a}},{key:"handleRangeDataFormat",value:function(t,e,i){var a=[],s=[],r=e[i].data.filter((function(t,e,i){return e===i.findIndex((function(e){return e.x===t.x}))})).map((function(t,e){return {x:t.x,overlaps:[],y:[]}}));if("array"===t)for(var o=0;o<e[i].data.length;o++)Array.isArray(e[i].data[o])?(a.push(e[i].data[o][1][0]),s.push(e[i].data[o][1][1])):(a.push(e[i].data[o]),s.push(e[i].data[o]));else if("xy"===t)for(var n=function(t){var o=Array.isArray(e[i].data[t].y),n=x.randomId(),l=e[i].data[t].x,h={y1:o?e[i].data[t].y[0]:e[i].data[t].y,y2:o?e[i].data[t].y[1]:e[i].data[t].y,rangeName:n};e[i].data[t].rangeName=n;var c=r.findIndex((function(t){return t.x===l}));r[c].y.push(h),a.push(h.y1),s.push(h.y2);},l=0;l<e[i].data.length;l++)n(l);return {start:a,end:s,rangeUniques:r}}},{key:"handleCandleStickBoxDataFormat",value:function(t,e,i){var a=this.w,s="boxPlot"===a.config.chart.type||"boxPlot"===a.config.series[i].type,r=[],o=[],n=[],l=[],h=[];if("array"===t)if(s&&6===e[i].data[0].length||!s&&5===e[i].data[0].length)for(var c=0;c<e[i].data.length;c++)r.push(e[i].data[c][1]),o.push(e[i].data[c][2]),s?(n.push(e[i].data[c][3]),l.push(e[i].data[c][4]),h.push(e[i].data[c][5])):(l.push(e[i].data[c][3]),h.push(e[i].data[c][4]));else for(var d=0;d<e[i].data.length;d++)Array.isArray(e[i].data[d][1])&&(r.push(e[i].data[d][1][0]),o.push(e[i].data[d][1][1]),s?(n.push(e[i].data[d][1][2]),l.push(e[i].data[d][1][3]),h.push(e[i].data[d][1][4])):(l.push(e[i].data[d][1][2]),h.push(e[i].data[d][1][3])));else if("xy"===t)for(var g=0;g<e[i].data.length;g++)Array.isArray(e[i].data[g].y)&&(r.push(e[i].data[g].y[0]),o.push(e[i].data[g].y[1]),s?(n.push(e[i].data[g].y[2]),l.push(e[i].data[g].y[3]),h.push(e[i].data[g].y[4])):(l.push(e[i].data[g].y[2]),h.push(e[i].data[g].y[3])));return {o:r,h:o,m:n,l:l,c:h}}},{key:"parseDataAxisCharts",value:function(t){var e=this,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.ctx,a=this.w.config,s=this.w.globals,r=new A(i),o=a.labels.length>0?a.labels.slice():a.xaxis.categories.slice();s.isRangeBar="rangeBar"===a.chart.type&&s.isBarHorizontal,s.hasXaxisGroups="category"===a.xaxis.type&&a.xaxis.group.groups.length>0,s.hasXaxisGroups&&(s.groups=a.xaxis.group.groups),t.forEach((function(t,e){void 0!==t.name?s.seriesNames.push(t.name):s.seriesNames.push("series-"+parseInt(e+1,10));})),this.coreUtils.setSeriesYAxisMappings();var n=[],l=u(new Set(a.series.map((function(t){return t.group}))));a.series.forEach((function(t,e){var i=l.indexOf(t.group);n[i]||(n[i]=[]),n[i].push(s.seriesNames[e]);})),s.seriesGroups=n;for(var h=function(){for(var t=0;t<o.length;t++)if("string"==typeof o[t]){if(!r.isValidDate(o[t]))throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");e.twoDSeriesX.push(r.parseDate(o[t]));}else e.twoDSeriesX.push(o[t]);},c=0;c<t.length;c++){if(this.twoDSeries=[],this.twoDSeriesX=[],this.threeDSeries=[],void 0===t[c].data)return void console.error("It is a possibility that you may have not included 'data' property in series.");if("rangeBar"!==a.chart.type&&"rangeArea"!==a.chart.type&&"rangeBar"!==t[c].type&&"rangeArea"!==t[c].type||(s.isRangeData=!0,"rangeBar"!==a.chart.type&&"rangeArea"!==a.chart.type||this.handleRangeData(t,c)),this.isMultiFormat())this.isFormat2DArray()?this.handleFormat2DArray(t,c):this.isFormatXY()&&this.handleFormatXY(t,c),"candlestick"!==a.chart.type&&"candlestick"!==t[c].type&&"boxPlot"!==a.chart.type&&"boxPlot"!==t[c].type||this.handleCandleStickBoxData(t,c),s.series.push(this.twoDSeries),s.labels.push(this.twoDSeriesX),s.seriesX.push(this.twoDSeriesX),s.seriesGoals=this.seriesGoals,c!==this.activeSeriesIndex||this.fallbackToCategory||(s.isXNumeric=!0);else {"datetime"===a.xaxis.type?(s.isXNumeric=!0,h(),s.seriesX.push(this.twoDSeriesX)):"numeric"===a.xaxis.type&&(s.isXNumeric=!0,o.length>0&&(this.twoDSeriesX=o,s.seriesX.push(this.twoDSeriesX))),s.labels.push(this.twoDSeriesX);var d=t[c].data.map((function(t){return x.parseNumber(t)}));s.series.push(d);}s.seriesZ.push(this.threeDSeries),void 0!==t[c].color?s.seriesColors.push(t[c].color):s.seriesColors.push(void 0);}return this.w}},{key:"parseDataNonAxisCharts",value:function(t){var e=this.w.globals,i=this.w.config;e.series=t.slice(),e.seriesNames=i.labels.slice();for(var a=0;a<e.series.length;a++)void 0===e.seriesNames[a]&&e.seriesNames.push("series-"+(a+1));return this.w}},{key:"handleExternalLabelsData",value:function(t){var e=this.w.config,i=this.w.globals;if(e.xaxis.categories.length>0)i.labels=e.xaxis.categories;else if(e.labels.length>0)i.labels=e.labels.slice();else if(this.fallbackToCategory){if(i.labels=i.labels[0],i.seriesRange.length&&(i.seriesRange.map((function(t){t.forEach((function(t){i.labels.indexOf(t.x)<0&&t.x&&i.labels.push(t.x);}));})),i.labels=Array.from(new Set(i.labels.map(JSON.stringify)),JSON.parse)),e.xaxis.convertedCatToNumeric)new E(e).convertCatToNumericXaxis(e,this.ctx,i.seriesX[0]),this._generateExternalLabels(t);}else this._generateExternalLabels(t);}},{key:"_generateExternalLabels",value:function(t){var e=this.w.globals,i=this.w.config,a=[];if(e.axisCharts){if(e.series.length>0)if(this.isFormatXY())for(var s=i.series.map((function(t,e){return t.data.filter((function(t,e,i){return i.findIndex((function(e){return e.x===t.x}))===e}))})),r=s.reduce((function(t,e,i,a){return a[t].length>e.length?t:i}),0),o=0;o<s[r].length;o++)a.push(o+1);else for(var n=0;n<e.series[e.maxValsInArrayIndex].length;n++)a.push(n+1);e.seriesX=[];for(var l=0;l<t.length;l++)e.seriesX.push(a);this.w.globals.isBarHorizontal||(e.isXNumeric=!0);}if(0===a.length){a=e.axisCharts?[]:e.series.map((function(t,e){return e+1}));for(var h=0;h<t.length;h++)e.seriesX.push(a);}e.labels=a,i.xaxis.convertedCatToNumeric&&(e.categoryLabels=a.map((function(t){return i.xaxis.labels.formatter(t)}))),e.noLabelsProvided=!0;}},{key:"parseData",value:function(t){var e=this.w,i=e.config,a=e.globals;if(this.excludeCollapsedSeriesInYAxis(),this.fallbackToCategory=!1,this.ctx.core.resetGlobals(),this.ctx.core.isMultipleY(),a.axisCharts?(this.parseDataAxisCharts(t),this.coreUtils.getLargestSeries()):this.parseDataNonAxisCharts(t),i.chart.stacked){var s=new W(this.ctx);a.series=s.setNullSeriesToZeroValues(a.series);}this.coreUtils.getSeriesTotals(),a.axisCharts&&(a.stackedSeriesTotals=this.coreUtils.getStackedSeriesTotals(),a.stackedSeriesTotalsByGroups=this.coreUtils.getStackedSeriesTotalsByGroups()),this.coreUtils.getPercentSeries(),a.dataFormatXNumeric||a.isXNumeric&&("numeric"!==i.xaxis.type||0!==i.labels.length||0!==i.xaxis.categories.length)||this.handleExternalLabelsData(t);for(var r=this.coreUtils.getCategoryLabels(a.labels),o=0;o<r.length;o++)if(Array.isArray(r[o])){a.isMultiLineX=!0;break}}},{key:"excludeCollapsedSeriesInYAxis",value:function(){var t=this.w,e=[];t.globals.seriesYAxisMap.forEach((function(i,a){var s=0;i.forEach((function(e){-1!==t.globals.collapsedSeriesIndices.indexOf(e)&&s++;})),s>0&&s==i.length&&e.push(a);})),t.globals.ignoreYAxisIndexes=e.map((function(t){return t}));}}]),t}(),G=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w;}return r(t,[{key:"scaleSvgNode",value:function(t,e){var i=parseFloat(t.getAttributeNS(null,"width")),a=parseFloat(t.getAttributeNS(null,"height"));t.setAttributeNS(null,"width",i*e),t.setAttributeNS(null,"height",a*e),t.setAttributeNS(null,"viewBox","0 0 "+i+" "+a);}},{key:"fixSvgStringForIe11",value:function(t){if(!x.isIE11())return t.replace(/&nbsp;/g,"&#160;");var e=0,i=t.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g,(function(t){return 2===++e?'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.dev"':t}));return i=(i=i.replace(/xmlns:NS\d+=""/g,"")).replace(/NS\d+:(\w+:\w+=")/g,"$1")}},{key:"getSvgString",value:function(t){null==t&&(t=1);var e=this.w.globals.dom.Paper.svg();if(1!==t){var i=this.w.globals.dom.Paper.node.cloneNode(!0);this.scaleSvgNode(i,t),e=(new XMLSerializer).serializeToString(i);}return this.fixSvgStringForIe11(e)}},{key:"cleanup",value:function(){var t=this.w,e=t.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs"),i=t.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs"),a=t.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");Array.prototype.forEach.call(a,(function(t){t.setAttribute("width",0);})),e&&e[0]&&(e[0].setAttribute("x",-500),e[0].setAttribute("x1",-500),e[0].setAttribute("x2",-500)),i&&i[0]&&(i[0].setAttribute("y",-100),i[0].setAttribute("y1",-100),i[0].setAttribute("y2",-100));}},{key:"svgUrl",value:function(){this.cleanup();var t=this.getSvgString(),e=new Blob([t],{type:"image/svg+xml;charset=utf-8"});return URL.createObjectURL(e)}},{key:"dataURI",value:function(t){var e=this;return new Promise((function(i){var a=e.w,s=t?t.scale||t.width/a.globals.svgWidth:1;e.cleanup();var r=document.createElement("canvas");r.width=a.globals.svgWidth*s,r.height=parseInt(a.globals.dom.elWrap.style.height,10)*s;var o="transparent"===a.config.chart.background?"#fff":a.config.chart.background,n=r.getContext("2d");n.fillStyle=o,n.fillRect(0,0,r.width*s,r.height*s);var l=e.getSvgString(s);if(window.canvg&&x.isIE11()){var h=window.canvg.Canvg.fromString(n,l,{ignoreClear:!0,ignoreDimensions:!0});h.start();var c=r.msToBlob();h.stop(),i({blob:c});}else {var d="data:image/svg+xml,"+encodeURIComponent(l),g=new Image;g.crossOrigin="anonymous",g.onload=function(){if(n.drawImage(g,0,0),r.msToBlob){var t=r.msToBlob();i({blob:t});}else {var e=r.toDataURL("image/png");i({imgURI:e});}},g.src=d;}}))}},{key:"exportToSVG",value:function(){this.triggerDownload(this.svgUrl(),this.w.config.chart.toolbar.export.svg.filename,".svg");}},{key:"exportToPng",value:function(){var t=this;this.dataURI().then((function(e){var i=e.imgURI,a=e.blob;a?navigator.msSaveOrOpenBlob(a,t.w.globals.chartID+".png"):t.triggerDownload(i,t.w.config.chart.toolbar.export.png.filename,".png");}));}},{key:"exportToCSV",value:function(t){var e=this,i=t.series,a=t.fileName,s=t.columnDelimiter,r=void 0===s?",":s,o=t.lineDelimiter,n=void 0===o?"\n":o,l=this.w;i||(i=l.config.series);var h,c,d=[],g=[],p="",f=l.globals.series.map((function(t,e){return -1===l.globals.collapsedSeriesIndices.indexOf(e)?t:[]})),b=function(t){return "datetime"===l.config.xaxis.type&&String(t).length>=10},v=Math.max.apply(Math,u(i.map((function(t){return t.data?t.data.length:0})))),m=new B(this.ctx),y=new C(this.ctx),w=function(t){var i="";if(l.globals.axisCharts){if("category"===l.config.xaxis.type||l.config.xaxis.convertedCatToNumeric)if(l.globals.isBarHorizontal){var a=l.globals.yLabelFormatters[0],s=new W(e.ctx).getActiveConfigSeriesIndex();i=a(l.globals.labels[t],{seriesIndex:s,dataPointIndex:t,w:l});}else i=y.getLabel(l.globals.labels,l.globals.timescaleLabels,0,t).text;"datetime"===l.config.xaxis.type&&(l.config.xaxis.categories.length?i=l.config.xaxis.categories[t]:l.config.labels.length&&(i=l.config.labels[t]));}else i=l.config.labels[t];return null===i?"nullvalue":(Array.isArray(i)&&(i=i.join(" ")),x.isNumber(i)?i:i.split(r).join(""))},k=function(t,e){if(d.length&&0===e&&g.push(d.join(r)),t.data){t.data=t.data.length&&t.data||u(Array(v)).map((function(){return ""}));for(var a=0;a<t.data.length;a++){d=[];var s=w(a);if("nullvalue"!==s){if(s||(m.isFormatXY()?s=i[e].data[a].x:m.isFormat2DArray()&&(s=i[e].data[a]?i[e].data[a][0]:"")),0===e){d.push(b(s)?l.config.chart.toolbar.export.csv.dateFormatter(s):x.isNumber(s)?s:s.split(r).join(""));for(var o=0;o<l.globals.series.length;o++){var n;if(m.isFormatXY())d.push(null===(n=i[o].data[a])||void 0===n?void 0:n.y);else d.push(f[o][a]);}}("candlestick"===l.config.chart.type||t.type&&"candlestick"===t.type)&&(d.pop(),d.push(l.globals.seriesCandleO[e][a]),d.push(l.globals.seriesCandleH[e][a]),d.push(l.globals.seriesCandleL[e][a]),d.push(l.globals.seriesCandleC[e][a])),("boxPlot"===l.config.chart.type||t.type&&"boxPlot"===t.type)&&(d.pop(),d.push(l.globals.seriesCandleO[e][a]),d.push(l.globals.seriesCandleH[e][a]),d.push(l.globals.seriesCandleM[e][a]),d.push(l.globals.seriesCandleL[e][a]),d.push(l.globals.seriesCandleC[e][a])),"rangeBar"===l.config.chart.type&&(d.pop(),d.push(l.globals.seriesRangeStart[e][a]),d.push(l.globals.seriesRangeEnd[e][a])),d.length&&g.push(d.join(r));}}}};d.push(l.config.chart.toolbar.export.csv.headerCategory),"boxPlot"===l.config.chart.type?(d.push("minimum"),d.push("q1"),d.push("median"),d.push("q3"),d.push("maximum")):"candlestick"===l.config.chart.type?(d.push("open"),d.push("high"),d.push("low"),d.push("close")):"rangeBar"===l.config.chart.type?(d.push("minimum"),d.push("maximum")):i.map((function(t,e){var i=(t.name?t.name:"series-".concat(e))+"";l.globals.axisCharts&&d.push(i.split(r).join("")?i.split(r).join(""):"series-".concat(e));})),l.globals.axisCharts||(d.push(l.config.chart.toolbar.export.csv.headerValue),g.push(d.join(r))),l.globals.allSeriesHasEqualX||!l.globals.axisCharts||l.config.xaxis.categories.length||l.config.labels.length?i.map((function(t,e){l.globals.axisCharts?k(t,e):((d=[]).push(l.globals.labels[e].split(r).join("")),d.push(f[e]),g.push(d.join(r)));})):(h=new Set,c={},i.forEach((function(t,e){null==t||t.data.forEach((function(t){var a,s;if(m.isFormatXY())a=t.x,s=t.y;else {if(!m.isFormat2DArray())return;a=t[0],s=t[1];}c[a]||(c[a]=Array(i.length).fill("")),c[a][e]=s,h.add(a);}));})),d.length&&g.push(d.join(r)),Array.from(h).sort().forEach((function(t){g.push([b(t)&&"datetime"===l.config.xaxis.type?l.config.chart.toolbar.export.csv.dateFormatter(t):x.isNumber(t)?t:t.split(r).join(""),c[t].join(r)]);}))),p+=g.join(n),this.triggerDownload("data:text/csv; charset=utf-8,"+encodeURIComponent("\ufeff"+p),a||l.config.chart.toolbar.export.csv.filename,".csv");}},{key:"triggerDownload",value:function(t,e,i){var a=document.createElement("a");a.href=t,a.download=(e||this.w.globals.chartID)+i,document.body.appendChild(a),a.click(),document.body.removeChild(a);}}]),t}(),V=function(){function t(e,i){a(this,t),this.ctx=e,this.elgrid=i,this.w=e.w;var s=this.w;this.axesUtils=new C(e),this.xaxisLabels=s.globals.labels.slice(),s.globals.timescaleLabels.length>0&&!s.globals.isBarHorizontal&&(this.xaxisLabels=s.globals.timescaleLabels.slice()),s.config.xaxis.overwriteCategories&&(this.xaxisLabels=s.config.xaxis.overwriteCategories),this.drawnLabels=[],this.drawnLabelsRects=[],"top"===s.config.xaxis.position?this.offY=0:this.offY=s.globals.gridHeight,this.offY=this.offY+s.config.xaxis.axisBorder.offsetY,this.isCategoryBarHorizontal="bar"===s.config.chart.type&&s.config.plotOptions.bar.horizontal,this.xaxisFontSize=s.config.xaxis.labels.style.fontSize,this.xaxisFontFamily=s.config.xaxis.labels.style.fontFamily,this.xaxisForeColors=s.config.xaxis.labels.style.colors,this.xaxisBorderWidth=s.config.xaxis.axisBorder.width,this.isCategoryBarHorizontal&&(this.xaxisBorderWidth=s.config.yaxis[0].axisBorder.width.toString()),this.xaxisBorderWidth.indexOf("%")>-1?this.xaxisBorderWidth=s.globals.gridWidth*parseInt(this.xaxisBorderWidth,10)/100:this.xaxisBorderWidth=parseInt(this.xaxisBorderWidth,10),this.xaxisBorderHeight=s.config.xaxis.axisBorder.height,this.yaxis=s.config.yaxis[0];}return r(t,[{key:"drawXaxis",value:function(){var t=this.w,e=new m(this.ctx),i=e.group({class:"apexcharts-xaxis",transform:"translate(".concat(t.config.xaxis.offsetX,", ").concat(t.config.xaxis.offsetY,")")}),a=e.group({class:"apexcharts-xaxis-texts-g",transform:"translate(".concat(t.globals.translateXAxisX,", ").concat(t.globals.translateXAxisY,")")});i.add(a);for(var s=[],r=0;r<this.xaxisLabels.length;r++)s.push(this.xaxisLabels[r]);if(this.drawXAxisLabelAndGroup(!0,e,a,s,t.globals.isXNumeric,(function(t,e){return e})),t.globals.hasXaxisGroups){var o=t.globals.groups;s=[];for(var n=0;n<o.length;n++)s.push(o[n].title);var l={};t.config.xaxis.group.style&&(l.xaxisFontSize=t.config.xaxis.group.style.fontSize,l.xaxisFontFamily=t.config.xaxis.group.style.fontFamily,l.xaxisForeColors=t.config.xaxis.group.style.colors,l.fontWeight=t.config.xaxis.group.style.fontWeight,l.cssClass=t.config.xaxis.group.style.cssClass),this.drawXAxisLabelAndGroup(!1,e,a,s,!1,(function(t,e){return o[t].cols*e}),l);}if(void 0!==t.config.xaxis.title.text){var h=e.group({class:"apexcharts-xaxis-title"}),c=e.drawText({x:t.globals.gridWidth/2+t.config.xaxis.title.offsetX,y:this.offY+parseFloat(this.xaxisFontSize)+("bottom"===t.config.xaxis.position?t.globals.xAxisLabelsHeight:-t.globals.xAxisLabelsHeight-10)+t.config.xaxis.title.offsetY,text:t.config.xaxis.title.text,textAnchor:"middle",fontSize:t.config.xaxis.title.style.fontSize,fontFamily:t.config.xaxis.title.style.fontFamily,fontWeight:t.config.xaxis.title.style.fontWeight,foreColor:t.config.xaxis.title.style.color,cssClass:"apexcharts-xaxis-title-text "+t.config.xaxis.title.style.cssClass});h.add(c),i.add(h);}if(t.config.xaxis.axisBorder.show){var d=t.globals.barPadForNumericAxis,g=e.drawLine(t.globals.padHorizontal+t.config.xaxis.axisBorder.offsetX-d,this.offY,this.xaxisBorderWidth+d,this.offY,t.config.xaxis.axisBorder.color,0,this.xaxisBorderHeight);this.elgrid&&this.elgrid.elGridBorders&&t.config.grid.show?this.elgrid.elGridBorders.add(g):i.add(g);}return i}},{key:"drawXAxisLabelAndGroup",value:function(t,e,i,a,s,r){var o,n=this,l=arguments.length>6&&void 0!==arguments[6]?arguments[6]:{},h=[],c=[],d=this.w,g=l.xaxisFontSize||this.xaxisFontSize,u=l.xaxisFontFamily||this.xaxisFontFamily,p=l.xaxisForeColors||this.xaxisForeColors,f=l.fontWeight||d.config.xaxis.labels.style.fontWeight,x=l.cssClass||d.config.xaxis.labels.style.cssClass,b=d.globals.padHorizontal,v=a.length,m="category"===d.config.xaxis.type?d.globals.dataPoints:v;if(0===m&&v>m&&(m=v),s){var y=m>1?m-1:m;o=d.globals.gridWidth/Math.min(y,v-1),b=b+r(0,o)/2+d.config.xaxis.labels.offsetX;}else o=d.globals.gridWidth/m,b=b+r(0,o)+d.config.xaxis.labels.offsetX;for(var w=function(s){var l=b-r(s,o)/2+d.config.xaxis.labels.offsetX;0===s&&1===v&&o/2===b&&1===m&&(l=d.globals.gridWidth/2);var y=n.axesUtils.getLabel(a,d.globals.timescaleLabels,l,s,h,g,t),w=28;d.globals.rotateXLabels&&t&&(w=22),d.config.xaxis.title.text&&"top"===d.config.xaxis.position&&(w+=parseFloat(d.config.xaxis.title.style.fontSize)+2),t||(w=w+parseFloat(g)+(d.globals.xAxisLabelsHeight-d.globals.xAxisGroupLabelsHeight)+(d.globals.rotateXLabels?10:0)),y=void 0!==d.config.xaxis.tickAmount&&"dataPoints"!==d.config.xaxis.tickAmount&&"datetime"!==d.config.xaxis.type?n.axesUtils.checkLabelBasedOnTickamount(s,y,v):n.axesUtils.checkForOverflowingLabels(s,y,v,h,c);if(d.config.xaxis.labels.show){var k=e.drawText({x:y.x,y:n.offY+d.config.xaxis.labels.offsetY+w-("top"===d.config.xaxis.position?d.globals.xAxisHeight+d.config.xaxis.axisTicks.height-2:0),text:y.text,textAnchor:"middle",fontWeight:y.isBold?600:f,fontSize:g,fontFamily:u,foreColor:Array.isArray(p)?t&&d.config.xaxis.convertedCatToNumeric?p[d.globals.minX+s-1]:p[s]:p,isPlainText:!1,cssClass:(t?"apexcharts-xaxis-label ":"apexcharts-xaxis-group-label ")+x});if(i.add(k),k.on("click",(function(t){if("function"==typeof d.config.chart.events.xAxisLabelClick){var e=Object.assign({},d,{labelIndex:s});d.config.chart.events.xAxisLabelClick(t,n.ctx,e);}})),t){var A=document.createElementNS(d.globals.SVGNS,"title");A.textContent=Array.isArray(y.text)?y.text.join(" "):y.text,k.node.appendChild(A),""!==y.text&&(h.push(y.text),c.push(y));}}s<v-1&&(b+=r(s+1,o));},k=0;k<=v-1;k++)w(k);}},{key:"drawXaxisInversed",value:function(t){var e,i,a=this,s=this.w,r=new m(this.ctx),o=s.config.yaxis[0].opposite?s.globals.translateYAxisX[t]:0,n=r.group({class:"apexcharts-yaxis apexcharts-xaxis-inversed",rel:t}),l=r.group({class:"apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g",transform:"translate("+o+", 0)"});n.add(l);var h=[];if(s.config.yaxis[t].show)for(var c=0;c<this.xaxisLabels.length;c++)h.push(this.xaxisLabels[c]);e=s.globals.gridHeight/h.length,i=-e/2.2;var d=s.globals.yLabelFormatters[0],g=s.config.yaxis[0].labels;if(g.show)for(var u=function(o){var n=void 0===h[o]?"":h[o];n=d(n,{seriesIndex:t,dataPointIndex:o,w:s});var c=a.axesUtils.getYAxisForeColor(g.style.colors,t),u=0;Array.isArray(n)&&(u=n.length/2*parseInt(g.style.fontSize,10));var p=g.offsetX-15,f="end";a.yaxis.opposite&&(f="start"),"left"===s.config.yaxis[0].labels.align?(p=g.offsetX,f="start"):"center"===s.config.yaxis[0].labels.align?(p=g.offsetX,f="middle"):"right"===s.config.yaxis[0].labels.align&&(f="end");var x=r.drawText({x:p,y:i+e+g.offsetY-u,text:n,textAnchor:f,foreColor:Array.isArray(c)?c[o]:c,fontSize:g.style.fontSize,fontFamily:g.style.fontFamily,fontWeight:g.style.fontWeight,isPlainText:!1,cssClass:"apexcharts-yaxis-label "+g.style.cssClass,maxWidth:g.maxWidth});l.add(x),x.on("click",(function(t){if("function"==typeof s.config.chart.events.xAxisLabelClick){var e=Object.assign({},s,{labelIndex:o});s.config.chart.events.xAxisLabelClick(t,a.ctx,e);}}));var b=document.createElementNS(s.globals.SVGNS,"title");if(b.textContent=Array.isArray(n)?n.join(" "):n,x.node.appendChild(b),0!==s.config.yaxis[t].labels.rotate){var v=r.rotateAroundCenter(x.node);x.node.setAttribute("transform","rotate(".concat(s.config.yaxis[t].labels.rotate," 0 ").concat(v.y,")"));}i+=e;},p=0;p<=h.length-1;p++)u(p);if(void 0!==s.config.yaxis[0].title.text){var f=r.group({class:"apexcharts-yaxis-title apexcharts-xaxis-title-inversed",transform:"translate("+o+", 0)"}),x=r.drawText({x:s.config.yaxis[0].title.offsetX,y:s.globals.gridHeight/2+s.config.yaxis[0].title.offsetY,text:s.config.yaxis[0].title.text,textAnchor:"middle",foreColor:s.config.yaxis[0].title.style.color,fontSize:s.config.yaxis[0].title.style.fontSize,fontWeight:s.config.yaxis[0].title.style.fontWeight,fontFamily:s.config.yaxis[0].title.style.fontFamily,cssClass:"apexcharts-yaxis-title-text "+s.config.yaxis[0].title.style.cssClass});f.add(x),n.add(f);}var b=0;this.isCategoryBarHorizontal&&s.config.yaxis[0].opposite&&(b=s.globals.gridWidth);var v=s.config.xaxis.axisBorder;if(v.show){var y=r.drawLine(s.globals.padHorizontal+v.offsetX+b,1+v.offsetY,s.globals.padHorizontal+v.offsetX+b,s.globals.gridHeight+v.offsetY,v.color,0);this.elgrid&&this.elgrid.elGridBorders&&s.config.grid.show?this.elgrid.elGridBorders.add(y):n.add(y);}return s.config.yaxis[0].axisTicks.show&&this.axesUtils.drawYAxisTicks(b,h.length,s.config.yaxis[0].axisBorder,s.config.yaxis[0].axisTicks,0,e,n),n}},{key:"drawXaxisTicks",value:function(t,e,i){var a=this.w,s=t;if(!(t<0||t-2>a.globals.gridWidth)){var r=this.offY+a.config.xaxis.axisTicks.offsetY;if(e=e+r+a.config.xaxis.axisTicks.height,"top"===a.config.xaxis.position&&(e=r-a.config.xaxis.axisTicks.height),a.config.xaxis.axisTicks.show){var o=new m(this.ctx).drawLine(t+a.config.xaxis.axisTicks.offsetX,r+a.config.xaxis.offsetY,s+a.config.xaxis.axisTicks.offsetX,e+a.config.xaxis.offsetY,a.config.xaxis.axisTicks.color);i.add(o),o.node.classList.add("apexcharts-xaxis-tick");}}}},{key:"getXAxisTicksPositions",value:function(){var t=this.w,e=[],i=this.xaxisLabels.length,a=t.globals.padHorizontal;if(t.globals.timescaleLabels.length>0)for(var s=0;s<i;s++)a=this.xaxisLabels[s].position,e.push(a);else for(var r=i,o=0;o<r;o++){var n=r;t.globals.isXNumeric&&"bar"!==t.config.chart.type&&(n-=1),a+=t.globals.gridWidth/n,e.push(a);}return e}},{key:"xAxisLabelCorrections",value:function(){var t=this.w,e=new m(this.ctx),i=t.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"),a=t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"),s=t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"),r=t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");if(t.globals.rotateXLabels||t.config.xaxis.labels.rotateAlways)for(var o=0;o<a.length;o++){var n=e.rotateAroundCenter(a[o]);n.y=n.y-1,n.x=n.x+1,a[o].setAttribute("transform","rotate(".concat(t.config.xaxis.labels.rotate," ").concat(n.x," ").concat(n.y,")")),a[o].setAttribute("text-anchor","end");i.setAttribute("transform","translate(0, ".concat(-10,")"));var l=a[o].childNodes;t.config.xaxis.labels.trim&&Array.prototype.forEach.call(l,(function(i){e.placeTextWithEllipsis(i,i.textContent,t.globals.xAxisLabelsHeight-("bottom"===t.config.legend.position?20:10));}));}else !function(){for(var i=t.globals.gridWidth/(t.globals.labels.length+1),s=0;s<a.length;s++){var r=a[s].childNodes;t.config.xaxis.labels.trim&&"datetime"!==t.config.xaxis.type&&Array.prototype.forEach.call(r,(function(t){e.placeTextWithEllipsis(t,t.textContent,i);}));}}();if(s.length>0){var h=s[s.length-1].getBBox(),c=s[0].getBBox();h.x<-20&&s[s.length-1].parentNode.removeChild(s[s.length-1]),c.x+c.width>t.globals.gridWidth&&!t.globals.isBarHorizontal&&s[0].parentNode.removeChild(s[0]);for(var d=0;d<r.length;d++)e.placeTextWithEllipsis(r[d],r[d].textContent,t.config.yaxis[0].labels.maxWidth-(t.config.yaxis[0].title.text?2*parseFloat(t.config.yaxis[0].title.style.fontSize):0)-15);}}}]),t}(),j=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w;var i=this.w;this.xaxisLabels=i.globals.labels.slice(),this.axesUtils=new C(e),this.isRangeBar=i.globals.seriesRange.length&&i.globals.isBarHorizontal,i.globals.timescaleLabels.length>0&&(this.xaxisLabels=i.globals.timescaleLabels.slice());}return r(t,[{key:"drawGridArea",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,e=this.w,i=new m(this.ctx);null===t&&(t=i.group({class:"apexcharts-grid"}));var a=i.drawLine(e.globals.padHorizontal,1,e.globals.padHorizontal,e.globals.gridHeight,"transparent"),s=i.drawLine(e.globals.padHorizontal,e.globals.gridHeight,e.globals.gridWidth,e.globals.gridHeight,"transparent");return t.add(s),t.add(a),t}},{key:"drawGrid",value:function(){var t=null;return this.w.globals.axisCharts&&(t=this.renderGrid(),this.drawGridArea(t.el)),t}},{key:"createGridMask",value:function(){var t=this.w,e=t.globals,i=new m(this.ctx),a=Array.isArray(t.config.stroke.width)?0:t.config.stroke.width;if(Array.isArray(t.config.stroke.width)){var s=0;t.config.stroke.width.forEach((function(t){s=Math.max(s,t);})),a=s;}e.dom.elGridRectMask=document.createElementNS(e.SVGNS,"clipPath"),e.dom.elGridRectMask.setAttribute("id","gridRectMask".concat(e.cuid)),e.dom.elGridRectMarkerMask=document.createElementNS(e.SVGNS,"clipPath"),e.dom.elGridRectMarkerMask.setAttribute("id","gridRectMarkerMask".concat(e.cuid)),e.dom.elForecastMask=document.createElementNS(e.SVGNS,"clipPath"),e.dom.elForecastMask.setAttribute("id","forecastMask".concat(e.cuid)),e.dom.elNonForecastMask=document.createElementNS(e.SVGNS,"clipPath"),e.dom.elNonForecastMask.setAttribute("id","nonForecastMask".concat(e.cuid));var r=t.config.chart.type,o=0,n=0;("bar"===r||"rangeBar"===r||"candlestick"===r||"boxPlot"===r||t.globals.comboBarCount>0)&&t.globals.isXNumeric&&!t.globals.isBarHorizontal&&(o=t.config.grid.padding.left,n=t.config.grid.padding.right,e.barPadForNumericAxis>o&&(o=e.barPadForNumericAxis,n=e.barPadForNumericAxis)),e.dom.elGridRect=i.drawRect(-a/2-o-2,-a/2-2,e.gridWidth+a+n+o+4,e.gridHeight+a+4,0,"#fff");var l=t.globals.markers.largestSize+1;e.dom.elGridRectMarker=i.drawRect(2*-l,2*-l,e.gridWidth+4*l,e.gridHeight+4*l,0,"#fff"),e.dom.elGridRectMask.appendChild(e.dom.elGridRect.node),e.dom.elGridRectMarkerMask.appendChild(e.dom.elGridRectMarker.node);var h=e.dom.baseEl.querySelector("defs");h.appendChild(e.dom.elGridRectMask),h.appendChild(e.dom.elForecastMask),h.appendChild(e.dom.elNonForecastMask),h.appendChild(e.dom.elGridRectMarkerMask);}},{key:"_drawGridLines",value:function(t){var e=t.i,i=t.x1,a=t.y1,s=t.x2,r=t.y2,o=t.xCount,n=t.parent,l=this.w;if(!(0===e&&l.globals.skipFirstTimelinelabel||e===o-1&&l.globals.skipLastTimelinelabel&&!l.config.xaxis.labels.formatter||"radar"===l.config.chart.type)){l.config.grid.xaxis.lines.show&&this._drawGridLine({i:e,x1:i,y1:a,x2:s,y2:r,xCount:o,parent:n});var h=0;if(l.globals.hasXaxisGroups&&"between"===l.config.xaxis.tickPlacement){var c=l.globals.groups;if(c){for(var d=0,g=0;d<e&&g<c.length;g++)d+=c[g].cols;d===e&&(h=.6*l.globals.xAxisLabelsHeight);}}new V(this.ctx).drawXaxisTicks(i,h,l.globals.dom.elGraphical);}}},{key:"_drawGridLine",value:function(t){var e=t.i,i=t.x1,a=t.y1,s=t.x2,r=t.y2,o=t.xCount,n=t.parent,l=this.w,h=!1,c=n.node.classList.contains("apexcharts-gridlines-horizontal"),d=l.config.grid.strokeDashArray,g=l.globals.barPadForNumericAxis;(0===a&&0===r||0===i&&0===s)&&(h=!0),a===l.globals.gridHeight&&r===l.globals.gridHeight&&(h=!0),!l.globals.isBarHorizontal||0!==e&&e!==o-1||(h=!0);var u=new m(this).drawLine(i-(c?g:0),a,s+(c?g:0),r,l.config.grid.borderColor,d);u.node.classList.add("apexcharts-gridline"),h&&l.config.grid.show?this.elGridBorders.add(u):n.add(u);}},{key:"_drawGridBandRect",value:function(t){var e=t.c,i=t.x1,a=t.y1,s=t.x2,r=t.y2,o=t.type,n=this.w,l=new m(this.ctx),h=n.globals.barPadForNumericAxis;if("column"!==o||"datetime"!==n.config.xaxis.type){var c=n.config.grid[o].colors[e],d=l.drawRect(i-("row"===o?h:0),a,s+("row"===o?2*h:0),r,0,c,n.config.grid[o].opacity);this.elg.add(d),d.attr("clip-path","url(#gridRectMask".concat(n.globals.cuid,")")),d.node.classList.add("apexcharts-grid-".concat(o));}}},{key:"_drawXYLines",value:function(t){var e=this,i=t.xCount,a=t.tickAmount,s=this.w;if(s.config.grid.xaxis.lines.show||s.config.xaxis.axisTicks.show){var r,o=s.globals.padHorizontal,n=s.globals.gridHeight;s.globals.timescaleLabels.length?function(t){for(var a=t.xC,s=t.x1,r=t.y1,o=t.x2,n=t.y2,l=0;l<a;l++)s=e.xaxisLabels[l].position,o=e.xaxisLabels[l].position,e._drawGridLines({i:l,x1:s,y1:r,x2:o,y2:n,xCount:i,parent:e.elgridLinesV});}({xC:i,x1:o,y1:0,x2:r,y2:n}):(s.globals.isXNumeric&&(i=s.globals.xAxisScale.result.length),function(t){for(var a=t.xC,r=t.x1,o=t.y1,n=t.x2,l=t.y2,h=0;h<a+(s.globals.isXNumeric?0:1);h++)0===h&&1===a&&1===s.globals.dataPoints&&(n=r=s.globals.gridWidth/2),e._drawGridLines({i:h,x1:r,y1:o,x2:n,y2:l,xCount:i,parent:e.elgridLinesV}),n=r+=s.globals.gridWidth/(s.globals.isXNumeric?a-1:a);}({xC:i,x1:o,y1:0,x2:r,y2:n}));}if(s.config.grid.yaxis.lines.show){var l=0,h=0,c=s.globals.gridWidth,d=a+1;this.isRangeBar&&(d=s.globals.labels.length);for(var g=0;g<d+(this.isRangeBar?1:0);g++)this._drawGridLine({i:g,xCount:d+(this.isRangeBar?1:0),x1:0,y1:l,x2:c,y2:h,parent:this.elgridLinesH}),h=l+=s.globals.gridHeight/(this.isRangeBar?d:a);}}},{key:"_drawInvertedXYLines",value:function(t){var e=t.xCount,i=this.w;if(i.config.grid.xaxis.lines.show||i.config.xaxis.axisTicks.show)for(var a,s=i.globals.padHorizontal,r=i.globals.gridHeight,o=0;o<e+1;o++){i.config.grid.xaxis.lines.show&&this._drawGridLine({i:o,xCount:e+1,x1:s,y1:0,x2:a,y2:r,parent:this.elgridLinesV}),new V(this.ctx).drawXaxisTicks(s,0,i.globals.dom.elGraphical),a=s+=i.globals.gridWidth/e;}if(i.config.grid.yaxis.lines.show)for(var n=0,l=0,h=i.globals.gridWidth,c=0;c<i.globals.dataPoints+1;c++)this._drawGridLine({i:c,xCount:i.globals.dataPoints+1,x1:0,y1:n,x2:h,y2:l,parent:this.elgridLinesH}),l=n+=i.globals.gridHeight/i.globals.dataPoints;}},{key:"renderGrid",value:function(){var t=this.w,e=t.globals,i=new m(this.ctx);this.elg=i.group({class:"apexcharts-grid"}),this.elgridLinesH=i.group({class:"apexcharts-gridlines-horizontal"}),this.elgridLinesV=i.group({class:"apexcharts-gridlines-vertical"}),this.elGridBorders=i.group({class:"apexcharts-grid-borders"}),this.elg.add(this.elgridLinesH),this.elg.add(this.elgridLinesV),t.config.grid.show||(this.elgridLinesV.hide(),this.elgridLinesH.hide(),this.elGridBorders.hide());for(var a=0;a<e.seriesYAxisMap.length&&-1!==e.ignoreYAxisIndexes.indexOf(a);)a++;a===e.seriesYAxisMap.length&&(a=0);var s,r=e.yAxisScale[a].result.length-1;if(!e.isBarHorizontal||this.isRangeBar){var o,n,l;if(s=this.xaxisLabels.length,this.isRangeBar)r=e.labels.length,t.config.xaxis.tickAmount&&t.config.xaxis.labels.formatter&&(s=t.config.xaxis.tickAmount),(null===(o=e.yAxisScale)||void 0===o||null===(n=o[a])||void 0===n||null===(l=n.result)||void 0===l?void 0:l.length)>0&&"datetime"!==t.config.xaxis.type&&(s=e.yAxisScale[a].result.length-1);this._drawXYLines({xCount:s,tickAmount:r});}else s=r,r=e.xTickAmount,this._drawInvertedXYLines({xCount:s,tickAmount:r});return this.drawGridBands(s,r),{el:this.elg,elGridBorders:this.elGridBorders,xAxisTickWidth:e.gridWidth/s}}},{key:"drawGridBands",value:function(t,e){var i=this.w;if(void 0!==i.config.grid.row.colors&&i.config.grid.row.colors.length>0)for(var a=0,s=i.globals.gridHeight/e,r=i.globals.gridWidth,o=0,n=0;o<e;o++,n++)n>=i.config.grid.row.colors.length&&(n=0),this._drawGridBandRect({c:n,x1:0,y1:a,x2:r,y2:s,type:"row"}),a+=i.globals.gridHeight/e;if(void 0!==i.config.grid.column.colors&&i.config.grid.column.colors.length>0)for(var l=i.globals.isBarHorizontal||"on"!==i.config.xaxis.tickPlacement||"category"!==i.config.xaxis.type&&!i.config.xaxis.convertedCatToNumeric?t:t-1,h=i.globals.padHorizontal,c=i.globals.padHorizontal+i.globals.gridWidth/l,d=i.globals.gridHeight,g=0,u=0;g<t;g++,u++)u>=i.config.grid.column.colors.length&&(u=0),this._drawGridBandRect({c:u,x1:h,y1:0,x2:c,y2:d,type:"column"}),h+=i.globals.gridWidth/l;}}]),t}(),_=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w;}return r(t,[{key:"niceScale",value:function(t,e){var i,a,s,r,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,n=1e-11,l=this.w,h=l.globals;h.isBarHorizontal?(i=l.config.xaxis,a=Math.max((h.svgWidth-100)/25,2)):(i=l.config.yaxis[o],a=Math.max((h.svgHeight-100)/15,2)),s=void 0!==i.min&&null!==i.min,r=void 0!==i.max&&null!==i.min;var c=void 0!==i.stepSize&&null!==i.stepSize,d=void 0!==i.tickAmount&&null!==i.tickAmount,g=d?i.tickAmount:i.forceNiceScale?h.niceScaleDefaultTicks[Math.min(Math.round(a/2),h.niceScaleDefaultTicks.length-1)]:10;if(h.isMultipleYAxis&&!d&&h.multiAxisTickAmount>0&&(g=h.multiAxisTickAmount,d=!0),g="dataPoints"===g?h.dataPoints-1:Math.abs(Math.round(g)),(t===Number.MIN_VALUE&&0===e||!x.isNumber(t)&&!x.isNumber(e)||t===Number.MIN_VALUE&&e===-Number.MAX_VALUE)&&(t=x.isNumber(i.min)?i.min:0,e=x.isNumber(i.max)?i.max:t+g,h.allSeriesCollapsed=!1),t>e){console.warn("axis.min cannot be greater than axis.max: swapping min and max");var u=e;e=t,t=u;}else t===e&&(t=0===t?0:t-1,e=0===e?2:e+1);var p=[];g<1&&(g=1);var f=g,b=Math.abs(e-t);if(i.forceNiceScale){!s&&t>0&&t/b<.15&&(t=0,s=!0),!r&&e<0&&-e/b<.15&&(e=0,r=!0),b=Math.abs(e-t);}var v=b/f,m=v,y=Math.floor(Math.log10(m)),w=Math.pow(10,y),k=Math.ceil(m/w);if(v=m=(k=h.niceScaleAllowedMagMsd[0===h.yValueDecimal?0:1][k])*w,h.isBarHorizontal&&i.stepSize&&"datetime"!==i.type?(v=i.stepSize,c=!0):c&&(v=i.stepSize),c&&i.forceNiceScale){var A=Math.floor(Math.log10(v));v*=Math.pow(10,y-A);}if(s&&r){var S=b/f;if(d)if(c)if(0!=x.mod(b,v)){var C=x.getGCD(v,S);v=S/C<10?C:S;}else 0==x.mod(v,S)?v=S:(S=v,d=!1);else v=S;else if(c)0==x.mod(b,v)?S=v:v=S;else if(0==x.mod(b,v))S=v;else {S=b/(f=Math.ceil(b/v));var L=x.getGCD(b,v);b/L<a&&(S=L),v=S;}f=Math.round(b/v);}else {if(s||r){if(r)if(d)t=e-v*f;else {var P=t;t=v*Math.floor(t/v),Math.abs(e-t)/x.getGCD(b,v)>a&&(t=e-v*g,t+=v*Math.floor((P-t)/v));}else if(s)if(d)e=t+v*f;else {var M=e;e=v*Math.ceil(e/v),Math.abs(e-t)/x.getGCD(b,v)>a&&(e=t+v*g,e+=v*Math.ceil((M-e)/v));}}else if(d){var I=v/(e-t>e?1:2),T=I*Math.floor(t/I);Math.abs(T-t)<=I/2?e=(t=T)+v*f:t=(e=I*Math.ceil(e/I))-v*f;}else t=v*Math.floor(t/v),e=v*Math.ceil(e/v);b=Math.abs(e-t),v=x.getGCD(b,v),f=Math.round(b/v);}if(d||s||r||(f=Math.ceil((b-n)/(v+n)))>16&&x.getPrimeFactors(f).length<2&&f++,!d&&i.forceNiceScale&&0===h.yValueDecimal&&f>b&&(f=b,v=Math.round(b/f)),f>a&&(!d&&!c||i.forceNiceScale)){var z=x.getPrimeFactors(f),X=z.length-1,E=f;t:for(var Y=0;Y<X;Y++)for(var F=0;F<=X-Y;F++){for(var R=Math.min(F+Y,X),H=E,D=1,O=F;O<=R;O++)D*=z[O];if((H/=D)<a){E=H;break t}}v=E===f?b:b/E,f=Math.round(b/v);}h.isMultipleYAxis&&0==h.multiAxisTickAmount&&h.ignoreYAxisIndexes.indexOf(o)<0&&(h.multiAxisTickAmount=f);var N=t-v,W=v*n;do{N+=v,p.push(x.stripNumber(N,7));}while(e-N>W);return {result:p,niceMin:p[0],niceMax:p[p.length-1]}}},{key:"linearScale",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:10,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0,r=Math.abs(e-t);"dataPoints"===(i=this._adjustTicksForSmallRange(i,a,r))&&(i=this.w.globals.dataPoints-1),s||(s=r/i),i===Number.MAX_VALUE&&(i=5,s=1);for(var o=[],n=t;i>=0;)o.push(n),n+=s,i-=1;return {result:o,niceMin:o[0],niceMax:o[o.length-1]}}},{key:"logarithmicScaleNice",value:function(t,e,i){e<=0&&(e=Math.max(t,i)),t<=0&&(t=Math.min(e,i));for(var a=[],s=Math.ceil(Math.log(e)/Math.log(i)+1),r=Math.floor(Math.log(t)/Math.log(i));r<s;r++)a.push(Math.pow(i,r));return {result:a,niceMin:a[0],niceMax:a[a.length-1]}}},{key:"logarithmicScale",value:function(t,e,i){e<=0&&(e=Math.max(t,i)),t<=0&&(t=Math.min(e,i));for(var a=[],s=Math.log(e)/Math.log(i),r=Math.log(t)/Math.log(i),o=s-r,n=Math.round(o),l=o/n,h=0,c=r;h<n;h++,c+=l)a.push(Math.pow(i,c));return a.push(Math.pow(i,s)),{result:a,niceMin:t,niceMax:e}}},{key:"_adjustTicksForSmallRange",value:function(t,e,i){var a=t;if(void 0!==e&&this.w.config.yaxis[e].labels.formatter&&void 0===this.w.config.yaxis[e].tickAmount){var s=Number(this.w.config.yaxis[e].labels.formatter(1));x.isNumber(s)&&0===this.w.globals.yValueDecimal&&(a=Math.ceil(i));}return a<t?a:t}},{key:"setYScaleForIndex",value:function(t,e,i){var a=this.w.globals,s=this.w.config,r=a.isBarHorizontal?s.xaxis:s.yaxis[t];void 0===a.yAxisScale[t]&&(a.yAxisScale[t]=[]);var o=Math.abs(i-e);r.logarithmic&&o<=5&&(a.invalidLogScale=!0),r.logarithmic&&o>5?(a.allSeriesCollapsed=!1,a.yAxisScale[t]=r.forceNiceScale?this.logarithmicScaleNice(e,i,r.logBase):this.logarithmicScale(e,i,r.logBase)):i!==-Number.MAX_VALUE&&x.isNumber(i)&&e!==Number.MAX_VALUE&&x.isNumber(e)?(a.allSeriesCollapsed=!1,a.yAxisScale[t]=this.niceScale(e,i,t)):a.yAxisScale[t]=this.niceScale(Number.MIN_VALUE,0,t);}},{key:"setXScale",value:function(t,e){var i=this.w,a=i.globals,s=Math.abs(e-t);return e!==-Number.MAX_VALUE&&x.isNumber(e)?a.xAxisScale=this.linearScale(t,e,i.config.xaxis.tickAmount?i.config.xaxis.tickAmount:s<10&&s>1?s+1:10,0,i.config.xaxis.stepSize):a.xAxisScale=this.linearScale(0,10,10),a.xAxisScale}},{key:"setSeriesYAxisMappings",value:function(){var t=this.w.globals,e=this.w.config;t.minYArr,t.maxYArr;var i=[],a=[],s=[],r=t.series.length>e.yaxis.length||e.yaxis.some((function(t){return Array.isArray(t.seriesName)}));e.series.forEach((function(t,e){s.push(e),a.push(null);})),e.yaxis.forEach((function(t,e){i[e]=[];}));var o=[];e.yaxis.forEach((function(t,a){var n=!1;if(t.seriesName){var l=[];Array.isArray(t.seriesName)?l=t.seriesName:l.push(t.seriesName),l.forEach((function(t){e.series.forEach((function(e,o){if(e.name===t){var l=o;a===o||r?!r||s.indexOf(o)>-1?i[a].push([a,o]):console.warn("Series '"+e.name+"' referenced more than once in what looks like the new style. That is, when using either seriesName: [], or when there are more series than yaxes."):(i[o].push([o,a]),l=a),n=!0,-1!==(l=s.indexOf(l))&&s.splice(l,1);}}));}));}n||o.push(a);})),i=i.map((function(t,e){var i=[];return t.forEach((function(t){a[t[1]]=t[0],i.push(t[1]);})),i}));for(var n=e.yaxis.length-1,l=0;l<o.length&&(n=o[l],i[n]=[],s);l++){var h=s[0];s.shift(),i[n].push(h),a[h]=n;}s.forEach((function(t){i[n].push(t),a[t]=n;})),t.seriesYAxisMap=i.map((function(t){return t})),t.seriesYAxisReverseMap=a.map((function(t){return t}));}},{key:"scaleMultipleYAxes",value:function(){var t=this,e=this.w.config,i=this.w.globals;this.setSeriesYAxisMappings();var a=i.seriesYAxisMap,s=i.minYArr,r=i.maxYArr;i.allSeriesCollapsed=!0,i.barGroups=[],a.forEach((function(a,o){var n=[];a.forEach((function(t){var i=e.series[t].group;n.indexOf(i)<0&&n.push(i);})),a.length>0?function(){var l,h,c=Number.MAX_VALUE,d=-Number.MAX_VALUE,g=c,u=d;if(e.chart.stacked)!function(){var t=i.seriesX[a[0]],s=[],r=[],p=[];n.forEach((function(){s.push(t.map((function(){return Number.MIN_VALUE}))),r.push(t.map((function(){return Number.MIN_VALUE}))),p.push(t.map((function(){return Number.MIN_VALUE})));}));for(var f=function(t){!l&&e.series[a[t]].type&&(l=e.series[a[t]].type);var c=a[t];h=e.series[c].group?e.series[c].group:"axis-".concat(o),!(i.collapsedSeriesIndices.indexOf(c)<0&&i.ancillaryCollapsedSeriesIndices.indexOf(c)<0)||(i.allSeriesCollapsed=!1,n.forEach((function(t,a){if(e.series[c].group===t)for(var o=0;o<i.series[c].length;o++){var n=i.series[c][o];n>=0?r[a][o]+=n:p[a][o]+=n,s[a][o]+=n,g=Math.min(g,n),u=Math.max(u,n);}}))),"bar"!==l&&"column"!==l||i.barGroups.push(h);},x=0;x<a.length;x++)f(x);l||(l=e.chart.type),"bar"===l||"column"===l?n.forEach((function(t,e){c=Math.min(c,Math.min.apply(null,p[e])),d=Math.max(d,Math.max.apply(null,r[e]));})):(n.forEach((function(t,e){g=Math.min(g,Math.min.apply(null,s[e])),u=Math.max(u,Math.max.apply(null,s[e]));})),c=g,d=u),c===Number.MIN_VALUE&&d===Number.MIN_VALUE&&(d=-Number.MAX_VALUE);}();else for(var p=0;p<a.length;p++){var f=a[p];c=Math.min(c,s[f]),d=Math.max(d,r[f]),!(i.collapsedSeriesIndices.indexOf(f)<0&&i.ancillaryCollapsedSeriesIndices.indexOf(f)<0)||(i.allSeriesCollapsed=!1);}void 0!==e.yaxis[o].min&&(c="function"==typeof e.yaxis[o].min?e.yaxis[o].min(c):e.yaxis[o].min),void 0!==e.yaxis[o].max&&(d="function"==typeof e.yaxis[o].max?e.yaxis[o].max(d):e.yaxis[o].max),i.barGroups=i.barGroups.filter((function(t,e,i){return i.indexOf(t)===e})),t.setYScaleForIndex(o,c,d),a.forEach((function(t){s[t]=i.yAxisScale[o].niceMin,r[t]=i.yAxisScale[o].niceMax;}));}():t.setYScaleForIndex(o,0,-Number.MAX_VALUE);}));}}]),t}(),U=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w,this.scales=new _(e);}return r(t,[{key:"init",value:function(){this.setYRange(),this.setXRange(),this.setZRange();}},{key:"getMinYMaxY",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Number.MAX_VALUE,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-Number.MAX_VALUE,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=this.w.config,r=this.w.globals,o=-Number.MAX_VALUE,n=Number.MIN_VALUE;null===a&&(a=t+1);var l=0,h=0,c=void 0;if(r.seriesX.length>=a){var d,g;l=0,h=(c=u(new Set((d=[]).concat.apply(d,u(r.seriesX.slice(t,a)))))).length-1;var p=null===(g=r.brushSource)||void 0===g?void 0:g.w.config.chart.brush;if(s.chart.zoom.enabled&&s.chart.zoom.autoScaleYaxis||null!=p&&p.enabled&&null!=p&&p.autoScaleYaxis){if(s.xaxis.min)for(l=0;l<h&&c[l]<s.xaxis.min;l++);if(s.xaxis.max)for(;h>l&&c[h]>s.xaxis.max;h--);}}var f=r.series,b=f,v=f;"candlestick"===s.chart.type?(b=r.seriesCandleL,v=r.seriesCandleH):"boxPlot"===s.chart.type?(b=r.seriesCandleO,v=r.seriesCandleC):r.isRangeData&&(b=r.seriesRangeStart,v=r.seriesRangeEnd);for(var m=t;m<a;m++){r.dataPoints=Math.max(r.dataPoints,f[m].length);var y=s.series[m].type;r.categoryLabels.length&&(r.dataPoints=r.categoryLabels.filter((function(t){return void 0!==t})).length),r.labels.length&&"datetime"!==s.xaxis.type&&0!==r.series.reduce((function(t,e){return t+e.length}),0)&&(r.dataPoints=Math.max(r.dataPoints,r.labels.length)),c||(l=0,h=r.series[m].length);for(var w=l;w<=h&&w<r.series[m].length;w++){var k=f[m][w];if(null!==k&&x.isNumber(k)){switch(void 0!==v[m][w]&&(o=Math.max(o,v[m][w]),e=Math.min(e,v[m][w])),void 0!==b[m][w]&&(e=Math.min(e,b[m][w]),i=Math.max(i,b[m][w])),y){case"candlestick":void 0!==r.seriesCandleC[m][w]&&(o=Math.max(o,r.seriesCandleH[m][w]),e=Math.min(e,r.seriesCandleL[m][w]));break;case"boxPlot":void 0!==r.seriesCandleC[m][w]&&(o=Math.max(o,r.seriesCandleC[m][w]),e=Math.min(e,r.seriesCandleO[m][w]));}y&&"candlestick"!==y&&"boxPlot"!==y&&"rangeArea"!==y&&"rangeBar"!==y&&(o=Math.max(o,r.series[m][w]),e=Math.min(e,r.series[m][w])),i=o,r.seriesGoals[m]&&r.seriesGoals[m][w]&&Array.isArray(r.seriesGoals[m][w])&&r.seriesGoals[m][w].forEach((function(t){n!==Number.MIN_VALUE&&(n=Math.min(n,t.value),e=n),o=Math.max(o,t.value),i=o;})),x.isFloat(k)&&(k=x.noExponents(k),r.yValueDecimal=Math.max(r.yValueDecimal,k.toString().split(".")[1].length)),n>b[m][w]&&b[m][w]<0&&(n=b[m][w]);}else r.hasNullValues=!0;}"bar"!==y&&"column"!==y||(n<0&&o<0&&(o=0,i=Math.max(i,0)),n===Number.MIN_VALUE&&(n=0,e=Math.min(e,0)));}return "rangeBar"===s.chart.type&&r.seriesRangeStart.length&&r.isBarHorizontal&&(n=e),"bar"===s.chart.type&&(n<0&&o<0&&(o=0),n===Number.MIN_VALUE&&(n=0)),{minY:n,maxY:o,lowestY:e,highestY:i}}},{key:"setYRange",value:function(){var t=this.w.globals,e=this.w.config;t.maxY=-Number.MAX_VALUE,t.minY=Number.MIN_VALUE;var i,a=Number.MAX_VALUE;if(t.isMultipleYAxis){a=Number.MAX_VALUE;for(var s=0;s<t.series.length;s++)i=this.getMinYMaxY(s),t.minYArr[s]=i.lowestY,t.maxYArr[s]=i.highestY,a=Math.min(a,i.lowestY);}if(i=this.getMinYMaxY(0,a,null,t.series.length),"bar"===e.chart.type?(t.minY=i.minY,t.maxY=i.maxY):(t.minY=i.lowestY,t.maxY=i.highestY),a=i.lowestY,e.chart.stacked&&this._setStackedMinMax(),"line"===e.chart.type||"area"===e.chart.type||"scatter"===e.chart.type||"candlestick"===e.chart.type||"boxPlot"===e.chart.type||"rangeBar"===e.chart.type&&!t.isBarHorizontal?t.minY===Number.MIN_VALUE&&a!==-Number.MAX_VALUE&&a!==t.maxY&&(t.minY=a):t.minY=i.minY,e.yaxis.forEach((function(e,i){void 0!==e.max&&("number"==typeof e.max?t.maxYArr[i]=e.max:"function"==typeof e.max&&(t.maxYArr[i]=e.max(t.isMultipleYAxis?t.maxYArr[i]:t.maxY)),t.maxY=t.maxYArr[i]),void 0!==e.min&&("number"==typeof e.min?t.minYArr[i]=e.min:"function"==typeof e.min&&(t.minYArr[i]=e.min(t.isMultipleYAxis?t.minYArr[i]===Number.MIN_VALUE?0:t.minYArr[i]:t.minY)),t.minY=t.minYArr[i]);})),t.isBarHorizontal){["min","max"].forEach((function(i){void 0!==e.xaxis[i]&&"number"==typeof e.xaxis[i]&&("min"===i?t.minY=e.xaxis[i]:t.maxY=e.xaxis[i]);}));}return t.isMultipleYAxis?(this.scales.scaleMultipleYAxes(),t.minY=a):(this.scales.setYScaleForIndex(0,t.minY,t.maxY),t.minY=t.yAxisScale[0].niceMin,t.maxY=t.yAxisScale[0].niceMax,t.minYArr[0]=t.minY,t.maxYArr[0]=t.maxY),t.barGroups=[],t.lineGroups=[],t.areaGroups=[],e.series.forEach((function(i){switch(i.type||e.chart.type){case"bar":case"column":t.barGroups.push(i.group);break;case"line":t.lineGroups.push(i.group);break;case"area":t.areaGroups.push(i.group);}})),t.barGroups=t.barGroups.filter((function(t,e,i){return i.indexOf(t)===e})),t.lineGroups=t.lineGroups.filter((function(t,e,i){return i.indexOf(t)===e})),t.areaGroups=t.areaGroups.filter((function(t,e,i){return i.indexOf(t)===e})),{minY:t.minY,maxY:t.maxY,minYArr:t.minYArr,maxYArr:t.maxYArr,yAxisScale:t.yAxisScale}}},{key:"setXRange",value:function(){var t=this.w.globals,e=this.w.config,i="numeric"===e.xaxis.type||"datetime"===e.xaxis.type||"category"===e.xaxis.type&&!t.noLabelsProvided||t.noLabelsProvided||t.isXNumeric;if(t.isXNumeric&&function(){for(var e=0;e<t.series.length;e++)if(t.labels[e])for(var i=0;i<t.labels[e].length;i++)null!==t.labels[e][i]&&x.isNumber(t.labels[e][i])&&(t.maxX=Math.max(t.maxX,t.labels[e][i]),t.initialMaxX=Math.max(t.maxX,t.labels[e][i]),t.minX=Math.min(t.minX,t.labels[e][i]),t.initialMinX=Math.min(t.minX,t.labels[e][i]));}(),t.noLabelsProvided&&0===e.xaxis.categories.length&&(t.maxX=t.labels[t.labels.length-1],t.initialMaxX=t.labels[t.labels.length-1],t.minX=1,t.initialMinX=1),t.isXNumeric||t.noLabelsProvided||t.dataFormatXNumeric){var a;if(void 0===e.xaxis.tickAmount?(a=Math.round(t.svgWidth/150),"numeric"===e.xaxis.type&&t.dataPoints<30&&(a=t.dataPoints-1),a>t.dataPoints&&0!==t.dataPoints&&(a=t.dataPoints-1)):"dataPoints"===e.xaxis.tickAmount?(t.series.length>1&&(a=t.series[t.maxValsInArrayIndex].length-1),t.isXNumeric&&(a=t.maxX-t.minX-1)):a=e.xaxis.tickAmount,t.xTickAmount=a,void 0!==e.xaxis.max&&"number"==typeof e.xaxis.max&&(t.maxX=e.xaxis.max),void 0!==e.xaxis.min&&"number"==typeof e.xaxis.min&&(t.minX=e.xaxis.min),void 0!==e.xaxis.range&&(t.minX=t.maxX-e.xaxis.range),t.minX!==Number.MAX_VALUE&&t.maxX!==-Number.MAX_VALUE)if(e.xaxis.convertedCatToNumeric&&!t.dataFormatXNumeric){for(var s=[],r=t.minX-1;r<t.maxX;r++)s.push(r+1);t.xAxisScale={result:s,niceMin:s[0],niceMax:s[s.length-1]};}else t.xAxisScale=this.scales.setXScale(t.minX,t.maxX);else t.xAxisScale=this.scales.linearScale(0,a,a,0,e.xaxis.stepSize),t.noLabelsProvided&&t.labels.length>0&&(t.xAxisScale=this.scales.linearScale(1,t.labels.length,a-1,0,e.xaxis.stepSize),t.seriesX=t.labels.slice());i&&(t.labels=t.xAxisScale.result.slice());}return t.isBarHorizontal&&t.labels.length&&(t.xTickAmount=t.labels.length),this._handleSingleDataPoint(),this._getMinXDiff(),{minX:t.minX,maxX:t.maxX}}},{key:"setZRange",value:function(){var t=this.w.globals;if(t.isDataXYZ)for(var e=0;e<t.series.length;e++)if(void 0!==t.seriesZ[e])for(var i=0;i<t.seriesZ[e].length;i++)null!==t.seriesZ[e][i]&&x.isNumber(t.seriesZ[e][i])&&(t.maxZ=Math.max(t.maxZ,t.seriesZ[e][i]),t.minZ=Math.min(t.minZ,t.seriesZ[e][i]));}},{key:"_handleSingleDataPoint",value:function(){var t=this.w.globals,e=this.w.config;if(t.minX===t.maxX){var i=new A(this.ctx);if("datetime"===e.xaxis.type){var a=i.getDate(t.minX);e.xaxis.labels.datetimeUTC?a.setUTCDate(a.getUTCDate()-2):a.setDate(a.getDate()-2),t.minX=new Date(a).getTime();var s=i.getDate(t.maxX);e.xaxis.labels.datetimeUTC?s.setUTCDate(s.getUTCDate()+2):s.setDate(s.getDate()+2),t.maxX=new Date(s).getTime();}else ("numeric"===e.xaxis.type||"category"===e.xaxis.type&&!t.noLabelsProvided)&&(t.minX=t.minX-2,t.initialMinX=t.minX,t.maxX=t.maxX+2,t.initialMaxX=t.maxX);}}},{key:"_getMinXDiff",value:function(){var t=this.w.globals;t.isXNumeric&&t.seriesX.forEach((function(e,i){1===e.length&&e.push(t.seriesX[t.maxValsInArrayIndex][t.seriesX[t.maxValsInArrayIndex].length-1]);var a=e.slice();a.sort((function(t,e){return t-e})),a.forEach((function(e,i){if(i>0){var s=e-a[i-1];s>0&&(t.minXDiff=Math.min(s,t.minXDiff));}})),1!==t.dataPoints&&t.minXDiff!==Number.MAX_VALUE||(t.minXDiff=.5);}));}},{key:"_setStackedMinMax",value:function(){var t=this,e=this.w.globals;if(e.series.length){var i=e.seriesGroups;i.length||(i=[this.w.globals.seriesNames.map((function(t){return t}))]);var a={},s={};i.forEach((function(i){a[i]=[],s[i]=[],t.w.config.series.map((function(t,a){return i.indexOf(e.seriesNames[a])>-1?a:null})).filter((function(t){return null!==t})).forEach((function(r){for(var o=0;o<e.series[e.maxValsInArrayIndex].length;o++){var n,l,h,c;void 0===a[i][o]&&(a[i][o]=0,s[i][o]=0),(t.w.config.chart.stacked&&!e.comboCharts||t.w.config.chart.stacked&&e.comboCharts&&(!t.w.config.chart.stackOnlyBar||"bar"===(null===(n=t.w.config.series)||void 0===n||null===(l=n[r])||void 0===l?void 0:l.type)||"column"===(null===(h=t.w.config.series)||void 0===h||null===(c=h[r])||void 0===c?void 0:c.type)))&&null!==e.series[r][o]&&x.isNumber(e.series[r][o])&&(e.series[r][o]>0?a[i][o]+=parseFloat(e.series[r][o])+1e-4:s[i][o]+=parseFloat(e.series[r][o]));}}));})),Object.entries(a).forEach((function(t){var i=g(t,1)[0];a[i].forEach((function(t,r){e.maxY=Math.max(e.maxY,a[i][r]),e.minY=Math.min(e.minY,s[i][r]);}));}));}}}]),t}(),q=function(){function t(e,i){a(this,t),this.ctx=e,this.elgrid=i,this.w=e.w;var s=this.w;this.xaxisFontSize=s.config.xaxis.labels.style.fontSize,this.axisFontFamily=s.config.xaxis.labels.style.fontFamily,this.xaxisForeColors=s.config.xaxis.labels.style.colors,this.isCategoryBarHorizontal="bar"===s.config.chart.type&&s.config.plotOptions.bar.horizontal,this.xAxisoffX=0,"bottom"===s.config.xaxis.position&&(this.xAxisoffX=s.globals.gridHeight),this.drawnLabels=[],this.axesUtils=new C(e);}return r(t,[{key:"drawYaxis",value:function(t){var e=this,i=this.w,a=new m(this.ctx),s=i.config.yaxis[t].labels.style,r=s.fontSize,o=s.fontFamily,n=s.fontWeight,l=a.group({class:"apexcharts-yaxis",rel:t,transform:"translate("+i.globals.translateYAxisX[t]+", 0)"});if(this.axesUtils.isYAxisHidden(t))return l;var h=a.group({class:"apexcharts-yaxis-texts-g"});l.add(h);var c=i.globals.yAxisScale[t].result.length-1,d=i.globals.gridHeight/c,g=i.globals.yLabelFormatters[t],u=i.globals.yAxisScale[t].result.slice();u=this.axesUtils.checkForReversedLabels(t,u);var p="";if(i.config.yaxis[t].labels.show){var f=i.globals.translateY+i.config.yaxis[t].labels.offsetY;i.globals.isBarHorizontal?f=0:"heatmap"===i.config.chart.type&&(f-=d/2),f+=parseInt(i.config.yaxis[t].labels.style.fontSize,10)/3;for(var x=function(l){var x=u[l];x=g(x,l,i);var b=i.config.yaxis[t].labels.padding;i.config.yaxis[t].opposite&&0!==i.config.yaxis.length&&(b*=-1);var v="end";i.config.yaxis[t].opposite&&(v="start"),"left"===i.config.yaxis[t].labels.align?v="start":"center"===i.config.yaxis[t].labels.align?v="middle":"right"===i.config.yaxis[t].labels.align&&(v="end");var m=e.axesUtils.getYAxisForeColor(s.colors,t),y=a.drawText({x:b,y:f,text:x,textAnchor:v,fontSize:r,fontFamily:o,fontWeight:n,maxWidth:i.config.yaxis[t].labels.maxWidth,foreColor:Array.isArray(m)?m[l]:m,isPlainText:!1,cssClass:"apexcharts-yaxis-label "+s.cssClass});l===c&&(p=y),h.add(y);var w=document.createElementNS(i.globals.SVGNS,"title");if(w.textContent=Array.isArray(x)?x.join(" "):x,y.node.appendChild(w),0!==i.config.yaxis[t].labels.rotate){var k=a.rotateAroundCenter(p.node),A=a.rotateAroundCenter(y.node);y.node.setAttribute("transform","rotate(".concat(i.config.yaxis[t].labels.rotate," ").concat(k.x," ").concat(A.y,")"));}f+=d;},b=c;b>=0;b--)x(b);}if(void 0!==i.config.yaxis[t].title.text){var v=a.group({class:"apexcharts-yaxis-title"}),y=0;i.config.yaxis[t].opposite&&(y=i.globals.translateYAxisX[t]);var w=a.drawText({x:y,y:i.globals.gridHeight/2+i.globals.translateY+i.config.yaxis[t].title.offsetY,text:i.config.yaxis[t].title.text,textAnchor:"end",foreColor:i.config.yaxis[t].title.style.color,fontSize:i.config.yaxis[t].title.style.fontSize,fontWeight:i.config.yaxis[t].title.style.fontWeight,fontFamily:i.config.yaxis[t].title.style.fontFamily,cssClass:"apexcharts-yaxis-title-text "+i.config.yaxis[t].title.style.cssClass});v.add(w),l.add(v);}var k=i.config.yaxis[t].axisBorder,A=31+k.offsetX;if(i.config.yaxis[t].opposite&&(A=-31-k.offsetX),k.show){var S=a.drawLine(A,i.globals.translateY+k.offsetY-2,A,i.globals.gridHeight+i.globals.translateY+k.offsetY+2,k.color,0,k.width);l.add(S);}return i.config.yaxis[t].axisTicks.show&&this.axesUtils.drawYAxisTicks(A,c,k,i.config.yaxis[t].axisTicks,t,d,l),l}},{key:"drawYaxisInversed",value:function(t){var e=this.w,i=new m(this.ctx),a=i.group({class:"apexcharts-xaxis apexcharts-yaxis-inversed"}),s=i.group({class:"apexcharts-xaxis-texts-g",transform:"translate(".concat(e.globals.translateXAxisX,", ").concat(e.globals.translateXAxisY,")")});a.add(s);var r=e.globals.yAxisScale[t].result.length-1,o=e.globals.gridWidth/r+.1,n=o+e.config.xaxis.labels.offsetX,l=e.globals.xLabelFormatter,h=e.globals.yAxisScale[t].result.slice(),c=e.globals.timescaleLabels;c.length>0&&(this.xaxisLabels=c.slice(),r=(h=c.slice()).length),h=this.axesUtils.checkForReversedLabels(t,h);var d=c.length;if(e.config.xaxis.labels.show)for(var g=d?0:r;d?g<d:g>=0;d?g++:g--){var u=h[g];u=l(u,g,e);var p=e.globals.gridWidth+e.globals.padHorizontal-(n-o+e.config.xaxis.labels.offsetX);if(c.length){var f=this.axesUtils.getLabel(h,c,p,g,this.drawnLabels,this.xaxisFontSize);p=f.x,u=f.text,this.drawnLabels.push(f.text),0===g&&e.globals.skipFirstTimelinelabel&&(u=""),g===h.length-1&&e.globals.skipLastTimelinelabel&&(u="");}var x=i.drawText({x:p,y:this.xAxisoffX+e.config.xaxis.labels.offsetY+30-("top"===e.config.xaxis.position?e.globals.xAxisHeight+e.config.xaxis.axisTicks.height-2:0),text:u,textAnchor:"middle",foreColor:Array.isArray(this.xaxisForeColors)?this.xaxisForeColors[t]:this.xaxisForeColors,fontSize:this.xaxisFontSize,fontFamily:this.xaxisFontFamily,fontWeight:e.config.xaxis.labels.style.fontWeight,isPlainText:!1,cssClass:"apexcharts-xaxis-label "+e.config.xaxis.labels.style.cssClass});s.add(x),x.tspan(u);var b=document.createElementNS(e.globals.SVGNS,"title");b.textContent=u,x.node.appendChild(b),n+=o;}return this.inversedYAxisTitleText(a),this.inversedYAxisBorder(a),a}},{key:"inversedYAxisBorder",value:function(t){var e=this.w,i=new m(this.ctx),a=e.config.xaxis.axisBorder;if(a.show){var s=0;"bar"===e.config.chart.type&&e.globals.isXNumeric&&(s-=15);var r=i.drawLine(e.globals.padHorizontal+s+a.offsetX,this.xAxisoffX,e.globals.gridWidth,this.xAxisoffX,a.color,0,a.height);this.elgrid&&this.elgrid.elGridBorders&&e.config.grid.show?this.elgrid.elGridBorders.add(r):t.add(r);}}},{key:"inversedYAxisTitleText",value:function(t){var e=this.w,i=new m(this.ctx);if(void 0!==e.config.xaxis.title.text){var a=i.group({class:"apexcharts-xaxis-title apexcharts-yaxis-title-inversed"}),s=i.drawText({x:e.globals.gridWidth/2+e.config.xaxis.title.offsetX,y:this.xAxisoffX+parseFloat(this.xaxisFontSize)+parseFloat(e.config.xaxis.title.style.fontSize)+e.config.xaxis.title.offsetY+20,text:e.config.xaxis.title.text,textAnchor:"middle",fontSize:e.config.xaxis.title.style.fontSize,fontFamily:e.config.xaxis.title.style.fontFamily,fontWeight:e.config.xaxis.title.style.fontWeight,foreColor:e.config.xaxis.title.style.color,cssClass:"apexcharts-xaxis-title-text "+e.config.xaxis.title.style.cssClass});a.add(s),t.add(a);}}},{key:"yAxisTitleRotate",value:function(t,e){var i=this.w,a=new m(this.ctx),s={width:0,height:0},r={width:0,height:0},o=i.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(t,"'] .apexcharts-yaxis-texts-g"));null!==o&&(s=o.getBoundingClientRect());var n=i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t,"'] .apexcharts-yaxis-title text"));if(null!==n&&(r=n.getBoundingClientRect()),null!==n){var l=this.xPaddingForYAxisTitle(t,s,r,e);n.setAttribute("x",l.xPos-(e?10:0));}if(null!==n){var h=a.rotateAroundCenter(n);n.setAttribute("transform","rotate(".concat(e?-1*i.config.yaxis[t].title.rotate:i.config.yaxis[t].title.rotate," ").concat(h.x," ").concat(h.y,")"));}}},{key:"xPaddingForYAxisTitle",value:function(t,e,i,a){var s=this.w,r=0,o=0,n=10;return void 0===s.config.yaxis[t].title.text||t<0?{xPos:o,padd:0}:(a?(o=e.width+s.config.yaxis[t].title.offsetX+i.width/2+n/2,0===(r+=1)&&(o-=n/2)):(o=-1*e.width+s.config.yaxis[t].title.offsetX+n/2+i.width/2,s.globals.isBarHorizontal&&(n=25,o=-1*e.width-s.config.yaxis[t].title.offsetX-n)),{xPos:o,padd:n})}},{key:"setYAxisXPosition",value:function(t,e){var i=this.w,a=0,s=0,r=18,o=1;i.config.yaxis.length>1&&(this.multipleYs=!0),i.config.yaxis.map((function(n,l){var h=i.globals.ignoreYAxisIndexes.indexOf(l)>-1||!n.show||n.floating||0===t[l].width,c=t[l].width+e[l].width;n.opposite?i.globals.isBarHorizontal?(s=i.globals.gridWidth+i.globals.translateX-1,i.globals.translateYAxisX[l]=s-n.labels.offsetX):(s=i.globals.gridWidth+i.globals.translateX+o,h||(o=o+c+20),i.globals.translateYAxisX[l]=s-n.labels.offsetX+20):(a=i.globals.translateX-r,h||(r=r+c+20),i.globals.translateYAxisX[l]=a+n.labels.offsetX);}));}},{key:"setYAxisTextAlignments",value:function(){var t=this.w,e=t.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis");(e=x.listToArray(e)).forEach((function(e,i){var a=t.config.yaxis[i];if(a&&!a.floating&&void 0!==a.labels.align){var s=t.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(i,"'] .apexcharts-yaxis-texts-g")),r=t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(i,"'] .apexcharts-yaxis-label"));r=x.listToArray(r);var o=s.getBoundingClientRect();"left"===a.labels.align?(r.forEach((function(t,e){t.setAttribute("text-anchor","start");})),a.opposite||s.setAttribute("transform","translate(-".concat(o.width,", 0)"))):"center"===a.labels.align?(r.forEach((function(t,e){t.setAttribute("text-anchor","middle");})),s.setAttribute("transform","translate(".concat(o.width/2*(a.opposite?1:-1),", 0)"))):"right"===a.labels.align&&(r.forEach((function(t,e){t.setAttribute("text-anchor","end");})),a.opposite&&s.setAttribute("transform","translate(".concat(o.width,", 0)")));}}));}}]),t}(),Z=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w,this.documentEvent=x.bind(this.documentEvent,this);}return r(t,[{key:"addEventListener",value:function(t,e){var i=this.w;i.globals.events.hasOwnProperty(t)?i.globals.events[t].push(e):i.globals.events[t]=[e];}},{key:"removeEventListener",value:function(t,e){var i=this.w;if(i.globals.events.hasOwnProperty(t)){var a=i.globals.events[t].indexOf(e);-1!==a&&i.globals.events[t].splice(a,1);}}},{key:"fireEvent",value:function(t,e){var i=this.w;if(i.globals.events.hasOwnProperty(t)){e&&e.length||(e=[]);for(var a=i.globals.events[t],s=a.length,r=0;r<s;r++)a[r].apply(null,e);}}},{key:"setupEventHandlers",value:function(){var t=this,e=this.w,i=this.ctx,a=e.globals.dom.baseEl.querySelector(e.globals.chartClass);this.ctx.eventList.forEach((function(t){a.addEventListener(t,(function(t){var a=Object.assign({},e,{seriesIndex:e.globals.axisCharts?e.globals.capturedSeriesIndex:0,dataPointIndex:e.globals.capturedDataPointIndex});"mousemove"===t.type||"touchmove"===t.type?"function"==typeof e.config.chart.events.mouseMove&&e.config.chart.events.mouseMove(t,i,a):"mouseleave"===t.type||"touchleave"===t.type?"function"==typeof e.config.chart.events.mouseLeave&&e.config.chart.events.mouseLeave(t,i,a):("mouseup"===t.type&&1===t.which||"touchend"===t.type)&&("function"==typeof e.config.chart.events.click&&e.config.chart.events.click(t,i,a),i.ctx.events.fireEvent("click",[t,i,a]));}),{capture:!1,passive:!0});})),this.ctx.eventList.forEach((function(i){e.globals.dom.baseEl.addEventListener(i,t.documentEvent,{passive:!0});})),this.ctx.core.setupBrushHandler();}},{key:"documentEvent",value:function(t){var e=this.w,i=t.target.className;if("click"===t.type){var a=e.globals.dom.baseEl.querySelector(".apexcharts-menu");a&&a.classList.contains("apexcharts-menu-open")&&"apexcharts-menu-icon"!==i&&a.classList.remove("apexcharts-menu-open");}e.globals.clientX="touchmove"===t.type?t.touches[0].clientX:t.clientX,e.globals.clientY="touchmove"===t.type?t.touches[0].clientY:t.clientY;}}]),t}(),$=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w;}return r(t,[{key:"setCurrentLocaleValues",value:function(t){var e=this.w.config.chart.locales;window.Apex.chart&&window.Apex.chart.locales&&window.Apex.chart.locales.length>0&&(e=this.w.config.chart.locales.concat(window.Apex.chart.locales));var i=e.filter((function(e){return e.name===t}))[0];if(!i)throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");var a=x.extend(M,i);this.w.globals.locale=a.options;}}]),t}(),J=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w;}return r(t,[{key:"drawAxis",value:function(t,e){var i,a,s=this,r=this.w.globals,o=this.w.config,n=new V(this.ctx,e),l=new q(this.ctx,e);r.axisCharts&&"radar"!==t&&(r.isBarHorizontal?(a=l.drawYaxisInversed(0),i=n.drawXaxisInversed(0),r.dom.elGraphical.add(i),r.dom.elGraphical.add(a)):(i=n.drawXaxis(),r.dom.elGraphical.add(i),o.yaxis.map((function(t,e){if(-1===r.ignoreYAxisIndexes.indexOf(e)&&(a=l.drawYaxis(e),r.dom.Paper.add(a),"back"===s.w.config.grid.position)){var i=r.dom.Paper.children()[1];i.remove(),r.dom.Paper.add(i);}}))));}}]),t}(),Q=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w;}return r(t,[{key:"drawXCrosshairs",value:function(){var t=this.w,e=new m(this.ctx),i=new v(this.ctx),a=t.config.xaxis.crosshairs.fill.gradient,s=t.config.xaxis.crosshairs.dropShadow,r=t.config.xaxis.crosshairs.fill.type,o=a.colorFrom,n=a.colorTo,l=a.opacityFrom,h=a.opacityTo,c=a.stops,d=s.enabled,g=s.left,u=s.top,p=s.blur,f=s.color,b=s.opacity,y=t.config.xaxis.crosshairs.fill.color;if(t.config.xaxis.crosshairs.show){"gradient"===r&&(y=e.drawGradient("vertical",o,n,l,h,null,c,null));var w=e.drawRect();1===t.config.xaxis.crosshairs.width&&(w=e.drawLine());var k=t.globals.gridHeight;(!x.isNumber(k)||k<0)&&(k=0);var A=t.config.xaxis.crosshairs.width;(!x.isNumber(A)||A<0)&&(A=0),w.attr({class:"apexcharts-xcrosshairs",x:0,y:0,y2:k,width:A,height:k,fill:y,filter:"none","fill-opacity":t.config.xaxis.crosshairs.opacity,stroke:t.config.xaxis.crosshairs.stroke.color,"stroke-width":t.config.xaxis.crosshairs.stroke.width,"stroke-dasharray":t.config.xaxis.crosshairs.stroke.dashArray}),d&&(w=i.dropShadow(w,{left:g,top:u,blur:p,color:f,opacity:b})),t.globals.dom.elGraphical.add(w);}}},{key:"drawYCrosshairs",value:function(){var t=this.w,e=new m(this.ctx),i=t.config.yaxis[0].crosshairs,a=t.globals.barPadForNumericAxis;if(t.config.yaxis[0].crosshairs.show){var s=e.drawLine(-a,0,t.globals.gridWidth+a,0,i.stroke.color,i.stroke.dashArray,i.stroke.width);s.attr({class:"apexcharts-ycrosshairs"}),t.globals.dom.elGraphical.add(s);}var r=e.drawLine(-a,0,t.globals.gridWidth+a,0,i.stroke.color,0,0);r.attr({class:"apexcharts-ycrosshairs-hidden"}),t.globals.dom.elGraphical.add(r);}}]),t}(),K=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w;}return r(t,[{key:"checkResponsiveConfig",value:function(t){var e=this,i=this.w,a=i.config;if(0!==a.responsive.length){var s=a.responsive.slice();s.sort((function(t,e){return t.breakpoint>e.breakpoint?1:e.breakpoint>t.breakpoint?-1:0})).reverse();var r=new Y({}),o=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},a=s[0].breakpoint,o=window.innerWidth>0?window.innerWidth:screen.width;if(o>a){var n=x.clone(i.globals.initialConfig);n.series=x.clone(i.config.series);var l=y.extendArrayProps(r,n,i);t=x.extend(l,t),t=x.extend(i.config,t),e.overrideResponsiveOptions(t);}else for(var h=0;h<s.length;h++)if(o<s[h].breakpoint){var c=y.extendArrayProps(r,s[h].options,i);t=x.extend(c,t),t=x.extend(i.config,t),e.overrideResponsiveOptions(t);}};if(t){var n=y.extendArrayProps(r,t,i);n=x.extend(i.config,n),o(n=x.extend(n,t));}else o({});}}},{key:"overrideResponsiveOptions",value:function(t){var e=new Y(t).init({responsiveOverride:!0});this.w.config=e;}}]),t}(),tt=function(){function t(e){a(this,t),this.ctx=e,this.colors=[],this.w=e.w;var i=this.w;this.isColorFn=!1,this.isHeatmapDistributed="treemap"===i.config.chart.type&&i.config.plotOptions.treemap.distributed||"heatmap"===i.config.chart.type&&i.config.plotOptions.heatmap.distributed,this.isBarDistributed=i.config.plotOptions.bar.distributed&&("bar"===i.config.chart.type||"rangeBar"===i.config.chart.type);}return r(t,[{key:"init",value:function(){this.setDefaultColors();}},{key:"setDefaultColors",value:function(){var t,e=this,i=this.w,a=new x;if(i.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(i.config.theme.mode)),void 0===i.config.colors||0===(null===(t=i.config.colors)||void 0===t?void 0:t.length)?i.globals.colors=this.predefined():(i.globals.colors=i.config.colors,Array.isArray(i.config.colors)&&i.config.colors.length>0&&"function"==typeof i.config.colors[0]&&(i.globals.colors=i.config.series.map((function(t,a){var s=i.config.colors[a];return s||(s=i.config.colors[0]),"function"==typeof s?(e.isColorFn=!0,s({value:i.globals.axisCharts?i.globals.series[a][0]?i.globals.series[a][0]:0:i.globals.series[a],seriesIndex:a,dataPointIndex:a,w:i})):s})))),i.globals.seriesColors.map((function(t,e){t&&(i.globals.colors[e]=t);})),i.config.theme.monochrome.enabled){var s=[],r=i.globals.series.length;(this.isBarDistributed||this.isHeatmapDistributed)&&(r=i.globals.series[0].length*i.globals.series.length);for(var o=i.config.theme.monochrome.color,n=1/(r/i.config.theme.monochrome.shadeIntensity),l=i.config.theme.monochrome.shadeTo,h=0,c=0;c<r;c++){var d=void 0;"dark"===l?(d=a.shadeColor(-1*h,o),h+=n):(d=a.shadeColor(h,o),h+=n),s.push(d);}i.globals.colors=s.slice();}var g=i.globals.colors.slice();this.pushExtraColors(i.globals.colors);["fill","stroke"].forEach((function(t){void 0===i.config[t].colors?i.globals[t].colors=e.isColorFn?i.config.colors:g:i.globals[t].colors=i.config[t].colors.slice(),e.pushExtraColors(i.globals[t].colors);})),void 0===i.config.dataLabels.style.colors?i.globals.dataLabels.style.colors=g:i.globals.dataLabels.style.colors=i.config.dataLabels.style.colors.slice(),this.pushExtraColors(i.globals.dataLabels.style.colors,50),void 0===i.config.plotOptions.radar.polygons.fill.colors?i.globals.radarPolygons.fill.colors=["dark"===i.config.theme.mode?"#424242":"none"]:i.globals.radarPolygons.fill.colors=i.config.plotOptions.radar.polygons.fill.colors.slice(),this.pushExtraColors(i.globals.radarPolygons.fill.colors,20),void 0===i.config.markers.colors?i.globals.markers.colors=g:i.globals.markers.colors=i.config.markers.colors.slice(),this.pushExtraColors(i.globals.markers.colors);}},{key:"pushExtraColors",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=this.w,s=e||a.globals.series.length;if(null===i&&(i=this.isBarDistributed||this.isHeatmapDistributed||"heatmap"===a.config.chart.type&&a.config.plotOptions.heatmap.colorScale.inverse),i&&a.globals.series.length&&(s=a.globals.series[a.globals.maxValsInArrayIndex].length*a.globals.series.length),t.length<s)for(var r=s-t.length,o=0;o<r;o++)t.push(t[o]);}},{key:"updateThemeOptions",value:function(t){t.chart=t.chart||{},t.tooltip=t.tooltip||{};var e=t.theme.mode||"light",i=t.theme.palette?t.theme.palette:"dark"===e?"palette4":"palette1",a=t.chart.foreColor?t.chart.foreColor:"dark"===e?"#f6f7f8":"#373d3f";return t.tooltip.theme=e,t.chart.foreColor=a,t.theme.palette=i,t}},{key:"predefined",value:function(){switch(this.w.config.theme.palette){case"palette1":default:this.colors=["#008FFB","#00E396","#FEB019","#FF4560","#775DD0"];break;case"palette2":this.colors=["#3f51b5","#03a9f4","#4caf50","#f9ce1d","#FF9800"];break;case"palette3":this.colors=["#33b2df","#546E7A","#d4526e","#13d8aa","#A5978B"];break;case"palette4":this.colors=["#4ecdc4","#c7f464","#81D4FA","#fd6a6a","#546E7A"];break;case"palette5":this.colors=["#2b908f","#f9a3a4","#90ee7e","#fa4443","#69d2e7"];break;case"palette6":this.colors=["#449DD1","#F86624","#EA3546","#662E9B","#C5D86D"];break;case"palette7":this.colors=["#D7263D","#1B998B","#2E294E","#F46036","#E2C044"];break;case"palette8":this.colors=["#662E9B","#F86624","#F9C80E","#EA3546","#43BCCD"];break;case"palette9":this.colors=["#5C4742","#A5978B","#8D5B4C","#5A2A27","#C4BBAF"];break;case"palette10":this.colors=["#A300D6","#7D02EB","#5653FE","#2983FF","#00B1F2"];}return this.colors}}]),t}(),et=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w;}return r(t,[{key:"draw",value:function(){this.drawTitleSubtitle("title"),this.drawTitleSubtitle("subtitle");}},{key:"drawTitleSubtitle",value:function(t){var e=this.w,i="title"===t?e.config.title:e.config.subtitle,a=e.globals.svgWidth/2,s=i.offsetY,r="middle";if("left"===i.align?(a=10,r="start"):"right"===i.align&&(a=e.globals.svgWidth-10,r="end"),a+=i.offsetX,s=s+parseInt(i.style.fontSize,10)+i.margin/2,void 0!==i.text){var o=new m(this.ctx).drawText({x:a,y:s,text:i.text,textAnchor:r,fontSize:i.style.fontSize,fontFamily:i.style.fontFamily,fontWeight:i.style.fontWeight,foreColor:i.style.color,opacity:1});o.node.setAttribute("class","apexcharts-".concat(t,"-text")),e.globals.dom.Paper.add(o);}}}]),t}(),it=function(){function t(e){a(this,t),this.w=e.w,this.dCtx=e;}return r(t,[{key:"getTitleSubtitleCoords",value:function(t){var e=this.w,i=0,a=0,s="title"===t?e.config.title.floating:e.config.subtitle.floating,r=e.globals.dom.baseEl.querySelector(".apexcharts-".concat(t,"-text"));if(null!==r&&!s){var o=r.getBoundingClientRect();i=o.width,a=e.globals.axisCharts?o.height+5:o.height;}return {width:i,height:a}}},{key:"getLegendsRect",value:function(){var t=this.w,e=t.globals.dom.elLegendWrap;t.config.legend.height||"top"!==t.config.legend.position&&"bottom"!==t.config.legend.position||(e.style.maxHeight=t.globals.svgHeight/2+"px");var i=Object.assign({},x.getBoundingClientRect(e));return null!==e&&!t.config.legend.floating&&t.config.legend.show?this.dCtx.lgRect={x:i.x,y:i.y,height:i.height,width:0===i.height?0:i.width}:this.dCtx.lgRect={x:0,y:0,height:0,width:0},"left"!==t.config.legend.position&&"right"!==t.config.legend.position||1.5*this.dCtx.lgRect.width>t.globals.svgWidth&&(this.dCtx.lgRect.width=t.globals.svgWidth/1.5),this.dCtx.lgRect}},{key:"getDatalabelsRect",value:function(){var t=this,e=this.w,i=[];e.config.series.forEach((function(s,r){s.data.forEach((function(s,o){var n;n=e.globals.series[r][o],a=e.config.dataLabels.formatter(n,{ctx:t.dCtx.ctx,seriesIndex:r,dataPointIndex:o,w:e}),i.push(a);}));}));var a=x.getLargestStringFromArr(i),s=new m(this.dCtx.ctx),r=e.config.dataLabels.style,o=s.getTextRects(a,parseInt(r.fontSize),r.fontFamily);return {width:1.05*o.width,height:o.height}}},{key:"getLargestStringFromMultiArr",value:function(t,e){var i=t;if(this.w.globals.isMultiLineX){var a=e.map((function(t,e){return Array.isArray(t)?t.length:1})),s=Math.max.apply(Math,u(a));i=e[a.indexOf(s)];}return i}}]),t}(),at=function(){function t(e){a(this,t),this.w=e.w,this.dCtx=e;}return r(t,[{key:"getxAxisLabelsCoords",value:function(){var t,e=this.w,i=e.globals.labels.slice();if(e.config.xaxis.convertedCatToNumeric&&0===i.length&&(i=e.globals.categoryLabels),e.globals.timescaleLabels.length>0){var a=this.getxAxisTimeScaleLabelsCoords();t={width:a.width,height:a.height},e.globals.rotateXLabels=!1;}else {this.dCtx.lgWidthForSideLegends="left"!==e.config.legend.position&&"right"!==e.config.legend.position||e.config.legend.floating?0:this.dCtx.lgRect.width;var s=e.globals.xLabelFormatter,r=x.getLargestStringFromArr(i),o=this.dCtx.dimHelpers.getLargestStringFromMultiArr(r,i);e.globals.isBarHorizontal&&(o=r=e.globals.yAxisScale[0].result.reduce((function(t,e){return t.length>e.length?t:e}),0));var n=new S(this.dCtx.ctx),l=r;r=n.xLabelFormat(s,r,l,{i:void 0,dateFormatter:new A(this.dCtx.ctx).formatDate,w:e}),o=n.xLabelFormat(s,o,l,{i:void 0,dateFormatter:new A(this.dCtx.ctx).formatDate,w:e}),(e.config.xaxis.convertedCatToNumeric&&void 0===r||""===String(r).trim())&&(o=r="1");var h=new m(this.dCtx.ctx),c=h.getTextRects(r,e.config.xaxis.labels.style.fontSize),d=c;if(r!==o&&(d=h.getTextRects(o,e.config.xaxis.labels.style.fontSize)),(t={width:c.width>=d.width?c.width:d.width,height:c.height>=d.height?c.height:d.height}).width*i.length>e.globals.svgWidth-this.dCtx.lgWidthForSideLegends-this.dCtx.yAxisWidth-this.dCtx.gridPad.left-this.dCtx.gridPad.right&&0!==e.config.xaxis.labels.rotate||e.config.xaxis.labels.rotateAlways){if(!e.globals.isBarHorizontal){e.globals.rotateXLabels=!0;var g=function(t){return h.getTextRects(t,e.config.xaxis.labels.style.fontSize,e.config.xaxis.labels.style.fontFamily,"rotate(".concat(e.config.xaxis.labels.rotate," 0 0)"),!1)};c=g(r),r!==o&&(d=g(o)),t.height=(c.height>d.height?c.height:d.height)/1.5,t.width=c.width>d.width?c.width:d.width;}}else e.globals.rotateXLabels=!1;}return e.config.xaxis.labels.show||(t={width:0,height:0}),{width:t.width,height:t.height}}},{key:"getxAxisGroupLabelsCoords",value:function(){var t,e=this.w;if(!e.globals.hasXaxisGroups)return {width:0,height:0};var i,a=(null===(t=e.config.xaxis.group.style)||void 0===t?void 0:t.fontSize)||e.config.xaxis.labels.style.fontSize,s=e.globals.groups.map((function(t){return t.title})),r=x.getLargestStringFromArr(s),o=this.dCtx.dimHelpers.getLargestStringFromMultiArr(r,s),n=new m(this.dCtx.ctx),l=n.getTextRects(r,a),h=l;return r!==o&&(h=n.getTextRects(o,a)),i={width:l.width>=h.width?l.width:h.width,height:l.height>=h.height?l.height:h.height},e.config.xaxis.labels.show||(i={width:0,height:0}),{width:i.width,height:i.height}}},{key:"getxAxisTitleCoords",value:function(){var t=this.w,e=0,i=0;if(void 0!==t.config.xaxis.title.text){var a=new m(this.dCtx.ctx).getTextRects(t.config.xaxis.title.text,t.config.xaxis.title.style.fontSize);e=a.width,i=a.height;}return {width:e,height:i}}},{key:"getxAxisTimeScaleLabelsCoords",value:function(){var t,e=this.w;this.dCtx.timescaleLabels=e.globals.timescaleLabels.slice();var i=this.dCtx.timescaleLabels.map((function(t){return t.value})),a=i.reduce((function(t,e){return void 0===t?(console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"),0):t.length>e.length?t:e}),0);return 1.05*(t=new m(this.dCtx.ctx).getTextRects(a,e.config.xaxis.labels.style.fontSize)).width*i.length>e.globals.gridWidth&&0!==e.config.xaxis.labels.rotate&&(e.globals.overlappingXLabels=!0),t}},{key:"additionalPaddingXLabels",value:function(t){var e=this,i=this.w,a=i.globals,s=i.config,r=s.xaxis.type,o=t.width;a.skipLastTimelinelabel=!1,a.skipFirstTimelinelabel=!1;var n=i.config.yaxis[0].opposite&&i.globals.isBarHorizontal,l=function(t,n){s.yaxis.length>1&&function(t){return -1!==a.collapsedSeriesIndices.indexOf(t)}(n)||function(t){if(e.dCtx.timescaleLabels&&e.dCtx.timescaleLabels.length){var n=e.dCtx.timescaleLabels[0],l=e.dCtx.timescaleLabels[e.dCtx.timescaleLabels.length-1].position+o/1.75-e.dCtx.yAxisWidthRight,h=n.position-o/1.75+e.dCtx.yAxisWidthLeft,c="right"===i.config.legend.position&&e.dCtx.lgRect.width>0?e.dCtx.lgRect.width:0;l>a.svgWidth-a.translateX-c&&(a.skipLastTimelinelabel=!0),h<-(t.show&&!t.floating||"bar"!==s.chart.type&&"candlestick"!==s.chart.type&&"rangeBar"!==s.chart.type&&"boxPlot"!==s.chart.type?10:o/1.75)&&(a.skipFirstTimelinelabel=!0);}else "datetime"===r?e.dCtx.gridPad.right<o&&!a.rotateXLabels&&(a.skipLastTimelinelabel=!0):"datetime"!==r&&e.dCtx.gridPad.right<o/2-e.dCtx.yAxisWidthRight&&!a.rotateXLabels&&!i.config.xaxis.labels.trim&&("between"!==i.config.xaxis.tickPlacement||i.globals.isBarHorizontal)&&(e.dCtx.xPadRight=o/2+1);}(t);};s.yaxis.forEach((function(t,i){n?(e.dCtx.gridPad.left<o&&(e.dCtx.xPadLeft=o/2+1),e.dCtx.xPadRight=o/2+1):l(t,i);}));}}]),t}(),st=function(){function t(e){a(this,t),this.w=e.w,this.dCtx=e;}return r(t,[{key:"getyAxisLabelsCoords",value:function(){var t=this,e=this.w,i=[],a=10,s=new C(this.dCtx.ctx);return e.config.yaxis.map((function(r,o){var n={seriesIndex:o,dataPointIndex:-1,w:e},l=e.globals.yAxisScale[o],h=0;if(!s.isYAxisHidden(o)&&r.labels.show&&void 0!==r.labels.minWidth&&(h=r.labels.minWidth),!s.isYAxisHidden(o)&&r.labels.show&&l.result.length){var c=e.globals.yLabelFormatters[o],d=l.niceMin===Number.MIN_VALUE?0:l.niceMin,g=l.result.reduce((function(t,e){var i,a;return (null===(i=String(c(t,n)))||void 0===i?void 0:i.length)>(null===(a=String(c(e,n)))||void 0===a?void 0:a.length)?t:e}),d),u=g=c(g,n);if(void 0!==g&&0!==g.length||(g=l.niceMax),e.globals.isBarHorizontal){a=0;var p=e.globals.labels.slice();g=x.getLargestStringFromArr(p),g=c(g,{seriesIndex:o,dataPointIndex:-1,w:e}),u=t.dCtx.dimHelpers.getLargestStringFromMultiArr(g,p);}var f=new m(t.dCtx.ctx),b="rotate(".concat(r.labels.rotate," 0 0)"),v=f.getTextRects(g,r.labels.style.fontSize,r.labels.style.fontFamily,b,!1),y=v;g!==u&&(y=f.getTextRects(u,r.labels.style.fontSize,r.labels.style.fontFamily,b,!1)),i.push({width:(h>y.width||h>v.width?h:y.width>v.width?y.width:v.width)+a,height:y.height>v.height?y.height:v.height});}else i.push({width:0,height:0});})),i}},{key:"getyAxisTitleCoords",value:function(){var t=this,e=this.w,i=[];return e.config.yaxis.map((function(e,a){if(e.show&&void 0!==e.title.text){var s=new m(t.dCtx.ctx),r="rotate(".concat(e.title.rotate," 0 0)"),o=s.getTextRects(e.title.text,e.title.style.fontSize,e.title.style.fontFamily,r,!1);i.push({width:o.width,height:o.height});}else i.push({width:0,height:0});})),i}},{key:"getTotalYAxisWidth",value:function(){var t=this.w,e=0,i=0,a=0,s=t.globals.yAxisScale.length>1?10:0,r=new C(this.dCtx.ctx),o=function(o,n){var l=t.config.yaxis[n].floating,h=0;o.width>0&&!l?(h=o.width+s,function(e){return t.globals.ignoreYAxisIndexes.indexOf(e)>-1}(n)&&(h=h-o.width-s)):h=l||r.isYAxisHidden(n)?0:5,t.config.yaxis[n].opposite?a+=h:i+=h,e+=h;};return t.globals.yLabelsCoords.map((function(t,e){o(t,e);})),t.globals.yTitleCoords.map((function(t,e){o(t,e);})),t.globals.isBarHorizontal&&!t.config.yaxis[0].floating&&(e=t.globals.yLabelsCoords[0].width+t.globals.yTitleCoords[0].width+15),this.dCtx.yAxisWidthLeft=i,this.dCtx.yAxisWidthRight=a,e}}]),t}(),rt=function(){function t(e){a(this,t),this.w=e.w,this.dCtx=e;}return r(t,[{key:"gridPadForColumnsInNumericAxis",value:function(t){var e=this.w,i=e.config,a=e.globals;if(a.noData||a.collapsedSeries.length+a.ancillaryCollapsedSeries.length===i.series.length)return 0;var s=function(t){return "bar"===t||"rangeBar"===t||"candlestick"===t||"boxPlot"===t},r=i.chart.type,o=0,n=s(r)?i.series.length:1;if(a.comboBarCount>0&&(n=a.comboBarCount),a.collapsedSeries.forEach((function(t){s(t.type)&&(n-=1);})),i.chart.stacked&&(n=1),(s(r)||a.comboBarCount>0)&&a.isXNumeric&&!a.isBarHorizontal&&n>0){var l,h,c=Math.abs(a.initialMaxX-a.initialMinX);c<=3&&(c=a.dataPoints),l=c/t,a.minXDiff&&a.minXDiff/l>0&&(h=a.minXDiff/l),h>t/2&&(h/=2),(o=h*parseInt(i.plotOptions.bar.columnWidth,10)/100)<1&&(o=1),a.barPadForNumericAxis=o;}return o}},{key:"gridPadFortitleSubtitle",value:function(){var t=this,e=this.w,i=e.globals,a=this.dCtx.isSparkline||!e.globals.axisCharts?0:10;["title","subtitle"].forEach((function(i){void 0!==e.config[i].text?a+=e.config[i].margin:a+=t.dCtx.isSparkline||!e.globals.axisCharts?0:5;})),!e.config.legend.show||"bottom"!==e.config.legend.position||e.config.legend.floating||e.globals.axisCharts||(a+=10);var s=this.dCtx.dimHelpers.getTitleSubtitleCoords("title"),r=this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");i.gridHeight=i.gridHeight-s.height-r.height-a,i.translateY=i.translateY+s.height+r.height+a;}},{key:"setGridXPosForDualYAxis",value:function(t,e){var i=this.w,a=new C(this.dCtx.ctx);i.config.yaxis.map((function(s,r){-1!==i.globals.ignoreYAxisIndexes.indexOf(r)||s.floating||a.isYAxisHidden(r)||(s.opposite&&(i.globals.translateX=i.globals.translateX-(e[r].width+t[r].width)-parseInt(i.config.yaxis[r].labels.style.fontSize,10)/1.2-12),i.globals.translateX<2&&(i.globals.translateX=2));}));}}]),t}(),ot=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w,this.lgRect={},this.yAxisWidth=0,this.yAxisWidthLeft=0,this.yAxisWidthRight=0,this.xAxisHeight=0,this.isSparkline=this.w.config.chart.sparkline.enabled,this.dimHelpers=new it(this),this.dimYAxis=new st(this),this.dimXAxis=new at(this),this.dimGrid=new rt(this),this.lgWidthForSideLegends=0,this.gridPad=this.w.config.grid.padding,this.xPadRight=0,this.xPadLeft=0;}return r(t,[{key:"plotCoords",value:function(){var t=this,e=this.w,i=e.globals;this.lgRect=this.dimHelpers.getLegendsRect(),this.datalabelsCoords={width:0,height:0};var a=Array.isArray(e.config.stroke.width)?Math.max.apply(Math,u(e.config.stroke.width)):e.config.stroke.width;this.isSparkline&&((e.config.markers.discrete.length>0||e.config.markers.size>0)&&Object.entries(this.gridPad).forEach((function(e){var i=g(e,2),a=i[0],s=i[1];t.gridPad[a]=Math.max(s,t.w.globals.markers.largestSize/1.5);})),this.gridPad.top=Math.max(a/2,this.gridPad.top),this.gridPad.bottom=Math.max(a/2,this.gridPad.bottom)),i.axisCharts?this.setDimensionsForAxisCharts():this.setDimensionsForNonAxisCharts(),this.dimGrid.gridPadFortitleSubtitle(),i.gridHeight=i.gridHeight-this.gridPad.top-this.gridPad.bottom,i.gridWidth=i.gridWidth-this.gridPad.left-this.gridPad.right-this.xPadRight-this.xPadLeft;var s=this.dimGrid.gridPadForColumnsInNumericAxis(i.gridWidth);i.gridWidth=i.gridWidth-2*s,i.translateX=i.translateX+this.gridPad.left+this.xPadLeft+(s>0?s:0),i.translateY=i.translateY+this.gridPad.top;}},{key:"setDimensionsForAxisCharts",value:function(){var t=this,e=this.w,i=e.globals,a=this.dimYAxis.getyAxisLabelsCoords(),s=this.dimYAxis.getyAxisTitleCoords();i.isSlopeChart&&(this.datalabelsCoords=this.dimHelpers.getDatalabelsRect()),e.globals.yLabelsCoords=[],e.globals.yTitleCoords=[],e.config.yaxis.map((function(t,i){e.globals.yLabelsCoords.push({width:a[i].width,index:i}),e.globals.yTitleCoords.push({width:s[i].width,index:i});})),this.yAxisWidth=this.dimYAxis.getTotalYAxisWidth();var r=this.dimXAxis.getxAxisLabelsCoords(),o=this.dimXAxis.getxAxisGroupLabelsCoords(),n=this.dimXAxis.getxAxisTitleCoords();this.conditionalChecksForAxisCoords(r,n,o),i.translateXAxisY=e.globals.rotateXLabels?this.xAxisHeight/8:-4,i.translateXAxisX=e.globals.rotateXLabels&&e.globals.isXNumeric&&e.config.xaxis.labels.rotate<=-45?-this.xAxisWidth/4:0,e.globals.isBarHorizontal&&(i.rotateXLabels=!1,i.translateXAxisY=parseInt(e.config.xaxis.labels.style.fontSize,10)/1.5*-1),i.translateXAxisY=i.translateXAxisY+e.config.xaxis.labels.offsetY,i.translateXAxisX=i.translateXAxisX+e.config.xaxis.labels.offsetX;var l=this.yAxisWidth,h=this.xAxisHeight;i.xAxisLabelsHeight=this.xAxisHeight-n.height,i.xAxisGroupLabelsHeight=i.xAxisLabelsHeight-r.height,i.xAxisLabelsWidth=this.xAxisWidth,i.xAxisHeight=this.xAxisHeight;var c=10;("radar"===e.config.chart.type||this.isSparkline)&&(l=0,h=i.goldenPadding),this.isSparkline&&(this.lgRect={height:0,width:0}),(this.isSparkline||"treemap"===e.config.chart.type)&&(l=0,h=0,c=0),this.isSparkline||this.dimXAxis.additionalPaddingXLabels(r);var d=function(){i.translateX=l+t.datalabelsCoords.width,i.gridHeight=i.svgHeight-t.lgRect.height-h-(t.isSparkline||"treemap"===e.config.chart.type?0:e.globals.rotateXLabels?10:15),i.gridWidth=i.svgWidth-l-2*t.datalabelsCoords.width;};switch("top"===e.config.xaxis.position&&(c=i.xAxisHeight-e.config.xaxis.axisTicks.height-5),e.config.legend.position){case"bottom":i.translateY=c,d();break;case"top":i.translateY=this.lgRect.height+c,d();break;case"left":i.translateY=c,i.translateX=this.lgRect.width+l+this.datalabelsCoords.width,i.gridHeight=i.svgHeight-h-12,i.gridWidth=i.svgWidth-this.lgRect.width-l-2*this.datalabelsCoords.width;break;case"right":i.translateY=c,i.translateX=l+this.datalabelsCoords.width,i.gridHeight=i.svgHeight-h-12,i.gridWidth=i.svgWidth-this.lgRect.width-l-2*this.datalabelsCoords.width-5;break;default:throw new Error("Legend position not supported")}this.dimGrid.setGridXPosForDualYAxis(s,a),new q(this.ctx).setYAxisXPosition(a,s);}},{key:"setDimensionsForNonAxisCharts",value:function(){var t=this.w,e=t.globals,i=t.config,a=0;t.config.legend.show&&!t.config.legend.floating&&(a=20);var s="pie"===i.chart.type||"polarArea"===i.chart.type||"donut"===i.chart.type?"pie":"radialBar",r=i.plotOptions[s].offsetY,o=i.plotOptions[s].offsetX;if(!i.legend.show||i.legend.floating)return e.gridHeight=e.svgHeight-i.grid.padding.left+i.grid.padding.right,e.gridWidth=Math.min(e.svgWidth,e.gridHeight),e.translateY=r,void(e.translateX=o+(e.svgWidth-e.gridWidth)/2);switch(i.legend.position){case"bottom":e.gridHeight=e.svgHeight-this.lgRect.height-e.goldenPadding,e.gridWidth=e.svgWidth,e.translateY=r-10,e.translateX=o+(e.svgWidth-e.gridWidth)/2;break;case"top":e.gridHeight=e.svgHeight-this.lgRect.height-e.goldenPadding,e.gridWidth=e.svgWidth,e.translateY=this.lgRect.height+r+10,e.translateX=o+(e.svgWidth-e.gridWidth)/2;break;case"left":e.gridWidth=e.svgWidth-this.lgRect.width-a,e.gridHeight="auto"!==i.chart.height?e.svgHeight:e.gridWidth,e.translateY=r,e.translateX=o+this.lgRect.width+a;break;case"right":e.gridWidth=e.svgWidth-this.lgRect.width-a-5,e.gridHeight="auto"!==i.chart.height?e.svgHeight:e.gridWidth,e.translateY=r,e.translateX=o+10;break;default:throw new Error("Legend position not supported")}}},{key:"conditionalChecksForAxisCoords",value:function(t,e,i){var a=this.w,s=a.globals.hasXaxisGroups?2:1,r=i.height+t.height+e.height,o=a.globals.isMultiLineX?1.2:a.globals.LINE_HEIGHT_RATIO,n=a.globals.rotateXLabels?22:10,l=a.globals.rotateXLabels&&"bottom"===a.config.legend.position?10:0;this.xAxisHeight=r*o+s*n+l,this.xAxisWidth=t.width,this.xAxisHeight-e.height>a.config.xaxis.labels.maxHeight&&(this.xAxisHeight=a.config.xaxis.labels.maxHeight),a.config.xaxis.labels.minHeight&&this.xAxisHeight<a.config.xaxis.labels.minHeight&&(this.xAxisHeight=a.config.xaxis.labels.minHeight),a.config.xaxis.floating&&(this.xAxisHeight=0);var h=0,c=0;a.config.yaxis.forEach((function(t){h+=t.labels.minWidth,c+=t.labels.maxWidth;})),this.yAxisWidth<h&&(this.yAxisWidth=h),this.yAxisWidth>c&&(this.yAxisWidth=c);}}]),t}(),nt=function(){function t(e){a(this,t),this.w=e.w,this.lgCtx=e;}return r(t,[{key:"getLegendStyles",value:function(){var t,e,i,a=document.createElement("style");a.setAttribute("type","text/css");var s=(null===(t=this.lgCtx.ctx)||void 0===t||null===(e=t.opts)||void 0===e||null===(i=e.chart)||void 0===i?void 0:i.nonce)||this.w.config.chart.nonce;s&&a.setAttribute("nonce",s);var r=document.createTextNode("\n      .apexcharts-legend {\n        display: flex;\n        overflow: auto;\n        padding: 0 10px;\n      }\n      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {\n        flex-wrap: wrap\n      }\n      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n        flex-direction: column;\n        bottom: 0;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n        justify-content: flex-start;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {\n        justify-content: center;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {\n        justify-content: flex-end;\n      }\n      .apexcharts-legend-series {\n        cursor: pointer;\n        line-height: normal;\n      }\n      .apexcharts-legend.apx-legend-position-bottom .apexcharts-legend-series, .apexcharts-legend.apx-legend-position-top .apexcharts-legend-series{\n        display: flex;\n        align-items: center;\n      }\n      .apexcharts-legend-text {\n        position: relative;\n        font-size: 14px;\n      }\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\n        pointer-events: none;\n      }\n      .apexcharts-legend-marker {\n        position: relative;\n        display: inline-block;\n        cursor: pointer;\n        margin-right: 3px;\n        border-style: solid;\n      }\n\n      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{\n        display: inline-block;\n      }\n      .apexcharts-legend-series.apexcharts-no-click {\n        cursor: auto;\n      }\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\n        display: none !important;\n      }\n      .apexcharts-inactive-legend {\n        opacity: 0.45;\n      }");return a.appendChild(r),a}},{key:"getLegendBBox",value:function(){var t=this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(),e=t.width;return {clwh:t.height,clww:e}}},{key:"appendToForeignObject",value:function(){this.w.globals.dom.elLegendForeign.appendChild(this.getLegendStyles());}},{key:"toggleDataSeries",value:function(t,e){var i=this,a=this.w;if(a.globals.axisCharts||"radialBar"===a.config.chart.type){a.globals.resized=!0;var s=null,r=null;if(a.globals.risingSeries=[],a.globals.axisCharts?(s=a.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t,"']")),r=parseInt(s.getAttribute("data:realIndex"),10)):(s=a.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t+1,"']")),r=parseInt(s.getAttribute("rel"),10)-1),e)[{cs:a.globals.collapsedSeries,csi:a.globals.collapsedSeriesIndices},{cs:a.globals.ancillaryCollapsedSeries,csi:a.globals.ancillaryCollapsedSeriesIndices}].forEach((function(t){i.riseCollapsedSeries(t.cs,t.csi,r);}));else this.hideSeries({seriesEl:s,realIndex:r});}else {var o=a.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(t+1,"'] path")),n=a.config.chart.type;if("pie"===n||"polarArea"===n||"donut"===n){var l=a.config.plotOptions.pie.donut.labels;new m(this.lgCtx.ctx).pathMouseDown(o.members[0],null),this.lgCtx.ctx.pie.printDataLabelsInner(o.members[0].node,l);}o.fire("click");}}},{key:"hideSeries",value:function(t){var e=t.seriesEl,i=t.realIndex,a=this.w,s=a.globals,r=x.clone(a.config.series);if(s.axisCharts){var o=a.config.yaxis[s.seriesYAxisReverseMap[i]];if(o&&o.show&&o.showAlways)s.ancillaryCollapsedSeriesIndices.indexOf(i)<0&&(s.ancillaryCollapsedSeries.push({index:i,data:r[i].data.slice(),type:e.parentNode.className.baseVal.split("-")[1]}),s.ancillaryCollapsedSeriesIndices.push(i));else if(s.collapsedSeriesIndices.indexOf(i)<0){s.collapsedSeries.push({index:i,data:r[i].data.slice(),type:e.parentNode.className.baseVal.split("-")[1]}),s.collapsedSeriesIndices.push(i);var n=s.risingSeries.indexOf(i);s.risingSeries.splice(n,1);}}else s.collapsedSeries.push({index:i,data:r[i]}),s.collapsedSeriesIndices.push(i);for(var l=e.childNodes,h=0;h<l.length;h++)l[h].classList.contains("apexcharts-series-markers-wrap")&&(l[h].classList.contains("apexcharts-hide")?l[h].classList.remove("apexcharts-hide"):l[h].classList.add("apexcharts-hide"));s.allSeriesCollapsed=s.collapsedSeries.length+s.ancillaryCollapsedSeries.length===a.config.series.length,r=this._getSeriesBasedOnCollapsedState(r),this.lgCtx.ctx.updateHelpers._updateSeries(r,a.config.chart.animations.dynamicAnimation.enabled);}},{key:"riseCollapsedSeries",value:function(t,e,i){var a=this.w,s=x.clone(a.config.series);if(t.length>0){for(var r=0;r<t.length;r++)t[r].index===i&&(a.globals.axisCharts?(s[i].data=t[r].data.slice(),t.splice(r,1),e.splice(r,1),a.globals.risingSeries.push(i)):(s[i]=t[r].data,t.splice(r,1),e.splice(r,1),a.globals.risingSeries.push(i)));s=this._getSeriesBasedOnCollapsedState(s),this.lgCtx.ctx.updateHelpers._updateSeries(s,a.config.chart.animations.dynamicAnimation.enabled);}}},{key:"_getSeriesBasedOnCollapsedState",value:function(t){var e=this.w,i=0;return e.globals.axisCharts?t.forEach((function(a,s){e.globals.collapsedSeriesIndices.indexOf(s)<0&&e.globals.ancillaryCollapsedSeriesIndices.indexOf(s)<0||(t[s].data=[],i++);})):t.forEach((function(a,s){!e.globals.collapsedSeriesIndices.indexOf(s)<0&&(t[s]=0,i++);})),e.globals.allSeriesCollapsed=i===t.length,t}}]),t}(),lt=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w,this.onLegendClick=this.onLegendClick.bind(this),this.onLegendHovered=this.onLegendHovered.bind(this),this.isBarsDistributed="bar"===this.w.config.chart.type&&this.w.config.plotOptions.bar.distributed&&1===this.w.config.series.length,this.legendHelpers=new nt(this);}return r(t,[{key:"init",value:function(){var t=this.w,e=t.globals,i=t.config;if((i.legend.showForSingleSeries&&1===e.series.length||this.isBarsDistributed||e.series.length>1||!e.axisCharts)&&i.legend.show){for(;e.dom.elLegendWrap.firstChild;)e.dom.elLegendWrap.removeChild(e.dom.elLegendWrap.firstChild);this.drawLegends(),x.isIE11()?document.getElementsByTagName("head")[0].appendChild(this.legendHelpers.getLegendStyles()):this.legendHelpers.appendToForeignObject(),"bottom"===i.legend.position||"top"===i.legend.position?this.legendAlignHorizontal():"right"!==i.legend.position&&"left"!==i.legend.position||this.legendAlignVertical();}}},{key:"drawLegends",value:function(){var t=this,e=this.w,i=e.config.legend.fontFamily,a=e.globals.seriesNames,s=e.globals.colors.slice();if("heatmap"===e.config.chart.type){var r=e.config.plotOptions.heatmap.colorScale.ranges;a=r.map((function(t){return t.name?t.name:t.from+" - "+t.to})),s=r.map((function(t){return t.color}));}else this.isBarsDistributed&&(a=e.globals.labels.slice());e.config.legend.customLegendItems.length&&(a=e.config.legend.customLegendItems);for(var o=e.globals.legendFormatter,n=e.config.legend.inverseOrder,l=n?a.length-1:0;n?l>=0:l<=a.length-1;n?l--:l++){var h,c=o(a[l],{seriesIndex:l,w:e}),d=!1,g=!1;if(e.globals.collapsedSeries.length>0)for(var u=0;u<e.globals.collapsedSeries.length;u++)e.globals.collapsedSeries[u].index===l&&(d=!0);if(e.globals.ancillaryCollapsedSeriesIndices.length>0)for(var p=0;p<e.globals.ancillaryCollapsedSeriesIndices.length;p++)e.globals.ancillaryCollapsedSeriesIndices[p]===l&&(g=!0);var f=document.createElement("span");f.classList.add("apexcharts-legend-marker");var b=e.config.legend.markers.offsetX,v=e.config.legend.markers.offsetY,w=e.config.legend.markers.height,k=e.config.legend.markers.width,A=e.config.legend.markers.strokeWidth,S=e.config.legend.markers.strokeColor,C=e.config.legend.markers.radius,L=f.style;L.background=s[l],L.color=s[l],L.setProperty("background",s[l],"important"),e.config.legend.markers.fillColors&&e.config.legend.markers.fillColors[l]&&(L.background=e.config.legend.markers.fillColors[l]),void 0!==e.globals.seriesColors[l]&&(L.background=e.globals.seriesColors[l],L.color=e.globals.seriesColors[l]),L.height=Array.isArray(w)?parseFloat(w[l])+"px":parseFloat(w)+"px",L.width=Array.isArray(k)?parseFloat(k[l])+"px":parseFloat(k)+"px",L.left=(Array.isArray(b)?parseFloat(b[l]):parseFloat(b))+"px",L.top=(Array.isArray(v)?parseFloat(v[l]):parseFloat(v))+"px",L.borderWidth=Array.isArray(A)?A[l]:A,L.borderColor=Array.isArray(S)?S[l]:S,L.borderRadius=Array.isArray(C)?parseFloat(C[l])+"px":parseFloat(C)+"px",e.config.legend.markers.customHTML&&(Array.isArray(e.config.legend.markers.customHTML)?e.config.legend.markers.customHTML[l]&&(f.innerHTML=e.config.legend.markers.customHTML[l]()):f.innerHTML=e.config.legend.markers.customHTML()),m.setAttrs(f,{rel:l+1,"data:collapsed":d||g}),(d||g)&&f.classList.add("apexcharts-inactive-legend");var P=document.createElement("div"),M=document.createElement("span");M.classList.add("apexcharts-legend-text"),M.innerHTML=Array.isArray(c)?c.join(" "):c;var I=e.config.legend.labels.useSeriesColors?e.globals.colors[l]:Array.isArray(e.config.legend.labels.colors)?null===(h=e.config.legend.labels.colors)||void 0===h?void 0:h[l]:e.config.legend.labels.colors;I||(I=e.config.chart.foreColor),M.style.color=I,M.style.fontSize=parseFloat(e.config.legend.fontSize)+"px",M.style.fontWeight=e.config.legend.fontWeight,M.style.fontFamily=i||e.config.chart.fontFamily,m.setAttrs(M,{rel:l+1,i:l,"data:default-text":encodeURIComponent(c),"data:collapsed":d||g}),P.appendChild(f),P.appendChild(M);var T=new y(this.ctx);if(!e.config.legend.showForZeroSeries)0===T.getSeriesTotalByIndex(l)&&T.seriesHaveSameValues(l)&&!T.isSeriesNull(l)&&-1===e.globals.collapsedSeriesIndices.indexOf(l)&&-1===e.globals.ancillaryCollapsedSeriesIndices.indexOf(l)&&P.classList.add("apexcharts-hidden-zero-series");e.config.legend.showForNullSeries||T.isSeriesNull(l)&&-1===e.globals.collapsedSeriesIndices.indexOf(l)&&-1===e.globals.ancillaryCollapsedSeriesIndices.indexOf(l)&&P.classList.add("apexcharts-hidden-null-series"),e.globals.dom.elLegendWrap.appendChild(P),e.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(e.config.legend.horizontalAlign)),e.globals.dom.elLegendWrap.classList.add("apx-legend-position-"+e.config.legend.position),P.classList.add("apexcharts-legend-series"),P.style.margin="".concat(e.config.legend.itemMargin.vertical,"px ").concat(e.config.legend.itemMargin.horizontal,"px"),e.globals.dom.elLegendWrap.style.width=e.config.legend.width?e.config.legend.width+"px":"",e.globals.dom.elLegendWrap.style.height=e.config.legend.height?e.config.legend.height+"px":"",m.setAttrs(P,{rel:l+1,seriesName:x.escapeString(a[l]),"data:collapsed":d||g}),(d||g)&&P.classList.add("apexcharts-inactive-legend"),e.config.legend.onItemClick.toggleDataSeries||P.classList.add("apexcharts-no-click");}e.globals.dom.elWrap.addEventListener("click",t.onLegendClick,!0),e.config.legend.onItemHover.highlightDataSeries&&0===e.config.legend.customLegendItems.length&&(e.globals.dom.elWrap.addEventListener("mousemove",t.onLegendHovered,!0),e.globals.dom.elWrap.addEventListener("mouseout",t.onLegendHovered,!0));}},{key:"setLegendWrapXY",value:function(t,e){var i=this.w,a=i.globals.dom.elLegendWrap,s=a.getBoundingClientRect(),r=0,o=0;if("bottom"===i.config.legend.position)o+=i.globals.svgHeight-s.height/2;else if("top"===i.config.legend.position){var n=new ot(this.ctx),l=n.dimHelpers.getTitleSubtitleCoords("title").height,h=n.dimHelpers.getTitleSubtitleCoords("subtitle").height;o=o+(l>0?l-10:0)+(h>0?h-10:0);}a.style.position="absolute",r=r+t+i.config.legend.offsetX,o=o+e+i.config.legend.offsetY,a.style.left=r+"px",a.style.top=o+"px","bottom"===i.config.legend.position?(a.style.top="auto",a.style.bottom=5-i.config.legend.offsetY+"px"):"right"===i.config.legend.position&&(a.style.left="auto",a.style.right=25+i.config.legend.offsetX+"px");["width","height"].forEach((function(t){a.style[t]&&(a.style[t]=parseInt(i.config.legend[t],10)+"px");}));}},{key:"legendAlignHorizontal",value:function(){var t=this.w;t.globals.dom.elLegendWrap.style.right=0;var e=this.legendHelpers.getLegendBBox(),i=new ot(this.ctx),a=i.dimHelpers.getTitleSubtitleCoords("title"),s=i.dimHelpers.getTitleSubtitleCoords("subtitle"),r=0;"bottom"===t.config.legend.position?r=-e.clwh/1.8:"top"===t.config.legend.position&&(r=a.height+s.height+t.config.title.margin+t.config.subtitle.margin-10),this.setLegendWrapXY(20,r);}},{key:"legendAlignVertical",value:function(){var t=this.w,e=this.legendHelpers.getLegendBBox(),i=0;"left"===t.config.legend.position&&(i=20),"right"===t.config.legend.position&&(i=t.globals.svgWidth-e.clww-10),this.setLegendWrapXY(i,20);}},{key:"onLegendHovered",value:function(t){var e=this.w,i=t.target.classList.contains("apexcharts-legend-series")||t.target.classList.contains("apexcharts-legend-text")||t.target.classList.contains("apexcharts-legend-marker");if("heatmap"===e.config.chart.type||this.isBarsDistributed){if(i){var a=parseInt(t.target.getAttribute("rel"),10)-1;this.ctx.events.fireEvent("legendHover",[this.ctx,a,this.w]),new W(this.ctx).highlightRangeInSeries(t,t.target);}}else !t.target.classList.contains("apexcharts-inactive-legend")&&i&&new W(this.ctx).toggleSeriesOnHover(t,t.target);}},{key:"onLegendClick",value:function(t){var e=this.w;if(!e.config.legend.customLegendItems.length&&(t.target.classList.contains("apexcharts-legend-series")||t.target.classList.contains("apexcharts-legend-text")||t.target.classList.contains("apexcharts-legend-marker"))){var i=parseInt(t.target.getAttribute("rel"),10)-1,a="true"===t.target.getAttribute("data:collapsed"),s=this.w.config.chart.events.legendClick;"function"==typeof s&&s(this.ctx,i,this.w),this.ctx.events.fireEvent("legendClick",[this.ctx,i,this.w]);var r=this.w.config.legend.markers.onClick;"function"==typeof r&&t.target.classList.contains("apexcharts-legend-marker")&&(r(this.ctx,i,this.w),this.ctx.events.fireEvent("legendMarkerClick",[this.ctx,i,this.w])),"treemap"!==e.config.chart.type&&"heatmap"!==e.config.chart.type&&!this.isBarsDistributed&&e.config.legend.onItemClick.toggleDataSeries&&this.legendHelpers.toggleDataSeries(i,a);}}}]),t}(),ht=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w;var i=this.w;this.ev=this.w.config.chart.events,this.selectedClass="apexcharts-selected",this.localeValues=this.w.globals.locale.toolbar,this.minX=i.globals.minX,this.maxX=i.globals.maxX;}return r(t,[{key:"createToolbar",value:function(){var t=this,e=this.w,i=function(){return document.createElement("div")},a=i();if(a.setAttribute("class","apexcharts-toolbar"),a.style.top=e.config.chart.toolbar.offsetY+"px",a.style.right=3-e.config.chart.toolbar.offsetX+"px",e.globals.dom.elWrap.appendChild(a),this.elZoom=i(),this.elZoomIn=i(),this.elZoomOut=i(),this.elPan=i(),this.elSelection=i(),this.elZoomReset=i(),this.elMenuIcon=i(),this.elMenu=i(),this.elCustomIcons=[],this.t=e.config.chart.toolbar.tools,Array.isArray(this.t.customIcons))for(var s=0;s<this.t.customIcons.length;s++)this.elCustomIcons.push(i());var r=[],o=function(i,a,s){var o=i.toLowerCase();t.t[o]&&e.config.chart.zoom.enabled&&r.push({el:a,icon:"string"==typeof t.t[o]?t.t[o]:s,title:t.localeValues[i],class:"apexcharts-".concat(o,"-icon")});};o("zoomIn",this.elZoomIn,'<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'),o("zoomOut",this.elZoomOut,'<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n');var n=function(i){t.t[i]&&e.config.chart[i].enabled&&r.push({el:"zoom"===i?t.elZoom:t.elSelection,icon:"string"==typeof t.t[i]?t.t[i]:"zoom"===i?'<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>':'<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>',title:t.localeValues["zoom"===i?"selectionZoom":"selection"],class:e.globals.isTouchDevice?"apexcharts-element-hidden":"apexcharts-".concat(i,"-icon")});};n("zoom"),n("selection"),this.t.pan&&e.config.chart.zoom.enabled&&r.push({el:this.elPan,icon:"string"==typeof this.t.pan?this.t.pan:'<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>',title:this.localeValues.pan,class:e.globals.isTouchDevice?"apexcharts-element-hidden":"apexcharts-pan-icon"}),o("reset",this.elZoomReset,'<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>'),this.t.download&&r.push({el:this.elMenuIcon,icon:"string"==typeof this.t.download?this.t.download:'<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>',title:this.localeValues.menu,class:"apexcharts-menu-icon"});for(var l=0;l<this.elCustomIcons.length;l++)r.push({el:this.elCustomIcons[l],icon:this.t.customIcons[l].icon,title:this.t.customIcons[l].title,index:this.t.customIcons[l].index,class:"apexcharts-toolbar-custom-icon "+this.t.customIcons[l].class});r.forEach((function(t,e){t.index&&x.moveIndexInArray(r,e,t.index);}));for(var h=0;h<r.length;h++)m.setAttrs(r[h].el,{class:r[h].class,title:r[h].title}),r[h].el.innerHTML=r[h].icon,a.appendChild(r[h].el);this._createHamburgerMenu(a),e.globals.zoomEnabled?this.elZoom.classList.add(this.selectedClass):e.globals.panEnabled?this.elPan.classList.add(this.selectedClass):e.globals.selectionEnabled&&this.elSelection.classList.add(this.selectedClass),this.addToolbarEventListeners();}},{key:"_createHamburgerMenu",value:function(t){this.elMenuItems=[],t.appendChild(this.elMenu),m.setAttrs(this.elMenu,{class:"apexcharts-menu"});for(var e=[{name:"exportSVG",title:this.localeValues.exportToSVG},{name:"exportPNG",title:this.localeValues.exportToPNG},{name:"exportCSV",title:this.localeValues.exportToCSV}],i=0;i<e.length;i++)this.elMenuItems.push(document.createElement("div")),this.elMenuItems[i].innerHTML=e[i].title,m.setAttrs(this.elMenuItems[i],{class:"apexcharts-menu-item ".concat(e[i].name),title:e[i].title}),this.elMenu.appendChild(this.elMenuItems[i]);}},{key:"addToolbarEventListeners",value:function(){var t=this;this.elZoomReset.addEventListener("click",this.handleZoomReset.bind(this)),this.elSelection.addEventListener("click",this.toggleZoomSelection.bind(this,"selection")),this.elZoom.addEventListener("click",this.toggleZoomSelection.bind(this,"zoom")),this.elZoomIn.addEventListener("click",this.handleZoomIn.bind(this)),this.elZoomOut.addEventListener("click",this.handleZoomOut.bind(this)),this.elPan.addEventListener("click",this.togglePanning.bind(this)),this.elMenuIcon.addEventListener("click",this.toggleMenu.bind(this)),this.elMenuItems.forEach((function(e){e.classList.contains("exportSVG")?e.addEventListener("click",t.handleDownload.bind(t,"svg")):e.classList.contains("exportPNG")?e.addEventListener("click",t.handleDownload.bind(t,"png")):e.classList.contains("exportCSV")&&e.addEventListener("click",t.handleDownload.bind(t,"csv"));}));for(var e=0;e<this.t.customIcons.length;e++)this.elCustomIcons[e].addEventListener("click",this.t.customIcons[e].click.bind(this,this.ctx,this.ctx.w));}},{key:"toggleZoomSelection",value:function(t){this.ctx.getSyncedCharts().forEach((function(e){e.ctx.toolbar.toggleOtherControls();var i="selection"===t?e.ctx.toolbar.elSelection:e.ctx.toolbar.elZoom,a="selection"===t?"selectionEnabled":"zoomEnabled";e.w.globals[a]=!e.w.globals[a],i.classList.contains(e.ctx.toolbar.selectedClass)?i.classList.remove(e.ctx.toolbar.selectedClass):i.classList.add(e.ctx.toolbar.selectedClass);}));}},{key:"getToolbarIconsReference",value:function(){var t=this.w;this.elZoom||(this.elZoom=t.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")),this.elPan||(this.elPan=t.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")),this.elSelection||(this.elSelection=t.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"));}},{key:"enableZoomPanFromToolbar",value:function(t){this.toggleOtherControls(),"pan"===t?this.w.globals.panEnabled=!0:this.w.globals.zoomEnabled=!0;var e="pan"===t?this.elPan:this.elZoom,i="pan"===t?this.elZoom:this.elPan;e&&e.classList.add(this.selectedClass),i&&i.classList.remove(this.selectedClass);}},{key:"togglePanning",value:function(){this.ctx.getSyncedCharts().forEach((function(t){t.ctx.toolbar.toggleOtherControls(),t.w.globals.panEnabled=!t.w.globals.panEnabled,t.ctx.toolbar.elPan.classList.contains(t.ctx.toolbar.selectedClass)?t.ctx.toolbar.elPan.classList.remove(t.ctx.toolbar.selectedClass):t.ctx.toolbar.elPan.classList.add(t.ctx.toolbar.selectedClass);}));}},{key:"toggleOtherControls",value:function(){var t=this,e=this.w;e.globals.panEnabled=!1,e.globals.zoomEnabled=!1,e.globals.selectionEnabled=!1,this.getToolbarIconsReference(),[this.elPan,this.elSelection,this.elZoom].forEach((function(e){e&&e.classList.remove(t.selectedClass);}));}},{key:"handleZoomIn",value:function(){var t=this.w;t.globals.isRangeBar&&(this.minX=t.globals.minY,this.maxX=t.globals.maxY);var e=(this.minX+this.maxX)/2,i=(this.minX+e)/2,a=(this.maxX+e)/2,s=this._getNewMinXMaxX(i,a);t.globals.disableZoomIn||this.zoomUpdateOptions(s.minX,s.maxX);}},{key:"handleZoomOut",value:function(){var t=this.w;if(t.globals.isRangeBar&&(this.minX=t.globals.minY,this.maxX=t.globals.maxY),!("datetime"===t.config.xaxis.type&&new Date(this.minX).getUTCFullYear()<1e3)){var e=(this.minX+this.maxX)/2,i=this.minX-(e-this.minX),a=this.maxX-(e-this.maxX),s=this._getNewMinXMaxX(i,a);t.globals.disableZoomOut||this.zoomUpdateOptions(s.minX,s.maxX);}}},{key:"_getNewMinXMaxX",value:function(t,e){var i=this.w.config.xaxis.convertedCatToNumeric;return {minX:i?Math.floor(t):t,maxX:i?Math.floor(e):e}}},{key:"zoomUpdateOptions",value:function(t,e){var i=this.w;if(void 0!==t||void 0!==e){if(!(i.config.xaxis.convertedCatToNumeric&&(t<1&&(t=1,e=i.globals.dataPoints),e-t<2))){var a={min:t,max:e},s=this.getBeforeZoomRange(a);s&&(a=s.xaxis);var r={xaxis:a},o=x.clone(i.globals.initialConfig.yaxis);i.config.chart.group||(r.yaxis=o),this.w.globals.zoomed=!0,this.ctx.updateHelpers._updateOptions(r,!1,this.w.config.chart.animations.dynamicAnimation.enabled),this.zoomCallback(a,o);}}else this.handleZoomReset();}},{key:"zoomCallback",value:function(t,e){"function"==typeof this.ev.zoomed&&this.ev.zoomed(this.ctx,{xaxis:t,yaxis:e});}},{key:"getBeforeZoomRange",value:function(t,e){var i=null;return "function"==typeof this.ev.beforeZoom&&(i=this.ev.beforeZoom(this,{xaxis:t,yaxis:e})),i}},{key:"toggleMenu",value:function(){var t=this;window.setTimeout((function(){t.elMenu.classList.contains("apexcharts-menu-open")?t.elMenu.classList.remove("apexcharts-menu-open"):t.elMenu.classList.add("apexcharts-menu-open");}),0);}},{key:"handleDownload",value:function(t){var e=this.w,i=new G(this.ctx);switch(t){case"svg":i.exportToSVG(this.ctx);break;case"png":i.exportToPng(this.ctx);break;case"csv":i.exportToCSV({series:e.config.series,columnDelimiter:e.config.chart.toolbar.export.csv.columnDelimiter});}}},{key:"handleZoomReset",value:function(t){this.ctx.getSyncedCharts().forEach((function(t){var e=t.w;if(e.globals.lastXAxis.min=e.globals.initialConfig.xaxis.min,e.globals.lastXAxis.max=e.globals.initialConfig.xaxis.max,t.updateHelpers.revertDefaultAxisMinMax(),"function"==typeof e.config.chart.events.beforeResetZoom){var i=e.config.chart.events.beforeResetZoom(t,e);i&&t.updateHelpers.revertDefaultAxisMinMax(i);}"function"==typeof e.config.chart.events.zoomed&&t.ctx.toolbar.zoomCallback({min:e.config.xaxis.min,max:e.config.xaxis.max}),e.globals.zoomed=!1;var a=t.ctx.series.emptyCollapsedSeries(x.clone(e.globals.initialSeries));t.updateHelpers._updateSeries(a,e.config.chart.animations.dynamicAnimation.enabled);}));}},{key:"destroy",value:function(){this.elZoom=null,this.elZoomIn=null,this.elZoomOut=null,this.elPan=null,this.elSelection=null,this.elZoomReset=null,this.elMenuIcon=null;}}]),t}(),ct=function(t){n(i,ht);var e=d(i);function i(t){var s;return a(this,i),(s=e.call(this,t)).ctx=t,s.w=t.w,s.dragged=!1,s.graphics=new m(s.ctx),s.eventList=["mousedown","mouseleave","mousemove","touchstart","touchmove","mouseup","touchend"],s.clientX=0,s.clientY=0,s.startX=0,s.endX=0,s.dragX=0,s.startY=0,s.endY=0,s.dragY=0,s.moveDirection="none",s}return r(i,[{key:"init",value:function(t){var e=this,i=t.xyRatios,a=this.w,s=this;this.xyRatios=i,this.zoomRect=this.graphics.drawRect(0,0,0,0),this.selectionRect=this.graphics.drawRect(0,0,0,0),this.gridRect=a.globals.dom.baseEl.querySelector(".apexcharts-grid"),this.zoomRect.node.classList.add("apexcharts-zoom-rect"),this.selectionRect.node.classList.add("apexcharts-selection-rect"),a.globals.dom.elGraphical.add(this.zoomRect),a.globals.dom.elGraphical.add(this.selectionRect),"x"===a.config.chart.selection.type?this.slDraggableRect=this.selectionRect.draggable({minX:0,minY:0,maxX:a.globals.gridWidth,maxY:a.globals.gridHeight}).on("dragmove",this.selectionDragging.bind(this,"dragging")):"y"===a.config.chart.selection.type?this.slDraggableRect=this.selectionRect.draggable({minX:0,maxX:a.globals.gridWidth}).on("dragmove",this.selectionDragging.bind(this,"dragging")):this.slDraggableRect=this.selectionRect.draggable().on("dragmove",this.selectionDragging.bind(this,"dragging")),this.preselectedSelection(),this.hoverArea=a.globals.dom.baseEl.querySelector("".concat(a.globals.chartClass," .apexcharts-svg")),this.hoverArea.classList.add("apexcharts-zoomable"),this.eventList.forEach((function(t){e.hoverArea.addEventListener(t,s.svgMouseEvents.bind(s,i),{capture:!1,passive:!0});}));}},{key:"destroy",value:function(){this.slDraggableRect&&(this.slDraggableRect.draggable(!1),this.slDraggableRect.off(),this.selectionRect.off()),this.selectionRect=null,this.zoomRect=null,this.gridRect=null;}},{key:"svgMouseEvents",value:function(t,e){var i=this.w,a=this,s=this.ctx.toolbar,r=i.globals.zoomEnabled?i.config.chart.zoom.type:i.config.chart.selection.type,o=i.config.chart.toolbar.autoSelected;if(e.shiftKey?(this.shiftWasPressed=!0,s.enableZoomPanFromToolbar("pan"===o?"zoom":"pan")):this.shiftWasPressed&&(s.enableZoomPanFromToolbar(o),this.shiftWasPressed=!1),e.target){var n,l=e.target.classList;if(e.target.parentNode&&null!==e.target.parentNode&&(n=e.target.parentNode.classList),!(l.contains("apexcharts-selection-rect")||l.contains("apexcharts-legend-marker")||l.contains("apexcharts-legend-text")||n&&n.contains("apexcharts-toolbar"))){if(a.clientX="touchmove"===e.type||"touchstart"===e.type?e.touches[0].clientX:"touchend"===e.type?e.changedTouches[0].clientX:e.clientX,a.clientY="touchmove"===e.type||"touchstart"===e.type?e.touches[0].clientY:"touchend"===e.type?e.changedTouches[0].clientY:e.clientY,"mousedown"===e.type&&1===e.which){var h=a.gridRect.getBoundingClientRect();a.startX=a.clientX-h.left,a.startY=a.clientY-h.top,a.dragged=!1,a.w.globals.mousedown=!0;}if(("mousemove"===e.type&&1===e.which||"touchmove"===e.type)&&(a.dragged=!0,i.globals.panEnabled?(i.globals.selection=null,a.w.globals.mousedown&&a.panDragging({context:a,zoomtype:r,xyRatios:t})):(a.w.globals.mousedown&&i.globals.zoomEnabled||a.w.globals.mousedown&&i.globals.selectionEnabled)&&(a.selection=a.selectionDrawing({context:a,zoomtype:r}))),"mouseup"===e.type||"touchend"===e.type||"mouseleave"===e.type){var c=a.gridRect.getBoundingClientRect();a.w.globals.mousedown&&(a.endX=a.clientX-c.left,a.endY=a.clientY-c.top,a.dragX=Math.abs(a.endX-a.startX),a.dragY=Math.abs(a.endY-a.startY),(i.globals.zoomEnabled||i.globals.selectionEnabled)&&a.selectionDrawn({context:a,zoomtype:r}),i.globals.panEnabled&&i.config.xaxis.convertedCatToNumeric&&a.delayedPanScrolled()),i.globals.zoomEnabled&&a.hideSelectionRect(this.selectionRect),a.dragged=!1,a.w.globals.mousedown=!1;}this.makeSelectionRectDraggable();}}}},{key:"makeSelectionRectDraggable",value:function(){var t=this.w;if(this.selectionRect){var e=this.selectionRect.node.getBoundingClientRect();e.width>0&&e.height>0&&this.slDraggableRect.selectize({points:"l, r",pointSize:8,pointType:"rect"}).resize({constraint:{minX:0,minY:0,maxX:t.globals.gridWidth,maxY:t.globals.gridHeight}}).on("resizing",this.selectionDragging.bind(this,"resizing"));}}},{key:"preselectedSelection",value:function(){var t=this.w,e=this.xyRatios;if(!t.globals.zoomEnabled)if(void 0!==t.globals.selection&&null!==t.globals.selection)this.drawSelectionRect(t.globals.selection);else if(void 0!==t.config.chart.selection.xaxis.min&&void 0!==t.config.chart.selection.xaxis.max){var i=(t.config.chart.selection.xaxis.min-t.globals.minX)/e.xRatio,a=t.globals.gridWidth-(t.globals.maxX-t.config.chart.selection.xaxis.max)/e.xRatio-i;t.globals.isRangeBar&&(i=(t.config.chart.selection.xaxis.min-t.globals.yAxisScale[0].niceMin)/e.invertedYRatio,a=(t.config.chart.selection.xaxis.max-t.config.chart.selection.xaxis.min)/e.invertedYRatio);var s={x:i,y:0,width:a,height:t.globals.gridHeight,translateX:0,translateY:0,selectionEnabled:!0};this.drawSelectionRect(s),this.makeSelectionRectDraggable(),"function"==typeof t.config.chart.events.selection&&t.config.chart.events.selection(this.ctx,{xaxis:{min:t.config.chart.selection.xaxis.min,max:t.config.chart.selection.xaxis.max},yaxis:{}});}}},{key:"drawSelectionRect",value:function(t){var e=t.x,i=t.y,a=t.width,s=t.height,r=t.translateX,o=void 0===r?0:r,n=t.translateY,l=void 0===n?0:n,h=this.w,c=this.zoomRect,d=this.selectionRect;if(this.dragged||null!==h.globals.selection){var g={transform:"translate("+o+", "+l+")"};h.globals.zoomEnabled&&this.dragged&&(a<0&&(a=1),c.attr({x:e,y:i,width:a,height:s,fill:h.config.chart.zoom.zoomedArea.fill.color,"fill-opacity":h.config.chart.zoom.zoomedArea.fill.opacity,stroke:h.config.chart.zoom.zoomedArea.stroke.color,"stroke-width":h.config.chart.zoom.zoomedArea.stroke.width,"stroke-opacity":h.config.chart.zoom.zoomedArea.stroke.opacity}),m.setAttrs(c.node,g)),h.globals.selectionEnabled&&(d.attr({x:e,y:i,width:a>0?a:0,height:s>0?s:0,fill:h.config.chart.selection.fill.color,"fill-opacity":h.config.chart.selection.fill.opacity,stroke:h.config.chart.selection.stroke.color,"stroke-width":h.config.chart.selection.stroke.width,"stroke-dasharray":h.config.chart.selection.stroke.dashArray,"stroke-opacity":h.config.chart.selection.stroke.opacity}),m.setAttrs(d.node,g));}}},{key:"hideSelectionRect",value:function(t){t&&t.attr({x:0,y:0,width:0,height:0});}},{key:"selectionDrawing",value:function(t){var e=t.context,i=t.zoomtype,a=this.w,s=e,r=this.gridRect.getBoundingClientRect(),o=s.startX-1,n=s.startY,l=!1,h=!1,c=s.clientX-r.left-o,d=s.clientY-r.top-n,g={};return Math.abs(c+o)>a.globals.gridWidth?c=a.globals.gridWidth-o:s.clientX-r.left<0&&(c=o),o>s.clientX-r.left&&(l=!0,c=Math.abs(c)),n>s.clientY-r.top&&(h=!0,d=Math.abs(d)),g="x"===i?{x:l?o-c:o,y:0,width:c,height:a.globals.gridHeight}:"y"===i?{x:0,y:h?n-d:n,width:a.globals.gridWidth,height:d}:{x:l?o-c:o,y:h?n-d:n,width:c,height:d},s.drawSelectionRect(g),s.selectionDragging("resizing"),g}},{key:"selectionDragging",value:function(t,e){var i=this,a=this.w,s=this.xyRatios,r=this.selectionRect,o=0;"resizing"===t&&(o=30);var n=function(t){return parseFloat(r.node.getAttribute(t))},l={x:n("x"),y:n("y"),width:n("width"),height:n("height")};a.globals.selection=l,"function"==typeof a.config.chart.events.selection&&a.globals.selectionEnabled&&(clearTimeout(this.w.globals.selectionResizeTimer),this.w.globals.selectionResizeTimer=window.setTimeout((function(){var t,e,o,n,l=i.gridRect.getBoundingClientRect(),h=r.node.getBoundingClientRect();a.globals.isRangeBar?(t=a.globals.yAxisScale[0].niceMin+(h.left-l.left)*s.invertedYRatio,e=a.globals.yAxisScale[0].niceMin+(h.right-l.left)*s.invertedYRatio,o=0,n=1):(t=a.globals.xAxisScale.niceMin+(h.left-l.left)*s.xRatio,e=a.globals.xAxisScale.niceMin+(h.right-l.left)*s.xRatio,o=a.globals.yAxisScale[0].niceMin+(l.bottom-h.bottom)*s.yRatio[0],n=a.globals.yAxisScale[0].niceMax-(h.top-l.top)*s.yRatio[0]);var c={xaxis:{min:t,max:e},yaxis:{min:o,max:n}};a.config.chart.events.selection(i.ctx,c),a.config.chart.brush.enabled&&void 0!==a.config.chart.events.brushScrolled&&a.config.chart.events.brushScrolled(i.ctx,c);}),o));}},{key:"selectionDrawn",value:function(t){var e=t.context,i=t.zoomtype,a=this.w,s=e,r=this.xyRatios,o=this.ctx.toolbar;if(s.startX>s.endX){var n=s.startX;s.startX=s.endX,s.endX=n;}if(s.startY>s.endY){var l=s.startY;s.startY=s.endY,s.endY=l;}var h=void 0,c=void 0;a.globals.isRangeBar?(h=a.globals.yAxisScale[0].niceMin+s.startX*r.invertedYRatio,c=a.globals.yAxisScale[0].niceMin+s.endX*r.invertedYRatio):(h=a.globals.xAxisScale.niceMin+s.startX*r.xRatio,c=a.globals.xAxisScale.niceMin+s.endX*r.xRatio);var d=[],g=[];if(a.config.yaxis.forEach((function(t,e){if(a.globals.seriesYAxisMap[e].length>0){var i=a.globals.seriesYAxisMap[e][0];d.push(a.globals.yAxisScale[e].niceMax-r.yRatio[i]*s.startY),g.push(a.globals.yAxisScale[e].niceMax-r.yRatio[i]*s.endY);}})),s.dragged&&(s.dragX>10||s.dragY>10)&&h!==c)if(a.globals.zoomEnabled){var u=x.clone(a.globals.initialConfig.yaxis),p=x.clone(a.globals.initialConfig.xaxis);if(a.globals.zoomed=!0,a.config.xaxis.convertedCatToNumeric&&(h=Math.floor(h),c=Math.floor(c),h<1&&(h=1,c=a.globals.dataPoints),c-h<2&&(c=h+1)),"xy"!==i&&"x"!==i||(p={min:h,max:c}),"xy"!==i&&"y"!==i||u.forEach((function(t,e){u[e].min=g[e],u[e].max=d[e];})),o){var f=o.getBeforeZoomRange(p,u);f&&(p=f.xaxis?f.xaxis:p,u=f.yaxis?f.yaxis:u);}var b={xaxis:p};a.config.chart.group||(b.yaxis=u),s.ctx.updateHelpers._updateOptions(b,!1,s.w.config.chart.animations.dynamicAnimation.enabled),"function"==typeof a.config.chart.events.zoomed&&o.zoomCallback(p,u);}else if(a.globals.selectionEnabled){var v,m=null;v={min:h,max:c},"xy"!==i&&"y"!==i||(m=x.clone(a.config.yaxis)).forEach((function(t,e){m[e].min=g[e],m[e].max=d[e];})),a.globals.selection=s.selection,"function"==typeof a.config.chart.events.selection&&a.config.chart.events.selection(s.ctx,{xaxis:v,yaxis:m});}}},{key:"panDragging",value:function(t){var e=t.context,i=this.w,a=e;if(void 0!==i.globals.lastClientPosition.x){var s=i.globals.lastClientPosition.x-a.clientX,r=i.globals.lastClientPosition.y-a.clientY;Math.abs(s)>Math.abs(r)&&s>0?this.moveDirection="left":Math.abs(s)>Math.abs(r)&&s<0?this.moveDirection="right":Math.abs(r)>Math.abs(s)&&r>0?this.moveDirection="up":Math.abs(r)>Math.abs(s)&&r<0&&(this.moveDirection="down");}i.globals.lastClientPosition={x:a.clientX,y:a.clientY};var o=i.globals.isRangeBar?i.globals.minY:i.globals.minX,n=i.globals.isRangeBar?i.globals.maxY:i.globals.maxX;i.config.xaxis.convertedCatToNumeric||a.panScrolled(o,n);}},{key:"delayedPanScrolled",value:function(){var t=this.w,e=t.globals.minX,i=t.globals.maxX,a=(t.globals.maxX-t.globals.minX)/2;"left"===this.moveDirection?(e=t.globals.minX+a,i=t.globals.maxX+a):"right"===this.moveDirection&&(e=t.globals.minX-a,i=t.globals.maxX-a),e=Math.floor(e),i=Math.floor(i),this.updateScrolledChart({xaxis:{min:e,max:i}},e,i);}},{key:"panScrolled",value:function(t,e){var i=this.w,a=this.xyRatios,s=x.clone(i.globals.initialConfig.yaxis),r=a.xRatio,o=i.globals.minX,n=i.globals.maxX;i.globals.isRangeBar&&(r=a.invertedYRatio,o=i.globals.minY,n=i.globals.maxY),"left"===this.moveDirection?(t=o+i.globals.gridWidth/15*r,e=n+i.globals.gridWidth/15*r):"right"===this.moveDirection&&(t=o-i.globals.gridWidth/15*r,e=n-i.globals.gridWidth/15*r),i.globals.isRangeBar||(t<i.globals.initialMinX||e>i.globals.initialMaxX)&&(t=o,e=n);var l={xaxis:{min:t,max:e}};i.config.chart.group||(l.yaxis=s),this.updateScrolledChart(l,t,e);}},{key:"updateScrolledChart",value:function(t,e,i){var a=this.w;this.ctx.updateHelpers._updateOptions(t,!1,!1),"function"==typeof a.config.chart.events.scrolled&&a.config.chart.events.scrolled(this.ctx,{xaxis:{min:e,max:i}});}}]),i}(),dt=function(){function t(e){a(this,t),this.w=e.w,this.ttCtx=e,this.ctx=e.ctx;}return r(t,[{key:"getNearestValues",value:function(t){var e=t.hoverArea,i=t.elGrid,a=t.clientX,s=t.clientY,r=this.w,o=i.getBoundingClientRect(),n=o.width,l=o.height,h=n/(r.globals.dataPoints-1),c=l/r.globals.dataPoints,d=this.hasBars();!r.globals.comboCharts&&!d||r.config.xaxis.convertedCatToNumeric||(h=n/r.globals.dataPoints);var g=a-o.left-r.globals.barPadForNumericAxis,u=s-o.top;g<0||u<0||g>n||u>l?(e.classList.remove("hovering-zoom"),e.classList.remove("hovering-pan")):r.globals.zoomEnabled?(e.classList.remove("hovering-pan"),e.classList.add("hovering-zoom")):r.globals.panEnabled&&(e.classList.remove("hovering-zoom"),e.classList.add("hovering-pan"));var p=Math.round(g/h),f=Math.floor(u/c);d&&!r.config.xaxis.convertedCatToNumeric&&(p=Math.ceil(g/h),p-=1);var b=null,v=null,m=r.globals.seriesXvalues.map((function(t){return t.filter((function(t){return x.isNumber(t)}))})),y=r.globals.seriesYvalues.map((function(t){return t.filter((function(t){return x.isNumber(t)}))}));if(r.globals.isXNumeric){var w=this.ttCtx.getElGrid().getBoundingClientRect(),k=g*(w.width/n),A=u*(w.height/l);b=(v=this.closestInMultiArray(k,A,m,y)).index,p=v.j,null!==b&&(m=r.globals.seriesXvalues[b],p=(v=this.closestInArray(k,m)).index);}return r.globals.capturedSeriesIndex=null===b?-1:b,(!p||p<1)&&(p=0),r.globals.isBarHorizontal?r.globals.capturedDataPointIndex=f:r.globals.capturedDataPointIndex=p,{capturedSeries:b,j:r.globals.isBarHorizontal?f:p,hoverX:g,hoverY:u}}},{key:"closestInMultiArray",value:function(t,e,i,a){var s=this.w,r=0,o=null,n=-1;s.globals.series.length>1?r=this.getFirstActiveXArray(i):o=0;var l=i[r][0],h=Math.abs(t-l);if(i.forEach((function(e){e.forEach((function(e,i){var a=Math.abs(t-e);a<=h&&(h=a,n=i);}));})),-1!==n){var c=a[r][n],d=Math.abs(e-c);o=r,a.forEach((function(t,i){var a=Math.abs(e-t[n]);a<=d&&(d=a,o=i);}));}return {index:o,j:n}}},{key:"getFirstActiveXArray",value:function(t){for(var e=this.w,i=0,a=t.map((function(t,e){return t.length>0?e:-1})),s=0;s<a.length;s++)if(-1!==a[s]&&-1===e.globals.collapsedSeriesIndices.indexOf(s)&&-1===e.globals.ancillaryCollapsedSeriesIndices.indexOf(s)){i=a[s];break}return i}},{key:"closestInArray",value:function(t,e){for(var i=e[0],a=null,s=Math.abs(t-i),r=0;r<e.length;r++){var o=Math.abs(t-e[r]);o<s&&(s=o,a=r);}return {index:a}}},{key:"isXoverlap",value:function(t){var e=[],i=this.w.globals.seriesX.filter((function(t){return void 0!==t[0]}));if(i.length>0)for(var a=0;a<i.length-1;a++)void 0!==i[a][t]&&void 0!==i[a+1][t]&&i[a][t]!==i[a+1][t]&&e.push("unEqual");return 0===e.length}},{key:"isInitialSeriesSameLen",value:function(){for(var t=!0,e=this.w.globals.initialSeries,i=0;i<e.length-1;i++)if(e[i].data.length!==e[i+1].data.length){t=!1;break}return t}},{key:"getBarsHeight",value:function(t){return u(t).reduce((function(t,e){return t+e.getBBox().height}),0)}},{key:"getElMarkers",value:function(t){return "number"==typeof t?this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:realIndex='".concat(t,"'] .apexcharts-series-markers-wrap > *")):this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap > *")}},{key:"getAllMarkers",value:function(){var t=this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");(t=u(t)).sort((function(t,e){var i=Number(t.getAttribute("data:realIndex")),a=Number(e.getAttribute("data:realIndex"));return a<i?1:a>i?-1:0}));var e=[];return t.forEach((function(t){e.push(t.querySelector(".apexcharts-marker"));})),e}},{key:"hasMarkers",value:function(t){return this.getElMarkers(t).length>0}},{key:"getElBars",value:function(){return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series")}},{key:"hasBars",value:function(){return this.getElBars().length>0}},{key:"getHoverMarkerSize",value:function(t){var e=this.w,i=e.config.markers.hover.size;return void 0===i&&(i=e.globals.markers.size[t]+e.config.markers.hover.sizeOffset),i}},{key:"toggleAllTooltipSeriesGroups",value:function(t){var e=this.w,i=this.ttCtx;0===i.allTooltipSeriesGroups.length&&(i.allTooltipSeriesGroups=e.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));for(var a=i.allTooltipSeriesGroups,s=0;s<a.length;s++)"enable"===t?(a[s].classList.add("apexcharts-active"),a[s].style.display=e.config.tooltip.items.display):(a[s].classList.remove("apexcharts-active"),a[s].style.display="none");}}]),t}(),gt=function(){function t(e){a(this,t),this.w=e.w,this.ctx=e.ctx,this.ttCtx=e,this.tooltipUtil=new dt(e);}return r(t,[{key:"drawSeriesTexts",value:function(t){var e=t.shared,i=void 0===e||e,a=t.ttItems,s=t.i,r=void 0===s?0:s,o=t.j,n=void 0===o?null:o,l=t.y1,h=t.y2,c=t.e,d=this.w;void 0!==d.config.tooltip.custom?this.handleCustomTooltip({i:r,j:n,y1:l,y2:h,w:d}):this.toggleActiveInactiveSeries(i);var g=this.getValuesToPrint({i:r,j:n});this.printLabels({i:r,j:n,values:g,ttItems:a,shared:i,e:c});var u=this.ttCtx.getElTooltip();this.ttCtx.tooltipRect.ttWidth=u.getBoundingClientRect().width,this.ttCtx.tooltipRect.ttHeight=u.getBoundingClientRect().height;}},{key:"printLabels",value:function(t){var i,a=this,s=t.i,r=t.j,o=t.values,n=t.ttItems,l=t.shared,h=t.e,c=this.w,d=[],g=function(t){return c.globals.seriesGoals[t]&&c.globals.seriesGoals[t][r]&&Array.isArray(c.globals.seriesGoals[t][r])},u=o.xVal,p=o.zVal,f=o.xAxisTTVal,x="",b=c.globals.colors[s];null!==r&&c.config.plotOptions.bar.distributed&&(b=c.globals.colors[r]);for(var v=function(t,o){var v=a.getFormatters(s);x=a.getSeriesName({fn:v.yLbTitleFormatter,index:s,seriesIndex:s,j:r}),"treemap"===c.config.chart.type&&(x=v.yLbTitleFormatter(String(c.config.series[s].data[r].x),{series:c.globals.series,seriesIndex:s,dataPointIndex:r,w:c}));var m=c.config.tooltip.inverseOrder?o:t;if(c.globals.axisCharts){var y=function(t){var e,i,a,s;return c.globals.isRangeData?v.yLbFormatter(null===(e=c.globals.seriesRangeStart)||void 0===e||null===(i=e[t])||void 0===i?void 0:i[r],{series:c.globals.seriesRangeStart,seriesIndex:t,dataPointIndex:r,w:c})+" - "+v.yLbFormatter(null===(a=c.globals.seriesRangeEnd)||void 0===a||null===(s=a[t])||void 0===s?void 0:s[r],{series:c.globals.seriesRangeEnd,seriesIndex:t,dataPointIndex:r,w:c}):v.yLbFormatter(c.globals.series[t][r],{series:c.globals.series,seriesIndex:t,dataPointIndex:r,w:c})};if(l)v=a.getFormatters(m),x=a.getSeriesName({fn:v.yLbTitleFormatter,index:m,seriesIndex:s,j:r}),b=c.globals.colors[m],i=y(m),g(m)&&(d=c.globals.seriesGoals[m][r].map((function(t){return {attrs:t,val:v.yLbFormatter(t.value,{seriesIndex:m,dataPointIndex:r,w:c})}})));else {var w,k=null==h||null===(w=h.target)||void 0===w?void 0:w.getAttribute("fill");k&&(b=-1!==k.indexOf("url")?document.querySelector(k.substr(4).slice(0,-1)).childNodes[0].getAttribute("stroke"):k),i=y(s),g(s)&&Array.isArray(c.globals.seriesGoals[s][r])&&(d=c.globals.seriesGoals[s][r].map((function(t){return {attrs:t,val:v.yLbFormatter(t.value,{seriesIndex:s,dataPointIndex:r,w:c})}})));}}null===r&&(i=v.yLbFormatter(c.globals.series[s],e(e({},c),{},{seriesIndex:s,dataPointIndex:s}))),a.DOMHandling({i:s,t:m,j:r,ttItems:n,values:{val:i,goalVals:d,xVal:u,xAxisTTVal:f,zVal:p},seriesName:x,shared:l,pColor:b});},m=0,y=c.globals.series.length-1;m<c.globals.series.length;m++,y--)v(m,y);}},{key:"getFormatters",value:function(t){var e,i=this.w,a=i.globals.yLabelFormatters[t];return void 0!==i.globals.ttVal?Array.isArray(i.globals.ttVal)?(a=i.globals.ttVal[t]&&i.globals.ttVal[t].formatter,e=i.globals.ttVal[t]&&i.globals.ttVal[t].title&&i.globals.ttVal[t].title.formatter):(a=i.globals.ttVal.formatter,"function"==typeof i.globals.ttVal.title.formatter&&(e=i.globals.ttVal.title.formatter)):e=i.config.tooltip.y.title.formatter,"function"!=typeof a&&(a=i.globals.yLabelFormatters[0]?i.globals.yLabelFormatters[0]:function(t){return t}),"function"!=typeof e&&(e=function(t){return t}),{yLbFormatter:a,yLbTitleFormatter:e}}},{key:"getSeriesName",value:function(t){var e=t.fn,i=t.index,a=t.seriesIndex,s=t.j,r=this.w;return e(String(r.globals.seriesNames[i]),{series:r.globals.series,seriesIndex:a,dataPointIndex:s,w:r})}},{key:"DOMHandling",value:function(t){t.i;var e=t.t,i=t.j,a=t.ttItems,s=t.values,r=t.seriesName,o=t.shared,n=t.pColor,l=this.w,h=this.ttCtx,c=s.val,d=s.goalVals,g=s.xVal,u=s.xAxisTTVal,p=s.zVal,f=null;f=a[e].children,l.config.tooltip.fillSeriesColor&&(a[e].style.backgroundColor=n,f[0].style.display="none"),h.showTooltipTitle&&(null===h.tooltipTitle&&(h.tooltipTitle=l.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")),h.tooltipTitle.innerHTML=g),h.isXAxisTooltipEnabled&&(h.xaxisTooltipText.innerHTML=""!==u?u:g);var x=a[e].querySelector(".apexcharts-tooltip-text-y-label");x&&(x.innerHTML=r||"");var b=a[e].querySelector(".apexcharts-tooltip-text-y-value");b&&(b.innerHTML=void 0!==c?c:""),f[0]&&f[0].classList.contains("apexcharts-tooltip-marker")&&(l.config.tooltip.marker.fillColors&&Array.isArray(l.config.tooltip.marker.fillColors)&&(n=l.config.tooltip.marker.fillColors[e]),f[0].style.backgroundColor=n),l.config.tooltip.marker.show||(f[0].style.display="none");var v=a[e].querySelector(".apexcharts-tooltip-text-goals-label"),m=a[e].querySelector(".apexcharts-tooltip-text-goals-value");if(d.length&&l.globals.seriesGoals[e]){var y=function(){var t="<div >",e="<div>";d.forEach((function(i,a){t+=' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(i.attrs.strokeColor,'; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(i.attrs.name,"</div>"),e+="<div>".concat(i.val,"</div>");})),v.innerHTML=t+"</div>",m.innerHTML=e+"</div>";};o?l.globals.seriesGoals[e][i]&&Array.isArray(l.globals.seriesGoals[e][i])?y():(v.innerHTML="",m.innerHTML=""):y();}else v.innerHTML="",m.innerHTML="";null!==p&&(a[e].querySelector(".apexcharts-tooltip-text-z-label").innerHTML=l.config.tooltip.z.title,a[e].querySelector(".apexcharts-tooltip-text-z-value").innerHTML=void 0!==p?p:"");if(o&&f[0]){if(l.config.tooltip.hideEmptySeries){var w=a[e].querySelector(".apexcharts-tooltip-marker"),k=a[e].querySelector(".apexcharts-tooltip-text");0==parseFloat(c)?(w.style.display="none",k.style.display="none"):(w.style.display="block",k.style.display="block");}null==c||l.globals.ancillaryCollapsedSeriesIndices.indexOf(e)>-1||l.globals.collapsedSeriesIndices.indexOf(e)>-1?f[0].parentNode.style.display="none":f[0].parentNode.style.display=l.config.tooltip.items.display;}}},{key:"toggleActiveInactiveSeries",value:function(t){var e=this.w;if(t)this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");else {this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");var i=e.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group");i&&(i.classList.add("apexcharts-active"),i.style.display=e.config.tooltip.items.display);}}},{key:"getValuesToPrint",value:function(t){var e=t.i,i=t.j,a=this.w,s=this.ctx.series.filteredSeriesX(),r="",o="",n=null,l=null,h={series:a.globals.series,seriesIndex:e,dataPointIndex:i,w:a},c=a.globals.ttZFormatter;null===i?l=a.globals.series[e]:a.globals.isXNumeric&&"treemap"!==a.config.chart.type?(r=s[e][i],0===s[e].length&&(r=s[this.tooltipUtil.getFirstActiveXArray(s)][i])):r=void 0!==a.globals.labels[i]?a.globals.labels[i]:"";var d=r;a.globals.isXNumeric&&"datetime"===a.config.xaxis.type?r=new S(this.ctx).xLabelFormat(a.globals.ttKeyFormatter,d,d,{i:void 0,dateFormatter:new A(this.ctx).formatDate,w:this.w}):r=a.globals.isBarHorizontal?a.globals.yLabelFormatters[0](d,h):a.globals.xLabelFormatter(d,h);return void 0!==a.config.tooltip.x.formatter&&(r=a.globals.ttKeyFormatter(d,h)),a.globals.seriesZ.length>0&&a.globals.seriesZ[e].length>0&&(n=c(a.globals.seriesZ[e][i],a)),o="function"==typeof a.config.xaxis.tooltip.formatter?a.globals.xaxisTooltipFormatter(d,h):r,{val:Array.isArray(l)?l.join(" "):l,xVal:Array.isArray(r)?r.join(" "):r,xAxisTTVal:Array.isArray(o)?o.join(" "):o,zVal:n}}},{key:"handleCustomTooltip",value:function(t){var e=t.i,i=t.j,a=t.y1,s=t.y2,r=t.w,o=this.ttCtx.getElTooltip(),n=r.config.tooltip.custom;Array.isArray(n)&&n[e]&&(n=n[e]),o.innerHTML=n({ctx:this.ctx,series:r.globals.series,seriesIndex:e,dataPointIndex:i,y1:a,y2:s,w:r});}}]),t}(),ut=function(){function t(e){a(this,t),this.ttCtx=e,this.ctx=e.ctx,this.w=e.w;}return r(t,[{key:"moveXCrosshairs",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,i=this.ttCtx,a=this.w,s=i.getElXCrosshairs(),r=t-i.xcrosshairsWidth/2,o=a.globals.labels.slice().length;if(null!==e&&(r=a.globals.gridWidth/o*e),null===s||a.globals.isBarHorizontal||(s.setAttribute("x",r),s.setAttribute("x1",r),s.setAttribute("x2",r),s.setAttribute("y2",a.globals.gridHeight),s.classList.add("apexcharts-active")),r<0&&(r=0),r>a.globals.gridWidth&&(r=a.globals.gridWidth),i.isXAxisTooltipEnabled){var n=r;"tickWidth"!==a.config.xaxis.crosshairs.width&&"barWidth"!==a.config.xaxis.crosshairs.width||(n=r+i.xcrosshairsWidth/2),this.moveXAxisTooltip(n);}}},{key:"moveYCrosshairs",value:function(t){var e=this.ttCtx;null!==e.ycrosshairs&&m.setAttrs(e.ycrosshairs,{y1:t,y2:t}),null!==e.ycrosshairsHidden&&m.setAttrs(e.ycrosshairsHidden,{y1:t,y2:t});}},{key:"moveXAxisTooltip",value:function(t){var e=this.w,i=this.ttCtx;if(null!==i.xaxisTooltip&&0!==i.xcrosshairsWidth){i.xaxisTooltip.classList.add("apexcharts-active");var a=i.xaxisOffY+e.config.xaxis.tooltip.offsetY+e.globals.translateY+1+e.config.xaxis.offsetY;if(t-=i.xaxisTooltip.getBoundingClientRect().width/2,!isNaN(t)){t+=e.globals.translateX;var s;s=new m(this.ctx).getTextRects(i.xaxisTooltipText.innerHTML),i.xaxisTooltipText.style.minWidth=s.width+"px",i.xaxisTooltip.style.left=t+"px",i.xaxisTooltip.style.top=a+"px";}}}},{key:"moveYAxisTooltip",value:function(t){var e=this.w,i=this.ttCtx;null===i.yaxisTTEls&&(i.yaxisTTEls=e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));var a=parseInt(i.ycrosshairsHidden.getAttribute("y1"),10),s=e.globals.translateY+a,r=i.yaxisTTEls[t].getBoundingClientRect().height,o=e.globals.translateYAxisX[t]-2;e.config.yaxis[t].opposite&&(o-=26),s-=r/2,-1===e.globals.ignoreYAxisIndexes.indexOf(t)?(i.yaxisTTEls[t].classList.add("apexcharts-active"),i.yaxisTTEls[t].style.top=s+"px",i.yaxisTTEls[t].style.left=o+e.config.yaxis[t].tooltip.offsetX+"px"):i.yaxisTTEls[t].classList.remove("apexcharts-active");}},{key:"moveTooltip",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=this.w,s=this.ttCtx,r=s.getElTooltip(),o=s.tooltipRect,n=null!==i?parseFloat(i):1,l=parseFloat(t)+n+5,h=parseFloat(e)+n/2;if(l>a.globals.gridWidth/2&&(l=l-o.ttWidth-n-10),l>a.globals.gridWidth-o.ttWidth-10&&(l=a.globals.gridWidth-o.ttWidth),l<-20&&(l=-20),a.config.tooltip.followCursor){var c=s.getElGrid().getBoundingClientRect();(l=s.e.clientX-c.left)>a.globals.gridWidth/2&&(l-=s.tooltipRect.ttWidth),(h=s.e.clientY+a.globals.translateY-c.top)>a.globals.gridHeight/2&&(h-=s.tooltipRect.ttHeight);}else a.globals.isBarHorizontal||o.ttHeight/2+h>a.globals.gridHeight&&(h=a.globals.gridHeight-o.ttHeight+a.globals.translateY);isNaN(l)||(l+=a.globals.translateX,r.style.left=l+"px",r.style.top=h+"px");}},{key:"moveMarkers",value:function(t,e){var i=this.w,a=this.ttCtx;if(i.globals.markers.size[t]>0)for(var s=i.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t,"'] .apexcharts-marker")),r=0;r<s.length;r++)parseInt(s[r].getAttribute("rel"),10)===e&&(a.marker.resetPointsSize(),a.marker.enlargeCurrentPoint(e,s[r]));else a.marker.resetPointsSize(),this.moveDynamicPointOnHover(e,t);}},{key:"moveDynamicPointOnHover",value:function(t,e){var i,a,s=this.w,r=this.ttCtx,o=s.globals.pointsArray,n=r.tooltipUtil.getHoverMarkerSize(e),l=s.config.series[e].type;if(!l||"column"!==l&&"candlestick"!==l&&"boxPlot"!==l){i=o[e][t][0],a=o[e][t][1]?o[e][t][1]:0;var h=s.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e,"'] .apexcharts-series-markers circle"));h&&a<s.globals.gridHeight&&a>0&&(h.setAttribute("r",n),h.setAttribute("cx",i),h.setAttribute("cy",a)),this.moveXCrosshairs(i),r.fixedTooltip||this.moveTooltip(i,a,n);}}},{key:"moveDynamicPointsOnHover",value:function(t){var e,i=this.ttCtx,a=i.w,s=0,r=0,o=a.globals.pointsArray;e=new W(this.ctx).getActiveConfigSeriesIndex("asc",["line","area","scatter","bubble"]);var n=i.tooltipUtil.getHoverMarkerSize(e);o[e]&&(s=o[e][t][0],r=o[e][t][1]);var l=i.tooltipUtil.getAllMarkers();if(null!==l)for(var h=0;h<a.globals.series.length;h++){var c=o[h];if(a.globals.comboCharts&&void 0===c&&l.splice(h,0,null),c&&c.length){var d=o[h][t][1],g=void 0;if(l[h].setAttribute("cx",s),"rangeArea"===a.config.chart.type&&!a.globals.comboCharts){var u=t+a.globals.series[h].length;g=o[h][u][1],d-=Math.abs(d-g)/2;}null!==d&&!isNaN(d)&&d<a.globals.gridHeight+n&&d+n>0?(l[h]&&l[h].setAttribute("r",n),l[h]&&l[h].setAttribute("cy",d)):l[h]&&l[h].setAttribute("r",0);}}this.moveXCrosshairs(s),i.fixedTooltip||this.moveTooltip(s,r||a.globals.gridHeight,n);}},{key:"moveStickyTooltipOverBars",value:function(t,e){var i=this.w,a=this.ttCtx,s=i.globals.columnSeries?i.globals.columnSeries.length:i.globals.series.length,r=s>=2&&s%2==0?Math.floor(s/2):Math.floor(s/2)+1;i.globals.isBarHorizontal&&(r=new W(this.ctx).getActiveConfigSeriesIndex("desc")+1);var o=i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(r,"'] path[j='").concat(t,"'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(r,"'] path[j='").concat(t,"'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(r,"'] path[j='").concat(t,"'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(r,"'] path[j='").concat(t,"']"));o||"number"!=typeof e||(o=i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[data\\:realIndex='".concat(e,"'] path[j='").concat(t,"'],\n        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex='").concat(e,"'] path[j='").concat(t,"'],\n        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex='").concat(e,"'] path[j='").concat(t,"'],\n        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex='").concat(e,"'] path[j='").concat(t,"']")));var n=o?parseFloat(o.getAttribute("cx")):0,l=o?parseFloat(o.getAttribute("cy")):0,h=o?parseFloat(o.getAttribute("barWidth")):0,c=a.getElGrid().getBoundingClientRect(),d=o&&(o.classList.contains("apexcharts-candlestick-area")||o.classList.contains("apexcharts-boxPlot-area"));i.globals.isXNumeric?(o&&!d&&(n-=s%2!=0?h/2:0),o&&d&&i.globals.comboCharts&&(n-=h/2)):i.globals.isBarHorizontal||(n=a.xAxisTicksPositions[t-1]+a.dataPointsDividedWidth/2,isNaN(n)&&(n=a.xAxisTicksPositions[t]-a.dataPointsDividedWidth/2)),i.globals.isBarHorizontal?l-=a.tooltipRect.ttHeight:i.config.tooltip.followCursor?l=a.e.clientY-c.top-a.tooltipRect.ttHeight/2:l+a.tooltipRect.ttHeight+15>i.globals.gridHeight&&(l=i.globals.gridHeight),i.globals.isBarHorizontal||this.moveXCrosshairs(n),a.fixedTooltip||this.moveTooltip(n,l||i.globals.gridHeight);}}]),t}(),pt=function(){function t(e){a(this,t),this.w=e.w,this.ttCtx=e,this.ctx=e.ctx,this.tooltipPosition=new ut(e);}return r(t,[{key:"drawDynamicPoints",value:function(){var t=this.w,e=new m(this.ctx),i=new D(this.ctx),a=t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");a=u(a),t.config.chart.stacked&&a.sort((function(t,e){return parseFloat(t.getAttribute("data:realIndex"))-parseFloat(e.getAttribute("data:realIndex"))}));for(var s=0;s<a.length;s++){var r=a[s].querySelector(".apexcharts-series-markers-wrap");if(null!==r){var o=void 0,n="apexcharts-marker w".concat((Math.random()+1).toString(36).substring(4));"line"!==t.config.chart.type&&"area"!==t.config.chart.type||t.globals.comboCharts||t.config.tooltip.intersect||(n+=" no-pointer-events");var l=i.getMarkerConfig({cssClass:n,seriesIndex:Number(r.getAttribute("data:realIndex"))});(o=e.drawMarker(0,0,l)).node.setAttribute("default-marker-size",0);var h=document.createElementNS(t.globals.SVGNS,"g");h.classList.add("apexcharts-series-markers"),h.appendChild(o.node),r.appendChild(h);}}}},{key:"enlargeCurrentPoint",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=this.w;"bubble"!==s.config.chart.type&&this.newPointSize(t,e);var r=e.getAttribute("cx"),o=e.getAttribute("cy");if(null!==i&&null!==a&&(r=i,o=a),this.tooltipPosition.moveXCrosshairs(r),!this.fixedTooltip){if("radar"===s.config.chart.type){var n=this.ttCtx.getElGrid().getBoundingClientRect();r=this.ttCtx.e.clientX-n.left;}this.tooltipPosition.moveTooltip(r,o,s.config.markers.hover.size);}}},{key:"enlargePoints",value:function(t){for(var e=this.w,i=this,a=this.ttCtx,s=t,r=e.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"),o=e.config.markers.hover.size,n=0;n<r.length;n++){var l=r[n].getAttribute("rel"),h=r[n].getAttribute("index");if(void 0===o&&(o=e.globals.markers.size[h]+e.config.markers.hover.sizeOffset),s===parseInt(l,10)){i.newPointSize(s,r[n]);var c=r[n].getAttribute("cx"),d=r[n].getAttribute("cy");i.tooltipPosition.moveXCrosshairs(c),a.fixedTooltip||i.tooltipPosition.moveTooltip(c,d,o);}else i.oldPointSize(r[n]);}}},{key:"newPointSize",value:function(t,e){var i=this.w,a=i.config.markers.hover.size,s=0===t?e.parentNode.firstChild:e.parentNode.lastChild;if("0"!==s.getAttribute("default-marker-size")){var r=parseInt(s.getAttribute("index"),10);void 0===a&&(a=i.globals.markers.size[r]+i.config.markers.hover.sizeOffset),a<0&&(a=0),s.setAttribute("r",a);}}},{key:"oldPointSize",value:function(t){var e=parseFloat(t.getAttribute("default-marker-size"));t.setAttribute("r",e);}},{key:"resetPointsSize",value:function(){for(var t=this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"),e=0;e<t.length;e++){var i=parseFloat(t[e].getAttribute("default-marker-size"));x.isNumber(i)&&i>=0?t[e].setAttribute("r",i):t[e].setAttribute("r",0);}}}]),t}(),ft=function(){function t(e){a(this,t),this.w=e.w;var i=this.w;this.ttCtx=e,this.isVerticalGroupedRangeBar=!i.globals.isBarHorizontal&&"rangeBar"===i.config.chart.type&&i.config.plotOptions.bar.rangeBarGroupRows;}return r(t,[{key:"getAttr",value:function(t,e){return parseFloat(t.target.getAttribute(e))}},{key:"handleHeatTreeTooltip",value:function(t){var e=t.e,i=t.opt,a=t.x,s=t.y,r=t.type,o=this.ttCtx,n=this.w;if(e.target.classList.contains("apexcharts-".concat(r,"-rect"))){var l=this.getAttr(e,"i"),h=this.getAttr(e,"j"),c=this.getAttr(e,"cx"),d=this.getAttr(e,"cy"),g=this.getAttr(e,"width"),u=this.getAttr(e,"height");if(o.tooltipLabels.drawSeriesTexts({ttItems:i.ttItems,i:l,j:h,shared:!1,e:e}),n.globals.capturedSeriesIndex=l,n.globals.capturedDataPointIndex=h,a=c+o.tooltipRect.ttWidth/2+g,s=d+o.tooltipRect.ttHeight/2-u/2,o.tooltipPosition.moveXCrosshairs(c+g/2),a>n.globals.gridWidth/2&&(a=c-o.tooltipRect.ttWidth/2+g),o.w.config.tooltip.followCursor){var p=n.globals.dom.elWrap.getBoundingClientRect();a=n.globals.clientX-p.left-(a>n.globals.gridWidth/2?o.tooltipRect.ttWidth:0),s=n.globals.clientY-p.top-(s>n.globals.gridHeight/2?o.tooltipRect.ttHeight:0);}}return {x:a,y:s}}},{key:"handleMarkerTooltip",value:function(t){var e,i,a=t.e,s=t.opt,r=t.x,o=t.y,n=this.w,l=this.ttCtx;if(a.target.classList.contains("apexcharts-marker")){var h=parseInt(s.paths.getAttribute("cx"),10),c=parseInt(s.paths.getAttribute("cy"),10),d=parseFloat(s.paths.getAttribute("val"));if(i=parseInt(s.paths.getAttribute("rel"),10),e=parseInt(s.paths.parentNode.parentNode.parentNode.getAttribute("rel"),10)-1,l.intersect){var g=x.findAncestor(s.paths,"apexcharts-series");g&&(e=parseInt(g.getAttribute("data:realIndex"),10));}if(l.tooltipLabels.drawSeriesTexts({ttItems:s.ttItems,i:e,j:i,shared:!l.showOnIntersect&&n.config.tooltip.shared,e:a}),"mouseup"===a.type&&l.markerClick(a,e,i),n.globals.capturedSeriesIndex=e,n.globals.capturedDataPointIndex=i,r=h,o=c+n.globals.translateY-1.4*l.tooltipRect.ttHeight,l.w.config.tooltip.followCursor){var u=l.getElGrid().getBoundingClientRect();o=l.e.clientY+n.globals.translateY-u.top;}d<0&&(o=c),l.marker.enlargeCurrentPoint(i,s.paths,r,o);}return {x:r,y:o}}},{key:"handleBarTooltip",value:function(t){var e,i,a=t.e,s=t.opt,r=this.w,o=this.ttCtx,n=o.getElTooltip(),l=0,h=0,c=0,d=this.getBarTooltipXY({e:a,opt:s});e=d.i;var g=d.barHeight,u=d.j;r.globals.capturedSeriesIndex=e,r.globals.capturedDataPointIndex=u,r.globals.isBarHorizontal&&o.tooltipUtil.hasBars()||!r.config.tooltip.shared?(h=d.x,c=d.y,i=Array.isArray(r.config.stroke.width)?r.config.stroke.width[e]:r.config.stroke.width,l=h):r.globals.comboCharts||r.config.tooltip.shared||(l/=2),isNaN(c)&&(c=r.globals.svgHeight-o.tooltipRect.ttHeight);var p=parseInt(s.paths.parentNode.getAttribute("data:realIndex"),10),f=r.globals.isMultipleYAxis?r.config.yaxis[p]&&r.config.yaxis[p].reversed:r.config.yaxis[0].reversed;if(h+o.tooltipRect.ttWidth>r.globals.gridWidth&&!f?h-=o.tooltipRect.ttWidth:h<0&&(h=0),o.w.config.tooltip.followCursor){var x=o.getElGrid().getBoundingClientRect();c=o.e.clientY-x.top;}null===o.tooltip&&(o.tooltip=r.globals.dom.baseEl.querySelector(".apexcharts-tooltip")),r.config.tooltip.shared||(r.globals.comboBarCount>0?o.tooltipPosition.moveXCrosshairs(l+i/2):o.tooltipPosition.moveXCrosshairs(l)),!o.fixedTooltip&&(!r.config.tooltip.shared||r.globals.isBarHorizontal&&o.tooltipUtil.hasBars())&&(f&&(h-=o.tooltipRect.ttWidth)<0&&(h=0),!f||r.globals.isBarHorizontal&&o.tooltipUtil.hasBars()||(c=c+g-2*(r.globals.series[e][u]<0?g:0)),c=c+r.globals.translateY-o.tooltipRect.ttHeight/2,n.style.left=h+r.globals.translateX+"px",n.style.top=c+"px");}},{key:"getBarTooltipXY",value:function(t){var e=this,i=t.e,a=t.opt,s=this.w,r=null,o=this.ttCtx,n=0,l=0,h=0,c=0,d=0,g=i.target.classList;if(g.contains("apexcharts-bar-area")||g.contains("apexcharts-candlestick-area")||g.contains("apexcharts-boxPlot-area")||g.contains("apexcharts-rangebar-area")){var u=i.target,p=u.getBoundingClientRect(),f=a.elGrid.getBoundingClientRect(),x=p.height;d=p.height;var b=p.width,v=parseInt(u.getAttribute("cx"),10),m=parseInt(u.getAttribute("cy"),10);c=parseFloat(u.getAttribute("barWidth"));var y="touchmove"===i.type?i.touches[0].clientX:i.clientX;r=parseInt(u.getAttribute("j"),10),n=parseInt(u.parentNode.getAttribute("rel"),10)-1;var w=u.getAttribute("data-range-y1"),k=u.getAttribute("data-range-y2");s.globals.comboCharts&&(n=parseInt(u.parentNode.getAttribute("data:realIndex"),10));var A=function(t){return s.globals.isXNumeric?v-b/2:e.isVerticalGroupedRangeBar?v+b/2:v-o.dataPointsDividedWidth+b/2},S=function(){return m-o.dataPointsDividedHeight+x/2-o.tooltipRect.ttHeight/2};o.tooltipLabels.drawSeriesTexts({ttItems:a.ttItems,i:n,j:r,y1:w?parseInt(w,10):null,y2:k?parseInt(k,10):null,shared:!o.showOnIntersect&&s.config.tooltip.shared,e:i}),s.config.tooltip.followCursor?s.globals.isBarHorizontal?(l=y-f.left+15,h=S()):(l=A(),h=i.clientY-f.top-o.tooltipRect.ttHeight/2-15):s.globals.isBarHorizontal?((l=v)<o.xyRatios.baseLineInvertedY&&(l=v-o.tooltipRect.ttWidth),h=S()):(l=A(),h=m);}return {x:l,y:h,barHeight:d,barWidth:c,i:n,j:r}}}]),t}(),xt=function(){function t(e){a(this,t),this.w=e.w,this.ttCtx=e;}return r(t,[{key:"drawXaxisTooltip",value:function(){var t=this.w,e=this.ttCtx,i="bottom"===t.config.xaxis.position;e.xaxisOffY=i?t.globals.gridHeight+1:-t.globals.xAxisHeight-t.config.xaxis.axisTicks.height+3;var a=i?"apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom":"apexcharts-xaxistooltip apexcharts-xaxistooltip-top",s=t.globals.dom.elWrap;e.isXAxisTooltipEnabled&&(null===t.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip")&&(e.xaxisTooltip=document.createElement("div"),e.xaxisTooltip.setAttribute("class",a+" apexcharts-theme-"+t.config.tooltip.theme),s.appendChild(e.xaxisTooltip),e.xaxisTooltipText=document.createElement("div"),e.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"),e.xaxisTooltipText.style.fontFamily=t.config.xaxis.tooltip.style.fontFamily||t.config.chart.fontFamily,e.xaxisTooltipText.style.fontSize=t.config.xaxis.tooltip.style.fontSize,e.xaxisTooltip.appendChild(e.xaxisTooltipText)));}},{key:"drawYaxisTooltip",value:function(){for(var t=this.w,e=this.ttCtx,i=0;i<t.config.yaxis.length;i++){var a=t.config.yaxis[i].opposite||t.config.yaxis[i].crosshairs.opposite;e.yaxisOffX=a?t.globals.gridWidth+1:1;var s="apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i,a?" apexcharts-yaxistooltip-right":" apexcharts-yaxistooltip-left"),r=t.globals.dom.elWrap;null===t.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i))&&(e.yaxisTooltip=document.createElement("div"),e.yaxisTooltip.setAttribute("class",s+" apexcharts-theme-"+t.config.tooltip.theme),r.appendChild(e.yaxisTooltip),0===i&&(e.yaxisTooltipText=[]),e.yaxisTooltipText[i]=document.createElement("div"),e.yaxisTooltipText[i].classList.add("apexcharts-yaxistooltip-text"),e.yaxisTooltip.appendChild(e.yaxisTooltipText[i]));}}},{key:"setXCrosshairWidth",value:function(){var t=this.w,e=this.ttCtx,i=e.getElXCrosshairs();if(e.xcrosshairsWidth=parseInt(t.config.xaxis.crosshairs.width,10),t.globals.comboCharts){var a=t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");if(null!==a&&"barWidth"===t.config.xaxis.crosshairs.width){var s=parseFloat(a.getAttribute("barWidth"));e.xcrosshairsWidth=s;}else if("tickWidth"===t.config.xaxis.crosshairs.width){var r=t.globals.labels.length;e.xcrosshairsWidth=t.globals.gridWidth/r;}}else if("tickWidth"===t.config.xaxis.crosshairs.width){var o=t.globals.labels.length;e.xcrosshairsWidth=t.globals.gridWidth/o;}else if("barWidth"===t.config.xaxis.crosshairs.width){var n=t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");if(null!==n){var l=parseFloat(n.getAttribute("barWidth"));e.xcrosshairsWidth=l;}else e.xcrosshairsWidth=1;}t.globals.isBarHorizontal&&(e.xcrosshairsWidth=0),null!==i&&e.xcrosshairsWidth>0&&i.setAttribute("width",e.xcrosshairsWidth);}},{key:"handleYCrosshair",value:function(){var t=this.w,e=this.ttCtx;e.ycrosshairs=t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"),e.ycrosshairsHidden=t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden");}},{key:"drawYaxisTooltipText",value:function(t,e,i){var a=this.ttCtx,s=this.w,r=s.globals,o=r.seriesYAxisMap[t];if(a.yaxisTooltips[t]&&o.length>0){var n=r.yLabelFormatters[t],l=a.getElGrid().getBoundingClientRect(),h=o[0];i.yRatio.length>1&&function(t){throw new TypeError('"'+t+'" is read-only')}("translationsIndex");var c=(e-l.top)*i.yRatio[0],d=r.maxYArr[h]-r.minYArr[h],g=r.minYArr[h]+(d-c);s.config.yaxis[t].reversed&&(g=r.maxYArr[h]-(d-c)),a.tooltipPosition.moveYCrosshairs(e-l.top),a.yaxisTooltipText[t].innerHTML=n(g),a.tooltipPosition.moveYAxisTooltip(t);}}}]),t}(),bt=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w;var i=this.w;this.tConfig=i.config.tooltip,this.tooltipUtil=new dt(this),this.tooltipLabels=new gt(this),this.tooltipPosition=new ut(this),this.marker=new pt(this),this.intersect=new ft(this),this.axesTooltip=new xt(this),this.showOnIntersect=this.tConfig.intersect,this.showTooltipTitle=this.tConfig.x.show,this.fixedTooltip=this.tConfig.fixed.enabled,this.xaxisTooltip=null,this.yaxisTTEls=null,this.isBarShared=!i.globals.isBarHorizontal&&this.tConfig.shared,this.lastHoverTime=Date.now();}return r(t,[{key:"getElTooltip",value:function(t){return t||(t=this),t.w.globals.dom.baseEl?t.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip"):null}},{key:"getElXCrosshairs",value:function(){return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs")}},{key:"getElGrid",value:function(){return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid")}},{key:"drawTooltip",value:function(t){var e=this.w;this.xyRatios=t,this.isXAxisTooltipEnabled=e.config.xaxis.tooltip.enabled&&e.globals.axisCharts,this.yaxisTooltips=e.config.yaxis.map((function(t,i){return !!(t.show&&t.tooltip.enabled&&e.globals.axisCharts)})),this.allTooltipSeriesGroups=[],e.globals.axisCharts||(this.showTooltipTitle=!1);var i=document.createElement("div");if(i.classList.add("apexcharts-tooltip"),e.config.tooltip.cssClass&&i.classList.add(e.config.tooltip.cssClass),i.classList.add("apexcharts-theme-".concat(this.tConfig.theme)),e.globals.dom.elWrap.appendChild(i),e.globals.axisCharts){this.axesTooltip.drawXaxisTooltip(),this.axesTooltip.drawYaxisTooltip(),this.axesTooltip.setXCrosshairWidth(),this.axesTooltip.handleYCrosshair();var a=new V(this.ctx);this.xAxisTicksPositions=a.getXAxisTicksPositions();}if(!e.globals.comboCharts&&!this.tConfig.intersect&&"rangeBar"!==e.config.chart.type||this.tConfig.shared||(this.showOnIntersect=!0),0!==e.config.markers.size&&0!==e.globals.markers.largestSize||this.marker.drawDynamicPoints(this),e.globals.collapsedSeries.length!==e.globals.series.length){this.dataPointsDividedHeight=e.globals.gridHeight/e.globals.dataPoints,this.dataPointsDividedWidth=e.globals.gridWidth/e.globals.dataPoints,this.showTooltipTitle&&(this.tooltipTitle=document.createElement("div"),this.tooltipTitle.classList.add("apexcharts-tooltip-title"),this.tooltipTitle.style.fontFamily=this.tConfig.style.fontFamily||e.config.chart.fontFamily,this.tooltipTitle.style.fontSize=this.tConfig.style.fontSize,i.appendChild(this.tooltipTitle));var s=e.globals.series.length;(e.globals.xyCharts||e.globals.comboCharts)&&this.tConfig.shared&&(s=this.showOnIntersect?1:e.globals.series.length),this.legendLabels=e.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"),this.ttItems=this.createTTElements(s),this.addSVGEvents();}}},{key:"createTTElements",value:function(t){for(var e=this,i=this.w,a=[],s=this.getElTooltip(),r=function(r){var o=document.createElement("div");o.classList.add("apexcharts-tooltip-series-group"),o.style.order=i.config.tooltip.inverseOrder?t-r:r+1,e.tConfig.shared&&e.tConfig.enabledOnSeries&&Array.isArray(e.tConfig.enabledOnSeries)&&e.tConfig.enabledOnSeries.indexOf(r)<0&&o.classList.add("apexcharts-tooltip-series-group-hidden");var n=document.createElement("span");n.classList.add("apexcharts-tooltip-marker"),n.style.backgroundColor=i.globals.colors[r],o.appendChild(n);var l=document.createElement("div");l.classList.add("apexcharts-tooltip-text"),l.style.fontFamily=e.tConfig.style.fontFamily||i.config.chart.fontFamily,l.style.fontSize=e.tConfig.style.fontSize,["y","goals","z"].forEach((function(t){var e=document.createElement("div");e.classList.add("apexcharts-tooltip-".concat(t,"-group"));var i=document.createElement("span");i.classList.add("apexcharts-tooltip-text-".concat(t,"-label")),e.appendChild(i);var a=document.createElement("span");a.classList.add("apexcharts-tooltip-text-".concat(t,"-value")),e.appendChild(a),l.appendChild(e);})),o.appendChild(l),s.appendChild(o),a.push(o);},o=0;o<t;o++)r(o);return a}},{key:"addSVGEvents",value:function(){var t=this.w,e=t.config.chart.type,i=this.getElTooltip(),a=!("bar"!==e&&"candlestick"!==e&&"boxPlot"!==e&&"rangeBar"!==e),s="area"===e||"line"===e||"scatter"===e||"bubble"===e||"radar"===e,r=t.globals.dom.Paper.node,o=this.getElGrid();o&&(this.seriesBound=o.getBoundingClientRect());var n,l=[],h=[],c={hoverArea:r,elGrid:o,tooltipEl:i,tooltipY:l,tooltipX:h,ttItems:this.ttItems};if(t.globals.axisCharts&&(s?n=t.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker"):a?n=t.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area"):"heatmap"!==e&&"treemap"!==e||(n=t.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")),n&&n.length))for(var d=0;d<n.length;d++)l.push(n[d].getAttribute("cy")),h.push(n[d].getAttribute("cx"));if(t.globals.xyCharts&&!this.showOnIntersect||t.globals.comboCharts&&!this.showOnIntersect||a&&this.tooltipUtil.hasBars()&&this.tConfig.shared)this.addPathsEventListeners([r],c);else if(a&&!t.globals.comboCharts||s&&this.showOnIntersect)this.addDatapointEventsListeners(c);else if(!t.globals.axisCharts||"heatmap"===e||"treemap"===e){var g=t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");this.addPathsEventListeners(g,c);}if(this.showOnIntersect){var u=t.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");u.length>0&&this.addPathsEventListeners(u,c),this.tooltipUtil.hasBars()&&!this.tConfig.shared&&this.addDatapointEventsListeners(c);}}},{key:"drawFixedTooltipRect",value:function(){var t=this.w,e=this.getElTooltip(),i=e.getBoundingClientRect(),a=i.width+10,s=i.height+10,r=this.tConfig.fixed.offsetX,o=this.tConfig.fixed.offsetY,n=this.tConfig.fixed.position.toLowerCase();return n.indexOf("right")>-1&&(r=r+t.globals.svgWidth-a+10),n.indexOf("bottom")>-1&&(o=o+t.globals.svgHeight-s-10),e.style.left=r+"px",e.style.top=o+"px",{x:r,y:o,ttWidth:a,ttHeight:s}}},{key:"addDatapointEventsListeners",value:function(t){var e=this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");this.addPathsEventListeners(e,t);}},{key:"addPathsEventListeners",value:function(t,e){for(var i=this,a=function(a){var s={paths:t[a],tooltipEl:e.tooltipEl,tooltipY:e.tooltipY,tooltipX:e.tooltipX,elGrid:e.elGrid,hoverArea:e.hoverArea,ttItems:e.ttItems};["mousemove","mouseup","touchmove","mouseout","touchend"].map((function(e){return t[a].addEventListener(e,i.onSeriesHover.bind(i,s),{capture:!1,passive:!0})}));},s=0;s<t.length;s++)a(s);}},{key:"onSeriesHover",value:function(t,e){var i=this,a=Date.now()-this.lastHoverTime;a>=100?this.seriesHover(t,e):(clearTimeout(this.seriesHoverTimeout),this.seriesHoverTimeout=setTimeout((function(){i.seriesHover(t,e);}),100-a));}},{key:"seriesHover",value:function(t,e){var i=this;this.lastHoverTime=Date.now();var a=[],s=this.w;s.config.chart.group&&(a=this.ctx.getGroupedCharts()),s.globals.axisCharts&&(s.globals.minX===-1/0&&s.globals.maxX===1/0||0===s.globals.dataPoints)||(a.length?a.forEach((function(a){var s=i.getElTooltip(a),r={paths:t.paths,tooltipEl:s,tooltipY:t.tooltipY,tooltipX:t.tooltipX,elGrid:t.elGrid,hoverArea:t.hoverArea,ttItems:a.w.globals.tooltip.ttItems};a.w.globals.minX===i.w.globals.minX&&a.w.globals.maxX===i.w.globals.maxX&&a.w.globals.tooltip.seriesHoverByContext({chartCtx:a,ttCtx:a.w.globals.tooltip,opt:r,e:e});})):this.seriesHoverByContext({chartCtx:this.ctx,ttCtx:this.w.globals.tooltip,opt:t,e:e}));}},{key:"seriesHoverByContext",value:function(t){var e=t.chartCtx,i=t.ttCtx,a=t.opt,s=t.e,r=e.w,o=this.getElTooltip();if(o){if(i.tooltipRect={x:0,y:0,ttWidth:o.getBoundingClientRect().width,ttHeight:o.getBoundingClientRect().height},i.e=s,i.tooltipUtil.hasBars()&&!r.globals.comboCharts&&!i.isBarShared)if(this.tConfig.onDatasetHover.highlightDataSeries)new W(e).toggleSeriesOnHover(s,s.target.parentNode);i.fixedTooltip&&i.drawFixedTooltipRect(),r.globals.axisCharts?i.axisChartsTooltips({e:s,opt:a,tooltipRect:i.tooltipRect}):i.nonAxisChartsTooltips({e:s,opt:a,tooltipRect:i.tooltipRect});}}},{key:"axisChartsTooltips",value:function(t){var e,i,a=t.e,s=t.opt,r=this.w,o=s.elGrid.getBoundingClientRect(),n="touchmove"===a.type?a.touches[0].clientX:a.clientX,l="touchmove"===a.type?a.touches[0].clientY:a.clientY;if(this.clientY=l,this.clientX=n,r.globals.capturedSeriesIndex=-1,r.globals.capturedDataPointIndex=-1,l<o.top||l>o.top+o.height)this.handleMouseOut(s);else {if(Array.isArray(this.tConfig.enabledOnSeries)&&!r.config.tooltip.shared){var h=parseInt(s.paths.getAttribute("index"),10);if(this.tConfig.enabledOnSeries.indexOf(h)<0)return void this.handleMouseOut(s)}var c=this.getElTooltip(),d=this.getElXCrosshairs(),g=r.globals.xyCharts||"bar"===r.config.chart.type&&!r.globals.isBarHorizontal&&this.tooltipUtil.hasBars()&&this.tConfig.shared||r.globals.comboCharts&&this.tooltipUtil.hasBars();if("mousemove"===a.type||"touchmove"===a.type||"mouseup"===a.type){if(r.globals.collapsedSeries.length+r.globals.ancillaryCollapsedSeries.length===r.globals.series.length)return;null!==d&&d.classList.add("apexcharts-active");var u=this.yaxisTooltips.filter((function(t){return !0===t}));if(null!==this.ycrosshairs&&u.length&&this.ycrosshairs.classList.add("apexcharts-active"),g&&!this.showOnIntersect)this.handleStickyTooltip(a,n,l,s);else if("heatmap"===r.config.chart.type||"treemap"===r.config.chart.type){var p=this.intersect.handleHeatTreeTooltip({e:a,opt:s,x:e,y:i,type:r.config.chart.type});e=p.x,i=p.y,c.style.left=e+"px",c.style.top=i+"px";}else this.tooltipUtil.hasBars()&&this.intersect.handleBarTooltip({e:a,opt:s}),this.tooltipUtil.hasMarkers()&&this.intersect.handleMarkerTooltip({e:a,opt:s,x:e,y:i});if(this.yaxisTooltips.length)for(var f=0;f<r.config.yaxis.length;f++)this.axesTooltip.drawYaxisTooltipText(f,l,this.xyRatios);s.tooltipEl.classList.add("apexcharts-active");}else "mouseout"!==a.type&&"touchend"!==a.type||this.handleMouseOut(s);}}},{key:"nonAxisChartsTooltips",value:function(t){var e=t.e,i=t.opt,a=t.tooltipRect,s=this.w,r=i.paths.getAttribute("rel"),o=this.getElTooltip(),n=s.globals.dom.elWrap.getBoundingClientRect();if("mousemove"===e.type||"touchmove"===e.type){o.classList.add("apexcharts-active"),this.tooltipLabels.drawSeriesTexts({ttItems:i.ttItems,i:parseInt(r,10)-1,shared:!1});var l=s.globals.clientX-n.left-a.ttWidth/2,h=s.globals.clientY-n.top-a.ttHeight-10;if(o.style.left=l+"px",o.style.top=h+"px",s.config.legend.tooltipHoverFormatter){var c=r-1,d=(0, s.config.legend.tooltipHoverFormatter)(this.legendLabels[c].getAttribute("data:default-text"),{seriesIndex:c,dataPointIndex:c,w:s});this.legendLabels[c].innerHTML=d;}}else "mouseout"!==e.type&&"touchend"!==e.type||(o.classList.remove("apexcharts-active"),s.config.legend.tooltipHoverFormatter&&this.legendLabels.forEach((function(t){var e=t.getAttribute("data:default-text");t.innerHTML=decodeURIComponent(e);})));}},{key:"handleStickyTooltip",value:function(t,e,i,a){var s=this.w,r=this.tooltipUtil.getNearestValues({context:this,hoverArea:a.hoverArea,elGrid:a.elGrid,clientX:e,clientY:i}),o=r.j,n=r.capturedSeries;s.globals.collapsedSeriesIndices.includes(n)&&(n=null);var l=a.elGrid.getBoundingClientRect();if(r.hoverX<0||r.hoverX>l.width)this.handleMouseOut(a);else if(null!==n)this.handleStickyCapturedSeries(t,n,a,o);else if(this.tooltipUtil.isXoverlap(o)||s.globals.isBarHorizontal){var h=s.globals.series.findIndex((function(t,e){return !s.globals.collapsedSeriesIndices.includes(e)}));this.create(t,this,h,o,a.ttItems);}}},{key:"handleStickyCapturedSeries",value:function(t,e,i,a){var s=this.w;if(!this.tConfig.shared&&null===s.globals.series[e][a])return void this.handleMouseOut(i);if(void 0!==s.globals.series[e][a])this.tConfig.shared&&this.tooltipUtil.isXoverlap(a)&&this.tooltipUtil.isInitialSeriesSameLen()?this.create(t,this,e,a,i.ttItems):this.create(t,this,e,a,i.ttItems,!1);else if(this.tooltipUtil.isXoverlap(a)){var r=s.globals.series.findIndex((function(t,e){return !s.globals.collapsedSeriesIndices.includes(e)}));this.create(t,this,r,a,i.ttItems);}}},{key:"deactivateHoverFilter",value:function(){for(var t=this.w,e=new m(this.ctx),i=t.globals.dom.Paper.select(".apexcharts-bar-area"),a=0;a<i.length;a++)e.pathMouseLeave(i[a]);}},{key:"handleMouseOut",value:function(t){var e=this.w,i=this.getElXCrosshairs();if(t.tooltipEl.classList.remove("apexcharts-active"),this.deactivateHoverFilter(),"bubble"!==e.config.chart.type&&this.marker.resetPointsSize(),null!==i&&i.classList.remove("apexcharts-active"),null!==this.ycrosshairs&&this.ycrosshairs.classList.remove("apexcharts-active"),this.isXAxisTooltipEnabled&&this.xaxisTooltip.classList.remove("apexcharts-active"),this.yaxisTooltips.length){null===this.yaxisTTEls&&(this.yaxisTTEls=e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));for(var a=0;a<this.yaxisTTEls.length;a++)this.yaxisTTEls[a].classList.remove("apexcharts-active");}e.config.legend.tooltipHoverFormatter&&this.legendLabels.forEach((function(t){var e=t.getAttribute("data:default-text");t.innerHTML=decodeURIComponent(e);}));}},{key:"markerClick",value:function(t,e,i){var a=this.w;"function"==typeof a.config.chart.events.markerClick&&a.config.chart.events.markerClick(t,this.ctx,{seriesIndex:e,dataPointIndex:i,w:a}),this.ctx.events.fireEvent("markerClick",[t,this.ctx,{seriesIndex:e,dataPointIndex:i,w:a}]);}},{key:"create",value:function(t,i,a,s,r){var o,n,l,h,c,d,g,u,p,f,x,b,v,y,w,k,A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,S=this.w,C=i;"mouseup"===t.type&&this.markerClick(t,a,s),null===A&&(A=this.tConfig.shared);var L=this.tooltipUtil.hasMarkers(a),P=this.tooltipUtil.getElBars();if(S.config.legend.tooltipHoverFormatter){var M=S.config.legend.tooltipHoverFormatter,I=Array.from(this.legendLabels);I.forEach((function(t){var e=t.getAttribute("data:default-text");t.innerHTML=decodeURIComponent(e);}));for(var T=0;T<I.length;T++){var z=I[T],X=parseInt(z.getAttribute("i"),10),E=decodeURIComponent(z.getAttribute("data:default-text")),Y=M(E,{seriesIndex:A?X:a,dataPointIndex:s,w:S});if(A)z.innerHTML=S.globals.collapsedSeriesIndices.indexOf(X)<0?Y:E;else if(z.innerHTML=X===a?Y:E,a===X)break}}var F=e(e({ttItems:r,i:a,j:s},void 0!==(null===(o=S.globals.seriesRange)||void 0===o||null===(n=o[a])||void 0===n||null===(l=n[s])||void 0===l||null===(h=l.y[0])||void 0===h?void 0:h.y1)&&{y1:null===(c=S.globals.seriesRange)||void 0===c||null===(d=c[a])||void 0===d||null===(g=d[s])||void 0===g||null===(u=g.y[0])||void 0===u?void 0:u.y1}),void 0!==(null===(p=S.globals.seriesRange)||void 0===p||null===(f=p[a])||void 0===f||null===(x=f[s])||void 0===x||null===(b=x.y[0])||void 0===b?void 0:b.y2)&&{y2:null===(v=S.globals.seriesRange)||void 0===v||null===(y=v[a])||void 0===y||null===(w=y[s])||void 0===w||null===(k=w.y[0])||void 0===k?void 0:k.y2});if(A){if(C.tooltipLabels.drawSeriesTexts(e(e({},F),{},{shared:!this.showOnIntersect&&this.tConfig.shared})),L)S.globals.markers.largestSize>0?C.marker.enlargePoints(s):C.tooltipPosition.moveDynamicPointsOnHover(s);else if(this.tooltipUtil.hasBars()&&(this.barSeriesHeight=this.tooltipUtil.getBarsHeight(P),this.barSeriesHeight>0)){var R=new m(this.ctx),H=S.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(s,"']"));this.deactivateHoverFilter(),this.tooltipPosition.moveStickyTooltipOverBars(s,a);for(var D=0;D<H.length;D++)R.pathMouseEnter(H[D]);}}else C.tooltipLabels.drawSeriesTexts(e({shared:!1},F)),this.tooltipUtil.hasBars()&&C.tooltipPosition.moveStickyTooltipOverBars(s,a),L&&C.tooltipPosition.moveMarkers(a,s);}}]),t}(),vt=function(){function t(e){a(this,t),this.w=e.w,this.barCtx=e,this.totalFormatter=this.w.config.plotOptions.bar.dataLabels.total.formatter,this.totalFormatter||(this.totalFormatter=this.w.config.dataLabels.formatter);}return r(t,[{key:"handleBarDataLabels",value:function(t){var e,i,a=t.x,s=t.y,r=t.y1,o=t.y2,n=t.i,l=t.j,h=t.realIndex,c=t.columnGroupIndex,d=t.series,g=t.barHeight,u=t.barWidth,p=t.barXPosition,f=t.barYPosition,x=t.visibleSeries,b=t.renderedPath,v=this.w,y=new m(this.barCtx.ctx),w=Array.isArray(this.barCtx.strokeWidth)?this.barCtx.strokeWidth[h]:this.barCtx.strokeWidth;v.globals.isXNumeric&&!v.globals.isBarHorizontal?(e=a+parseFloat(u*(x+1)),i=s+parseFloat(g*(x+1))-w):(e=a+parseFloat(u*x),i=s+parseFloat(g*x));var k,A=null,S=a,C=s,L={},P=v.config.dataLabels,M=this.barCtx.barOptions.dataLabels,I=this.barCtx.barOptions.dataLabels.total;void 0!==f&&this.barCtx.isRangeBar&&(i=f,C=f),void 0!==p&&this.barCtx.isVerticalGroupedRangeBar&&(e=p,S=p);var T=P.offsetX,z=P.offsetY,X={width:0,height:0};if(v.config.dataLabels.enabled){var E=this.barCtx.series[n][l];X=y.getTextRects(v.globals.yLabelFormatters[0](E),parseFloat(P.style.fontSize));}var Y={x:a,y:s,i:n,j:l,realIndex:h,columnGroupIndex:c,renderedPath:b,bcx:e,bcy:i,barHeight:g,barWidth:u,textRects:X,strokeWidth:w,dataLabelsX:S,dataLabelsY:C,dataLabelsConfig:P,barDataLabelsConfig:M,barTotalDataLabelsConfig:I,offX:T,offY:z};return L=this.barCtx.isHorizontal?this.calculateBarsDataLabelsPosition(Y):this.calculateColumnsDataLabelsPosition(Y),b.attr({cy:L.bcy,cx:L.bcx,j:l,val:d[n][l],barHeight:g,barWidth:u}),k=this.drawCalculatedDataLabels({x:L.dataLabelsX,y:L.dataLabelsY,val:this.barCtx.isRangeBar?[r,o]:d[n][l],i:h,j:l,barWidth:u,barHeight:g,textRects:X,dataLabelsConfig:P}),v.config.chart.stacked&&I.enabled&&(A=this.drawTotalDataLabels({x:L.totalDataLabelsX,y:L.totalDataLabelsY,barWidth:u,barHeight:g,realIndex:h,textAnchor:L.totalDataLabelsAnchor,val:this.getStackedTotalDataLabel({realIndex:h,j:l}),dataLabelsConfig:P,barTotalDataLabelsConfig:I})),{dataLabels:k,totalDataLabels:A}}},{key:"getStackedTotalDataLabel",value:function(t){var i=t.realIndex,a=t.j,s=this.w,r=this.barCtx.stackedSeriesTotals[a];return this.totalFormatter&&(r=this.totalFormatter(r,e(e({},s),{},{seriesIndex:i,dataPointIndex:a,w:s}))),r}},{key:"calculateColumnsDataLabelsPosition",value:function(t){var e,i,a=this.w,s=t.i,r=t.j,o=t.realIndex,n=t.columnGroupIndex,l=t.y,h=t.bcx,c=t.barWidth,d=t.barHeight,g=t.textRects,u=t.dataLabelsX,p=t.dataLabelsY,f=t.dataLabelsConfig,x=t.barDataLabelsConfig,b=t.barTotalDataLabelsConfig,v=t.strokeWidth,y=t.offX,w=t.offY,k=h;d=Math.abs(d);var A="vertical"===a.config.plotOptions.bar.dataLabels.orientation,S=this.barCtx.barHelpers.getZeroValueEncounters({i:s,j:r}).zeroEncounters;h=h-v/2+n*c;var C=a.globals.gridWidth/a.globals.dataPoints;if(this.barCtx.isVerticalGroupedRangeBar?u+=c/2:(u=a.globals.isXNumeric?h-c/2+y:h-C+c/2+y,S>0&&a.config.plotOptions.bar.hideZeroBarsWhenGrouped&&(u-=c*S)),A){u=u+g.height/2-v/2-2;}var L=this.barCtx.series[s][r]<0,P=l;switch(this.barCtx.isReversed&&(P=l+(L?d:-d),l-=d),x.position){case"center":p=A?L?P-d/2+w:P+d/2-w:L?P-d/2+g.height/2+w:P+d/2+g.height/2-w;break;case"bottom":p=A?L?P-d+w:P+d-w:L?P-d+g.height+v+w:P+d-g.height/2+v-w;break;case"top":p=A?L?P+w:P-w:L?P-g.height/2-w:P+g.height+w;}if(this.barCtx.lastActiveBarSerieIndex===o&&b.enabled){var M=new m(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({realIndex:o,j:r}),f.fontSize);e=L?P-M.height/2-w-b.offsetY+18:P+M.height+w+b.offsetY-18,i=k+(a.globals.isXNumeric?c*(a.globals.barGroups.length-1)-c/2:-(c*a.globals.barGroups.length-c/2-2*v))+b.offsetX;}return a.config.chart.stacked||(p<0?p=0+v:p+g.height/3>a.globals.gridHeight&&(p=a.globals.gridHeight-v)),{bcx:h,bcy:l,dataLabelsX:u,dataLabelsY:p,totalDataLabelsX:i,totalDataLabelsY:e,totalDataLabelsAnchor:"middle"}}},{key:"calculateBarsDataLabelsPosition",value:function(t){var e=this.w,i=t.x,a=t.i,s=t.j,r=t.realIndex,o=t.columnGroupIndex,n=t.bcy,l=t.barHeight,h=t.barWidth,c=t.textRects,d=t.dataLabelsX,g=t.strokeWidth,u=t.dataLabelsConfig,p=t.barDataLabelsConfig,f=t.barTotalDataLabelsConfig,x=t.offX,b=t.offY,v=e.globals.gridHeight/e.globals.dataPoints;h=Math.abs(h);var y,w,k=(n+=o*l)-(this.barCtx.isRangeBar?0:v)+l/2+c.height/2+b-3,A="start",S=this.barCtx.series[a][s]<0,C=i;switch(this.barCtx.isReversed&&(C=i+(S?-h:h),i=e.globals.gridWidth-h,A=S?"start":"end"),p.position){case"center":d=S?C+h/2-x:Math.max(c.width/2,C-h/2)+x;break;case"bottom":d=S?C+h-g-Math.round(c.width/2)-x:C-h+g+Math.round(c.width/2)+x;break;case"top":d=S?C-g+Math.round(c.width/2)-x:C-g-Math.round(c.width/2)+x;}if(this.barCtx.lastActiveBarSerieIndex===r&&f.enabled){var L=new m(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({realIndex:r,j:s}),u.fontSize);S?(y=C-g-x-f.offsetX,A="end"):y=C+x+f.offsetX+(this.barCtx.isReversed?-(h+g):g),w=k-c.height/2+L.height/2+f.offsetY+g;}return e.config.chart.stacked||(d<0?d=d+c.width+g:d+c.width/2>e.globals.gridWidth&&(d=e.globals.gridWidth-c.width-g)),{bcx:i,bcy:n,dataLabelsX:d,dataLabelsY:k,totalDataLabelsX:y,totalDataLabelsY:w,totalDataLabelsAnchor:A}}},{key:"drawCalculatedDataLabels",value:function(t){var i=t.x,a=t.y,s=t.val,r=t.i,o=t.j,n=t.textRects,l=t.barHeight,h=t.barWidth,c=t.dataLabelsConfig,d=this.w,g="rotate(0)";"vertical"===d.config.plotOptions.bar.dataLabels.orientation&&(g="rotate(-90, ".concat(i,", ").concat(a,")"));var u=new N(this.barCtx.ctx),p=new m(this.barCtx.ctx),f=c.formatter,x=null,b=d.globals.collapsedSeriesIndices.indexOf(r)>-1;if(c.enabled&&!b){x=p.group({class:"apexcharts-data-labels",transform:g});var v="";void 0!==s&&(v=f(s,e(e({},d),{},{seriesIndex:r,dataPointIndex:o,w:d}))),!s&&d.config.plotOptions.bar.hideZeroBarsWhenGrouped&&(v="");var y=d.globals.series[r][o]<0,w=d.config.plotOptions.bar.dataLabels.position;if("vertical"===d.config.plotOptions.bar.dataLabels.orientation&&("top"===w&&(c.textAnchor=y?"end":"start"),"center"===w&&(c.textAnchor="middle"),"bottom"===w&&(c.textAnchor=y?"end":"start")),this.barCtx.isRangeBar&&this.barCtx.barOptions.dataLabels.hideOverflowingLabels)h<p.getTextRects(v,parseFloat(c.style.fontSize)).width&&(v="");d.config.chart.stacked&&this.barCtx.barOptions.dataLabels.hideOverflowingLabels&&(this.barCtx.isHorizontal?n.width/1.6>Math.abs(h)&&(v=""):n.height/1.6>Math.abs(l)&&(v=""));var k=e({},c);this.barCtx.isHorizontal&&s<0&&("start"===c.textAnchor?k.textAnchor="end":"end"===c.textAnchor&&(k.textAnchor="start")),u.plotDataLabelsText({x:i,y:a,text:v,i:r,j:o,parent:x,dataLabelsConfig:k,alwaysDrawDataLabel:!0,offsetCorrection:!0});}return x}},{key:"drawTotalDataLabels",value:function(t){var e,i=t.x,a=t.y,s=t.val,r=t.barWidth,o=t.barHeight,n=t.realIndex,l=t.textAnchor,h=t.barTotalDataLabelsConfig,c=this.w,d=new m(this.barCtx.ctx);return h.enabled&&void 0!==i&&void 0!==a&&this.barCtx.lastActiveBarSerieIndex===n&&(e=d.drawText({x:i-(!c.globals.isBarHorizontal&&c.globals.barGroups.length?r*(c.globals.barGroups.length-1)/2:0),y:a-(c.globals.isBarHorizontal&&c.globals.barGroups.length?o*(c.globals.barGroups.length-1)/2:0),foreColor:h.style.color,text:s,textAnchor:l,fontFamily:h.style.fontFamily,fontSize:h.style.fontSize,fontWeight:h.style.fontWeight})),e}}]),t}(),mt=function(){function t(e){a(this,t),this.w=e.w,this.barCtx=e;}return r(t,[{key:"initVariables",value:function(t){var e=this.w;this.barCtx.series=t,this.barCtx.totalItems=0,this.barCtx.seriesLen=0,this.barCtx.visibleI=-1,this.barCtx.visibleItems=1;for(var i=0;i<t.length;i++)if(t[i].length>0&&(this.barCtx.seriesLen=this.barCtx.seriesLen+1,this.barCtx.totalItems+=t[i].length),e.globals.isXNumeric)for(var a=0;a<t[i].length;a++)e.globals.seriesX[i][a]>e.globals.minX&&e.globals.seriesX[i][a]<e.globals.maxX&&this.barCtx.visibleItems++;else this.barCtx.visibleItems=e.globals.dataPoints;0===this.barCtx.seriesLen&&(this.barCtx.seriesLen=1),this.barCtx.zeroSerieses=[],e.globals.comboCharts||this.checkZeroSeries({series:t});}},{key:"initialPositions",value:function(){var t,e,i,a,s,r,o,n,l=this.w,h=l.globals.dataPoints;this.barCtx.isRangeBar&&(h=l.globals.labels.length);var c=this.barCtx.seriesLen;if(l.config.plotOptions.bar.rangeBarGroupRows&&(c=1),this.barCtx.isHorizontal)s=(i=l.globals.gridHeight/h)/c,l.globals.isXNumeric&&(s=(i=l.globals.gridHeight/this.barCtx.totalItems)/this.barCtx.seriesLen),s=s*parseInt(this.barCtx.barOptions.barHeight,10)/100,-1===String(this.barCtx.barOptions.barHeight).indexOf("%")&&(s=parseInt(this.barCtx.barOptions.barHeight,10)),n=this.barCtx.baseLineInvertedY+l.globals.padHorizontal+(this.barCtx.isReversed?l.globals.gridWidth:0)-(this.barCtx.isReversed?2*this.barCtx.baseLineInvertedY:0),this.barCtx.isFunnel&&(n=l.globals.gridWidth/2),e=(i-s*this.barCtx.seriesLen)/2;else {if(a=l.globals.gridWidth/this.barCtx.visibleItems,l.config.xaxis.convertedCatToNumeric&&(a=l.globals.gridWidth/l.globals.dataPoints),r=a/c*parseInt(this.barCtx.barOptions.columnWidth,10)/100,l.globals.isXNumeric){var d=this.barCtx.xRatio;l.globals.minXDiff&&.5!==l.globals.minXDiff&&l.globals.minXDiff/d>0&&(a=l.globals.minXDiff/d),(r=a/c*parseInt(this.barCtx.barOptions.columnWidth,10)/100)<1&&(r=1);}-1===String(this.barCtx.barOptions.columnWidth).indexOf("%")&&(r=parseInt(this.barCtx.barOptions.columnWidth,10)),o=l.globals.gridHeight-this.barCtx.baseLineY[this.barCtx.translationsIndex]-(this.barCtx.isReversed?l.globals.gridHeight:0)+(this.barCtx.isReversed?2*this.barCtx.baseLineY[this.barCtx.translationsIndex]:0),t=l.globals.padHorizontal+(a-r*this.barCtx.seriesLen)/2;}return l.globals.barHeight=s,l.globals.barWidth=r,{x:t,y:e,yDivision:i,xDivision:a,barHeight:s,barWidth:r,zeroH:o,zeroW:n}}},{key:"initializeStackedPrevVars",value:function(t){t.w.globals.seriesGroups.forEach((function(e){t[e]||(t[e]={}),t[e].prevY=[],t[e].prevX=[],t[e].prevYF=[],t[e].prevXF=[],t[e].prevYVal=[],t[e].prevXVal=[];}));}},{key:"initializeStackedXYVars",value:function(t){t.w.globals.seriesGroups.forEach((function(e){t[e]||(t[e]={}),t[e].xArrj=[],t[e].xArrjF=[],t[e].xArrjVal=[],t[e].yArrj=[],t[e].yArrjF=[],t[e].yArrjVal=[];}));}},{key:"getPathFillColor",value:function(t,e,i,a){var s,r,o,n,l=this.w,h=new H(this.barCtx.ctx),c=null,d=this.barCtx.barOptions.distributed?i:e;this.barCtx.barOptions.colors.ranges.length>0&&this.barCtx.barOptions.colors.ranges.map((function(a){t[e][i]>=a.from&&t[e][i]<=a.to&&(c=a.color);}));return l.config.series[e].data[i]&&l.config.series[e].data[i].fillColor&&(c=l.config.series[e].data[i].fillColor),h.fillPath({seriesNumber:this.barCtx.barOptions.distributed?d:a,dataPointIndex:i,color:c,value:t[e][i],fillConfig:null===(s=l.config.series[e].data[i])||void 0===s?void 0:s.fill,fillType:null!==(r=l.config.series[e].data[i])&&void 0!==r&&null!==(o=r.fill)&&void 0!==o&&o.type?null===(n=l.config.series[e].data[i])||void 0===n?void 0:n.fill.type:Array.isArray(l.config.fill.type)?l.config.fill.type[e]:l.config.fill.type})}},{key:"getStrokeWidth",value:function(t,e,i){var a=0,s=this.w;return void 0===this.barCtx.series[t][e]||null===this.barCtx.series[t][e]?this.barCtx.isNullValue=!0:this.barCtx.isNullValue=!1,s.config.stroke.show&&(this.barCtx.isNullValue||(a=Array.isArray(this.barCtx.strokeWidth)?this.barCtx.strokeWidth[i]:this.barCtx.strokeWidth)),a}},{key:"shouldApplyRadius",value:function(t){var e=this.w,i=!1;return e.config.plotOptions.bar.borderRadius>0&&(e.config.chart.stacked&&"last"===e.config.plotOptions.bar.borderRadiusWhenStacked?this.barCtx.lastActiveBarSerieIndex===t&&(i=!0):i=!0),i}},{key:"barBackground",value:function(t){var e=t.j,i=t.i,a=t.x1,s=t.x2,r=t.y1,o=t.y2,n=t.elSeries,l=this.w,h=new m(this.barCtx.ctx),c=new W(this.barCtx.ctx).getActiveConfigSeriesIndex();if(this.barCtx.barOptions.colors.backgroundBarColors.length>0&&c===i){e>=this.barCtx.barOptions.colors.backgroundBarColors.length&&(e%=this.barCtx.barOptions.colors.backgroundBarColors.length);var d=this.barCtx.barOptions.colors.backgroundBarColors[e],g=h.drawRect(void 0!==a?a:0,void 0!==r?r:0,void 0!==s?s:l.globals.gridWidth,void 0!==o?o:l.globals.gridHeight,this.barCtx.barOptions.colors.backgroundBarRadius,d,this.barCtx.barOptions.colors.backgroundBarOpacity);n.add(g),g.node.classList.add("apexcharts-backgroundBar");}}},{key:"getColumnPaths",value:function(t){var e,i=t.barWidth,a=t.barXPosition,s=t.y1,r=t.y2,o=t.strokeWidth,n=t.seriesGroup,l=t.realIndex,h=t.i,c=t.j,d=t.w,g=new m(this.barCtx.ctx);(o=Array.isArray(o)?o[l]:o)||(o=0);var u=i,p=a;null!==(e=d.config.series[l].data[c])&&void 0!==e&&e.columnWidthOffset&&(p=a-d.config.series[l].data[c].columnWidthOffset/2,u=i+d.config.series[l].data[c].columnWidthOffset);var f=o/2,x=p+f,b=p+u-f;s+=.001-f,r+=.001+f;var v=g.move(x,s),y=g.move(x,s),w=g.line(b,s);if(d.globals.previousPaths.length>0&&(y=this.barCtx.getPreviousPath(l,c,!1)),v=v+g.line(x,r)+g.line(b,r)+g.line(b,s)+("around"===d.config.plotOptions.bar.borderRadiusApplication?" Z":" z"),y=y+g.line(x,s)+w+w+w+w+w+g.line(x,s)+("around"===d.config.plotOptions.bar.borderRadiusApplication?" Z":" z"),this.shouldApplyRadius(l)&&(v=g.roundPathCorners(v,d.config.plotOptions.bar.borderRadius)),d.config.chart.stacked){var k=this.barCtx;(k=this.barCtx[n]).yArrj.push(r-f),k.yArrjF.push(Math.abs(s-r+o)),k.yArrjVal.push(this.barCtx.series[h][c]);}return {pathTo:v,pathFrom:y}}},{key:"getBarpaths",value:function(t){var e,i=t.barYPosition,a=t.barHeight,s=t.x1,r=t.x2,o=t.strokeWidth,n=t.seriesGroup,l=t.realIndex,h=t.i,c=t.j,d=t.w,g=new m(this.barCtx.ctx);(o=Array.isArray(o)?o[l]:o)||(o=0);var u=i,p=a;null!==(e=d.config.series[l].data[c])&&void 0!==e&&e.barHeightOffset&&(u=i-d.config.series[l].data[c].barHeightOffset/2,p=a+d.config.series[l].data[c].barHeightOffset);var f=o/2,x=u+f,b=u+p-f;s+=.001-f,r+=.001+f;var v=g.move(s,x),y=g.move(s,x);d.globals.previousPaths.length>0&&(y=this.barCtx.getPreviousPath(l,c,!1));var w=g.line(s,b);if(v=v+g.line(r,x)+g.line(r,b)+w+("around"===d.config.plotOptions.bar.borderRadiusApplication?" Z":" z"),y=y+g.line(s,x)+w+w+w+w+w+g.line(s,x)+("around"===d.config.plotOptions.bar.borderRadiusApplication?" Z":" z"),this.shouldApplyRadius(l)&&(v=g.roundPathCorners(v,d.config.plotOptions.bar.borderRadius)),d.config.chart.stacked){var k=this.barCtx;(k=this.barCtx[n]).xArrj.push(r+f),k.xArrjF.push(Math.abs(s-r)),k.xArrjVal.push(this.barCtx.series[h][c]);}return {pathTo:v,pathFrom:y}}},{key:"checkZeroSeries",value:function(t){for(var e=t.series,i=this.w,a=0;a<e.length;a++){for(var s=0,r=0;r<e[i.globals.maxValsInArrayIndex].length;r++)s+=e[a][r];0===s&&this.barCtx.zeroSerieses.push(a);}}},{key:"getXForValue",value:function(t,e){var i=!(arguments.length>2&&void 0!==arguments[2])||arguments[2]?e:null;return null!=t&&(i=e+t/this.barCtx.invertedYRatio-2*(this.barCtx.isReversed?t/this.barCtx.invertedYRatio:0)),i}},{key:"getYForValue",value:function(t,e,i){var a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3]?e:null;return null!=t&&(a=e-t/this.barCtx.yRatio[i]+2*(this.barCtx.isReversed?t/this.barCtx.yRatio[i]:0)),a}},{key:"getGoalValues",value:function(t,i,a,s,r,n){var l=this,h=this.w,c=[],d=function(e,s){var r;c.push((o(r={},t,"x"===t?l.getXForValue(e,i,!1):l.getYForValue(e,a,n,!1)),o(r,"attrs",s),r));};if(h.globals.seriesGoals[s]&&h.globals.seriesGoals[s][r]&&Array.isArray(h.globals.seriesGoals[s][r])&&h.globals.seriesGoals[s][r].forEach((function(t){d(t.value,t);})),this.barCtx.barOptions.isDumbbell&&h.globals.seriesRange.length){var g=this.barCtx.barOptions.dumbbellColors?this.barCtx.barOptions.dumbbellColors:h.globals.colors,u={strokeHeight:"x"===t?0:h.globals.markers.size[s],strokeWidth:"x"===t?h.globals.markers.size[s]:0,strokeDashArray:0,strokeLineCap:"round",strokeColor:Array.isArray(g[s])?g[s][0]:g[s]};d(h.globals.seriesRangeStart[s][r],u),d(h.globals.seriesRangeEnd[s][r],e(e({},u),{},{strokeColor:Array.isArray(g[s])?g[s][1]:g[s]}));}return c}},{key:"drawGoalLine",value:function(t){var e=t.barXPosition,i=t.barYPosition,a=t.goalX,s=t.goalY,r=t.barWidth,o=t.barHeight,n=new m(this.barCtx.ctx),l=n.group({className:"apexcharts-bar-goals-groups"});l.node.classList.add("apexcharts-element-hidden"),this.barCtx.w.globals.delayedElements.push({el:l.node}),l.attr("clip-path","url(#gridRectMarkerMask".concat(this.barCtx.w.globals.cuid,")"));var h=null;return this.barCtx.isHorizontal?Array.isArray(a)&&a.forEach((function(t){if(t.x>=-1&&t.x<=n.w.globals.gridWidth+1){var e=void 0!==t.attrs.strokeHeight?t.attrs.strokeHeight:o/2,a=i+e+o/2;h=n.drawLine(t.x,a-2*e,t.x,a,t.attrs.strokeColor?t.attrs.strokeColor:void 0,t.attrs.strokeDashArray,t.attrs.strokeWidth?t.attrs.strokeWidth:2,t.attrs.strokeLineCap),l.add(h);}})):Array.isArray(s)&&s.forEach((function(t){if(t.y>=-1&&t.y<=n.w.globals.gridHeight+1){var i=void 0!==t.attrs.strokeWidth?t.attrs.strokeWidth:r/2,a=e+i+r/2;h=n.drawLine(a-2*i,t.y,a,t.y,t.attrs.strokeColor?t.attrs.strokeColor:void 0,t.attrs.strokeDashArray,t.attrs.strokeHeight?t.attrs.strokeHeight:2,t.attrs.strokeLineCap),l.add(h);}})),l}},{key:"drawBarShadow",value:function(t){var e=t.prevPaths,i=t.currPaths,a=t.color,s=this.w,r=e.x,o=e.x1,n=e.barYPosition,l=i.x,h=i.x1,c=i.barYPosition,d=n+i.barHeight,g=new m(this.barCtx.ctx),u=new x,p=g.move(o,d)+g.line(r,d)+g.line(l,c)+g.line(h,c)+g.line(o,d)+("around"===s.config.plotOptions.bar.borderRadiusApplication?" Z":" z");return g.drawPath({d:p,fill:u.shadeColor(.5,x.rgb2hex(a)),stroke:"none",strokeWidth:0,fillOpacity:1,classes:"apexcharts-bar-shadows"})}},{key:"getZeroValueEncounters",value:function(t){var e,i=t.i,a=t.j,s=this.w,r=0,o=0;return (s.config.plotOptions.bar.horizontal?s.globals.series.map((function(t,e){return e})):(null===(e=s.globals.columnSeries)||void 0===e?void 0:e.i.map((function(t){return t})))||[]).forEach((function(t){var e=s.globals.seriesPercent[t][a];e&&r++,t<i&&0===e&&o++;})),{nonZeroColumns:r,zeroEncounters:o}}},{key:"getGroupIndex",value:function(t){var e=this.w,i=e.globals.seriesGroups.findIndex((function(i){return i.indexOf(e.globals.seriesNames[t])>-1})),a=this.barCtx.columnGroupIndices,s=a.indexOf(i);return s<0&&(a.push(i),s=a.length-1),{groupIndex:i,columnGroupIndex:s}}}]),t}(),yt=function(){function t(e,i){a(this,t),this.ctx=e,this.w=e.w;var s=this.w;this.barOptions=s.config.plotOptions.bar,this.isHorizontal=this.barOptions.horizontal,this.strokeWidth=s.config.stroke.width,this.isNullValue=!1,this.isRangeBar=s.globals.seriesRange.length&&this.isHorizontal,this.isVerticalGroupedRangeBar=!s.globals.isBarHorizontal&&s.globals.seriesRange.length&&s.config.plotOptions.bar.rangeBarGroupRows,this.isFunnel=this.barOptions.isFunnel,this.xyRatios=i,null!==this.xyRatios&&(this.xRatio=i.xRatio,this.yRatio=i.yRatio,this.invertedXRatio=i.invertedXRatio,this.invertedYRatio=i.invertedYRatio,this.baseLineY=i.baseLineY,this.baseLineInvertedY=i.baseLineInvertedY),this.yaxisIndex=0,this.translationsIndex=0,this.seriesLen=0,this.pathArr=[];var r=new W(this.ctx);this.lastActiveBarSerieIndex=r.getActiveConfigSeriesIndex("desc",["bar","column"]),this.columnGroupIndices=[];var o=r.getBarSeriesIndices(),n=new y(this.ctx);this.stackedSeriesTotals=n.getStackedSeriesTotals(this.w.config.series.map((function(t,e){return -1===o.indexOf(e)?e:-1})).filter((function(t){return -1!==t}))),this.barHelpers=new mt(this);}return r(t,[{key:"draw",value:function(t,i){var a=this.w,s=new m(this.ctx),r=new y(this.ctx,a);t=r.getLogSeries(t),this.series=t,this.yRatio=r.getLogYRatios(this.yRatio),this.barHelpers.initVariables(t);var o=s.group({class:"apexcharts-bar-series apexcharts-plot-series"});a.config.dataLabels.enabled&&this.totalItems>this.barOptions.dataLabels.maxItems&&console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering - ApexCharts");for(var n=0,l=0;n<t.length;n++,l++){var h,c,d,g,u=void 0,p=void 0,f=[],b=[],v=a.globals.comboCharts?i[n]:n,w=this.barHelpers.getGroupIndex(v).columnGroupIndex,k=s.group({class:"apexcharts-series",rel:n+1,seriesName:x.escapeString(a.globals.seriesNames[v]),"data:realIndex":v});this.ctx.series.addCollapsedClassToSeries(k,v),t[n].length>0&&(this.visibleI=this.visibleI+1);var A=0,S=0;this.yRatio.length>1&&(this.yaxisIndex=a.globals.seriesYAxisReverseMap[v],this.translationsIndex=v);var C=this.translationsIndex;this.isReversed=a.config.yaxis[this.yaxisIndex]&&a.config.yaxis[this.yaxisIndex].reversed;var L=this.barHelpers.initialPositions();p=L.y,A=L.barHeight,c=L.yDivision,g=L.zeroW,u=L.x,S=L.barWidth,h=L.xDivision,d=L.zeroH,this.horizontal||b.push(u+S/2);var P=s.group({class:"apexcharts-datalabels","data:realIndex":v});a.globals.delayedElements.push({el:P.node}),P.node.classList.add("apexcharts-element-hidden");var M=s.group({class:"apexcharts-bar-goals-markers"}),I=s.group({class:"apexcharts-bar-shadows"});a.globals.delayedElements.push({el:I.node}),I.node.classList.add("apexcharts-element-hidden");for(var T=0;T<t[n].length;T++){var z=this.barHelpers.getStrokeWidth(n,T,v),X=null,E={indexes:{i:n,j:T,realIndex:v,translationsIndex:C,bc:l},x:u,y:p,strokeWidth:z,elSeries:k};this.isHorizontal?(X=this.drawBarPaths(e(e({},E),{},{barHeight:A,zeroW:g,yDivision:c})),S=this.series[n][T]/this.invertedYRatio):(X=this.drawColumnPaths(e(e({},E),{},{xDivision:h,barWidth:S,zeroH:d})),A=this.series[n][T]/this.yRatio[C]);var Y=this.barHelpers.getPathFillColor(t,n,T,v);if(this.isFunnel&&this.barOptions.isFunnel3d&&this.pathArr.length&&T>0){var F=this.barHelpers.drawBarShadow({color:"string"==typeof Y&&-1===(null==Y?void 0:Y.indexOf("url"))?Y:x.hexToRgba(a.globals.colors[n]),prevPaths:this.pathArr[this.pathArr.length-1],currPaths:X});F&&I.add(F);}this.pathArr.push(X);var R=this.barHelpers.drawGoalLine({barXPosition:X.barXPosition,barYPosition:X.barYPosition,goalX:X.goalX,goalY:X.goalY,barHeight:A,barWidth:S});R&&M.add(R),p=X.y,u=X.x,T>0&&b.push(u+S/2),f.push(p),this.renderSeries({realIndex:v,pathFill:Y,j:T,i:n,columnGroupIndex:w,pathFrom:X.pathFrom,pathTo:X.pathTo,strokeWidth:z,elSeries:k,x:u,y:p,series:t,barHeight:X.barHeight?X.barHeight:A,barWidth:X.barWidth?X.barWidth:S,elDataLabelsWrap:P,elGoalsMarkers:M,elBarShadows:I,visibleSeries:this.visibleI,type:"bar"});}a.globals.seriesXvalues[v]=b,a.globals.seriesYvalues[v]=f,o.add(k);}return o}},{key:"renderSeries",value:function(t){var e=t.realIndex,i=t.pathFill,a=t.lineFill,s=t.j,r=t.i,o=t.columnGroupIndex,n=t.pathFrom,l=t.pathTo,h=t.strokeWidth,c=t.elSeries,d=t.x,g=t.y,u=t.y1,p=t.y2,f=t.series,x=t.barHeight,b=t.barWidth,y=t.barXPosition,w=t.barYPosition,k=t.elDataLabelsWrap,A=t.elGoalsMarkers,S=t.elBarShadows,C=t.visibleSeries,L=t.type,P=this.w,M=new m(this.ctx);if(!a){var I="function"==typeof P.globals.stroke.colors[e]?function(t){var e,i=P.config.stroke.colors;return Array.isArray(i)&&i.length>0&&((e=i[t])||(e=""),"function"==typeof e)?e({value:P.globals.series[t][s],dataPointIndex:s,w:P}):e}(e):P.globals.stroke.colors[e];a=this.barOptions.distributed?P.globals.stroke.colors[s]:I;}P.config.series[r].data[s]&&P.config.series[r].data[s].strokeColor&&(a=P.config.series[r].data[s].strokeColor),this.isNullValue&&(i="none");var T=s/P.config.chart.animations.animateGradually.delay*(P.config.chart.animations.speed/P.globals.dataPoints)/2.4,z=M.renderPaths({i:r,j:s,realIndex:e,pathFrom:n,pathTo:l,stroke:a,strokeWidth:h,strokeLineCap:P.config.stroke.lineCap,fill:i,animationDelay:T,initialSpeed:P.config.chart.animations.speed,dataChangeSpeed:P.config.chart.animations.dynamicAnimation.speed,className:"apexcharts-".concat(L,"-area")});z.attr("clip-path","url(#gridRectMask".concat(P.globals.cuid,")"));var X=P.config.forecastDataPoints;X.count>0&&s>=P.globals.dataPoints-X.count&&(z.node.setAttribute("stroke-dasharray",X.dashArray),z.node.setAttribute("stroke-width",X.strokeWidth),z.node.setAttribute("fill-opacity",X.fillOpacity)),void 0!==u&&void 0!==p&&(z.attr("data-range-y1",u),z.attr("data-range-y2",p)),new v(this.ctx).setSelectionFilter(z,e,s),c.add(z);var E=new vt(this).handleBarDataLabels({x:d,y:g,y1:u,y2:p,i:r,j:s,series:f,realIndex:e,columnGroupIndex:o,barHeight:x,barWidth:b,barXPosition:y,barYPosition:w,renderedPath:z,visibleSeries:C});return null!==E.dataLabels&&k.add(E.dataLabels),E.totalDataLabels&&k.add(E.totalDataLabels),c.add(k),A&&c.add(A),S&&c.add(S),c}},{key:"drawBarPaths",value:function(t){var e,i=t.indexes,a=t.barHeight,s=t.strokeWidth,r=t.zeroW,o=t.x,n=t.y,l=t.yDivision,h=t.elSeries,c=this.w,d=i.i,g=i.j;if(c.globals.isXNumeric)e=(n=(c.globals.seriesX[d][g]-c.globals.minX)/this.invertedXRatio-a)+a*this.visibleI;else if(c.config.plotOptions.bar.hideZeroBarsWhenGrouped){var u=0,p=0;c.globals.seriesPercent.forEach((function(t,e){t[g]&&u++,e<d&&0===t[g]&&p++;})),u>0&&(a=this.seriesLen*a/u),e=n+a*this.visibleI,e-=a*p;}else e=n+a*this.visibleI;this.isFunnel&&(r-=(this.barHelpers.getXForValue(this.series[d][g],r)-r)/2),o=this.barHelpers.getXForValue(this.series[d][g],r);var f=this.barHelpers.getBarpaths({barYPosition:e,barHeight:a,x1:r,x2:o,strokeWidth:s,series:this.series,realIndex:i.realIndex,i:d,j:g,w:c});return c.globals.isXNumeric||(n+=l),this.barHelpers.barBackground({j:g,i:d,y1:e-a*this.visibleI,y2:a*this.seriesLen,elSeries:h}),{pathTo:f.pathTo,pathFrom:f.pathFrom,x1:r,x:o,y:n,goalX:this.barHelpers.getGoalValues("x",r,null,d,g),barYPosition:e,barHeight:a}}},{key:"drawColumnPaths",value:function(t){var e,i=t.indexes,a=t.x,s=t.y,r=t.xDivision,o=t.barWidth,n=t.zeroH,l=t.strokeWidth,h=t.elSeries,c=this.w,d=i.realIndex,g=i.translationsIndex,u=i.i,p=i.j,f=i.bc;if(c.globals.isXNumeric){var x=this.getBarXForNumericXAxis({x:a,j:p,realIndex:d,barWidth:o});a=x.x,e=x.barXPosition;}else if(c.config.plotOptions.bar.hideZeroBarsWhenGrouped){var b=this.barHelpers.getZeroValueEncounters({i:u,j:p}),v=b.nonZeroColumns,m=b.zeroEncounters;v>0&&(o=this.seriesLen*o/v),e=a+o*this.visibleI,e-=o*m;}else e=a+o*this.visibleI;s=this.barHelpers.getYForValue(this.series[u][p],n,g);var y=this.barHelpers.getColumnPaths({barXPosition:e,barWidth:o,y1:n,y2:s,strokeWidth:l,series:this.series,realIndex:d,i:u,j:p,w:c});return c.globals.isXNumeric||(a+=r),this.barHelpers.barBackground({bc:f,j:p,i:u,x1:e-l/2-o*this.visibleI,x2:o*this.seriesLen+l/2,elSeries:h}),{pathTo:y.pathTo,pathFrom:y.pathFrom,x:a,y:s,goalY:this.barHelpers.getGoalValues("y",null,n,u,p,g),barXPosition:e,barWidth:o}}},{key:"getBarXForNumericXAxis",value:function(t){var e=t.x,i=t.barWidth,a=t.realIndex,s=t.j,r=this.w,o=a;return r.globals.seriesX[a].length||(o=r.globals.maxValsInArrayIndex),r.globals.seriesX[o][s]&&(e=(r.globals.seriesX[o][s]-r.globals.minX)/this.xRatio-i*this.seriesLen/2),{barXPosition:e+i*this.visibleI,x:e}}},{key:"getPreviousPath",value:function(t,e){for(var i,a=this.w,s=0;s<a.globals.previousPaths.length;s++){var r=a.globals.previousPaths[s];r.paths&&r.paths.length>0&&parseInt(r.realIndex,10)===parseInt(t,10)&&void 0!==a.globals.previousPaths[s].paths[e]&&(i=a.globals.previousPaths[s].paths[e].d);}return i}}]),t}(),wt=function(t){n(s,yt);var i=d(s);function s(){return a(this,s),i.apply(this,arguments)}return r(s,[{key:"draw",value:function(t,i){var a=this,s=this.w;this.graphics=new m(this.ctx),this.bar=new yt(this.ctx,this.xyRatios);var r=new y(this.ctx,s);t=r.getLogSeries(t),this.yRatio=r.getLogYRatios(this.yRatio),this.barHelpers.initVariables(t),"100%"===s.config.chart.stackType&&(t=s.globals.comboCharts?i.map((function(t){return s.globals.seriesPercent[t]})):s.globals.seriesPercent.slice()),this.series=t,this.barHelpers.initializeStackedPrevVars(this);for(var o=this.graphics.group({class:"apexcharts-bar-series apexcharts-plot-series"}),n=0,l=0,h=function(r,h){var c=void 0,d=void 0,g=void 0,u=void 0,p=s.globals.comboCharts?i[r]:r,f=a.barHelpers.getGroupIndex(p),b=f.groupIndex,v=f.columnGroupIndex;a.groupCtx=a[s.globals.seriesGroups[b]];var m=[],y=[],w=0;a.yRatio.length>1&&(a.yaxisIndex=s.globals.seriesYAxisReverseMap[p][0],w=p),a.isReversed=s.config.yaxis[a.yaxisIndex]&&s.config.yaxis[a.yaxisIndex].reversed;var k=a.graphics.group({class:"apexcharts-series",seriesName:x.escapeString(s.globals.seriesNames[p]),rel:r+1,"data:realIndex":p});a.ctx.series.addCollapsedClassToSeries(k,p);var A=a.graphics.group({class:"apexcharts-datalabels","data:realIndex":p}),S=a.graphics.group({class:"apexcharts-bar-goals-markers"}),C=0,L=0,P=a.initialPositions(n,l,c,d,g,u,w);l=P.y,C=P.barHeight,d=P.yDivision,u=P.zeroW,n=P.x,L=P.barWidth,c=P.xDivision,g=P.zeroH,s.globals.barHeight=C,s.globals.barWidth=L,a.barHelpers.initializeStackedXYVars(a),1===a.groupCtx.prevY.length&&a.groupCtx.prevY[0].every((function(t){return isNaN(t)}))&&(a.groupCtx.prevY[0]=a.groupCtx.prevY[0].map((function(){return g})),a.groupCtx.prevYF[0]=a.groupCtx.prevYF[0].map((function(){return 0})));for(var M=0;M<s.globals.dataPoints;M++){var I=a.barHelpers.getStrokeWidth(r,M,p),T={indexes:{i:r,j:M,realIndex:p,translationsIndex:w,bc:h},strokeWidth:I,x:n,y:l,elSeries:k,columnGroupIndex:v,seriesGroup:s.globals.seriesGroups[b]},z=null;a.isHorizontal?(z=a.drawStackedBarPaths(e(e({},T),{},{zeroW:u,barHeight:C,yDivision:d})),L=a.series[r][M]/a.invertedYRatio):(z=a.drawStackedColumnPaths(e(e({},T),{},{xDivision:c,barWidth:L,zeroH:g})),C=a.series[r][M]/a.yRatio[w]);var X=a.barHelpers.drawGoalLine({barXPosition:z.barXPosition,barYPosition:z.barYPosition,goalX:z.goalX,goalY:z.goalY,barHeight:C,barWidth:L});X&&S.add(X),l=z.y,n=z.x,m.push(n),y.push(l);var E=a.barHelpers.getPathFillColor(t,r,M,p);k=a.renderSeries({realIndex:p,pathFill:E,j:M,i:r,columnGroupIndex:v,pathFrom:z.pathFrom,pathTo:z.pathTo,strokeWidth:I,elSeries:k,x:n,y:l,series:t,barHeight:C,barWidth:L,elDataLabelsWrap:A,elGoalsMarkers:S,type:"bar",visibleSeries:0});}s.globals.seriesXvalues[p]=m,s.globals.seriesYvalues[p]=y,a.groupCtx.prevY.push(a.groupCtx.yArrj),a.groupCtx.prevYF.push(a.groupCtx.yArrjF),a.groupCtx.prevYVal.push(a.groupCtx.yArrjVal),a.groupCtx.prevX.push(a.groupCtx.xArrj),a.groupCtx.prevXF.push(a.groupCtx.xArrjF),a.groupCtx.prevXVal.push(a.groupCtx.xArrjVal),o.add(k);},c=0,d=0;c<t.length;c++,d++)h(c,d);return o}},{key:"initialPositions",value:function(t,e,i,a,s,r,o){var n,l,h=this.w;if(this.isHorizontal){a=h.globals.gridHeight/h.globals.dataPoints;var c=h.config.plotOptions.bar.barHeight;n=-1===String(c).indexOf("%")?parseInt(c,10):a*parseInt(c,10)/100,r=h.globals.padHorizontal+(this.isReversed?h.globals.gridWidth-this.baseLineInvertedY:this.baseLineInvertedY),e=(a-n)/2;}else {l=i=h.globals.gridWidth/h.globals.dataPoints;var d=h.config.plotOptions.bar.columnWidth;h.globals.isXNumeric&&h.globals.dataPoints>1?l=(i=h.globals.minXDiff/this.xRatio)*parseInt(this.barOptions.columnWidth,10)/100:-1===String(d).indexOf("%")?l=parseInt(d,10):l*=parseInt(d,10)/100,s=h.globals.gridHeight-this.baseLineY[o]-(this.isReversed?h.globals.gridHeight:0),t=h.globals.padHorizontal+(i-l)/2;}var g=h.globals.barGroups.length||1;return {x:t,y:e,yDivision:a,xDivision:i,barHeight:n/g,barWidth:l/g,zeroH:s,zeroW:r}}},{key:"drawStackedBarPaths",value:function(t){for(var e,i=t.indexes,a=t.barHeight,s=t.strokeWidth,r=t.zeroW,o=t.x,n=t.y,l=t.columnGroupIndex,h=t.seriesGroup,c=t.yDivision,d=t.elSeries,g=this.w,u=n+l*a,p=i.i,f=i.j,x=i.realIndex,b=i.translationsIndex,v=0,m=0;m<this.groupCtx.prevXF.length;m++)v+=this.groupCtx.prevXF[m][f];var y;if((y=h.indexOf(g.config.series[x].name))>0){var w=r;this.groupCtx.prevXVal[y-1][f]<0?w=this.series[p][f]>=0?this.groupCtx.prevX[y-1][f]+v-2*(this.isReversed?v:0):this.groupCtx.prevX[y-1][f]:this.groupCtx.prevXVal[y-1][f]>=0&&(w=this.series[p][f]>=0?this.groupCtx.prevX[y-1][f]:this.groupCtx.prevX[y-1][f]-v+2*(this.isReversed?v:0)),e=w;}else e=r;o=null===this.series[p][f]?e:e+this.series[p][f]/this.invertedYRatio-2*(this.isReversed?this.series[p][f]/this.invertedYRatio:0);var k=this.barHelpers.getBarpaths({barYPosition:u,barHeight:a,x1:e,x2:o,strokeWidth:s,series:this.series,realIndex:i.realIndex,seriesGroup:h,i:p,j:f,w:g});return this.barHelpers.barBackground({j:f,i:p,y1:u,y2:a,elSeries:d}),n+=c,{pathTo:k.pathTo,pathFrom:k.pathFrom,goalX:this.barHelpers.getGoalValues("x",r,null,p,f,b),barXPosition:e,barYPosition:u,x:o,y:n}}},{key:"drawStackedColumnPaths",value:function(t){var e=t.indexes,i=t.x,a=t.y,s=t.xDivision,r=t.barWidth,o=t.zeroH,n=t.columnGroupIndex,l=t.seriesGroup,h=t.elSeries,c=this.w,d=e.i,g=e.j,u=e.bc,p=e.realIndex,f=e.translationsIndex;if(c.globals.isXNumeric){var x=c.globals.seriesX[p][g];x||(x=0),i=(x-c.globals.minX)/this.xRatio-r/2*c.globals.barGroups.length;}for(var b,v=i+n*r,m=0,y=0;y<this.groupCtx.prevYF.length;y++)m+=isNaN(this.groupCtx.prevYF[y][g])?0:this.groupCtx.prevYF[y][g];var w=d;if(l&&(w=l.indexOf(c.globals.seriesNames[p])),w>0&&!c.globals.isXNumeric||w>0&&c.globals.isXNumeric&&c.globals.seriesX[p-1][g]===c.globals.seriesX[p][g]){var k,A,S,C=Math.min(this.yRatio.length+1,p+1);if(void 0!==this.groupCtx.prevY[w-1]&&this.groupCtx.prevY[w-1].length)for(var L=1;L<C;L++){var P;if(!isNaN(null===(P=this.groupCtx.prevY[w-L])||void 0===P?void 0:P[g])){S=this.groupCtx.prevY[w-L][g];break}}for(var M=1;M<C;M++){var I,T;if((null===(I=this.groupCtx.prevYVal[w-M])||void 0===I?void 0:I[g])<0){A=this.series[d][g]>=0?S-m+2*(this.isReversed?m:0):S;break}if((null===(T=this.groupCtx.prevYVal[w-M])||void 0===T?void 0:T[g])>=0){A=this.series[d][g]>=0?S:S+m-2*(this.isReversed?m:0);break}}void 0===A&&(A=c.globals.gridHeight),b=null!==(k=this.groupCtx.prevYF[0])&&void 0!==k&&k.every((function(t){return 0===t}))&&this.groupCtx.prevYF.slice(1,w).every((function(t){return t.every((function(t){return isNaN(t)}))}))?o:A;}else b=o;a=this.series[d][g]?b-this.series[d][g]/this.yRatio[f]+2*(this.isReversed?this.series[d][g]/this.yRatio[f]:0):b;var z=this.barHelpers.getColumnPaths({barXPosition:v,barWidth:r,y1:b,y2:a,yRatio:this.yRatio[f],strokeWidth:this.strokeWidth,series:this.series,seriesGroup:l,realIndex:e.realIndex,i:d,j:g,w:c});return this.barHelpers.barBackground({bc:u,j:g,i:d,x1:v,x2:r,elSeries:h}),i+=s,{pathTo:z.pathTo,pathFrom:z.pathFrom,goalY:this.barHelpers.getGoalValues("y",null,o,d,g),barXPosition:v,x:c.globals.isXNumeric?i-s:i,y:a}}}]),s}(),kt=function(t){n(s,yt);var i=d(s);function s(){return a(this,s),i.apply(this,arguments)}return r(s,[{key:"draw",value:function(t,i,a){var s=this,r=this.w,o=new m(this.ctx),n=r.globals.comboCharts?i:r.config.chart.type,l=new H(this.ctx);this.candlestickOptions=this.w.config.plotOptions.candlestick,this.boxOptions=this.w.config.plotOptions.boxPlot,this.isHorizontal=r.config.plotOptions.bar.horizontal;var h=new y(this.ctx,r);t=h.getLogSeries(t),this.series=t,this.yRatio=h.getLogYRatios(this.yRatio),this.barHelpers.initVariables(t);for(var c=o.group({class:"apexcharts-".concat(n,"-series apexcharts-plot-series")}),d=function(i){s.isBoxPlot="boxPlot"===r.config.chart.type||"boxPlot"===r.config.series[i].type;var n,h,d,g,u=void 0,p=void 0,f=[],b=[],v=r.globals.comboCharts?a[i]:i,m=s.barHelpers.getGroupIndex(v).columnGroupIndex,y=o.group({class:"apexcharts-series",seriesName:x.escapeString(r.globals.seriesNames[v]),rel:i+1,"data:realIndex":v});s.ctx.series.addCollapsedClassToSeries(y,v),t[i].length>0&&(s.visibleI=s.visibleI+1);var w,k,A=0;s.yRatio.length>1&&(s.yaxisIndex=r.globals.seriesYAxisReverseMap[v][0],A=v);var S=s.barHelpers.initialPositions();p=S.y,w=S.barHeight,h=S.yDivision,g=S.zeroW,u=S.x,k=S.barWidth,n=S.xDivision,d=S.zeroH,b.push(u+k/2);for(var C=o.group({class:"apexcharts-datalabels","data:realIndex":v}),L=function(a){var o=s.barHelpers.getStrokeWidth(i,a,v),c=null,x={indexes:{i:i,j:a,realIndex:v,translationsIndex:A},x:u,y:p,strokeWidth:o,elSeries:y};c=s.isHorizontal?s.drawHorizontalBoxPaths(e(e({},x),{},{yDivision:h,barHeight:w,zeroW:g})):s.drawVerticalBoxPaths(e(e({},x),{},{xDivision:n,barWidth:k,zeroH:d})),p=c.y,u=c.x,a>0&&b.push(u+k/2),f.push(p),c.pathTo.forEach((function(e,n){var h=!s.isBoxPlot&&s.candlestickOptions.wick.useFillColor?c.color[n]:r.globals.stroke.colors[i],d=l.fillPath({seriesNumber:v,dataPointIndex:a,color:c.color[n],value:t[i][a]});s.renderSeries({realIndex:v,pathFill:d,lineFill:h,j:a,i:i,pathFrom:c.pathFrom,pathTo:e,strokeWidth:o,elSeries:y,x:u,y:p,series:t,columnGroupIndex:m,barHeight:w,barWidth:k,elDataLabelsWrap:C,visibleSeries:s.visibleI,type:r.config.chart.type});}));},P=0;P<r.globals.dataPoints;P++)L(P);r.globals.seriesXvalues[v]=b,r.globals.seriesYvalues[v]=f,c.add(y);},g=0;g<t.length;g++)d(g);return c}},{key:"drawVerticalBoxPaths",value:function(t){var e=t.indexes,i=t.x;t.y;var a=t.xDivision,s=t.barWidth,r=t.zeroH,o=t.strokeWidth,n=this.w,l=new m(this.ctx),h=e.i,c=e.j,d=!0,g=n.config.plotOptions.candlestick.colors.upward,u=n.config.plotOptions.candlestick.colors.downward,p="";this.isBoxPlot&&(p=[this.boxOptions.colors.lower,this.boxOptions.colors.upper]);var f=this.yRatio[e.translationsIndex],x=e.realIndex,b=this.getOHLCValue(x,c),v=r,y=r;b.o>b.c&&(d=!1);var w=Math.min(b.o,b.c),k=Math.max(b.o,b.c),A=b.m;n.globals.isXNumeric&&(i=(n.globals.seriesX[x][c]-n.globals.minX)/this.xRatio-s/2);var S=i+s*this.visibleI;void 0===this.series[h][c]||null===this.series[h][c]?(w=r,k=r):(w=r-w/f,k=r-k/f,v=r-b.h/f,y=r-b.l/f,A=r-b.m/f);var C=l.move(S,r),L=l.move(S+s/2,w);return n.globals.previousPaths.length>0&&(L=this.getPreviousPath(x,c,!0)),C=this.isBoxPlot?[l.move(S,w)+l.line(S+s/2,w)+l.line(S+s/2,v)+l.line(S+s/4,v)+l.line(S+s-s/4,v)+l.line(S+s/2,v)+l.line(S+s/2,w)+l.line(S+s,w)+l.line(S+s,A)+l.line(S,A)+l.line(S,w+o/2),l.move(S,A)+l.line(S+s,A)+l.line(S+s,k)+l.line(S+s/2,k)+l.line(S+s/2,y)+l.line(S+s-s/4,y)+l.line(S+s/4,y)+l.line(S+s/2,y)+l.line(S+s/2,k)+l.line(S,k)+l.line(S,A)+"z"]:[l.move(S,k)+l.line(S+s/2,k)+l.line(S+s/2,v)+l.line(S+s/2,k)+l.line(S+s,k)+l.line(S+s,w)+l.line(S+s/2,w)+l.line(S+s/2,y)+l.line(S+s/2,w)+l.line(S,w)+l.line(S,k-o/2)],L+=l.move(S,w),n.globals.isXNumeric||(i+=a),{pathTo:C,pathFrom:L,x:i,y:k,barXPosition:S,color:this.isBoxPlot?p:d?[g]:[u]}}},{key:"drawHorizontalBoxPaths",value:function(t){var e=t.indexes;t.x;var i=t.y,a=t.yDivision,s=t.barHeight,r=t.zeroW,o=t.strokeWidth,n=this.w,l=new m(this.ctx),h=e.i,c=e.j,d=this.boxOptions.colors.lower;this.isBoxPlot&&(d=[this.boxOptions.colors.lower,this.boxOptions.colors.upper]);var g=this.invertedYRatio,u=e.realIndex,p=this.getOHLCValue(u,c),f=r,x=r,b=Math.min(p.o,p.c),v=Math.max(p.o,p.c),y=p.m;n.globals.isXNumeric&&(i=(n.globals.seriesX[u][c]-n.globals.minX)/this.invertedXRatio-s/2);var w=i+s*this.visibleI;void 0===this.series[h][c]||null===this.series[h][c]?(b=r,v=r):(b=r+b/g,v=r+v/g,f=r+p.h/g,x=r+p.l/g,y=r+p.m/g);var k=l.move(r,w),A=l.move(b,w+s/2);return n.globals.previousPaths.length>0&&(A=this.getPreviousPath(u,c,!0)),k=[l.move(b,w)+l.line(b,w+s/2)+l.line(f,w+s/2)+l.line(f,w+s/2-s/4)+l.line(f,w+s/2+s/4)+l.line(f,w+s/2)+l.line(b,w+s/2)+l.line(b,w+s)+l.line(y,w+s)+l.line(y,w)+l.line(b+o/2,w),l.move(y,w)+l.line(y,w+s)+l.line(v,w+s)+l.line(v,w+s/2)+l.line(x,w+s/2)+l.line(x,w+s-s/4)+l.line(x,w+s/4)+l.line(x,w+s/2)+l.line(v,w+s/2)+l.line(v,w)+l.line(y,w)+"z"],A+=l.move(b,w),n.globals.isXNumeric||(i+=a),{pathTo:k,pathFrom:A,x:v,y:i,barYPosition:w,color:d}}},{key:"getOHLCValue",value:function(t,e){var i=this.w;return {o:this.isBoxPlot?i.globals.seriesCandleH[t][e]:i.globals.seriesCandleO[t][e],h:this.isBoxPlot?i.globals.seriesCandleO[t][e]:i.globals.seriesCandleH[t][e],m:i.globals.seriesCandleM[t][e],l:this.isBoxPlot?i.globals.seriesCandleC[t][e]:i.globals.seriesCandleL[t][e],c:this.isBoxPlot?i.globals.seriesCandleL[t][e]:i.globals.seriesCandleC[t][e]}}}]),s}(),At=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w;}return r(t,[{key:"checkColorRange",value:function(){var t=this.w,e=!1,i=t.config.plotOptions[t.config.chart.type];return i.colorScale.ranges.length>0&&i.colorScale.ranges.map((function(t,i){t.from<=0&&(e=!0);})),e}},{key:"getShadeColor",value:function(t,e,i,a){var s=this.w,r=1,o=s.config.plotOptions[t].shadeIntensity,n=this.determineColor(t,e,i);s.globals.hasNegs||a?r=s.config.plotOptions[t].reverseNegativeShade?n.percent<0?n.percent/100*(1.25*o):(1-n.percent/100)*(1.25*o):n.percent<=0?1-(1+n.percent/100)*o:(1-n.percent/100)*o:(r=1-n.percent/100,"treemap"===t&&(r=(1-n.percent/100)*(1.25*o)));var l=n.color,h=new x;return s.config.plotOptions[t].enableShades&&(l="dark"===this.w.config.theme.mode?x.hexToRgba(h.shadeColor(-1*r,n.color),s.config.fill.opacity):x.hexToRgba(h.shadeColor(r,n.color),s.config.fill.opacity)),{color:l,colorProps:n}}},{key:"determineColor",value:function(t,e,i){var a=this.w,s=a.globals.series[e][i],r=a.config.plotOptions[t],o=r.colorScale.inverse?i:e;r.distributed&&"treemap"===a.config.chart.type&&(o=i);var n=a.globals.colors[o],l=null,h=Math.min.apply(Math,u(a.globals.series[e])),c=Math.max.apply(Math,u(a.globals.series[e]));r.distributed||"heatmap"!==t||(h=a.globals.minY,c=a.globals.maxY),void 0!==r.colorScale.min&&(h=r.colorScale.min<a.globals.minY?r.colorScale.min:a.globals.minY,c=r.colorScale.max>a.globals.maxY?r.colorScale.max:a.globals.maxY);var d=Math.abs(c)+Math.abs(h),g=100*s/(0===d?d-1e-6:d);r.colorScale.ranges.length>0&&r.colorScale.ranges.map((function(t,e){if(s>=t.from&&s<=t.to){n=t.color,l=t.foreColor?t.foreColor:null,h=t.from,c=t.to;var i=Math.abs(c)+Math.abs(h);g=100*s/(0===i?i-1e-6:i);}}));return {color:n,foreColor:l,percent:g}}},{key:"calculateDataLabels",value:function(t){var e=t.text,i=t.x,a=t.y,s=t.i,r=t.j,o=t.colorProps,n=t.fontSize,l=this.w.config.dataLabels,h=new m(this.ctx),c=new N(this.ctx),d=null;if(l.enabled){d=h.group({class:"apexcharts-data-labels"});var g=l.offsetX,u=l.offsetY,p=i+g,f=a+parseFloat(l.style.fontSize)/3+u;c.plotDataLabelsText({x:p,y:f,text:e,i:s,j:r,color:o.foreColor,parent:d,fontSize:n,dataLabelsConfig:l});}return d}},{key:"addListeners",value:function(t){var e=new m(this.ctx);t.node.addEventListener("mouseenter",e.pathMouseEnter.bind(this,t)),t.node.addEventListener("mouseleave",e.pathMouseLeave.bind(this,t)),t.node.addEventListener("mousedown",e.pathMouseDown.bind(this,t));}}]),t}(),St=function(){function t(e,i){a(this,t),this.ctx=e,this.w=e.w,this.xRatio=i.xRatio,this.yRatio=i.yRatio,this.dynamicAnim=this.w.config.chart.animations.dynamicAnimation,this.helpers=new At(e),this.rectRadius=this.w.config.plotOptions.heatmap.radius,this.strokeWidth=this.w.config.stroke.show?this.w.config.stroke.width:0;}return r(t,[{key:"draw",value:function(t){var e=this.w,i=new m(this.ctx),a=i.group({class:"apexcharts-heatmap"});a.attr("clip-path","url(#gridRectMask".concat(e.globals.cuid,")"));var s=e.globals.gridWidth/e.globals.dataPoints,r=e.globals.gridHeight/e.globals.series.length,o=0,n=!1;this.negRange=this.helpers.checkColorRange();var l=t.slice();e.config.yaxis[0].reversed&&(n=!0,l.reverse());for(var h=n?0:l.length-1;n?h<l.length:h>=0;n?h++:h--){var c=i.group({class:"apexcharts-series apexcharts-heatmap-series",seriesName:x.escapeString(e.globals.seriesNames[h]),rel:h+1,"data:realIndex":h});if(this.ctx.series.addCollapsedClassToSeries(c,h),e.config.chart.dropShadow.enabled){var d=e.config.chart.dropShadow;new v(this.ctx).dropShadow(c,d,h);}for(var g=0,u=e.config.plotOptions.heatmap.shadeIntensity,p=0;p<l[h].length;p++){var f=this.helpers.getShadeColor(e.config.chart.type,h,p,this.negRange),b=f.color,y=f.colorProps;if("image"===e.config.fill.type)b=new H(this.ctx).fillPath({seriesNumber:h,dataPointIndex:p,opacity:e.globals.hasNegs?y.percent<0?1-(1+y.percent/100):u+y.percent/100:y.percent/100,patternID:x.randomId(),width:e.config.fill.image.width?e.config.fill.image.width:s,height:e.config.fill.image.height?e.config.fill.image.height:r});var w=this.rectRadius,k=i.drawRect(g,o,s,r,w);if(k.attr({cx:g,cy:o}),k.node.classList.add("apexcharts-heatmap-rect"),c.add(k),k.attr({fill:b,i:h,index:h,j:p,val:t[h][p],"stroke-width":this.strokeWidth,stroke:e.config.plotOptions.heatmap.useFillColorAsStroke?b:e.globals.stroke.colors[0],color:b}),this.helpers.addListeners(k),e.config.chart.animations.enabled&&!e.globals.dataChanged){var A=1;e.globals.resized||(A=e.config.chart.animations.speed),this.animateHeatMap(k,g,o,s,r,A);}if(e.globals.dataChanged){var S=1;if(this.dynamicAnim.enabled&&e.globals.shouldAnimate){S=this.dynamicAnim.speed;var C=e.globals.previousPaths[h]&&e.globals.previousPaths[h][p]&&e.globals.previousPaths[h][p].color;C||(C="rgba(255, 255, 255, 0)"),this.animateHeatColor(k,x.isColorHex(C)?C:x.rgb2hex(C),x.isColorHex(b)?b:x.rgb2hex(b),S);}}var L=(0, e.config.dataLabels.formatter)(e.globals.series[h][p],{value:e.globals.series[h][p],seriesIndex:h,dataPointIndex:p,w:e}),P=this.helpers.calculateDataLabels({text:L,x:g+s/2,y:o+r/2,i:h,j:p,colorProps:y,series:l});null!==P&&c.add(P),g+=s;}o+=r,a.add(c);}var M=e.globals.yAxisScale[0].result.slice();return e.config.yaxis[0].reversed?M.unshift(""):M.push(""),e.globals.yAxisScale[0].result=M,a}},{key:"animateHeatMap",value:function(t,e,i,a,s,r){var o=new b(this.ctx);o.animateRect(t,{x:e+a/2,y:i+s/2,width:0,height:0},{x:e,y:i,width:a,height:s},r,(function(){o.animationCompleted(t);}));}},{key:"animateHeatColor",value:function(t,e,i,a){t.attr({fill:e}).animate(a).attr({fill:i});}}]),t}(),Ct=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w;}return r(t,[{key:"drawYAxisTexts",value:function(t,e,i,a){var s=this.w,r=s.config.yaxis[0],o=s.globals.yLabelFormatters[0];return new m(this.ctx).drawText({x:t+r.labels.offsetX,y:e+r.labels.offsetY,text:o(a,i),textAnchor:"middle",fontSize:r.labels.style.fontSize,fontFamily:r.labels.style.fontFamily,foreColor:Array.isArray(r.labels.style.colors)?r.labels.style.colors[i]:r.labels.style.colors})}}]),t}(),Lt=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w;var i=this.w;this.chartType=this.w.config.chart.type,this.initialAnim=this.w.config.chart.animations.enabled,this.dynamicAnim=this.initialAnim&&this.w.config.chart.animations.dynamicAnimation.enabled,this.animBeginArr=[0],this.animDur=0,this.donutDataLabels=this.w.config.plotOptions.pie.donut.labels,this.lineColorArr=void 0!==i.globals.stroke.colors?i.globals.stroke.colors:i.globals.colors,this.defaultSize=Math.min(i.globals.gridWidth,i.globals.gridHeight),this.centerY=this.defaultSize/2,this.centerX=i.globals.gridWidth/2,"radialBar"===i.config.chart.type?this.fullAngle=360:this.fullAngle=Math.abs(i.config.plotOptions.pie.endAngle-i.config.plotOptions.pie.startAngle),this.initialAngle=i.config.plotOptions.pie.startAngle%this.fullAngle,i.globals.radialSize=this.defaultSize/2.05-i.config.stroke.width-(i.config.chart.sparkline.enabled?0:i.config.chart.dropShadow.blur),this.donutSize=i.globals.radialSize*parseInt(i.config.plotOptions.pie.donut.size,10)/100,this.maxY=0,this.sliceLabels=[],this.sliceSizes=[],this.prevSectorAngleArr=[];}return r(t,[{key:"draw",value:function(t){var e=this,i=this.w,a=new m(this.ctx);if(this.ret=a.group({class:"apexcharts-pie"}),i.globals.noData)return this.ret;for(var s=0,r=0;r<t.length;r++)s+=x.negToZero(t[r]);var o=[],n=a.group();0===s&&(s=1e-5),t.forEach((function(t){e.maxY=Math.max(e.maxY,t);})),i.config.yaxis[0].max&&(this.maxY=i.config.yaxis[0].max),"back"===i.config.grid.position&&"polarArea"===this.chartType&&this.drawPolarElements(this.ret);for(var l=0;l<t.length;l++){var h=this.fullAngle*x.negToZero(t[l])/s;o.push(h),"polarArea"===this.chartType?(o[l]=this.fullAngle/t.length,this.sliceSizes.push(i.globals.radialSize*t[l]/this.maxY)):this.sliceSizes.push(i.globals.radialSize);}if(i.globals.dataChanged){for(var c,d=0,g=0;g<i.globals.previousPaths.length;g++)d+=x.negToZero(i.globals.previousPaths[g]);for(var u=0;u<i.globals.previousPaths.length;u++)c=this.fullAngle*x.negToZero(i.globals.previousPaths[u])/d,this.prevSectorAngleArr.push(c);}this.donutSize<0&&(this.donutSize=0);var p=i.config.plotOptions.pie.customScale,f=i.globals.gridWidth/2,b=i.globals.gridHeight/2,v=f-i.globals.gridWidth/2*p,y=b-i.globals.gridHeight/2*p;if("donut"===this.chartType){var w=a.drawCircle(this.donutSize);w.attr({cx:this.centerX,cy:this.centerY,fill:i.config.plotOptions.pie.donut.background?i.config.plotOptions.pie.donut.background:"transparent"}),n.add(w);}var k=this.drawArcs(o,t);if(this.sliceLabels.forEach((function(t){k.add(t);})),n.attr({transform:"translate(".concat(v,", ").concat(y,") scale(").concat(p,")")}),n.add(k),this.ret.add(n),this.donutDataLabels.show){var A=this.renderInnerDataLabels(this.donutDataLabels,{hollowSize:this.donutSize,centerX:this.centerX,centerY:this.centerY,opacity:this.donutDataLabels.show,translateX:v,translateY:y});this.ret.add(A);}return "front"===i.config.grid.position&&"polarArea"===this.chartType&&this.drawPolarElements(this.ret),this.ret}},{key:"drawArcs",value:function(t,e){var i=this.w,a=new v(this.ctx),s=new m(this.ctx),r=new H(this.ctx),o=s.group({class:"apexcharts-slices"}),n=this.initialAngle,l=this.initialAngle,h=this.initialAngle,c=this.initialAngle;this.strokeWidth=i.config.stroke.show?i.config.stroke.width:0;for(var d=0;d<t.length;d++){var g=s.group({class:"apexcharts-series apexcharts-pie-series",seriesName:x.escapeString(i.globals.seriesNames[d]),rel:d+1,"data:realIndex":d});o.add(g),l=c,h=(n=h)+t[d],c=l+this.prevSectorAngleArr[d];var u=h<n?this.fullAngle+h-n:h-n,p=r.fillPath({seriesNumber:d,size:this.sliceSizes[d],value:e[d]}),f=this.getChangedPath(l,c),b=s.drawPath({d:f,stroke:Array.isArray(this.lineColorArr)?this.lineColorArr[d]:this.lineColorArr,strokeWidth:0,fill:p,fillOpacity:i.config.fill.opacity,classes:"apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(),"-slice-").concat(d)});if(b.attr({index:0,j:d}),a.setSelectionFilter(b,0,d),i.config.chart.dropShadow.enabled){var y=i.config.chart.dropShadow;a.dropShadow(b,y,d);}this.addListeners(b,this.donutDataLabels),m.setAttrs(b.node,{"data:angle":u,"data:startAngle":n,"data:strokeWidth":this.strokeWidth,"data:value":e[d]});var w={x:0,y:0};"pie"===this.chartType||"polarArea"===this.chartType?w=x.polarToCartesian(this.centerX,this.centerY,i.globals.radialSize/1.25+i.config.plotOptions.pie.dataLabels.offset,(n+u/2)%this.fullAngle):"donut"===this.chartType&&(w=x.polarToCartesian(this.centerX,this.centerY,(i.globals.radialSize+this.donutSize)/2+i.config.plotOptions.pie.dataLabels.offset,(n+u/2)%this.fullAngle)),g.add(b);var k=0;if(!this.initialAnim||i.globals.resized||i.globals.dataChanged?this.animBeginArr.push(0):(0===(k=u/this.fullAngle*i.config.chart.animations.speed)&&(k=1),this.animDur=k+this.animDur,this.animBeginArr.push(this.animDur)),this.dynamicAnim&&i.globals.dataChanged?this.animatePaths(b,{size:this.sliceSizes[d],endAngle:h,startAngle:n,prevStartAngle:l,prevEndAngle:c,animateStartingPos:!0,i:d,animBeginArr:this.animBeginArr,shouldSetPrevPaths:!0,dur:i.config.chart.animations.dynamicAnimation.speed}):this.animatePaths(b,{size:this.sliceSizes[d],endAngle:h,startAngle:n,i:d,totalItems:t.length-1,animBeginArr:this.animBeginArr,dur:k}),i.config.plotOptions.pie.expandOnClick&&"polarArea"!==this.chartType&&b.node.addEventListener("mouseup",this.pieClicked.bind(this,d)),void 0!==i.globals.selectedDataPoints[0]&&i.globals.selectedDataPoints[0].indexOf(d)>-1&&this.pieClicked(d),i.config.dataLabels.enabled){var A=w.x,S=w.y,C=100*u/this.fullAngle+"%";if(0!==u&&i.config.plotOptions.pie.dataLabels.minAngleToShowLabel<t[d]){var L=i.config.dataLabels.formatter;void 0!==L&&(C=L(i.globals.seriesPercent[d][0],{seriesIndex:d,w:i}));var P=i.globals.dataLabels.style.colors[d],M=s.group({class:"apexcharts-datalabels"}),I=s.drawText({x:A,y:S,text:C,textAnchor:"middle",fontSize:i.config.dataLabels.style.fontSize,fontFamily:i.config.dataLabels.style.fontFamily,fontWeight:i.config.dataLabels.style.fontWeight,foreColor:P});if(M.add(I),i.config.dataLabels.dropShadow.enabled){var T=i.config.dataLabels.dropShadow;a.dropShadow(I,T);}I.node.classList.add("apexcharts-pie-label"),i.config.chart.animations.animate&&!1===i.globals.resized&&(I.node.classList.add("apexcharts-pie-label-delay"),I.node.style.animationDelay=i.config.chart.animations.speed/940+"s"),this.sliceLabels.push(M);}}}return o}},{key:"addListeners",value:function(t,e){var i=new m(this.ctx);t.node.addEventListener("mouseenter",i.pathMouseEnter.bind(this,t)),t.node.addEventListener("mouseleave",i.pathMouseLeave.bind(this,t)),t.node.addEventListener("mouseleave",this.revertDataLabelsInner.bind(this,t.node,e)),t.node.addEventListener("mousedown",i.pathMouseDown.bind(this,t)),this.donutDataLabels.total.showAlways||(t.node.addEventListener("mouseenter",this.printDataLabelsInner.bind(this,t.node,e)),t.node.addEventListener("mousedown",this.printDataLabelsInner.bind(this,t.node,e)));}},{key:"animatePaths",value:function(t,e){var i=this.w,a=e.endAngle<e.startAngle?this.fullAngle+e.endAngle-e.startAngle:e.endAngle-e.startAngle,s=a,r=e.startAngle,o=e.startAngle;void 0!==e.prevStartAngle&&void 0!==e.prevEndAngle&&(r=e.prevEndAngle,s=e.prevEndAngle<e.prevStartAngle?this.fullAngle+e.prevEndAngle-e.prevStartAngle:e.prevEndAngle-e.prevStartAngle),e.i===i.config.series.length-1&&(a+o>this.fullAngle?e.endAngle=e.endAngle-(a+o):a+o<this.fullAngle&&(e.endAngle=e.endAngle+(this.fullAngle-(a+o)))),a===this.fullAngle&&(a=this.fullAngle-.01),this.animateArc(t,r,o,a,s,e);}},{key:"animateArc",value:function(t,e,i,a,s,r){var o,n=this,l=this.w,h=new b(this.ctx),c=r.size;(isNaN(e)||isNaN(s))&&(e=i,s=a,r.dur=0);var d=a,g=i,u=e<i?this.fullAngle+e-i:e-i;l.globals.dataChanged&&r.shouldSetPrevPaths&&r.prevEndAngle&&(o=n.getPiePath({me:n,startAngle:r.prevStartAngle,angle:r.prevEndAngle<r.prevStartAngle?this.fullAngle+r.prevEndAngle-r.prevStartAngle:r.prevEndAngle-r.prevStartAngle,size:c}),t.attr({d:o})),0!==r.dur?t.animate(r.dur,l.globals.easing,r.animBeginArr[r.i]).afterAll((function(){"pie"!==n.chartType&&"donut"!==n.chartType&&"polarArea"!==n.chartType||this.animate(l.config.chart.animations.dynamicAnimation.speed).attr({"stroke-width":n.strokeWidth}),r.i===l.config.series.length-1&&h.animationCompleted(t);})).during((function(l){d=u+(a-u)*l,r.animateStartingPos&&(d=s+(a-s)*l,g=e-s+(i-(e-s))*l),o=n.getPiePath({me:n,startAngle:g,angle:d,size:c}),t.node.setAttribute("data:pathOrig",o),t.attr({d:o});})):(o=n.getPiePath({me:n,startAngle:g,angle:a,size:c}),r.isTrack||(l.globals.animationEnded=!0),t.node.setAttribute("data:pathOrig",o),t.attr({d:o,"stroke-width":n.strokeWidth}));}},{key:"pieClicked",value:function(t){var e,i=this.w,a=this,s=a.sliceSizes[t]+(i.config.plotOptions.pie.expandOnClick?4:0),r=i.globals.dom.Paper.select(".apexcharts-".concat(a.chartType.toLowerCase(),"-slice-").concat(t)).members[0];if("true"!==r.attr("data:pieClicked")){var o=i.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");Array.prototype.forEach.call(o,(function(t){t.setAttribute("data:pieClicked","false");var e=t.getAttribute("data:pathOrig");e&&t.setAttribute("d",e);})),i.globals.capturedDataPointIndex=t,r.attr("data:pieClicked","true");var n=parseInt(r.attr("data:startAngle"),10),l=parseInt(r.attr("data:angle"),10);e=a.getPiePath({me:a,startAngle:n,angle:l,size:s}),360!==l&&r.plot(e);}else {r.attr({"data:pieClicked":"false"}),this.revertDataLabelsInner(r.node,this.donutDataLabels);var h=r.attr("data:pathOrig");r.attr({d:h});}}},{key:"getChangedPath",value:function(t,e){var i="";return this.dynamicAnim&&this.w.globals.dataChanged&&(i=this.getPiePath({me:this,startAngle:t,angle:e-t,size:this.size})),i}},{key:"getPiePath",value:function(t){var e,i=t.me,a=t.startAngle,s=t.angle,r=t.size,o=new m(this.ctx),n=a,l=Math.PI*(n-90)/180,h=s+a;Math.ceil(h)>=this.fullAngle+this.w.config.plotOptions.pie.startAngle%this.fullAngle&&(h=this.fullAngle+this.w.config.plotOptions.pie.startAngle%this.fullAngle-.01),Math.ceil(h)>this.fullAngle&&(h-=this.fullAngle);var c=Math.PI*(h-90)/180,d=i.centerX+r*Math.cos(l),g=i.centerY+r*Math.sin(l),u=i.centerX+r*Math.cos(c),p=i.centerY+r*Math.sin(c),f=x.polarToCartesian(i.centerX,i.centerY,i.donutSize,h),b=x.polarToCartesian(i.centerX,i.centerY,i.donutSize,n),v=s>180?1:0,y=["M",d,g,"A",r,r,0,v,1,u,p];return e="donut"===i.chartType?[].concat(y,["L",f.x,f.y,"A",i.donutSize,i.donutSize,0,v,0,b.x,b.y,"L",d,g,"z"]).join(" "):"pie"===i.chartType||"polarArea"===i.chartType?[].concat(y,["L",i.centerX,i.centerY,"L",d,g]).join(" "):[].concat(y).join(" "),o.roundPathCorners(e,2*this.strokeWidth)}},{key:"drawPolarElements",value:function(t){var e=this.w,i=new _(this.ctx),a=new m(this.ctx),s=new Ct(this.ctx),r=a.group(),o=a.group(),n=i.niceScale(0,Math.ceil(this.maxY),0),l=n.result.reverse(),h=n.result.length;this.maxY=n.niceMax;for(var c=e.globals.radialSize,d=c/(h-1),g=0;g<h-1;g++){var u=a.drawCircle(c);if(u.attr({cx:this.centerX,cy:this.centerY,fill:"none","stroke-width":e.config.plotOptions.polarArea.rings.strokeWidth,stroke:e.config.plotOptions.polarArea.rings.strokeColor}),e.config.yaxis[0].show){var p=s.drawYAxisTexts(this.centerX,this.centerY-c+parseInt(e.config.yaxis[0].labels.style.fontSize,10)/2,g,l[g]);o.add(p);}r.add(u),c-=d;}this.drawSpokes(t),t.add(r),t.add(o);}},{key:"renderInnerDataLabels",value:function(t,e){var i=this.w,a=new m(this.ctx),s=a.group({class:"apexcharts-datalabels-group",transform:"translate(".concat(e.translateX?e.translateX:0,", ").concat(e.translateY?e.translateY:0,") scale(").concat(i.config.plotOptions.pie.customScale,")")}),r=t.total.show;s.node.style.opacity=e.opacity;var o,n,l=e.centerX,h=e.centerY;o=void 0===t.name.color?i.globals.colors[0]:t.name.color;var c=t.name.fontSize,d=t.name.fontFamily,g=t.name.fontWeight;n=void 0===t.value.color?i.config.chart.foreColor:t.value.color;var u=t.value.formatter,p="",f="";if(r?(o=t.total.color,c=t.total.fontSize,d=t.total.fontFamily,g=t.total.fontWeight,f=t.total.label,p=t.total.formatter(i)):1===i.globals.series.length&&(p=u(i.globals.series[0],i),f=i.globals.seriesNames[0]),f&&(f=t.name.formatter(f,t.total.show,i)),t.name.show){var x=a.drawText({x:l,y:h+parseFloat(t.name.offsetY),text:f,textAnchor:"middle",foreColor:o,fontSize:c,fontWeight:g,fontFamily:d});x.node.classList.add("apexcharts-datalabel-label"),s.add(x);}if(t.value.show){var b=t.name.show?parseFloat(t.value.offsetY)+16:t.value.offsetY,v=a.drawText({x:l,y:h+b,text:p,textAnchor:"middle",foreColor:n,fontWeight:t.value.fontWeight,fontSize:t.value.fontSize,fontFamily:t.value.fontFamily});v.node.classList.add("apexcharts-datalabel-value"),s.add(v);}return s}},{key:"printInnerLabels",value:function(t,e,i,a){var s,r=this.w;a?s=void 0===t.name.color?r.globals.colors[parseInt(a.parentNode.getAttribute("rel"),10)-1]:t.name.color:r.globals.series.length>1&&t.total.show&&(s=t.total.color);var o=r.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"),n=r.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");i=(0, t.value.formatter)(i,r),a||"function"!=typeof t.total.formatter||(i=t.total.formatter(r));var l=e===t.total.label;e=t.name.formatter(e,l,r),null!==o&&(o.textContent=e),null!==n&&(n.textContent=i),null!==o&&(o.style.fill=s);}},{key:"printDataLabelsInner",value:function(t,e){var i=this.w,a=t.getAttribute("data:value"),s=i.globals.seriesNames[parseInt(t.parentNode.getAttribute("rel"),10)-1];i.globals.series.length>1&&this.printInnerLabels(e,s,a,t);var r=i.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");null!==r&&(r.style.opacity=1);}},{key:"drawSpokes",value:function(t){var e=this,i=this.w,a=new m(this.ctx),s=i.config.plotOptions.polarArea.spokes;if(0!==s.strokeWidth){for(var r=[],o=360/i.globals.series.length,n=0;n<i.globals.series.length;n++)r.push(x.polarToCartesian(this.centerX,this.centerY,i.globals.radialSize,i.config.plotOptions.pie.startAngle+o*n));r.forEach((function(i,r){var o=a.drawLine(i.x,i.y,e.centerX,e.centerY,Array.isArray(s.connectorColors)?s.connectorColors[r]:s.connectorColors);t.add(o);}));}}},{key:"revertDataLabelsInner",value:function(t,e,i){var a=this,s=this.w,r=s.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group"),o=!1,n=s.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area"),l=function(t){var i=t.makeSliceOut,s=t.printLabel;Array.prototype.forEach.call(n,(function(t){"true"===t.getAttribute("data:pieClicked")&&(i&&(o=!0),s&&a.printDataLabelsInner(t,e));}));};if(l({makeSliceOut:!0,printLabel:!1}),e.total.show&&s.globals.series.length>1)o&&!e.total.showAlways?l({makeSliceOut:!1,printLabel:!0}):this.printInnerLabels(e,e.total.label,e.total.formatter(s));else if(l({makeSliceOut:!1,printLabel:!0}),!o)if(s.globals.selectedDataPoints.length&&s.globals.series.length>1)if(s.globals.selectedDataPoints[0].length>0){var h=s.globals.selectedDataPoints[0],c=s.globals.dom.baseEl.querySelector(".apexcharts-".concat(this.chartType.toLowerCase(),"-slice-").concat(h));this.printDataLabelsInner(c,e);}else r&&s.globals.selectedDataPoints.length&&0===s.globals.selectedDataPoints[0].length&&(r.style.opacity=0);else r&&s.globals.series.length>1&&(r.style.opacity=0);}}]),t}(),Pt=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w,this.chartType=this.w.config.chart.type,this.initialAnim=this.w.config.chart.animations.enabled,this.dynamicAnim=this.initialAnim&&this.w.config.chart.animations.dynamicAnimation.enabled,this.animDur=0;var i=this.w;this.graphics=new m(this.ctx),this.lineColorArr=void 0!==i.globals.stroke.colors?i.globals.stroke.colors:i.globals.colors,this.defaultSize=i.globals.svgHeight<i.globals.svgWidth?i.globals.gridHeight+1.5*i.globals.goldenPadding:i.globals.gridWidth,this.isLog=i.config.yaxis[0].logarithmic,this.logBase=i.config.yaxis[0].logBase,this.coreUtils=new y(this.ctx),this.maxValue=this.isLog?this.coreUtils.getLogVal(this.logBase,i.globals.maxY,0):i.globals.maxY,this.minValue=this.isLog?this.coreUtils.getLogVal(this.logBase,this.w.globals.minY,0):i.globals.minY,this.polygons=i.config.plotOptions.radar.polygons,this.strokeWidth=i.config.stroke.show?i.config.stroke.width:0,this.size=this.defaultSize/2.1-this.strokeWidth-i.config.chart.dropShadow.blur,i.config.xaxis.labels.show&&(this.size=this.size-i.globals.xAxisLabelsWidth/1.75),void 0!==i.config.plotOptions.radar.size&&(this.size=i.config.plotOptions.radar.size),this.dataRadiusOfPercent=[],this.dataRadius=[],this.angleArr=[],this.yaxisLabelsTextsPos=[];}return r(t,[{key:"draw",value:function(t){var i=this,a=this.w,s=new H(this.ctx),r=[],o=new N(this.ctx);t.length&&(this.dataPointsLen=t[a.globals.maxValsInArrayIndex].length),this.disAngle=2*Math.PI/this.dataPointsLen;var n=a.globals.gridWidth/2,l=a.globals.gridHeight/2,h=n+a.config.plotOptions.radar.offsetX,c=l+a.config.plotOptions.radar.offsetY,d=this.graphics.group({class:"apexcharts-radar-series apexcharts-plot-series",transform:"translate(".concat(h||0,", ").concat(c||0,")")}),g=[],u=null,p=null;if(this.yaxisLabels=this.graphics.group({class:"apexcharts-yaxis"}),t.forEach((function(t,n){var l=t.length===a.globals.dataPoints,h=i.graphics.group().attr({class:"apexcharts-series","data:longestSeries":l,seriesName:x.escapeString(a.globals.seriesNames[n]),rel:n+1,"data:realIndex":n});i.dataRadiusOfPercent[n]=[],i.dataRadius[n]=[],i.angleArr[n]=[],t.forEach((function(t,e){var a=Math.abs(i.maxValue-i.minValue);t-=i.minValue,i.isLog&&(t=i.coreUtils.getLogVal(i.logBase,t,0)),i.dataRadiusOfPercent[n][e]=t/a,i.dataRadius[n][e]=i.dataRadiusOfPercent[n][e]*i.size,i.angleArr[n][e]=e*i.disAngle;})),g=i.getDataPointsPos(i.dataRadius[n],i.angleArr[n]);var c=i.createPaths(g,{x:0,y:0});u=i.graphics.group({class:"apexcharts-series-markers-wrap apexcharts-element-hidden"}),p=i.graphics.group({class:"apexcharts-datalabels","data:realIndex":n}),a.globals.delayedElements.push({el:u.node,index:n});var d={i:n,realIndex:n,animationDelay:n,initialSpeed:a.config.chart.animations.speed,dataChangeSpeed:a.config.chart.animations.dynamicAnimation.speed,className:"apexcharts-radar",shouldClipToGrid:!1,bindEventsOnPaths:!1,stroke:a.globals.stroke.colors[n],strokeLineCap:a.config.stroke.lineCap},f=null;a.globals.previousPaths.length>0&&(f=i.getPreviousPath(n));for(var b=0;b<c.linePathsTo.length;b++){var m=i.graphics.renderPaths(e(e({},d),{},{pathFrom:null===f?c.linePathsFrom[b]:f,pathTo:c.linePathsTo[b],strokeWidth:Array.isArray(i.strokeWidth)?i.strokeWidth[n]:i.strokeWidth,fill:"none",drawShadow:!1}));h.add(m);var y=s.fillPath({seriesNumber:n}),w=i.graphics.renderPaths(e(e({},d),{},{pathFrom:null===f?c.areaPathsFrom[b]:f,pathTo:c.areaPathsTo[b],strokeWidth:0,fill:y,drawShadow:!1}));if(a.config.chart.dropShadow.enabled){var k=new v(i.ctx),A=a.config.chart.dropShadow;k.dropShadow(w,Object.assign({},A,{noUserSpaceOnUse:!0}),n);}h.add(w);}t.forEach((function(t,s){var r=new D(i.ctx).getMarkerConfig({cssClass:"apexcharts-marker",seriesIndex:n,dataPointIndex:s}),l=i.graphics.drawMarker(g[s].x,g[s].y,r);l.attr("rel",s),l.attr("j",s),l.attr("index",n),l.node.setAttribute("default-marker-size",r.pSize);var c=i.graphics.group({class:"apexcharts-series-markers"});c&&c.add(l),u.add(c),h.add(u);var d=a.config.dataLabels;if(d.enabled){var f=d.formatter(a.globals.series[n][s],{seriesIndex:n,dataPointIndex:s,w:a});o.plotDataLabelsText({x:g[s].x,y:g[s].y,text:f,textAnchor:"middle",i:n,j:n,parent:p,offsetCorrection:!1,dataLabelsConfig:e({},d)});}h.add(p);})),r.push(h);})),this.drawPolygons({parent:d}),a.config.xaxis.labels.show){var f=this.drawXAxisTexts();d.add(f);}return r.forEach((function(t){d.add(t);})),d.add(this.yaxisLabels),d}},{key:"drawPolygons",value:function(t){for(var e=this,i=this.w,a=t.parent,s=new Ct(this.ctx),r=i.globals.yAxisScale[0].result.reverse(),o=r.length,n=[],l=this.size/(o-1),h=0;h<o;h++)n[h]=l*h;n.reverse();var c=[],d=[];n.forEach((function(t,i){var a=x.getPolygonPos(t,e.dataPointsLen),s="";a.forEach((function(t,a){if(0===i){var r=e.graphics.drawLine(t.x,t.y,0,0,Array.isArray(e.polygons.connectorColors)?e.polygons.connectorColors[a]:e.polygons.connectorColors);d.push(r);}0===a&&e.yaxisLabelsTextsPos.push({x:t.x,y:t.y}),s+=t.x+","+t.y+" ";})),c.push(s);})),c.forEach((function(t,s){var r=e.polygons.strokeColors,o=e.polygons.strokeWidth,n=e.graphics.drawPolygon(t,Array.isArray(r)?r[s]:r,Array.isArray(o)?o[s]:o,i.globals.radarPolygons.fill.colors[s]);a.add(n);})),d.forEach((function(t){a.add(t);})),i.config.yaxis[0].show&&this.yaxisLabelsTextsPos.forEach((function(t,i){var a=s.drawYAxisTexts(t.x,t.y,i,r[i]);e.yaxisLabels.add(a);}));}},{key:"drawXAxisTexts",value:function(){var t=this,i=this.w,a=i.config.xaxis.labels,s=this.graphics.group({class:"apexcharts-xaxis"}),r=x.getPolygonPos(this.size,this.dataPointsLen);return i.globals.labels.forEach((function(o,n){var l=i.config.xaxis.labels.formatter,h=new N(t.ctx);if(r[n]){var c=t.getTextPos(r[n],t.size),d=l(o,{seriesIndex:-1,dataPointIndex:n,w:i});h.plotDataLabelsText({x:c.newX,y:c.newY,text:d,textAnchor:c.textAnchor,i:n,j:n,parent:s,color:Array.isArray(a.style.colors)&&a.style.colors[n]?a.style.colors[n]:"#a8a8a8",dataLabelsConfig:e({textAnchor:c.textAnchor,dropShadow:{enabled:!1}},a),offsetCorrection:!1});}})),s}},{key:"createPaths",value:function(t,e){var i=this,a=[],s=[],r=[],o=[];if(t.length){s=[this.graphics.move(e.x,e.y)],o=[this.graphics.move(e.x,e.y)];var n=this.graphics.move(t[0].x,t[0].y),l=this.graphics.move(t[0].x,t[0].y);t.forEach((function(e,a){n+=i.graphics.line(e.x,e.y),l+=i.graphics.line(e.x,e.y),a===t.length-1&&(n+="Z",l+="Z");})),a.push(n),r.push(l);}return {linePathsFrom:s,linePathsTo:a,areaPathsFrom:o,areaPathsTo:r}}},{key:"getTextPos",value:function(t,e){var i="middle",a=t.x,s=t.y;return Math.abs(t.x)>=10?t.x>0?(i="start",a+=10):t.x<0&&(i="end",a-=10):i="middle",Math.abs(t.y)>=e-10&&(t.y<0?s-=10:t.y>0&&(s+=10)),{textAnchor:i,newX:a,newY:s}}},{key:"getPreviousPath",value:function(t){for(var e=this.w,i=null,a=0;a<e.globals.previousPaths.length;a++){var s=e.globals.previousPaths[a];s.paths.length>0&&parseInt(s.realIndex,10)===parseInt(t,10)&&void 0!==e.globals.previousPaths[a].paths[0]&&(i=e.globals.previousPaths[a].paths[0].d);}return i}},{key:"getDataPointsPos",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.dataPointsLen;t=t||[],e=e||[];for(var a=[],s=0;s<i;s++){var r={};r.x=t[s]*Math.sin(e[s]),r.y=-t[s]*Math.cos(e[s]),a.push(r);}return a}}]),t}(),Mt=function(t){n(i,Lt);var e=d(i);function i(t){var s;a(this,i),(s=e.call(this,t)).ctx=t,s.w=t.w,s.animBeginArr=[0],s.animDur=0;var r=s.w;return s.startAngle=r.config.plotOptions.radialBar.startAngle,s.endAngle=r.config.plotOptions.radialBar.endAngle,s.totalAngle=Math.abs(r.config.plotOptions.radialBar.endAngle-r.config.plotOptions.radialBar.startAngle),s.trackStartAngle=r.config.plotOptions.radialBar.track.startAngle,s.trackEndAngle=r.config.plotOptions.radialBar.track.endAngle,s.barLabels=s.w.config.plotOptions.radialBar.barLabels,s.donutDataLabels=s.w.config.plotOptions.radialBar.dataLabels,s.radialDataLabels=s.donutDataLabels,s.trackStartAngle||(s.trackStartAngle=s.startAngle),s.trackEndAngle||(s.trackEndAngle=s.endAngle),360===s.endAngle&&(s.endAngle=359.99),s.margin=parseInt(r.config.plotOptions.radialBar.track.margin,10),s.onBarLabelClick=s.onBarLabelClick.bind(c(s)),s}return r(i,[{key:"draw",value:function(t){var e=this.w,i=new m(this.ctx),a=i.group({class:"apexcharts-radialbar"});if(e.globals.noData)return a;var s=i.group(),r=this.defaultSize/2,o=e.globals.gridWidth/2,n=this.defaultSize/2.05;e.config.chart.sparkline.enabled||(n=n-e.config.stroke.width-e.config.chart.dropShadow.blur);var l=e.globals.fill.colors;if(e.config.plotOptions.radialBar.track.show){var h=this.drawTracks({size:n,centerX:o,centerY:r,colorArr:l,series:t});s.add(h);}var c=this.drawArcs({size:n,centerX:o,centerY:r,colorArr:l,series:t}),d=360;e.config.plotOptions.radialBar.startAngle<0&&(d=this.totalAngle);var g=(360-d)/360;if(e.globals.radialSize=n-n*g,this.radialDataLabels.value.show){var u=Math.max(this.radialDataLabels.value.offsetY,this.radialDataLabels.name.offsetY);e.globals.radialSize+=u*g;}return s.add(c.g),"front"===e.config.plotOptions.radialBar.hollow.position&&(c.g.add(c.elHollow),c.dataLabels&&c.g.add(c.dataLabels)),a.add(s),a}},{key:"drawTracks",value:function(t){var e=this.w,i=new m(this.ctx),a=i.group({class:"apexcharts-tracks"}),s=new v(this.ctx),r=new H(this.ctx),o=this.getStrokeWidth(t);t.size=t.size-o/2;for(var n=0;n<t.series.length;n++){var l=i.group({class:"apexcharts-radialbar-track apexcharts-track"});a.add(l),l.attr({rel:n+1}),t.size=t.size-o-this.margin;var h=e.config.plotOptions.radialBar.track,c=r.fillPath({seriesNumber:0,size:t.size,fillColors:Array.isArray(h.background)?h.background[n]:h.background,solid:!0}),d=this.trackStartAngle,g=this.trackEndAngle;Math.abs(g)+Math.abs(d)>=360&&(g=360-Math.abs(this.startAngle)-.1);var u=i.drawPath({d:"",stroke:c,strokeWidth:o*parseInt(h.strokeWidth,10)/100,fill:"none",strokeOpacity:h.opacity,classes:"apexcharts-radialbar-area"});if(h.dropShadow.enabled){var p=h.dropShadow;s.dropShadow(u,p);}l.add(u),u.attr("id","apexcharts-radialbarTrack-"+n),this.animatePaths(u,{centerX:t.centerX,centerY:t.centerY,endAngle:g,startAngle:d,size:t.size,i:n,totalItems:2,animBeginArr:0,dur:0,isTrack:!0,easing:e.globals.easing});}return a}},{key:"drawArcs",value:function(t){var e=this.w,i=new m(this.ctx),a=new H(this.ctx),s=new v(this.ctx),r=i.group(),o=this.getStrokeWidth(t);t.size=t.size-o/2;var n=e.config.plotOptions.radialBar.hollow.background,l=t.size-o*t.series.length-this.margin*t.series.length-o*parseInt(e.config.plotOptions.radialBar.track.strokeWidth,10)/100/2,h=l-e.config.plotOptions.radialBar.hollow.margin;void 0!==e.config.plotOptions.radialBar.hollow.image&&(n=this.drawHollowImage(t,r,l,n));var c=this.drawHollow({size:h,centerX:t.centerX,centerY:t.centerY,fill:n||"transparent"});if(e.config.plotOptions.radialBar.hollow.dropShadow.enabled){var d=e.config.plotOptions.radialBar.hollow.dropShadow;s.dropShadow(c,d);}var g=1;!this.radialDataLabels.total.show&&e.globals.series.length>1&&(g=0);var u=null;this.radialDataLabels.show&&(u=this.renderInnerDataLabels(this.radialDataLabels,{hollowSize:l,centerX:t.centerX,centerY:t.centerY,opacity:g})),"back"===e.config.plotOptions.radialBar.hollow.position&&(r.add(c),u&&r.add(u));var p=!1;e.config.plotOptions.radialBar.inverseOrder&&(p=!0);for(var f=p?t.series.length-1:0;p?f>=0:f<t.series.length;p?f--:f++){var b=i.group({class:"apexcharts-series apexcharts-radial-series",seriesName:x.escapeString(e.globals.seriesNames[f])});r.add(b),b.attr({rel:f+1,"data:realIndex":f}),this.ctx.series.addCollapsedClassToSeries(b,f),t.size=t.size-o-this.margin;var y=a.fillPath({seriesNumber:f,size:t.size,value:t.series[f]}),w=this.startAngle,k=void 0,A=x.negToZero(t.series[f]>100?100:t.series[f])/100,S=Math.round(this.totalAngle*A)+this.startAngle,C=void 0;e.globals.dataChanged&&(k=this.startAngle,C=Math.round(this.totalAngle*x.negToZero(e.globals.previousPaths[f])/100)+k),Math.abs(S)+Math.abs(w)>=360&&(S-=.01),Math.abs(C)+Math.abs(k)>=360&&(C-=.01);var L=S-w,P=Array.isArray(e.config.stroke.dashArray)?e.config.stroke.dashArray[f]:e.config.stroke.dashArray,M=i.drawPath({d:"",stroke:y,strokeWidth:o,fill:"none",fillOpacity:e.config.fill.opacity,classes:"apexcharts-radialbar-area apexcharts-radialbar-slice-"+f,strokeDashArray:P});if(m.setAttrs(M.node,{"data:angle":L,"data:value":t.series[f]}),e.config.chart.dropShadow.enabled){var I=e.config.chart.dropShadow;s.dropShadow(M,I,f);}if(s.setSelectionFilter(M,0,f),this.addListeners(M,this.radialDataLabels),b.add(M),M.attr({index:0,j:f}),this.barLabels.enabled){var T=x.polarToCartesian(t.centerX,t.centerY,t.size,w),z=this.barLabels.formatter(e.globals.seriesNames[f],{seriesIndex:f,w:e}),X=["apexcharts-radialbar-label"];this.barLabels.onClick||X.push("apexcharts-no-click");var E=this.barLabels.useSeriesColors?e.globals.colors[f]:e.config.chart.foreColor;E||(E=e.config.chart.foreColor);var Y=T.x-this.barLabels.margin,F=T.y,R=i.drawText({x:Y,y:F,text:z,textAnchor:"end",dominantBaseline:"middle",fontFamily:this.barLabels.fontFamily,fontWeight:this.barLabels.fontWeight,fontSize:this.barLabels.fontSize,foreColor:E,cssClass:X.join(" ")});R.on("click",this.onBarLabelClick),R.attr({rel:f+1}),0!==w&&R.attr({"transform-origin":"".concat(Y," ").concat(F),transform:"rotate(".concat(w," 0 0)")}),b.add(R);}var D=0;!this.initialAnim||e.globals.resized||e.globals.dataChanged||(D=e.config.chart.animations.speed),e.globals.dataChanged&&(D=e.config.chart.animations.dynamicAnimation.speed),this.animDur=D/(1.2*t.series.length)+this.animDur,this.animBeginArr.push(this.animDur),this.animatePaths(M,{centerX:t.centerX,centerY:t.centerY,endAngle:S,startAngle:w,prevEndAngle:C,prevStartAngle:k,size:t.size,i:f,totalItems:2,animBeginArr:this.animBeginArr,dur:D,shouldSetPrevPaths:!0,easing:e.globals.easing});}return {g:r,elHollow:c,dataLabels:u}}},{key:"drawHollow",value:function(t){var e=new m(this.ctx).drawCircle(2*t.size);return e.attr({class:"apexcharts-radialbar-hollow",cx:t.centerX,cy:t.centerY,r:t.size,fill:t.fill}),e}},{key:"drawHollowImage",value:function(t,e,i,a){var s=this.w,r=new H(this.ctx),o=x.randomId(),n=s.config.plotOptions.radialBar.hollow.image;if(s.config.plotOptions.radialBar.hollow.imageClipped)r.clippedImgArea({width:i,height:i,image:n,patternID:"pattern".concat(s.globals.cuid).concat(o)}),a="url(#pattern".concat(s.globals.cuid).concat(o,")");else {var l=s.config.plotOptions.radialBar.hollow.imageWidth,h=s.config.plotOptions.radialBar.hollow.imageHeight;if(void 0===l&&void 0===h){var c=s.globals.dom.Paper.image(n).loaded((function(e){this.move(t.centerX-e.width/2+s.config.plotOptions.radialBar.hollow.imageOffsetX,t.centerY-e.height/2+s.config.plotOptions.radialBar.hollow.imageOffsetY);}));e.add(c);}else {var d=s.globals.dom.Paper.image(n).loaded((function(e){this.move(t.centerX-l/2+s.config.plotOptions.radialBar.hollow.imageOffsetX,t.centerY-h/2+s.config.plotOptions.radialBar.hollow.imageOffsetY),this.size(l,h);}));e.add(d);}}return a}},{key:"getStrokeWidth",value:function(t){var e=this.w;return t.size*(100-parseInt(e.config.plotOptions.radialBar.hollow.size,10))/100/(t.series.length+1)-this.margin}},{key:"onBarLabelClick",value:function(t){var e=parseInt(t.target.getAttribute("rel"),10)-1,i=this.barLabels.onClick,a=this.w;i&&i(a.globals.seriesNames[e],{w:a,seriesIndex:e});}}]),i}(),It=function(t){n(s,yt);var i=d(s);function s(){return a(this,s),i.apply(this,arguments)}return r(s,[{key:"draw",value:function(t,i){var a=this.w,s=new m(this.ctx);this.rangeBarOptions=this.w.config.plotOptions.rangeBar,this.series=t,this.seriesRangeStart=a.globals.seriesRangeStart,this.seriesRangeEnd=a.globals.seriesRangeEnd,this.barHelpers.initVariables(t);for(var r=s.group({class:"apexcharts-rangebar-series apexcharts-plot-series"}),n=0;n<t.length;n++){var l,h,c,d,g=void 0,u=void 0,p=a.globals.comboCharts?i[n]:n,f=this.barHelpers.getGroupIndex(p).columnGroupIndex,b=s.group({class:"apexcharts-series",seriesName:x.escapeString(a.globals.seriesNames[p]),rel:n+1,"data:realIndex":p});this.ctx.series.addCollapsedClassToSeries(b,p),t[n].length>0&&(this.visibleI=this.visibleI+1);var v=0,y=0,w=0;this.yRatio.length>1&&(this.yaxisIndex=a.globals.seriesYAxisReverseMap[p][0],w=p);var k=this.barHelpers.initialPositions();u=k.y,d=k.zeroW,g=k.x,y=k.barWidth,v=k.barHeight,l=k.xDivision,h=k.yDivision,c=k.zeroH;for(var A=s.group({class:"apexcharts-datalabels","data:realIndex":p}),S=s.group({class:"apexcharts-rangebar-goals-markers"}),C=0;C<a.globals.dataPoints;C++){var L,P=this.barHelpers.getStrokeWidth(n,C,p),M=this.seriesRangeStart[n][C],I=this.seriesRangeEnd[n][C],T=null,z=null,X=null,E={x:g,y:u,strokeWidth:P,elSeries:b},Y=this.seriesLen;if(a.config.plotOptions.bar.rangeBarGroupRows&&(Y=1),void 0===a.config.series[n].data[C])break;if(this.isHorizontal){X=u+v*this.visibleI;var F=(h-v*Y)/2;if(a.config.series[n].data[C].x){var R=this.detectOverlappingBars({i:n,j:C,barYPosition:X,srty:F,barHeight:v,yDivision:h,initPositions:k});v=R.barHeight,X=R.barYPosition;}y=(T=this.drawRangeBarPaths(e({indexes:{i:n,j:C,realIndex:p},barHeight:v,barYPosition:X,zeroW:d,yDivision:h,y1:M,y2:I},E))).barWidth;}else {a.globals.isXNumeric&&(g=(a.globals.seriesX[n][C]-a.globals.minX)/this.xRatio-y/2),z=g+y*this.visibleI;var H=(l-y*Y)/2;if(a.config.series[n].data[C].x){var D=this.detectOverlappingBars({i:n,j:C,barXPosition:z,srtx:H,barWidth:y,xDivision:l,initPositions:k});y=D.barWidth,z=D.barXPosition;}v=(T=this.drawRangeColumnPaths(e({indexes:{i:n,j:C,realIndex:p,translationsIndex:w},barWidth:y,barXPosition:z,zeroH:c,xDivision:l},E))).barHeight;}var O=this.barHelpers.drawGoalLine({barXPosition:T.barXPosition,barYPosition:X,goalX:T.goalX,goalY:T.goalY,barHeight:v,barWidth:y});O&&S.add(O),u=T.y,g=T.x;var N=this.barHelpers.getPathFillColor(t,n,C,p),W=a.globals.stroke.colors[p];this.renderSeries((o(L={realIndex:p,pathFill:N,lineFill:W,j:C,i:n,x:g,y:u,y1:M,y2:I,pathFrom:T.pathFrom,pathTo:T.pathTo,strokeWidth:P,elSeries:b,series:t,barHeight:v,barWidth:y,barXPosition:z,barYPosition:X},"barWidth",y),o(L,"columnGroupIndex",f),o(L,"elDataLabelsWrap",A),o(L,"elGoalsMarkers",S),o(L,"visibleSeries",this.visibleI),o(L,"type","rangebar"),L));}r.add(b);}return r}},{key:"detectOverlappingBars",value:function(t){var e=t.i,i=t.j,a=t.barYPosition,s=t.barXPosition,r=t.srty,o=t.srtx,n=t.barHeight,l=t.barWidth,h=t.yDivision,c=t.xDivision,d=t.initPositions,g=this.w,u=[],p=g.config.series[e].data[i].rangeName,f=g.config.series[e].data[i].x,x=Array.isArray(f)?f.join(" "):f,b=g.globals.labels.map((function(t){return Array.isArray(t)?t.join(" "):t})).indexOf(x),v=g.globals.seriesRange[e].findIndex((function(t){return t.x===x&&t.overlaps.length>0}));return this.isHorizontal?(a=g.config.plotOptions.bar.rangeBarGroupRows?r+h*b:r+n*this.visibleI+h*b,v>-1&&!g.config.plotOptions.bar.rangeBarOverlap&&(u=g.globals.seriesRange[e][v].overlaps).indexOf(p)>-1&&(a=(n=d.barHeight/u.length)*this.visibleI+h*(100-parseInt(this.barOptions.barHeight,10))/100/2+n*(this.visibleI+u.indexOf(p))+h*b)):(b>-1&&!g.globals.timescaleLabels.length&&(s=g.config.plotOptions.bar.rangeBarGroupRows?o+c*b:o+l*this.visibleI+c*b),v>-1&&!g.config.plotOptions.bar.rangeBarOverlap&&(u=g.globals.seriesRange[e][v].overlaps).indexOf(p)>-1&&(s=(l=d.barWidth/u.length)*this.visibleI+c*(100-parseInt(this.barOptions.barWidth,10))/100/2+l*(this.visibleI+u.indexOf(p))+c*b)),{barYPosition:a,barXPosition:s,barHeight:n,barWidth:l}}},{key:"drawRangeColumnPaths",value:function(t){var e=t.indexes,i=t.x,a=t.xDivision,s=t.barWidth,r=t.barXPosition,o=t.zeroH,n=this.w,l=e.i,h=e.j,c=e.realIndex,d=e.translationsIndex,g=this.yRatio[d],u=this.getRangeValue(c,h),p=Math.min(u.start,u.end),f=Math.max(u.start,u.end);void 0===this.series[l][h]||null===this.series[l][h]?p=o:(p=o-p/g,f=o-f/g);var x=Math.abs(f-p),b=this.barHelpers.getColumnPaths({barXPosition:r,barWidth:s,y1:p,y2:f,strokeWidth:this.strokeWidth,series:this.seriesRangeEnd,realIndex:c,i:c,j:h,w:n});if(n.globals.isXNumeric){var v=this.getBarXForNumericXAxis({x:i,j:h,realIndex:c,barWidth:s});i=v.x,r=v.barXPosition;}else i+=a;return {pathTo:b.pathTo,pathFrom:b.pathFrom,barHeight:x,x:i,y:u.start<0&&u.end<0?p:f,goalY:this.barHelpers.getGoalValues("y",null,o,l,h,d),barXPosition:r}}},{key:"drawRangeBarPaths",value:function(t){var e=t.indexes,i=t.y,a=t.y1,s=t.y2,r=t.yDivision,o=t.barHeight,n=t.barYPosition,l=t.zeroW,h=this.w,c=e.realIndex,d=e.j,g=l+a/this.invertedYRatio,u=l+s/this.invertedYRatio,p=this.getRangeValue(c,d),f=Math.abs(u-g),x=this.barHelpers.getBarpaths({barYPosition:n,barHeight:o,x1:g,x2:u,strokeWidth:this.strokeWidth,series:this.seriesRangeEnd,i:c,realIndex:c,j:d,w:h});return h.globals.isXNumeric||(i+=r),{pathTo:x.pathTo,pathFrom:x.pathFrom,barWidth:f,x:p.start<0&&p.end<0?g:u,goalX:this.barHelpers.getGoalValues("x",l,null,c,d),y:i}}},{key:"getRangeValue",value:function(t,e){var i=this.w;return {start:i.globals.seriesRangeStart[t][e],end:i.globals.seriesRangeEnd[t][e]}}}]),s}(),Tt=function(){function t(e){a(this,t),this.w=e.w,this.lineCtx=e;}return r(t,[{key:"sameValueSeriesFix",value:function(t,e){var i=this.w;if(("gradient"===i.config.fill.type||"gradient"===i.config.fill.type[t])&&new y(this.lineCtx.ctx,i).seriesHaveSameValues(t)){var a=e[t].slice();a[a.length-1]=a[a.length-1]+1e-6,e[t]=a;}return e}},{key:"calculatePoints",value:function(t){var e=t.series,i=t.realIndex,a=t.x,s=t.y,r=t.i,o=t.j,n=t.prevY,l=this.w,h=[],c=[];if(0===o){var d=this.lineCtx.categoryAxisCorrection+l.config.markers.offsetX;l.globals.isXNumeric&&(d=(l.globals.seriesX[i][0]-l.globals.minX)/this.lineCtx.xRatio+l.config.markers.offsetX),h.push(d),c.push(x.isNumber(e[r][0])?n+l.config.markers.offsetY:null),h.push(a+l.config.markers.offsetX),c.push(x.isNumber(e[r][o+1])?s+l.config.markers.offsetY:null);}else h.push(a+l.config.markers.offsetX),c.push(x.isNumber(e[r][o+1])?s+l.config.markers.offsetY:null);return {x:h,y:c}}},{key:"checkPreviousPaths",value:function(t){for(var e=t.pathFromLine,i=t.pathFromArea,a=t.realIndex,s=this.w,r=0;r<s.globals.previousPaths.length;r++){var o=s.globals.previousPaths[r];("line"===o.type||"area"===o.type)&&o.paths.length>0&&parseInt(o.realIndex,10)===parseInt(a,10)&&("line"===o.type?(this.lineCtx.appendPathFrom=!1,e=s.globals.previousPaths[r].paths[0].d):"area"===o.type&&(this.lineCtx.appendPathFrom=!1,i=s.globals.previousPaths[r].paths[0].d,s.config.stroke.show&&s.globals.previousPaths[r].paths[1]&&(e=s.globals.previousPaths[r].paths[1].d)));}return {pathFromLine:e,pathFromArea:i}}},{key:"determineFirstPrevY",value:function(t){var e,i,a,s=t.i,r=t.realIndex,o=t.series,n=t.prevY,l=t.lineYPosition,h=t.translationsIndex,c=this.w,d=c.config.chart.stacked&&!c.globals.comboCharts||c.config.chart.stacked&&c.globals.comboCharts&&(!this.w.config.chart.stackOnlyBar||"bar"===(null===(e=this.w.config.series[r])||void 0===e?void 0:e.type)||"column"===(null===(i=this.w.config.series[r])||void 0===i?void 0:i.type));if(void 0!==(null===(a=o[s])||void 0===a?void 0:a[0]))n=(l=d&&s>0?this.lineCtx.prevSeriesY[s-1][0]:this.lineCtx.zeroY)-o[s][0]/this.lineCtx.yRatio[h]+2*(this.lineCtx.isReversed?o[s][0]/this.lineCtx.yRatio[h]:0);else if(d&&s>0&&void 0===o[s][0])for(var g=s-1;g>=0;g--)if(null!==o[g][0]&&void 0!==o[g][0]){n=l=this.lineCtx.prevSeriesY[g][0];break}return {prevY:n,lineYPosition:l}}}]),t}(),zt=function(t){for(var e,i,a,s,r=function(t){for(var e=[],i=t[0],a=t[1],s=e[0]=Yt(i,a),r=1,o=t.length-1;r<o;r++)i=a,a=t[r+1],e[r]=.5*(s+(s=Yt(i,a)));return e[r]=s,e}(t),o=t.length-1,n=[],l=0;l<o;l++)a=Yt(t[l],t[l+1]),Math.abs(a)<1e-6?r[l]=r[l+1]=0:(s=(e=r[l]/a)*e+(i=r[l+1]/a)*i)>9&&(s=3*a/Math.sqrt(s),r[l]=s*e,r[l+1]=s*i);for(var h=0;h<=o;h++)s=(t[Math.min(o,h+1)][0]-t[Math.max(0,h-1)][0])/(6*(1+r[h]*r[h])),n.push([s||0,r[h]*s||0]);return n},Xt=function(t){var e=zt(t),i=t[1],a=t[0],s=[],r=e[1],o=e[0];s.push(a,[a[0]+o[0],a[1]+o[1],i[0]-r[0],i[1]-r[1],i[0],i[1]]);for(var n=2,l=e.length;n<l;n++){var h=t[n],c=e[n];s.push([h[0]-c[0],h[1]-c[1],h[0],h[1]]);}return s},Et=function(t,e,i){var a=t.slice(e,i);if(e){if(i-e>1&&a[1].length<6){var s=a[0].length;a[1]=[2*a[0][s-2]-a[0][s-4],2*a[0][s-1]-a[0][s-3]].concat(a[1]);}a[0]=a[0].slice(-2);}return a};function Yt(t,e){return (e[1]-t[1])/(e[0]-t[0])}var Ft=function(){function t(e,i,s){a(this,t),this.ctx=e,this.w=e.w,this.xyRatios=i,this.pointsChart=!("bubble"!==this.w.config.chart.type&&"scatter"!==this.w.config.chart.type)||s,this.scatter=new O(this.ctx),this.noNegatives=this.w.globals.minX===Number.MAX_VALUE,this.lineHelpers=new Tt(this),this.markers=new D(this.ctx),this.prevSeriesY=[],this.categoryAxisCorrection=0,this.yaxisIndex=0;}return r(t,[{key:"draw",value:function(t,i,a,s){var r,o=this.w,n=new m(this.ctx),l=o.globals.comboCharts?i:o.config.chart.type,h=n.group({class:"apexcharts-".concat(l,"-series apexcharts-plot-series")}),c=new y(this.ctx,o);this.yRatio=this.xyRatios.yRatio,this.zRatio=this.xyRatios.zRatio,this.xRatio=this.xyRatios.xRatio,this.baseLineY=this.xyRatios.baseLineY,t=c.getLogSeries(t),this.yRatio=c.getLogYRatios(this.yRatio),this.prevSeriesY=[];for(var d=[],g=0;g<t.length;g++){t=this.lineHelpers.sameValueSeriesFix(g,t);var u=o.globals.comboCharts?a[g]:g,p=this.yRatio.length>1?u:0;this._initSerieVariables(t,g,u);var f=[],x=[],b=[],v=o.globals.padHorizontal+this.categoryAxisCorrection;this.ctx.series.addCollapsedClassToSeries(this.elSeries,u),o.globals.isXNumeric&&o.globals.seriesX.length>0&&(v=(o.globals.seriesX[u][0]-o.globals.minX)/this.xRatio),b.push(v);var w,k=v,A=void 0,S=k,C=this.zeroY,L=this.zeroY;C=this.lineHelpers.determineFirstPrevY({i:g,realIndex:u,series:t,prevY:C,lineYPosition:0,translationsIndex:p}).prevY,"monotoneCubic"===o.config.stroke.curve&&null===t[g][0]?f.push(null):f.push(C),w=C;"rangeArea"===l&&(A=L=this.lineHelpers.determineFirstPrevY({i:g,realIndex:u,series:s,prevY:L,lineYPosition:0,translationsIndex:p}).prevY,x.push(null!==f[0]?L:null));var P=this._calculatePathsFrom({type:l,series:t,i:g,realIndex:u,translationsIndex:p,prevX:S,prevY:C,prevY2:L}),M=[f[0]],I=[x[0]],T={type:l,series:t,realIndex:u,translationsIndex:p,i:g,x:v,y:1,pX:k,pY:w,pathsFrom:P,linePaths:[],areaPaths:[],seriesIndex:a,lineYPosition:0,xArrj:b,yArrj:f,y2Arrj:x,seriesRangeEnd:s},z=this._iterateOverDataPoints(e(e({},T),{},{iterations:"rangeArea"===l?t[g].length-1:void 0,isRangeStart:!0}));if("rangeArea"===l){for(var X=this._calculatePathsFrom({series:s,i:g,realIndex:u,prevX:S,prevY:L}),E=this._iterateOverDataPoints(e(e({},T),{},{series:s,xArrj:[v],yArrj:M,y2Arrj:I,pY:A,areaPaths:z.areaPaths,pathsFrom:X,iterations:s[g].length-1,isRangeStart:!1})),Y=z.linePaths.length/2,F=0;F<Y;F++)z.linePaths[F]=E.linePaths[F+Y]+z.linePaths[F];z.linePaths.splice(Y),z.pathFromLine=E.pathFromLine+z.pathFromLine;}else z.pathFromArea+=n.line(0,this.zeroY);this._handlePaths({type:l,realIndex:u,i:g,paths:z}),this.elSeries.add(this.elPointsMain),this.elSeries.add(this.elDataLabelsWrap),d.push(this.elSeries);}if(void 0!==(null===(r=o.config.series[0])||void 0===r?void 0:r.zIndex)&&d.sort((function(t,e){return Number(t.node.getAttribute("zIndex"))-Number(e.node.getAttribute("zIndex"))})),o.config.chart.stacked)for(var R=d.length-1;R>=0;R--)h.add(d[R]);else for(var H=0;H<d.length;H++)h.add(d[H]);return h}},{key:"_initSerieVariables",value:function(t,e,i){var a=this.w,s=new m(this.ctx);this.xDivision=a.globals.gridWidth/(a.globals.dataPoints-("on"===a.config.xaxis.tickPlacement?1:0)),this.strokeWidth=Array.isArray(a.config.stroke.width)?a.config.stroke.width[i]:a.config.stroke.width;var r=0;this.yRatio.length>1&&(this.yaxisIndex=a.globals.seriesYAxisReverseMap[i],r=i),this.isReversed=a.config.yaxis[this.yaxisIndex]&&a.config.yaxis[this.yaxisIndex].reversed,this.zeroY=a.globals.gridHeight-this.baseLineY[r]-(this.isReversed?a.globals.gridHeight:0)+(this.isReversed?2*this.baseLineY[r]:0),this.areaBottomY=this.zeroY,(this.zeroY>a.globals.gridHeight||"end"===a.config.plotOptions.area.fillTo)&&(this.areaBottomY=a.globals.gridHeight),this.categoryAxisCorrection=this.xDivision/2,this.elSeries=s.group({class:"apexcharts-series",zIndex:void 0!==a.config.series[i].zIndex?a.config.series[i].zIndex:i,seriesName:x.escapeString(a.globals.seriesNames[i])}),this.elPointsMain=s.group({class:"apexcharts-series-markers-wrap","data:realIndex":i}),this.elDataLabelsWrap=s.group({class:"apexcharts-datalabels","data:realIndex":i});var o=t[e].length===a.globals.dataPoints;this.elSeries.attr({"data:longestSeries":o,rel:e+1,"data:realIndex":i}),this.appendPathFrom=!0;}},{key:"_calculatePathsFrom",value:function(t){var e,i,a,s,r=t.type,o=t.series,n=t.i,l=t.realIndex,h=t.translationsIndex,c=t.prevX,d=t.prevY,g=t.prevY2,u=this.w,p=new m(this.ctx);if(null===o[n][0]){for(var f=0;f<o[n].length;f++)if(null!==o[n][f]){c=this.xDivision*f,d=this.zeroY-o[n][f]/this.yRatio[h],e=p.move(c,d),i=p.move(c,this.areaBottomY);break}}else e=p.move(c,d),"rangeArea"===r&&(e=p.move(c,g)+p.line(c,d)),i=p.move(c,this.areaBottomY)+p.line(c,d);if(a=p.move(0,this.zeroY)+p.line(0,this.zeroY),s=p.move(0,this.zeroY)+p.line(0,this.zeroY),u.globals.previousPaths.length>0){var x=this.lineHelpers.checkPreviousPaths({pathFromLine:a,pathFromArea:s,realIndex:l});a=x.pathFromLine,s=x.pathFromArea;}return {prevX:c,prevY:d,linePath:e,areaPath:i,pathFromLine:a,pathFromArea:s}}},{key:"_handlePaths",value:function(t){var i=t.type,a=t.realIndex,s=t.i,r=t.paths,o=this.w,n=new m(this.ctx),l=new H(this.ctx);this.prevSeriesY.push(r.yArrj),o.globals.seriesXvalues[a]=r.xArrj,o.globals.seriesYvalues[a]=r.yArrj;var h=o.config.forecastDataPoints;if(h.count>0&&"rangeArea"!==i){var c=o.globals.seriesXvalues[a][o.globals.seriesXvalues[a].length-h.count-1],d=n.drawRect(c,0,o.globals.gridWidth,o.globals.gridHeight,0);o.globals.dom.elForecastMask.appendChild(d.node);var g=n.drawRect(0,0,c,o.globals.gridHeight,0);o.globals.dom.elNonForecastMask.appendChild(g.node);}this.pointsChart||o.globals.delayedElements.push({el:this.elPointsMain.node,index:a});var u={i:s,realIndex:a,animationDelay:s,initialSpeed:o.config.chart.animations.speed,dataChangeSpeed:o.config.chart.animations.dynamicAnimation.speed,className:"apexcharts-".concat(i)};if("area"===i)for(var p=l.fillPath({seriesNumber:a}),f=0;f<r.areaPaths.length;f++){var x=n.renderPaths(e(e({},u),{},{pathFrom:r.pathFromArea,pathTo:r.areaPaths[f],stroke:"none",strokeWidth:0,strokeLineCap:null,fill:p}));this.elSeries.add(x);}if(o.config.stroke.show&&!this.pointsChart){var b=null;if("line"===i)b=l.fillPath({seriesNumber:a,i:s});else if("solid"===o.config.stroke.fill.type)b=o.globals.stroke.colors[a];else {var v=o.config.fill;o.config.fill=o.config.stroke.fill,b=l.fillPath({seriesNumber:a,i:s}),o.config.fill=v;}for(var y=0;y<r.linePaths.length;y++){var w=b;"rangeArea"===i&&(w=l.fillPath({seriesNumber:a}));var k=e(e({},u),{},{pathFrom:r.pathFromLine,pathTo:r.linePaths[y],stroke:b,strokeWidth:this.strokeWidth,strokeLineCap:o.config.stroke.lineCap,fill:"rangeArea"===i?w:"none"}),A=n.renderPaths(k);if(this.elSeries.add(A),A.attr("fill-rule","evenodd"),h.count>0&&"rangeArea"!==i){var S=n.renderPaths(k);S.node.setAttribute("stroke-dasharray",h.dashArray),h.strokeWidth&&S.node.setAttribute("stroke-width",h.strokeWidth),this.elSeries.add(S),S.attr("clip-path","url(#forecastMask".concat(o.globals.cuid,")")),A.attr("clip-path","url(#nonForecastMask".concat(o.globals.cuid,")"));}}}}},{key:"_iterateOverDataPoints",value:function(t){var e,i,a=this,s=t.type,r=t.series,o=t.iterations,n=t.realIndex,l=t.translationsIndex,h=t.i,c=t.x,d=t.y,g=t.pX,u=t.pY,p=t.pathsFrom,f=t.linePaths,b=t.areaPaths,v=t.seriesIndex,y=t.lineYPosition,w=t.xArrj,k=t.yArrj,A=t.y2Arrj,S=t.isRangeStart,C=t.seriesRangeEnd,L=this.w,P=new m(this.ctx),M=this.yRatio,I=p.prevY,T=p.linePath,z=p.areaPath,X=p.pathFromLine,E=p.pathFromArea,Y=x.isNumber(L.globals.minYArr[n])?L.globals.minYArr[n]:L.globals.minY;o||(o=L.globals.dataPoints>1?L.globals.dataPoints-1:L.globals.dataPoints);var F=function(t,e){return e-t/M[l]+2*(a.isReversed?t/M[l]:0)},R=d,H=L.config.chart.stacked&&!L.globals.comboCharts||L.config.chart.stacked&&L.globals.comboCharts&&(!this.w.config.chart.stackOnlyBar||"bar"===(null===(e=this.w.config.series[n])||void 0===e?void 0:e.type)||"column"===(null===(i=this.w.config.series[n])||void 0===i?void 0:i.type)),D=L.config.stroke.curve;Array.isArray(D)&&(D=Array.isArray(v)?D[v[h]]:D[h]);for(var O,N=0,W=0;W<o;W++){var B=void 0===r[h][W+1]||null===r[h][W+1];if(L.globals.isXNumeric){var G=L.globals.seriesX[n][W+1];void 0===L.globals.seriesX[n][W+1]&&(G=L.globals.seriesX[n][o-1]),c=(G-L.globals.minX)/this.xRatio;}else c+=this.xDivision;if(H)if(h>0&&L.globals.collapsedSeries.length<L.config.series.length-1){y=this.prevSeriesY[function(t){for(var e=t;e>0;e--){if(!(L.globals.collapsedSeriesIndices.indexOf((null==v?void 0:v[e])||e)>-1))return e;e--;}return 0}(h-1)][W+1];}else y=this.zeroY;else y=this.zeroY;B?d=F(Y,y):(d=F(r[h][W+1],y),"rangeArea"===s&&(R=F(C[h][W+1],y))),w.push(c),!B||"smooth"!==L.config.stroke.curve&&"monotoneCubic"!==L.config.stroke.curve?(k.push(d),A.push(R)):(k.push(null),A.push(null));var V=this.lineHelpers.calculatePoints({series:r,x:c,y:d,realIndex:n,i:h,j:W,prevY:I}),j=this._createPaths({type:s,series:r,i:h,realIndex:n,j:W,x:c,y:d,y2:R,xArrj:w,yArrj:k,y2Arrj:A,pX:g,pY:u,pathState:N,segmentStartX:O,linePath:T,areaPath:z,linePaths:f,areaPaths:b,curve:D,isRangeStart:S});b=j.areaPaths,f=j.linePaths,g=j.pX,u=j.pY,N=j.pathState,O=j.segmentStartX,z=j.areaPath,T=j.linePath,!this.appendPathFrom||"monotoneCubic"===D&&"rangeArea"===s||(X+=P.line(c,this.zeroY),E+=P.line(c,this.zeroY)),this.handleNullDataPoints(r,V,h,W,n),this._handleMarkersAndLabels({type:s,pointsPos:V,i:h,j:W,realIndex:n,isRangeStart:S});}return {yArrj:k,xArrj:w,pathFromArea:E,areaPaths:b,pathFromLine:X,linePaths:f,linePath:T,areaPath:z}}},{key:"_handleMarkersAndLabels",value:function(t){var e=t.type,i=t.pointsPos,a=t.isRangeStart,s=t.i,r=t.j,o=t.realIndex,n=this.w,l=new N(this.ctx);if(this.pointsChart)this.scatter.draw(this.elSeries,r,{realIndex:o,pointsPos:i,zRatio:this.zRatio,elParent:this.elPointsMain});else {n.globals.series[s].length>1&&this.elPointsMain.node.classList.add("apexcharts-element-hidden");var h=this.markers.plotChartMarkers(i,o,r+1);null!==h&&this.elPointsMain.add(h);}var c=l.drawDataLabel({type:e,isRangeStart:a,pos:i,i:o,j:r+1});null!==c&&this.elDataLabelsWrap.add(c);}},{key:"_createPaths",value:function(t){var e=t.type,i=t.series,a=t.i;t.realIndex;var s=t.j,r=t.x,o=t.y,n=t.xArrj,l=t.yArrj,h=t.y2,c=t.y2Arrj,d=t.pX,g=t.pY,u=t.pathState,p=t.segmentStartX,f=t.linePath,x=t.areaPath,b=t.linePaths,v=t.areaPaths,y=t.curve,w=t.isRangeStart;this.w;var k,A=new m(this.ctx),S=this.areaBottomY,C="rangeArea"===e,L="rangeArea"===e&&w;switch(y){case"monotoneCubic":var P=w?l:c;switch(u){case 0:if(null===P[s+1])break;u=1;case 1:if(!(C?n.length===i[a].length:s===i[a].length-2))break;case 2:var M=w?n:n.slice().reverse(),I=w?P:P.slice().reverse(),T=(k=I,M.map((function(t,e){return [t,k[e]]})).filter((function(t){return null!==t[1]}))),z=T.length>1?Xt(T):T,X=[];C&&(L?v=T:X=v.reverse());var E=0,Y=0;if(function(t,e){for(var i=function(t){var e=[],i=0;return t.forEach((function(t){null!==t?i++:i>0&&(e.push(i),i=0);})),i>0&&e.push(i),e}(t),a=[],s=0,r=0;s<i.length;r+=i[s++])a[s]=Et(e,r,r+i[s]);return a}(I,z).forEach((function(t){E++;var e=function(t){for(var e="",i=0;i<t.length;i++){var a=t[i],s=a.length;s>4?(e+="C".concat(a[0],", ").concat(a[1]),e+=", ".concat(a[2],", ").concat(a[3]),e+=", ".concat(a[4],", ").concat(a[5])):s>2&&(e+="S".concat(a[0],", ").concat(a[1]),e+=", ".concat(a[2],", ").concat(a[3]));}return e}(t),i=Y,a=(Y+=t.length)-1;L?f=A.move(T[i][0],T[i][1])+e:C?f=A.move(X[i][0],X[i][1])+A.line(T[i][0],T[i][1])+e+A.line(X[a][0],X[a][1]):(f=A.move(T[i][0],T[i][1])+e,x=f+A.line(T[a][0],S)+A.line(T[i][0],S)+"z",v.push(x)),b.push(f);})),C&&E>1&&!L){var F=b.slice(E).reverse();b.splice(E),F.forEach((function(t){return b.push(t)}));}u=0;}break;case"smooth":var R=.35*(r-d);if(null===i[a][s])u=0;else switch(u){case 0:if(p=d,f=L?A.move(d,c[s])+A.line(d,g):A.move(d,g),x=A.move(d,g),u=1,s<i[a].length-2){var H=A.curve(d+R,g,r-R,o,r,o);f+=H,x+=H;break}case 1:if(null===i[a][s+1])f+=L?A.line(d,h):A.move(d,g),x+=A.line(d,S)+A.line(p,S)+"z",b.push(f),v.push(x);else {var D=A.curve(d+R,g,r-R,o,r,o);f+=D,x+=D,s>=i[a].length-2&&(L&&(f+=A.curve(r,o,r,o,r,h)+A.move(r,h)),x+=A.curve(r,o,r,o,r,S)+A.line(p,S)+"z",b.push(f),v.push(x));}}d=r,g=o;break;default:var O=function(t,e,i){var a=[];switch(t){case"stepline":a=A.line(e,null,"H")+A.line(null,i,"V");break;case"linestep":a=A.line(null,i,"V")+A.line(e,null,"H");break;case"straight":a=A.line(e,i);}return a};if(null===i[a][s])u=0;else switch(u){case 0:if(p=d,f=L?A.move(d,c[s])+A.line(d,g):A.move(d,g),x=A.move(d,g),u=1,s<i[a].length-2){var N=O(y,r,o);f+=N,x+=N;break}case 1:if(null===i[a][s+1])f+=L?A.line(d,h):A.move(d,g),x+=A.line(d,S)+A.line(p,S)+"z",b.push(f),v.push(x);else {var W=O(y,r,o);f+=W,x+=W,s>=i[a].length-2&&(L&&(f+=A.line(r,h)),x+=A.line(r,S)+A.line(p,S)+"z",b.push(f),v.push(x));}}d=r,g=o;}return {linePaths:b,areaPaths:v,pX:d,pY:g,pathState:u,segmentStartX:p,linePath:f,areaPath:x}}},{key:"handleNullDataPoints",value:function(t,e,i,a,s){var r=this.w;if(null===t[i][a]&&r.config.markers.showNullDataPoints||1===t[i].length){var o=this.strokeWidth-r.config.markers.strokeWidth/2;o>0||(o=0);var n=this.markers.plotChartMarkers(e,s,a+1,o,!0);null!==n&&this.elPointsMain.add(n);}}}]),t}();window.TreemapSquared={},window.TreemapSquared.generate=function(){function t(e,i,a,s){this.xoffset=e,this.yoffset=i,this.height=s,this.width=a,this.shortestEdge=function(){return Math.min(this.height,this.width)},this.getCoordinates=function(t){var e,i=[],a=this.xoffset,s=this.yoffset,o=r(t)/this.height,n=r(t)/this.width;if(this.width>=this.height)for(e=0;e<t.length;e++)i.push([a,s,a+o,s+t[e]/o]),s+=t[e]/o;else for(e=0;e<t.length;e++)i.push([a,s,a+t[e]/n,s+n]),a+=t[e]/n;return i},this.cutArea=function(e){var i;if(this.width>=this.height){var a=e/this.height,s=this.width-a;i=new t(this.xoffset+a,this.yoffset,s,this.height);}else {var r=e/this.width,o=this.height-r;i=new t(this.xoffset,this.yoffset+r,this.width,o);}return i};}function e(e,a,s,o,n){o=void 0===o?0:o,n=void 0===n?0:n;var l=i(function(t,e){var i,a=[],s=e/r(t);for(i=0;i<t.length;i++)a[i]=t[i]*s;return a}(e,a*s),[],new t(o,n,a,s),[]);return function(t){var e,i,a=[];for(e=0;e<t.length;e++)for(i=0;i<t[e].length;i++)a.push(t[e][i]);return a}(l)}function i(t,e,s,o){var n,l,h;if(0!==t.length)return n=s.shortestEdge(),function(t,e,i){var s;if(0===t.length)return !0;(s=t.slice()).push(e);var r=a(t,i),o=a(s,i);return r>=o}(e,l=t[0],n)?(e.push(l),i(t.slice(1),e,s,o)):(h=s.cutArea(r(e),o),o.push(s.getCoordinates(e)),i(t,[],h,o)),o;o.push(s.getCoordinates(e));}function a(t,e){var i=Math.min.apply(Math,t),a=Math.max.apply(Math,t),s=r(t);return Math.max(Math.pow(e,2)*a/Math.pow(s,2),Math.pow(s,2)/(Math.pow(e,2)*i))}function s(t){return t&&t.constructor===Array}function r(t){var e,i=0;for(e=0;e<t.length;e++)i+=t[e];return i}function o(t){var e,i=0;if(s(t[0]))for(e=0;e<t.length;e++)i+=o(t[e]);else i=r(t);return i}return function t(i,a,r,n,l){n=void 0===n?0:n,l=void 0===l?0:l;var h,c,d=[],g=[];if(s(i[0])){for(c=0;c<i.length;c++)d[c]=o(i[c]);for(h=e(d,a,r,n,l),c=0;c<i.length;c++)g.push(t(i[c],h[c][2]-h[c][0],h[c][3]-h[c][1],h[c][0],h[c][1]));}else g=e(i,a,r,n,l);return g}}();var Rt,Ht,Dt=function(){function t(e,i){a(this,t),this.ctx=e,this.w=e.w,this.strokeWidth=this.w.config.stroke.width,this.helpers=new At(e),this.dynamicAnim=this.w.config.chart.animations.dynamicAnimation,this.labels=[];}return r(t,[{key:"draw",value:function(t){var e=this,i=this.w,a=new m(this.ctx),s=new H(this.ctx),r=a.group({class:"apexcharts-treemap"});if(i.globals.noData)return r;var o=[];return t.forEach((function(t){var e=t.map((function(t){return Math.abs(t)}));o.push(e);})),this.negRange=this.helpers.checkColorRange(),i.config.series.forEach((function(t,i){t.data.forEach((function(t){Array.isArray(e.labels[i])||(e.labels[i]=[]),e.labels[i].push(t.x);}));})),window.TreemapSquared.generate(o,i.globals.gridWidth,i.globals.gridHeight).forEach((function(o,n){var l=a.group({class:"apexcharts-series apexcharts-treemap-series",seriesName:x.escapeString(i.globals.seriesNames[n]),rel:n+1,"data:realIndex":n});if(i.config.chart.dropShadow.enabled){var h=i.config.chart.dropShadow;new v(e.ctx).dropShadow(r,h,n);}var c=a.group({class:"apexcharts-data-labels"});o.forEach((function(r,o){var h=r[0],c=r[1],d=r[2],g=r[3],u=a.drawRect(h,c,d-h,g-c,i.config.plotOptions.treemap.borderRadius,"#fff",1,e.strokeWidth,i.config.plotOptions.treemap.useFillColorAsStroke?f:i.globals.stroke.colors[n]);u.attr({cx:h,cy:c,index:n,i:n,j:o,width:d-h,height:g-c});var p=e.helpers.getShadeColor(i.config.chart.type,n,o,e.negRange),f=p.color;void 0!==i.config.series[n].data[o]&&i.config.series[n].data[o].fillColor&&(f=i.config.series[n].data[o].fillColor);var x=s.fillPath({color:f,seriesNumber:n,dataPointIndex:o});u.node.classList.add("apexcharts-treemap-rect"),u.attr({fill:x}),e.helpers.addListeners(u);var b={x:h+(d-h)/2,y:c+(g-c)/2,width:0,height:0},v={x:h,y:c,width:d-h,height:g-c};if(i.config.chart.animations.enabled&&!i.globals.dataChanged){var m=1;i.globals.resized||(m=i.config.chart.animations.speed),e.animateTreemap(u,b,v,m);}if(i.globals.dataChanged){var y=1;e.dynamicAnim.enabled&&i.globals.shouldAnimate&&(y=e.dynamicAnim.speed,i.globals.previousPaths[n]&&i.globals.previousPaths[n][o]&&i.globals.previousPaths[n][o].rect&&(b=i.globals.previousPaths[n][o].rect),e.animateTreemap(u,b,v,y));}var w=e.getFontSize(r),k=i.config.dataLabels.formatter(e.labels[n][o],{value:i.globals.series[n][o],seriesIndex:n,dataPointIndex:o,w:i});"truncate"===i.config.plotOptions.treemap.dataLabels.format&&(w=parseInt(i.config.dataLabels.style.fontSize,10),k=e.truncateLabels(k,w,h,c,d,g));var A=e.helpers.calculateDataLabels({text:k,x:(h+d)/2,y:(c+g)/2+e.strokeWidth/2+w/3,i:n,j:o,colorProps:p,fontSize:w,series:t});i.config.dataLabels.enabled&&A&&e.rotateToFitLabel(A,w,k,h,c,d,g),l.add(u),null!==A&&l.add(A);})),l.add(c),r.add(l);})),r}},{key:"getFontSize",value:function(t){var e=this.w;var i,a,s,r,o=function t(e){var i,a=0;if(Array.isArray(e[0]))for(i=0;i<e.length;i++)a+=t(e[i]);else for(i=0;i<e.length;i++)a+=e[i].length;return a}(this.labels)/function t(e){var i,a=0;if(Array.isArray(e[0]))for(i=0;i<e.length;i++)a+=t(e[i]);else for(i=0;i<e.length;i++)a+=1;return a}(this.labels);return i=t[2]-t[0],a=t[3]-t[1],s=i*a,r=Math.pow(s,.5),Math.min(r/o,parseInt(e.config.dataLabels.style.fontSize,10))}},{key:"rotateToFitLabel",value:function(t,e,i,a,s,r,o){var n=new m(this.ctx),l=n.getTextRects(i,e);if(l.width+this.w.config.stroke.width+5>r-a&&l.width<=o-s){var h=n.rotateAroundCenter(t.node);t.node.setAttribute("transform","rotate(-90 ".concat(h.x," ").concat(h.y,") translate(").concat(l.height/3,")"));}}},{key:"truncateLabels",value:function(t,e,i,a,s,r){var o=new m(this.ctx),n=o.getTextRects(t,e).width+this.w.config.stroke.width+5>s-i&&r-a>s-i?r-a:s-i,l=o.getTextBasedOnMaxWidth({text:t,maxWidth:n,fontSize:e});return t.length!==l.length&&n/e<5?"":l}},{key:"animateTreemap",value:function(t,e,i,a){var s=new b(this.ctx);s.animateRect(t,{x:e.x,y:e.y,width:e.width,height:e.height},{x:i.x,y:i.y,width:i.width,height:i.height},a,(function(){s.animationCompleted(t);}));}}]),t}(),Ot=86400,Nt=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w,this.timeScaleArray=[],this.utc=this.w.config.xaxis.labels.datetimeUTC;}return r(t,[{key:"calculateTimeScaleTicks",value:function(t,i){var a=this,s=this.w;if(s.globals.allSeriesCollapsed)return s.globals.labels=[],s.globals.timescaleLabels=[],[];var r=new A(this.ctx),o=(i-t)/864e5;this.determineInterval(o),s.globals.disableZoomIn=!1,s.globals.disableZoomOut=!1,o<.00011574074074074075?s.globals.disableZoomIn=!0:o>5e4&&(s.globals.disableZoomOut=!0);var n=r.getTimeUnitsfromTimestamp(t,i,this.utc),l=s.globals.gridWidth/o,h=l/24,c=h/60,d=c/60,g=Math.floor(24*o),u=Math.floor(1440*o),p=Math.floor(o*Ot),f=Math.floor(o),x=Math.floor(o/30),b=Math.floor(o/365),v={minMillisecond:n.minMillisecond,minSecond:n.minSecond,minMinute:n.minMinute,minHour:n.minHour,minDate:n.minDate,minMonth:n.minMonth,minYear:n.minYear},m={firstVal:v,currentMillisecond:v.minMillisecond,currentSecond:v.minSecond,currentMinute:v.minMinute,currentHour:v.minHour,currentMonthDate:v.minDate,currentDate:v.minDate,currentMonth:v.minMonth,currentYear:v.minYear,daysWidthOnXAxis:l,hoursWidthOnXAxis:h,minutesWidthOnXAxis:c,secondsWidthOnXAxis:d,numberOfSeconds:p,numberOfMinutes:u,numberOfHours:g,numberOfDays:f,numberOfMonths:x,numberOfYears:b};switch(this.tickInterval){case"years":this.generateYearScale(m);break;case"months":case"half_year":this.generateMonthScale(m);break;case"months_days":case"months_fortnight":case"days":case"week_days":this.generateDayScale(m);break;case"hours":this.generateHourScale(m);break;case"minutes_fives":case"minutes":this.generateMinuteScale(m);break;case"seconds_tens":case"seconds_fives":case"seconds":this.generateSecondScale(m);}var y=this.timeScaleArray.map((function(t){var i={position:t.position,unit:t.unit,year:t.year,day:t.day?t.day:1,hour:t.hour?t.hour:0,month:t.month+1};return "month"===t.unit?e(e({},i),{},{day:1,value:t.value+1}):"day"===t.unit||"hour"===t.unit?e(e({},i),{},{value:t.value}):"minute"===t.unit?e(e({},i),{},{value:t.value,minute:t.value}):"second"===t.unit?e(e({},i),{},{value:t.value,minute:t.minute,second:t.second}):t}));return y.filter((function(t){var e=1,i=Math.ceil(s.globals.gridWidth/120),r=t.value;void 0!==s.config.xaxis.tickAmount&&(i=s.config.xaxis.tickAmount),y.length>i&&(e=Math.floor(y.length/i));var o=!1,n=!1;switch(a.tickInterval){case"years":"year"===t.unit&&(o=!0);break;case"half_year":e=7,"year"===t.unit&&(o=!0);break;case"months":e=1,"year"===t.unit&&(o=!0);break;case"months_fortnight":e=15,"year"!==t.unit&&"month"!==t.unit||(o=!0),30===r&&(n=!0);break;case"months_days":e=10,"month"===t.unit&&(o=!0),30===r&&(n=!0);break;case"week_days":e=8,"month"===t.unit&&(o=!0);break;case"days":e=1,"month"===t.unit&&(o=!0);break;case"hours":"day"===t.unit&&(o=!0);break;case"minutes_fives":case"seconds_fives":r%5!=0&&(n=!0);break;case"seconds_tens":r%10!=0&&(n=!0);}if("hours"===a.tickInterval||"minutes_fives"===a.tickInterval||"seconds_tens"===a.tickInterval||"seconds_fives"===a.tickInterval){if(!n)return !0}else if((r%e==0||o)&&!n)return !0}))}},{key:"recalcDimensionsBasedOnFormat",value:function(t,e){var i=this.w,a=this.formatDates(t),s=this.removeOverlappingTS(a);i.globals.timescaleLabels=s.slice(),new ot(this.ctx).plotCoords();}},{key:"determineInterval",value:function(t){var e=24*t,i=60*e;switch(!0){case t/365>5:this.tickInterval="years";break;case t>800:this.tickInterval="half_year";break;case t>180:this.tickInterval="months";break;case t>90:this.tickInterval="months_fortnight";break;case t>60:this.tickInterval="months_days";break;case t>30:this.tickInterval="week_days";break;case t>2:this.tickInterval="days";break;case e>2.4:this.tickInterval="hours";break;case i>15:this.tickInterval="minutes_fives";break;case i>5:this.tickInterval="minutes";break;case i>1:this.tickInterval="seconds_tens";break;case 60*i>20:this.tickInterval="seconds_fives";break;default:this.tickInterval="seconds";}}},{key:"generateYearScale",value:function(t){var e=t.firstVal,i=t.currentMonth,a=t.currentYear,s=t.daysWidthOnXAxis,r=t.numberOfYears,o=e.minYear,n=0,l=new A(this.ctx),h="year";if(e.minDate>1||e.minMonth>0){var c=l.determineRemainingDaysOfYear(e.minYear,e.minMonth,e.minDate);n=(l.determineDaysOfYear(e.minYear)-c+1)*s,o=e.minYear+1,this.timeScaleArray.push({position:n,value:o,unit:h,year:o,month:x.monthMod(i+1)});}else 1===e.minDate&&0===e.minMonth&&this.timeScaleArray.push({position:n,value:o,unit:h,year:a,month:x.monthMod(i+1)});for(var d=o,g=n,u=0;u<r;u++)d++,g=l.determineDaysOfYear(d-1)*s+g,this.timeScaleArray.push({position:g,value:d,unit:h,year:d,month:1});}},{key:"generateMonthScale",value:function(t){var e=t.firstVal,i=t.currentMonthDate,a=t.currentMonth,s=t.currentYear,r=t.daysWidthOnXAxis,o=t.numberOfMonths,n=a,l=0,h=new A(this.ctx),c="month",d=0;if(e.minDate>1){l=(h.determineDaysOfMonths(a+1,e.minYear)-i+1)*r,n=x.monthMod(a+1);var g=s+d,u=x.monthMod(n),p=n;0===n&&(c="year",p=g,u=1,g+=d+=1),this.timeScaleArray.push({position:l,value:p,unit:c,year:g,month:u});}else this.timeScaleArray.push({position:l,value:n,unit:c,year:s,month:x.monthMod(a)});for(var f=n+1,b=l,v=0,m=1;v<o;v++,m++){0===(f=x.monthMod(f))?(c="year",d+=1):c="month";var y=this._getYear(s,f,d);b=h.determineDaysOfMonths(f,y)*r+b;var w=0===f?y:f;this.timeScaleArray.push({position:b,value:w,unit:c,year:y,month:0===f?1:f}),f++;}}},{key:"generateDayScale",value:function(t){var e=t.firstVal,i=t.currentMonth,a=t.currentYear,s=t.hoursWidthOnXAxis,r=t.numberOfDays,o=new A(this.ctx),n="day",l=e.minDate+1,h=l,c=function(t,e,i){return t>o.determineDaysOfMonths(e+1,i)?(h=1,n="month",g=e+=1,e):e},d=(24-e.minHour)*s,g=l,u=c(h,i,a);0===e.minHour&&1===e.minDate?(d=0,g=x.monthMod(e.minMonth),n="month",h=e.minDate):1!==e.minDate&&0===e.minHour&&0===e.minMinute&&(d=0,l=e.minDate,g=l,u=c(h=l,i,a)),this.timeScaleArray.push({position:d,value:g,unit:n,year:this._getYear(a,u,0),month:x.monthMod(u),day:h});for(var p=d,f=0;f<r;f++){n="day",u=c(h+=1,u,this._getYear(a,u,0));var b=this._getYear(a,u,0);p=24*s+p;var v=1===h?x.monthMod(u):h;this.timeScaleArray.push({position:p,value:v,unit:n,year:b,month:x.monthMod(u),day:v});}}},{key:"generateHourScale",value:function(t){var e=t.firstVal,i=t.currentDate,a=t.currentMonth,s=t.currentYear,r=t.minutesWidthOnXAxis,o=t.numberOfHours,n=new A(this.ctx),l="hour",h=function(t,e){return t>n.determineDaysOfMonths(e+1,s)&&(f=1,e+=1),{month:e,date:f}},c=function(t,e){return t>n.determineDaysOfMonths(e+1,s)?e+=1:e},d=60-(e.minMinute+e.minSecond/60),g=d*r,u=e.minHour+1,p=u;60===d&&(g=0,p=u=e.minHour);var f=i;p>=24&&(p=0,f+=1,l="day");var b=h(f,a).month;b=c(f,b),this.timeScaleArray.push({position:g,value:u,unit:l,day:f,hour:p,year:s,month:x.monthMod(b)}),p++;for(var v=g,m=0;m<o;m++){if(l="hour",p>=24)p=0,l="day",b=h(f+=1,b).month,b=c(f,b);var y=this._getYear(s,b,0);v=60*r+v;var w=0===p?f:p;this.timeScaleArray.push({position:v,value:w,unit:l,hour:p,day:f,year:y,month:x.monthMod(b)}),p++;}}},{key:"generateMinuteScale",value:function(t){for(var e=t.currentMillisecond,i=t.currentSecond,a=t.currentMinute,s=t.currentHour,r=t.currentDate,o=t.currentMonth,n=t.currentYear,l=t.minutesWidthOnXAxis,h=t.secondsWidthOnXAxis,c=t.numberOfMinutes,d=a+1,g=r,u=o,p=n,f=s,b=(60-i-e/1e3)*h,v=0;v<c;v++)d>=60&&(d=0,24===(f+=1)&&(f=0)),this.timeScaleArray.push({position:b,value:d,unit:"minute",hour:f,minute:d,day:g,year:this._getYear(p,u,0),month:x.monthMod(u)}),b+=l,d++;}},{key:"generateSecondScale",value:function(t){for(var e=t.currentMillisecond,i=t.currentSecond,a=t.currentMinute,s=t.currentHour,r=t.currentDate,o=t.currentMonth,n=t.currentYear,l=t.secondsWidthOnXAxis,h=t.numberOfSeconds,c=i+1,d=a,g=r,u=o,p=n,f=s,b=(1e3-e)/1e3*l,v=0;v<h;v++)c>=60&&(c=0,++d>=60&&(d=0,24===++f&&(f=0))),this.timeScaleArray.push({position:b,value:c,unit:"second",hour:f,minute:d,second:c,day:g,year:this._getYear(p,u,0),month:x.monthMod(u)}),b+=l,c++;}},{key:"createRawDateString",value:function(t,e){var i=t.year;return 0===t.month&&(t.month=1),i+="-"+("0"+t.month.toString()).slice(-2),"day"===t.unit?i+="day"===t.unit?"-"+("0"+e).slice(-2):"-01":i+="-"+("0"+(t.day?t.day:"1")).slice(-2),"hour"===t.unit?i+="hour"===t.unit?"T"+("0"+e).slice(-2):"T00":i+="T"+("0"+(t.hour?t.hour:"0")).slice(-2),"minute"===t.unit?i+=":"+("0"+e).slice(-2):i+=":"+(t.minute?("0"+t.minute).slice(-2):"00"),"second"===t.unit?i+=":"+("0"+e).slice(-2):i+=":00",this.utc&&(i+=".000Z"),i}},{key:"formatDates",value:function(t){var e=this,i=this.w;return t.map((function(t){var a=t.value.toString(),s=new A(e.ctx),r=e.createRawDateString(t,a),o=s.getDate(s.parseDate(r));if(e.utc||(o=s.getDate(s.parseDateWithTimezone(r))),void 0===i.config.xaxis.labels.format){var n="dd MMM",l=i.config.xaxis.labels.datetimeFormatter;"year"===t.unit&&(n=l.year),"month"===t.unit&&(n=l.month),"day"===t.unit&&(n=l.day),"hour"===t.unit&&(n=l.hour),"minute"===t.unit&&(n=l.minute),"second"===t.unit&&(n=l.second),a=s.formatDate(o,n);}else a=s.formatDate(o,i.config.xaxis.labels.format);return {dateString:r,position:t.position,value:a,unit:t.unit,year:t.year,month:t.month}}))}},{key:"removeOverlappingTS",value:function(t){var e,i=this,a=new m(this.ctx),s=!1;t.length>0&&t[0].value&&t.every((function(e){return e.value.length===t[0].value.length}))&&(s=!0,e=a.getTextRects(t[0].value).width);var r=0,o=t.map((function(o,n){if(n>0&&i.w.config.xaxis.labels.hideOverlappingLabels){var l=s?e:a.getTextRects(t[r].value).width,h=t[r].position;return o.position>h+l+10?(r=n,o):null}return o}));return o=o.filter((function(t){return null!==t}))}},{key:"_getYear",value:function(t,e,i){return t+Math.floor(e/12)+i}}]),t}(),Wt=function(){function t(e,i){a(this,t),this.ctx=i,this.w=i.w,this.el=e;}return r(t,[{key:"setupElements",value:function(){var t=this.w.globals,e=this.w.config,i=e.chart.type;t.axisCharts=["line","area","bar","rangeBar","rangeArea","candlestick","boxPlot","scatter","bubble","radar","heatmap","treemap"].indexOf(i)>-1,t.xyCharts=["line","area","bar","rangeBar","rangeArea","candlestick","boxPlot","scatter","bubble"].indexOf(i)>-1,t.isBarHorizontal=("bar"===e.chart.type||"rangeBar"===e.chart.type||"boxPlot"===e.chart.type)&&e.plotOptions.bar.horizontal,t.chartClass=".apexcharts"+t.chartID,t.dom.baseEl=this.el,t.dom.elWrap=document.createElement("div"),m.setAttrs(t.dom.elWrap,{id:t.chartClass.substring(1),class:"apexcharts-canvas "+t.chartClass.substring(1)}),this.el.appendChild(t.dom.elWrap),t.dom.Paper=new window.SVG.Doc(t.dom.elWrap),t.dom.Paper.attr({class:"apexcharts-svg","xmlns:data":"ApexChartsNS",transform:"translate(".concat(e.chart.offsetX,", ").concat(e.chart.offsetY,")")}),t.dom.Paper.node.style.background="dark"!==e.theme.mode||e.chart.background?e.chart.background:"rgba(0, 0, 0, 0.8)",this.setSVGDimensions(),t.dom.elLegendForeign=document.createElementNS(t.SVGNS,"foreignObject"),m.setAttrs(t.dom.elLegendForeign,{x:0,y:0,width:t.svgWidth,height:t.svgHeight}),t.dom.elLegendWrap=document.createElement("div"),t.dom.elLegendWrap.classList.add("apexcharts-legend"),t.dom.elLegendWrap.setAttribute("xmlns","http://www.w3.org/1999/xhtml"),t.dom.elLegendForeign.appendChild(t.dom.elLegendWrap),t.dom.Paper.node.appendChild(t.dom.elLegendForeign),t.dom.elGraphical=t.dom.Paper.group().attr({class:"apexcharts-inner apexcharts-graphical"}),t.dom.elDefs=t.dom.Paper.defs(),t.dom.Paper.add(t.dom.elGraphical),t.dom.elGraphical.add(t.dom.elDefs);}},{key:"plotChartType",value:function(t,e){var i=this.w,a=i.config,s=i.globals,r={series:[],i:[]},o={series:[],i:[]},n={series:[],i:[]},l={series:[],i:[]},h={series:[],i:[]},c={series:[],i:[]},d={series:[],i:[]},g={series:[],i:[]},p={series:[],seriesRangeEnd:[],i:[]},f=void 0!==a.chart.type?a.chart.type:"line",x=null,b=0;s.series.forEach((function(e,a){var u=t[a].type||f;switch(u){case"column":case"bar":h.series.push(e),h.i.push(a),i.globals.columnSeries=h;break;case"area":o.series.push(e),o.i.push(a);break;case"line":r.series.push(e),r.i.push(a);break;case"scatter":n.series.push(e),n.i.push(a);break;case"bubble":l.series.push(e),l.i.push(a);break;case"candlestick":c.series.push(e),c.i.push(a);break;case"boxPlot":d.series.push(e),d.i.push(a);break;case"rangeBar":g.series.push(e),g.i.push(a);break;case"rangeArea":p.series.push(s.seriesRangeStart[a]),p.seriesRangeEnd.push(s.seriesRangeEnd[a]),p.i.push(a);break;case"heatmap":case"treemap":case"pie":case"donut":case"polarArea":case"radialBar":case"radar":x=u;break;default:console.warn("You have specified an unrecognized series type (",u,").");}f!==u&&"scatter"!==u&&b++;})),b>0&&(null!==x&&console.warn("Chart or series type ",x," can not appear with other chart or series types."),h.series.length>0&&a.plotOptions.bar.horizontal&&(b-=h.length,h={series:[],i:[]},i.globals.columnSeries={series:[],i:[]},console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"))),s.comboCharts||(s.comboCharts=b>0);var v=new Ft(this.ctx,e),m=new kt(this.ctx,e);this.ctx.pie=new Lt(this.ctx);var w=new Mt(this.ctx);this.ctx.rangeBar=new It(this.ctx,e);var k=new Pt(this.ctx),A=[];if(s.comboCharts){var S,C,L=new y(this.ctx);if(o.series.length>0)(S=A).push.apply(S,u(L.drawSeriesByGroup(o,s.areaGroups,"area",v)));if(h.series.length>0)if(i.config.chart.stacked){var P=new wt(this.ctx,e);A.push(P.draw(h.series,h.i));}else this.ctx.bar=new yt(this.ctx,e),A.push(this.ctx.bar.draw(h.series,h.i));if(p.series.length>0&&A.push(v.draw(p.series,"rangeArea",p.i,p.seriesRangeEnd)),r.series.length>0)(C=A).push.apply(C,u(L.drawSeriesByGroup(r,s.lineGroups,"line",v)));if(c.series.length>0&&A.push(m.draw(c.series,"candlestick",c.i)),d.series.length>0&&A.push(m.draw(d.series,"boxPlot",d.i)),g.series.length>0&&A.push(this.ctx.rangeBar.draw(g.series,g.i)),n.series.length>0){var M=new Ft(this.ctx,e,!0);A.push(M.draw(n.series,"scatter",n.i));}if(l.series.length>0){var I=new Ft(this.ctx,e,!0);A.push(I.draw(l.series,"bubble",l.i));}}else switch(a.chart.type){case"line":A=v.draw(s.series,"line");break;case"area":A=v.draw(s.series,"area");break;case"bar":if(a.chart.stacked)A=new wt(this.ctx,e).draw(s.series);else this.ctx.bar=new yt(this.ctx,e),A=this.ctx.bar.draw(s.series);break;case"candlestick":A=new kt(this.ctx,e).draw(s.series,"candlestick");break;case"boxPlot":A=new kt(this.ctx,e).draw(s.series,a.chart.type);break;case"rangeBar":A=this.ctx.rangeBar.draw(s.series);break;case"rangeArea":A=v.draw(s.seriesRangeStart,"rangeArea",void 0,s.seriesRangeEnd);break;case"heatmap":A=new St(this.ctx,e).draw(s.series);break;case"treemap":A=new Dt(this.ctx,e).draw(s.series);break;case"pie":case"donut":case"polarArea":A=this.ctx.pie.draw(s.series);break;case"radialBar":A=w.draw(s.series);break;case"radar":A=k.draw(s.series);break;default:A=v.draw(s.series);}return A}},{key:"setSVGDimensions",value:function(){var t=this.w.globals,e=this.w.config;t.svgWidth=e.chart.width,t.svgHeight=e.chart.height;var i=x.getDimensions(this.el),a=e.chart.width.toString().split(/[0-9]+/g).pop();"%"===a?x.isNumber(i[0])&&(0===i[0].width&&(i=x.getDimensions(this.el.parentNode)),t.svgWidth=i[0]*parseInt(e.chart.width,10)/100):"px"!==a&&""!==a||(t.svgWidth=parseInt(e.chart.width,10));var s=e.chart.height.toString().split(/[0-9]+/g).pop();if("auto"!==t.svgHeight&&""!==t.svgHeight)if("%"===s){var r=x.getDimensions(this.el.parentNode);t.svgHeight=r[1]*parseInt(e.chart.height,10)/100;}else t.svgHeight=parseInt(e.chart.height,10);else t.axisCharts?t.svgHeight=t.svgWidth/1.61:t.svgHeight=t.svgWidth/1.2;if(t.svgWidth<0&&(t.svgWidth=0),t.svgHeight<0&&(t.svgHeight=0),m.setAttrs(t.dom.Paper.node,{width:t.svgWidth,height:t.svgHeight}),"%"!==s){var o=e.chart.sparkline.enabled?0:t.axisCharts?e.chart.parentHeightOffset:0;t.dom.Paper.node.parentNode.parentNode.style.minHeight=t.svgHeight+o+"px";}t.dom.elWrap.style.width=t.svgWidth+"px",t.dom.elWrap.style.height=t.svgHeight+"px";}},{key:"shiftGraphPosition",value:function(){var t=this.w.globals,e=t.translateY,i={transform:"translate("+t.translateX+", "+e+")"};m.setAttrs(t.dom.elGraphical.node,i);}},{key:"resizeNonAxisCharts",value:function(){var t=this.w,e=t.globals,i=0,a=t.config.chart.sparkline.enabled?1:15;a+=t.config.grid.padding.bottom,"top"!==t.config.legend.position&&"bottom"!==t.config.legend.position||!t.config.legend.show||t.config.legend.floating||(i=new lt(this.ctx).legendHelpers.getLegendBBox().clwh+10);var s=t.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"),r=2.05*t.globals.radialSize;if(s&&!t.config.chart.sparkline.enabled&&0!==t.config.plotOptions.radialBar.startAngle){var o=x.getBoundingClientRect(s);r=o.bottom;var n=o.bottom-o.top;r=Math.max(2.05*t.globals.radialSize,n);}var l=r+e.translateY+i+a;e.dom.elLegendForeign&&e.dom.elLegendForeign.setAttribute("height",l),t.config.chart.height&&String(t.config.chart.height).indexOf("%")>0||(e.dom.elWrap.style.height=l+"px",m.setAttrs(e.dom.Paper.node,{height:l}),e.dom.Paper.node.parentNode.parentNode.style.minHeight=l+"px");}},{key:"coreCalculations",value:function(){new U(this.ctx).init();}},{key:"resetGlobals",value:function(){var t=this,e=function(){return t.w.config.series.map((function(t){return []}))},i=new F,a=this.w.globals;i.initGlobalVars(a),a.seriesXvalues=e(),a.seriesYvalues=e();}},{key:"isMultipleY",value:function(){if(this.w.config.yaxis.constructor===Array&&this.w.config.yaxis.length>1)return this.w.globals.isMultipleYAxis=!0,!0}},{key:"xySettings",value:function(){var t=null,e=this.w;if(e.globals.axisCharts){if("back"===e.config.xaxis.crosshairs.position)new Q(this.ctx).drawXCrosshairs();if("back"===e.config.yaxis[0].crosshairs.position)new Q(this.ctx).drawYCrosshairs();if("datetime"===e.config.xaxis.type&&void 0===e.config.xaxis.labels.formatter){this.ctx.timeScale=new Nt(this.ctx);var i=[];isFinite(e.globals.minX)&&isFinite(e.globals.maxX)&&!e.globals.isBarHorizontal?i=this.ctx.timeScale.calculateTimeScaleTicks(e.globals.minX,e.globals.maxX):e.globals.isBarHorizontal&&(i=this.ctx.timeScale.calculateTimeScaleTicks(e.globals.minY,e.globals.maxY)),this.ctx.timeScale.recalcDimensionsBasedOnFormat(i);}t=new y(this.ctx).getCalculatedRatios();}return t}},{key:"updateSourceChart",value:function(t){this.ctx.w.globals.selection=void 0,this.ctx.updateHelpers._updateOptions({chart:{selection:{xaxis:{min:t.w.globals.minX,max:t.w.globals.maxX}}}},!1,!1);}},{key:"setupBrushHandler",value:function(){var t=this,e=this.w;if(e.config.chart.brush.enabled&&"function"!=typeof e.config.chart.events.selection){var i=Array.isArray(e.config.chart.brush.targets)?e.config.chart.brush.targets:[e.config.chart.brush.target];i.forEach((function(e){var i=ApexCharts.getChartByID(e);i.w.globals.brushSource=t.ctx,"function"!=typeof i.w.config.chart.events.zoomed&&(i.w.config.chart.events.zoomed=function(){t.updateSourceChart(i);}),"function"!=typeof i.w.config.chart.events.scrolled&&(i.w.config.chart.events.scrolled=function(){t.updateSourceChart(i);});})),e.config.chart.events.selection=function(t,e){i.forEach((function(t){ApexCharts.getChartByID(t).ctx.updateHelpers._updateOptions({xaxis:{min:e.xaxis.min,max:e.xaxis.max}},!1,!1,!1,!1);}));};}}}]),t}(),Bt=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w;}return r(t,[{key:"_updateOptions",value:function(t){var e=this,a=arguments.length>1&&void 0!==arguments[1]&&arguments[1],s=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o=arguments.length>4&&void 0!==arguments[4]&&arguments[4];return new Promise((function(n){var l=[e.ctx];r&&(l=e.ctx.getSyncedCharts()),e.ctx.w.globals.isExecCalled&&(l=[e.ctx],e.ctx.w.globals.isExecCalled=!1),l.forEach((function(r,h){var c=r.w;if(c.globals.shouldAnimate=s,a||(c.globals.resized=!0,c.globals.dataChanged=!0,s&&r.series.getPreviousPaths()),t&&"object"===i(t)&&(r.config=new Y(t),t=y.extendArrayProps(r.config,t,c),r.w.globals.chartID!==e.ctx.w.globals.chartID&&delete t.series,c.config=x.extend(c.config,t),o&&(c.globals.lastXAxis=t.xaxis?x.clone(t.xaxis):[],c.globals.lastYAxis=t.yaxis?x.clone(t.yaxis):[],c.globals.initialConfig=x.extend({},c.config),c.globals.initialSeries=x.clone(c.config.series),t.series))){for(var d=0;d<c.globals.collapsedSeriesIndices.length;d++){var g=c.config.series[c.globals.collapsedSeriesIndices[d]];c.globals.collapsedSeries[d].data=c.globals.axisCharts?g.data.slice():g;}for(var u=0;u<c.globals.ancillaryCollapsedSeriesIndices.length;u++){var p=c.config.series[c.globals.ancillaryCollapsedSeriesIndices[u]];c.globals.ancillaryCollapsedSeries[u].data=c.globals.axisCharts?p.data.slice():p;}r.series.emptyCollapsedSeries(c.config.series);}return r.update(t).then((function(){h===l.length-1&&n(r);}))}));}))}},{key:"_updateSeries",value:function(t,e){var i=this,a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return new Promise((function(s){var r,o=i.w;return o.globals.shouldAnimate=e,o.globals.dataChanged=!0,e&&i.ctx.series.getPreviousPaths(),o.globals.axisCharts?(0===(r=t.map((function(t,e){return i._extendSeries(t,e)}))).length&&(r=[{data:[]}]),o.config.series=r):o.config.series=t.slice(),a&&(o.globals.initialConfig.series=x.clone(o.config.series),o.globals.initialSeries=x.clone(o.config.series)),i.ctx.update().then((function(){s(i.ctx);}))}))}},{key:"_extendSeries",value:function(t,i){var a=this.w,s=a.config.series[i];return e(e({},a.config.series[i]),{},{name:t.name?t.name:null==s?void 0:s.name,color:t.color?t.color:null==s?void 0:s.color,type:t.type?t.type:null==s?void 0:s.type,group:t.group?t.group:null==s?void 0:s.group,data:t.data?t.data:null==s?void 0:s.data,zIndex:void 0!==t.zIndex?t.zIndex:i})}},{key:"toggleDataPointSelection",value:function(t,e){var i=this.w,a=null,s=".apexcharts-series[data\\:realIndex='".concat(t,"']");return i.globals.axisCharts?a=i.globals.dom.Paper.select("".concat(s," path[j='").concat(e,"'], ").concat(s," circle[j='").concat(e,"'], ").concat(s," rect[j='").concat(e,"']")).members[0]:void 0===e&&(a=i.globals.dom.Paper.select("".concat(s," path[j='").concat(t,"']")).members[0],"pie"!==i.config.chart.type&&"polarArea"!==i.config.chart.type&&"donut"!==i.config.chart.type||this.ctx.pie.pieClicked(t)),a?(new m(this.ctx).pathMouseDown(a,null),a.node?a.node:null):(console.warn("toggleDataPointSelection: Element not found"),null)}},{key:"forceXAxisUpdate",value:function(t){var e=this.w;if(["min","max"].forEach((function(i){void 0!==t.xaxis[i]&&(e.config.xaxis[i]=t.xaxis[i],e.globals.lastXAxis[i]=t.xaxis[i]);})),t.xaxis.categories&&t.xaxis.categories.length&&(e.config.xaxis.categories=t.xaxis.categories),e.config.xaxis.convertedCatToNumeric){var i=new E(t);t=i.convertCatToNumericXaxis(t,this.ctx);}return t}},{key:"forceYAxisUpdate",value:function(t){return t.chart&&t.chart.stacked&&"100%"===t.chart.stackType&&(Array.isArray(t.yaxis)?t.yaxis.forEach((function(e,i){t.yaxis[i].min=0,t.yaxis[i].max=100;})):(t.yaxis.min=0,t.yaxis.max=100)),t}},{key:"revertDefaultAxisMinMax",value:function(t){var e=this,i=this.w,a=i.globals.lastXAxis,s=i.globals.lastYAxis;t&&t.xaxis&&(a=t.xaxis),t&&t.yaxis&&(s=t.yaxis),i.config.xaxis.min=a.min,i.config.xaxis.max=a.max;var r=function(t){void 0!==s[t]&&(i.config.yaxis[t].min=s[t].min,i.config.yaxis[t].max=s[t].max);};i.config.yaxis.map((function(t,a){i.globals.zoomed||void 0!==s[a]?r(a):void 0!==e.ctx.opts.yaxis[a]&&(t.min=e.ctx.opts.yaxis[a].min,t.max=e.ctx.opts.yaxis[a].max);}));}}]),t}();Rt="undefined"!=typeof window?window:void 0,Ht=function(t,e){var a=(void 0!==this?this:t).SVG=function(t){if(a.supported)return t=new a.Doc(t),a.parser.draw||a.prepare(),t};if(a.ns="http://www.w3.org/2000/svg",a.xmlns="http://www.w3.org/2000/xmlns/",a.xlink="http://www.w3.org/1999/xlink",a.svgjs="http://svgjs.dev",a.supported=!0,!a.supported)return !1;a.did=1e3,a.eid=function(t){return "Svgjs"+d(t)+a.did++},a.create=function(t){var i=e.createElementNS(this.ns,t);return i.setAttribute("id",this.eid(t)),i},a.extend=function(){var t,e;e=(t=[].slice.call(arguments)).pop();for(var i=t.length-1;i>=0;i--)if(t[i])for(var s in e)t[i].prototype[s]=e[s];a.Set&&a.Set.inherit&&a.Set.inherit();},a.invent=function(t){var e="function"==typeof t.create?t.create:function(){this.constructor.call(this,a.create(t.create));};return t.inherit&&(e.prototype=new t.inherit),t.extend&&a.extend(e,t.extend),t.construct&&a.extend(t.parent||a.Container,t.construct),e},a.adopt=function(e){return e?e.instance?e.instance:((i="svg"==e.nodeName?e.parentNode instanceof t.SVGElement?new a.Nested:new a.Doc:"linearGradient"==e.nodeName?new a.Gradient("linear"):"radialGradient"==e.nodeName?new a.Gradient("radial"):a[d(e.nodeName)]?new(a[d(e.nodeName)]):new a.Element(e)).type=e.nodeName,i.node=e,e.instance=i,i instanceof a.Doc&&i.namespace().defs(),i.setData(JSON.parse(e.getAttribute("svgjs:data"))||{}),i):null;var i;},a.prepare=function(){var t=e.getElementsByTagName("body")[0],i=(t?new a.Doc(t):a.adopt(e.documentElement).nested()).size(2,0);a.parser={body:t||e.documentElement,draw:i.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node,poly:i.polyline().node,path:i.path().node,native:a.create("svg")};},a.parser={native:a.create("svg")},e.addEventListener("DOMContentLoaded",(function(){a.parser.draw||a.prepare();}),!1),a.regex={numberAndUnit:/^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i,hex:/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,rgb:/rgb\((\d+),(\d+),(\d+)\)/,reference:/#([a-z0-9\-_]+)/i,transforms:/\)\s*,?\s*/,whitespace:/\s/g,isHex:/^#[a-f0-9]{3,6}$/i,isRgb:/^rgb\(/,isCss:/[^:]+:[^;]+;?/,isBlank:/^(\s+)?$/,isNumber:/^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,isPercent:/^-?[\d\.]+%$/,isImage:/\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i,delimiter:/[\s,]+/,hyphen:/([^e])\-/gi,pathLetters:/[MLHVCSQTAZ]/gi,isPathLetter:/[MLHVCSQTAZ]/i,numbersWithDots:/((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi,dots:/\./g},a.utils={map:function(t,e){for(var i=t.length,a=[],s=0;s<i;s++)a.push(e(t[s]));return a},filter:function(t,e){for(var i=t.length,a=[],s=0;s<i;s++)e(t[s])&&a.push(t[s]);return a},filterSVGElements:function(e){return this.filter(e,(function(e){return e instanceof t.SVGElement}))}},a.defaults={attrs:{"fill-opacity":1,"stroke-opacity":1,"stroke-width":0,"stroke-linejoin":"miter","stroke-linecap":"butt",fill:"#000000",stroke:"#000000",opacity:1,x:0,y:0,cx:0,cy:0,width:0,height:0,r:0,rx:0,ry:0,offset:0,"stop-opacity":1,"stop-color":"#000000","font-size":16,"font-family":"Helvetica, Arial, sans-serif","text-anchor":"start"}},a.Color=function(t){var e,s;this.r=0,this.g=0,this.b=0,t&&("string"==typeof t?a.regex.isRgb.test(t)?(e=a.regex.rgb.exec(t.replace(a.regex.whitespace,"")),this.r=parseInt(e[1]),this.g=parseInt(e[2]),this.b=parseInt(e[3])):a.regex.isHex.test(t)&&(e=a.regex.hex.exec(4==(s=t).length?["#",s.substring(1,2),s.substring(1,2),s.substring(2,3),s.substring(2,3),s.substring(3,4),s.substring(3,4)].join(""):s),this.r=parseInt(e[1],16),this.g=parseInt(e[2],16),this.b=parseInt(e[3],16)):"object"===i(t)&&(this.r=t.r,this.g=t.g,this.b=t.b));},a.extend(a.Color,{toString:function(){return this.toHex()},toHex:function(){return "#"+g(this.r)+g(this.g)+g(this.b)},toRgb:function(){return "rgb("+[this.r,this.g,this.b].join()+")"},brightness:function(){return this.r/255*.3+this.g/255*.59+this.b/255*.11},morph:function(t){return this.destination=new a.Color(t),this},at:function(t){return this.destination?(t=t<0?0:t>1?1:t,new a.Color({r:~~(this.r+(this.destination.r-this.r)*t),g:~~(this.g+(this.destination.g-this.g)*t),b:~~(this.b+(this.destination.b-this.b)*t)})):this}}),a.Color.test=function(t){return t+="",a.regex.isHex.test(t)||a.regex.isRgb.test(t)},a.Color.isRgb=function(t){return t&&"number"==typeof t.r&&"number"==typeof t.g&&"number"==typeof t.b},a.Color.isColor=function(t){return a.Color.isRgb(t)||a.Color.test(t)},a.Array=function(t,e){0==(t=(t||[]).valueOf()).length&&e&&(t=e.valueOf()),this.value=this.parse(t);},a.extend(a.Array,{toString:function(){return this.value.join(" ")},valueOf:function(){return this.value},parse:function(t){return t=t.valueOf(),Array.isArray(t)?t:this.split(t)}}),a.PointArray=function(t,e){a.Array.call(this,t,e||[[0,0]]);},a.PointArray.prototype=new a.Array,a.PointArray.prototype.constructor=a.PointArray;for(var s={M:function(t,e,i){return e.x=i.x=t[0],e.y=i.y=t[1],["M",e.x,e.y]},L:function(t,e){return e.x=t[0],e.y=t[1],["L",t[0],t[1]]},H:function(t,e){return e.x=t[0],["H",t[0]]},V:function(t,e){return e.y=t[0],["V",t[0]]},C:function(t,e){return e.x=t[4],e.y=t[5],["C",t[0],t[1],t[2],t[3],t[4],t[5]]},Q:function(t,e){return e.x=t[2],e.y=t[3],["Q",t[0],t[1],t[2],t[3]]},S:function(t,e){return e.x=t[2],e.y=t[3],["S",t[0],t[1],t[2],t[3]]},Z:function(t,e,i){return e.x=i.x,e.y=i.y,["Z"]}},r="mlhvqtcsaz".split(""),o=0,n=r.length;o<n;++o)s[r[o]]=function(t){return function(e,i,a){if("H"==t)e[0]=e[0]+i.x;else if("V"==t)e[0]=e[0]+i.y;else if("A"==t)e[5]=e[5]+i.x,e[6]=e[6]+i.y;else for(var r=0,o=e.length;r<o;++r)e[r]=e[r]+(r%2?i.y:i.x);if(s&&"function"==typeof s[t])return s[t](e,i,a)}}(r[o].toUpperCase());a.PathArray=function(t,e){a.Array.call(this,t,e||[["M",0,0]]);},a.PathArray.prototype=new a.Array,a.PathArray.prototype.constructor=a.PathArray,a.extend(a.PathArray,{toString:function(){return function(t){for(var e=0,i=t.length,a="";e<i;e++)a+=t[e][0],null!=t[e][1]&&(a+=t[e][1],null!=t[e][2]&&(a+=" ",a+=t[e][2],null!=t[e][3]&&(a+=" ",a+=t[e][3],a+=" ",a+=t[e][4],null!=t[e][5]&&(a+=" ",a+=t[e][5],a+=" ",a+=t[e][6],null!=t[e][7]&&(a+=" ",a+=t[e][7])))));return a+" "}(this.value)},move:function(t,e){var i=this.bbox();return i.x,i.y,this},at:function(t){if(!this.destination)return this;for(var e=this.value,i=this.destination.value,s=[],r=new a.PathArray,o=0,n=e.length;o<n;o++){s[o]=[e[o][0]];for(var l=1,h=e[o].length;l<h;l++)s[o][l]=e[o][l]+(i[o][l]-e[o][l])*t;"A"===s[o][0]&&(s[o][4]=+(0!=s[o][4]),s[o][5]=+(0!=s[o][5]));}return r.value=s,r},parse:function(t){if(t instanceof a.PathArray)return t.valueOf();var e,i={M:2,L:2,H:1,V:1,C:6,S:4,Q:4,T:2,A:7,Z:0};t="string"==typeof t?t.replace(a.regex.numbersWithDots,h).replace(a.regex.pathLetters," $& ").replace(a.regex.hyphen,"$1 -").trim().split(a.regex.delimiter):t.reduce((function(t,e){return [].concat.call(t,e)}),[]);var r=[],o=new a.Point,n=new a.Point,l=0,c=t.length;do{a.regex.isPathLetter.test(t[l])?(e=t[l],++l):"M"==e?e="L":"m"==e&&(e="l"),r.push(s[e].call(null,t.slice(l,l+=i[e.toUpperCase()]).map(parseFloat),o,n));}while(c>l);return r},bbox:function(){return a.parser.draw||a.prepare(),a.parser.path.setAttribute("d",this.toString()),a.parser.path.getBBox()}}),a.Number=a.invent({create:function(t,e){this.value=0,this.unit=e||"","number"==typeof t?this.value=isNaN(t)?0:isFinite(t)?t:t<0?-34e37:34e37:"string"==typeof t?(e=t.match(a.regex.numberAndUnit))&&(this.value=parseFloat(e[1]),"%"==e[5]?this.value/=100:"s"==e[5]&&(this.value*=1e3),this.unit=e[5]):t instanceof a.Number&&(this.value=t.valueOf(),this.unit=t.unit);},extend:{toString:function(){return ("%"==this.unit?~~(1e8*this.value)/1e6:"s"==this.unit?this.value/1e3:this.value)+this.unit},toJSON:function(){return this.toString()},valueOf:function(){return this.value},plus:function(t){return t=new a.Number(t),new a.Number(this+t,this.unit||t.unit)},minus:function(t){return t=new a.Number(t),new a.Number(this-t,this.unit||t.unit)},times:function(t){return t=new a.Number(t),new a.Number(this*t,this.unit||t.unit)},divide:function(t){return t=new a.Number(t),new a.Number(this/t,this.unit||t.unit)},to:function(t){var e=new a.Number(this);return "string"==typeof t&&(e.unit=t),e},morph:function(t){return this.destination=new a.Number(t),t.relative&&(this.destination.value+=this.value),this},at:function(t){return this.destination?new a.Number(this.destination).minus(this).times(t).plus(this):this}}}),a.Element=a.invent({create:function(t){this._stroke=a.defaults.attrs.stroke,this._event=null,this.dom={},(this.node=t)&&(this.type=t.nodeName,this.node.instance=this,this._stroke=t.getAttribute("stroke")||this._stroke);},extend:{x:function(t){return this.attr("x",t)},y:function(t){return this.attr("y",t)},cx:function(t){return null==t?this.x()+this.width()/2:this.x(t-this.width()/2)},cy:function(t){return null==t?this.y()+this.height()/2:this.y(t-this.height()/2)},move:function(t,e){return this.x(t).y(e)},center:function(t,e){return this.cx(t).cy(e)},width:function(t){return this.attr("width",t)},height:function(t){return this.attr("height",t)},size:function(t,e){var i=u(this,t,e);return this.width(new a.Number(i.width)).height(new a.Number(i.height))},clone:function(t){this.writeDataToDom();var e=x(this.node.cloneNode(!0));return t?t.add(e):this.after(e),e},remove:function(){return this.parent()&&this.parent().removeElement(this),this},replace:function(t){return this.after(t).remove(),t},addTo:function(t){return t.put(this)},putIn:function(t){return t.add(this)},id:function(t){return this.attr("id",t)},show:function(){return this.style("display","")},hide:function(){return this.style("display","none")},visible:function(){return "none"!=this.style("display")},toString:function(){return this.attr("id")},classes:function(){var t=this.attr("class");return null==t?[]:t.trim().split(a.regex.delimiter)},hasClass:function(t){return -1!=this.classes().indexOf(t)},addClass:function(t){if(!this.hasClass(t)){var e=this.classes();e.push(t),this.attr("class",e.join(" "));}return this},removeClass:function(t){return this.hasClass(t)&&this.attr("class",this.classes().filter((function(e){return e!=t})).join(" ")),this},toggleClass:function(t){return this.hasClass(t)?this.removeClass(t):this.addClass(t)},reference:function(t){return a.get(this.attr(t))},parent:function(e){var i=this;if(!i.node.parentNode)return null;if(i=a.adopt(i.node.parentNode),!e)return i;for(;i&&i.node instanceof t.SVGElement;){if("string"==typeof e?i.matches(e):i instanceof e)return i;if(!i.node.parentNode||"#document"==i.node.parentNode.nodeName)return null;i=a.adopt(i.node.parentNode);}},doc:function(){return this instanceof a.Doc?this:this.parent(a.Doc)},parents:function(t){var e=[],i=this;do{if(!(i=i.parent(t))||!i.node)break;e.push(i);}while(i.parent);return e},matches:function(t){return function(t,e){return (t.matches||t.matchesSelector||t.msMatchesSelector||t.mozMatchesSelector||t.webkitMatchesSelector||t.oMatchesSelector).call(t,e)}(this.node,t)},native:function(){return this.node},svg:function(t){var i=e.createElementNS("http://www.w3.org/2000/svg","svg");if(!(t&&this instanceof a.Parent))return i.appendChild(t=e.createElementNS("http://www.w3.org/2000/svg","svg")),this.writeDataToDom(),t.appendChild(this.node.cloneNode(!0)),i.innerHTML.replace(/^<svg>/,"").replace(/<\/svg>$/,"");i.innerHTML="<svg>"+t.replace(/\n/,"").replace(/<([\w:-]+)([^<]+?)\/>/g,"<$1$2></$1>")+"</svg>";for(var s=0,r=i.firstChild.childNodes.length;s<r;s++)this.node.appendChild(i.firstChild.firstChild);return this},writeDataToDom:function(){return (this.each||this.lines)&&(this.each?this:this.lines()).each((function(){this.writeDataToDom();})),this.node.removeAttribute("svgjs:data"),Object.keys(this.dom).length&&this.node.setAttribute("svgjs:data",JSON.stringify(this.dom)),this},setData:function(t){return this.dom=t,this},is:function(t){return function(t,e){return t instanceof e}(this,t)}}}),a.easing={"-":function(t){return t},"<>":function(t){return -Math.cos(t*Math.PI)/2+.5},">":function(t){return Math.sin(t*Math.PI/2)},"<":function(t){return 1-Math.cos(t*Math.PI/2)}},a.morph=function(t){return function(e,i){return new a.MorphObj(e,i).at(t)}},a.Situation=a.invent({create:function(t){this.init=!1,this.reversed=!1,this.reversing=!1,this.duration=new a.Number(t.duration).valueOf(),this.delay=new a.Number(t.delay).valueOf(),this.start=+new Date+this.delay,this.finish=this.start+this.duration,this.ease=t.ease,this.loop=0,this.loops=!1,this.animations={},this.attrs={},this.styles={},this.transforms=[],this.once={};}}),a.FX=a.invent({create:function(t){this._target=t,this.situations=[],this.active=!1,this.situation=null,this.paused=!1,this.lastPos=0,this.pos=0,this.absPos=0,this._speed=1;},extend:{animate:function(t,e,s){"object"===i(t)&&(e=t.ease,s=t.delay,t=t.duration);var r=new a.Situation({duration:t||1e3,delay:s||0,ease:a.easing[e||"-"]||e});return this.queue(r),this},target:function(t){return t&&t instanceof a.Element?(this._target=t,this):this._target},timeToAbsPos:function(t){return (t-this.situation.start)/(this.situation.duration/this._speed)},absPosToTime:function(t){return this.situation.duration/this._speed*t+this.situation.start},startAnimFrame:function(){this.stopAnimFrame(),this.animationFrame=t.requestAnimationFrame(function(){this.step();}.bind(this));},stopAnimFrame:function(){t.cancelAnimationFrame(this.animationFrame);},start:function(){return !this.active&&this.situation&&(this.active=!0,this.startCurrent()),this},startCurrent:function(){return this.situation.start=+new Date+this.situation.delay/this._speed,this.situation.finish=this.situation.start+this.situation.duration/this._speed,this.initAnimations().step()},queue:function(t){return ("function"==typeof t||t instanceof a.Situation)&&this.situations.push(t),this.situation||(this.situation=this.situations.shift()),this},dequeue:function(){return this.stop(),this.situation=this.situations.shift(),this.situation&&(this.situation instanceof a.Situation?this.start():this.situation.call(this)),this},initAnimations:function(){var t,e=this.situation;if(e.init)return this;for(var i in e.animations){t=this.target()[i](),Array.isArray(t)||(t=[t]),Array.isArray(e.animations[i])||(e.animations[i]=[e.animations[i]]);for(var s=t.length;s--;)e.animations[i][s]instanceof a.Number&&(t[s]=new a.Number(t[s])),e.animations[i][s]=t[s].morph(e.animations[i][s]);}for(var i in e.attrs)e.attrs[i]=new a.MorphObj(this.target().attr(i),e.attrs[i]);for(var i in e.styles)e.styles[i]=new a.MorphObj(this.target().style(i),e.styles[i]);return e.initialTransformation=this.target().matrixify(),e.init=!0,this},clearQueue:function(){return this.situations=[],this},clearCurrent:function(){return this.situation=null,this},stop:function(t,e){var i=this.active;return this.active=!1,e&&this.clearQueue(),t&&this.situation&&(!i&&this.startCurrent(),this.atEnd()),this.stopAnimFrame(),this.clearCurrent()},after:function(t){var e=this.last();return this.target().on("finished.fx",(function i(a){a.detail.situation==e&&(t.call(this,e),this.off("finished.fx",i));})),this._callStart()},during:function(t){var e=this.last(),i=function(i){i.detail.situation==e&&t.call(this,i.detail.pos,a.morph(i.detail.pos),i.detail.eased,e);};return this.target().off("during.fx",i).on("during.fx",i),this.after((function(){this.off("during.fx",i);})),this._callStart()},afterAll:function(t){var e=function e(i){t.call(this),this.off("allfinished.fx",e);};return this.target().off("allfinished.fx",e).on("allfinished.fx",e),this._callStart()},last:function(){return this.situations.length?this.situations[this.situations.length-1]:this.situation},add:function(t,e,i){return this.last()[i||"animations"][t]=e,this._callStart()},step:function(t){var e,i,a;t||(this.absPos=this.timeToAbsPos(+new Date)),!1!==this.situation.loops?(e=Math.max(this.absPos,0),i=Math.floor(e),!0===this.situation.loops||i<this.situation.loops?(this.pos=e-i,a=this.situation.loop,this.situation.loop=i):(this.absPos=this.situation.loops,this.pos=1,a=this.situation.loop-1,this.situation.loop=this.situation.loops),this.situation.reversing&&(this.situation.reversed=this.situation.reversed!=Boolean((this.situation.loop-a)%2))):(this.absPos=Math.min(this.absPos,1),this.pos=this.absPos),this.pos<0&&(this.pos=0),this.situation.reversed&&(this.pos=1-this.pos);var s=this.situation.ease(this.pos);for(var r in this.situation.once)r>this.lastPos&&r<=s&&(this.situation.once[r].call(this.target(),this.pos,s),delete this.situation.once[r]);return this.active&&this.target().fire("during",{pos:this.pos,eased:s,fx:this,situation:this.situation}),this.situation?(this.eachAt(),1==this.pos&&!this.situation.reversed||this.situation.reversed&&0==this.pos?(this.stopAnimFrame(),this.target().fire("finished",{fx:this,situation:this.situation}),this.situations.length||(this.target().fire("allfinished"),this.situations.length||(this.target().off(".fx"),this.active=!1)),this.active?this.dequeue():this.clearCurrent()):!this.paused&&this.active&&this.startAnimFrame(),this.lastPos=s,this):this},eachAt:function(){var t,e=this,i=this.target(),s=this.situation;for(var r in s.animations)t=[].concat(s.animations[r]).map((function(t){return "string"!=typeof t&&t.at?t.at(s.ease(e.pos),e.pos):t})),i[r].apply(i,t);for(var r in s.attrs)t=[r].concat(s.attrs[r]).map((function(t){return "string"!=typeof t&&t.at?t.at(s.ease(e.pos),e.pos):t})),i.attr.apply(i,t);for(var r in s.styles)t=[r].concat(s.styles[r]).map((function(t){return "string"!=typeof t&&t.at?t.at(s.ease(e.pos),e.pos):t})),i.style.apply(i,t);if(s.transforms.length){t=s.initialTransformation,r=0;for(var o=s.transforms.length;r<o;r++){var n=s.transforms[r];n instanceof a.Matrix?t=n.relative?t.multiply((new a.Matrix).morph(n).at(s.ease(this.pos))):t.morph(n).at(s.ease(this.pos)):(n.relative||n.undo(t.extract()),t=t.multiply(n.at(s.ease(this.pos))));}i.matrix(t);}return this},once:function(t,e,i){var a=this.last();return i||(t=a.ease(t)),a.once[t]=e,this},_callStart:function(){return setTimeout(function(){this.start();}.bind(this),0),this}},parent:a.Element,construct:{animate:function(t,e,i){return (this.fx||(this.fx=new a.FX(this))).animate(t,e,i)},delay:function(t){return (this.fx||(this.fx=new a.FX(this))).delay(t)},stop:function(t,e){return this.fx&&this.fx.stop(t,e),this},finish:function(){return this.fx&&this.fx.finish(),this}}}),a.MorphObj=a.invent({create:function(t,e){return a.Color.isColor(e)?new a.Color(t).morph(e):a.regex.delimiter.test(t)?a.regex.pathLetters.test(t)?new a.PathArray(t).morph(e):new a.Array(t).morph(e):a.regex.numberAndUnit.test(e)?new a.Number(t).morph(e):(this.value=t,void(this.destination=e))},extend:{at:function(t,e){return e<1?this.value:this.destination},valueOf:function(){return this.value}}}),a.extend(a.FX,{attr:function(t,e,a){if("object"===i(t))for(var s in t)this.attr(s,t[s]);else this.add(t,e,"attrs");return this},plot:function(t,e,i,a){return 4==arguments.length?this.plot([t,e,i,a]):this.add("plot",new(this.target().morphArray)(t))}}),a.Box=a.invent({create:function(t,e,s,r){if(!("object"!==i(t)||t instanceof a.Element))return a.Box.call(this,null!=t.left?t.left:t.x,null!=t.top?t.top:t.y,t.width,t.height);var o;4==arguments.length&&(this.x=t,this.y=e,this.width=s,this.height=r),null==(o=this).x&&(o.x=0,o.y=0,o.width=0,o.height=0),o.w=o.width,o.h=o.height,o.x2=o.x+o.width,o.y2=o.y+o.height,o.cx=o.x+o.width/2,o.cy=o.y+o.height/2;}}),a.BBox=a.invent({create:function(t){if(a.Box.apply(this,[].slice.call(arguments)),t instanceof a.Element){var i;try{if(!e.documentElement.contains){for(var s=t.node;s.parentNode;)s=s.parentNode;if(s!=e)throw new Error("Element not in the dom")}i=t.node.getBBox();}catch(e){if(t instanceof a.Shape){a.parser.draw||a.prepare();var r=t.clone(a.parser.draw.instance).show();r&&r.node&&"function"==typeof r.node.getBBox&&(i=r.node.getBBox()),r&&"function"==typeof r.remove&&r.remove();}else i={x:t.node.clientLeft,y:t.node.clientTop,width:t.node.clientWidth,height:t.node.clientHeight};}a.Box.call(this,i);}},inherit:a.Box,parent:a.Element,construct:{bbox:function(){return new a.BBox(this)}}}),a.BBox.prototype.constructor=a.BBox,a.Matrix=a.invent({create:function(t){var e=f([1,0,0,1,0,0]);t=null===t?e:t instanceof a.Element?t.matrixify():"string"==typeof t?f(t.split(a.regex.delimiter).map(parseFloat)):6==arguments.length?f([].slice.call(arguments)):Array.isArray(t)?f(t):t&&"object"===i(t)?t:e;for(var s=v.length-1;s>=0;--s)this[v[s]]=null!=t[v[s]]?t[v[s]]:e[v[s]];},extend:{extract:function(){var t=p(this,0,1);p(this,1,0);var e=180/Math.PI*Math.atan2(t.y,t.x)-90;return {x:this.e,y:this.f,transformedX:(this.e*Math.cos(e*Math.PI/180)+this.f*Math.sin(e*Math.PI/180))/Math.sqrt(this.a*this.a+this.b*this.b),transformedY:(this.f*Math.cos(e*Math.PI/180)+this.e*Math.sin(-e*Math.PI/180))/Math.sqrt(this.c*this.c+this.d*this.d),rotation:e,a:this.a,b:this.b,c:this.c,d:this.d,e:this.e,f:this.f,matrix:new a.Matrix(this)}},clone:function(){return new a.Matrix(this)},morph:function(t){return this.destination=new a.Matrix(t),this},multiply:function(t){return new a.Matrix(this.native().multiply(function(t){return t instanceof a.Matrix||(t=new a.Matrix(t)),t}(t).native()))},inverse:function(){return new a.Matrix(this.native().inverse())},translate:function(t,e){return new a.Matrix(this.native().translate(t||0,e||0))},native:function(){for(var t=a.parser.native.createSVGMatrix(),e=v.length-1;e>=0;e--)t[v[e]]=this[v[e]];return t},toString:function(){return "matrix("+b(this.a)+","+b(this.b)+","+b(this.c)+","+b(this.d)+","+b(this.e)+","+b(this.f)+")"}},parent:a.Element,construct:{ctm:function(){return new a.Matrix(this.node.getCTM())},screenCTM:function(){if(this instanceof a.Nested){var t=this.rect(1,1),e=t.node.getScreenCTM();return t.remove(),new a.Matrix(e)}return new a.Matrix(this.node.getScreenCTM())}}}),a.Point=a.invent({create:function(t,e){var a;a=Array.isArray(t)?{x:t[0],y:t[1]}:"object"===i(t)?{x:t.x,y:t.y}:null!=t?{x:t,y:null!=e?e:t}:{x:0,y:0},this.x=a.x,this.y=a.y;},extend:{clone:function(){return new a.Point(this)},morph:function(t,e){return this.destination=new a.Point(t,e),this}}}),a.extend(a.Element,{point:function(t,e){return new a.Point(t,e).transform(this.screenCTM().inverse())}}),a.extend(a.Element,{attr:function(t,e,s){if(null==t){for(t={},s=(e=this.node.attributes).length-1;s>=0;s--)t[e[s].nodeName]=a.regex.isNumber.test(e[s].nodeValue)?parseFloat(e[s].nodeValue):e[s].nodeValue;return t}if("object"===i(t))for(var r in t)this.attr(r,t[r]);else if(null===e)this.node.removeAttribute(t);else {if(null==e)return null==(e=this.node.getAttribute(t))?a.defaults.attrs[t]:a.regex.isNumber.test(e)?parseFloat(e):e;"stroke-width"==t?this.attr("stroke",parseFloat(e)>0?this._stroke:null):"stroke"==t&&(this._stroke=e),"fill"!=t&&"stroke"!=t||(a.regex.isImage.test(e)&&(e=this.doc().defs().image(e,0,0)),e instanceof a.Image&&(e=this.doc().defs().pattern(0,0,(function(){this.add(e);})))),"number"==typeof e?e=new a.Number(e):a.Color.isColor(e)?e=new a.Color(e):Array.isArray(e)&&(e=new a.Array(e)),"leading"==t?this.leading&&this.leading(e):"string"==typeof s?this.node.setAttributeNS(s,t,e.toString()):this.node.setAttribute(t,e.toString()),!this.rebuild||"font-size"!=t&&"x"!=t||this.rebuild(t,e);}return this}}),a.extend(a.Element,{transform:function(t,e){var s;return "object"!==i(t)?(s=new a.Matrix(this).extract(),"string"==typeof t?s[t]:s):(s=new a.Matrix(this),e=!!e||!!t.relative,null!=t.a&&(s=e?s.multiply(new a.Matrix(t)):new a.Matrix(t)),this.attr("transform",s))}}),a.extend(a.Element,{untransform:function(){return this.attr("transform",null)},matrixify:function(){return (this.attr("transform")||"").split(a.regex.transforms).slice(0,-1).map((function(t){var e=t.trim().split("(");return [e[0],e[1].split(a.regex.delimiter).map((function(t){return parseFloat(t)}))]})).reduce((function(t,e){return "matrix"==e[0]?t.multiply(f(e[1])):t[e[0]].apply(t,e[1])}),new a.Matrix)},toParent:function(t){if(this==t)return this;var e=this.screenCTM(),i=t.screenCTM().inverse();return this.addTo(t).untransform().transform(i.multiply(e)),this},toDoc:function(){return this.toParent(this.doc())}}),a.Transformation=a.invent({create:function(t,e){if(arguments.length>1&&"boolean"!=typeof e)return this.constructor.call(this,[].slice.call(arguments));if(Array.isArray(t))for(var a=0,s=this.arguments.length;a<s;++a)this[this.arguments[a]]=t[a];else if(t&&"object"===i(t))for(a=0,s=this.arguments.length;a<s;++a)this[this.arguments[a]]=t[this.arguments[a]];this.inversed=!1,!0===e&&(this.inversed=!0);}}),a.Translate=a.invent({parent:a.Matrix,inherit:a.Transformation,create:function(t,e){this.constructor.apply(this,[].slice.call(arguments));},extend:{arguments:["transformedX","transformedY"],method:"translate"}}),a.extend(a.Element,{style:function(t,e){if(0==arguments.length)return this.node.style.cssText||"";if(arguments.length<2)if("object"===i(t))for(var s in t)this.style(s,t[s]);else {if(!a.regex.isCss.test(t))return this.node.style[c(t)];for(t=t.split(/\s*;\s*/).filter((function(t){return !!t})).map((function(t){return t.split(/\s*:\s*/)}));e=t.pop();)this.style(e[0],e[1]);}else this.node.style[c(t)]=null===e||a.regex.isBlank.test(e)?"":e;return this}}),a.Parent=a.invent({create:function(t){this.constructor.call(this,t);},inherit:a.Element,extend:{children:function(){return a.utils.map(a.utils.filterSVGElements(this.node.childNodes),(function(t){return a.adopt(t)}))},add:function(t,e){return null==e?this.node.appendChild(t.node):t.node!=this.node.childNodes[e]&&this.node.insertBefore(t.node,this.node.childNodes[e]),this},put:function(t,e){return this.add(t,e),t},has:function(t){return this.index(t)>=0},index:function(t){return [].slice.call(this.node.childNodes).indexOf(t.node)},get:function(t){return a.adopt(this.node.childNodes[t])},first:function(){return this.get(0)},last:function(){return this.get(this.node.childNodes.length-1)},each:function(t,e){for(var i=this.children(),s=0,r=i.length;s<r;s++)i[s]instanceof a.Element&&t.apply(i[s],[s,i]),e&&i[s]instanceof a.Container&&i[s].each(t,e);return this},removeElement:function(t){return this.node.removeChild(t.node),this},clear:function(){for(;this.node.hasChildNodes();)this.node.removeChild(this.node.lastChild);return delete this._defs,this},defs:function(){return this.doc().defs()}}}),a.extend(a.Parent,{ungroup:function(t,e){return 0===e||this instanceof a.Defs||this.node==a.parser.draw||(t=t||(this instanceof a.Doc?this:this.parent(a.Parent)),e=e||1/0,this.each((function(){return this instanceof a.Defs?this:this instanceof a.Parent?this.ungroup(t,e-1):this.toParent(t)})),this.node.firstChild||this.remove()),this},flatten:function(t,e){return this.ungroup(t,e)}}),a.Container=a.invent({create:function(t){this.constructor.call(this,t);},inherit:a.Parent}),a.ViewBox=a.invent({parent:a.Container,construct:{}}),["click","dblclick","mousedown","mouseup","mouseover","mouseout","mousemove","touchstart","touchmove","touchleave","touchend","touchcancel"].forEach((function(t){a.Element.prototype[t]=function(e){return a.on(this.node,t,e),this};})),a.listeners=[],a.handlerMap=[],a.listenerId=0,a.on=function(t,e,i,s,r){var o=i.bind(s||t.instance||t),n=(a.handlerMap.indexOf(t)+1||a.handlerMap.push(t))-1,l=e.split(".")[0],h=e.split(".")[1]||"*";a.listeners[n]=a.listeners[n]||{},a.listeners[n][l]=a.listeners[n][l]||{},a.listeners[n][l][h]=a.listeners[n][l][h]||{},i._svgjsListenerId||(i._svgjsListenerId=++a.listenerId),a.listeners[n][l][h][i._svgjsListenerId]=o,t.addEventListener(l,o,r||{passive:!1});},a.off=function(t,e,i){var s=a.handlerMap.indexOf(t),r=e&&e.split(".")[0],o=e&&e.split(".")[1],n="";if(-1!=s)if(i){if("function"==typeof i&&(i=i._svgjsListenerId),!i)return;a.listeners[s][r]&&a.listeners[s][r][o||"*"]&&(t.removeEventListener(r,a.listeners[s][r][o||"*"][i],!1),delete a.listeners[s][r][o||"*"][i]);}else if(o&&r){if(a.listeners[s][r]&&a.listeners[s][r][o]){for(var l in a.listeners[s][r][o])a.off(t,[r,o].join("."),l);delete a.listeners[s][r][o];}}else if(o)for(var h in a.listeners[s])for(var n in a.listeners[s][h])o===n&&a.off(t,[h,o].join("."));else if(r){if(a.listeners[s][r]){for(var n in a.listeners[s][r])a.off(t,[r,n].join("."));delete a.listeners[s][r];}}else {for(var h in a.listeners[s])a.off(t,h);delete a.listeners[s],delete a.handlerMap[s];}},a.extend(a.Element,{on:function(t,e,i,s){return a.on(this.node,t,e,i,s),this},off:function(t,e){return a.off(this.node,t,e),this},fire:function(e,i){return e instanceof t.Event?this.node.dispatchEvent(e):this.node.dispatchEvent(e=new a.CustomEvent(e,{detail:i,cancelable:!0})),this._event=e,this},event:function(){return this._event}}),a.Defs=a.invent({create:"defs",inherit:a.Container}),a.G=a.invent({create:"g",inherit:a.Container,extend:{x:function(t){return null==t?this.transform("x"):this.transform({x:t-this.x()},!0)}},construct:{group:function(){return this.put(new a.G)}}}),a.Doc=a.invent({create:function(t){t&&("svg"==(t="string"==typeof t?e.getElementById(t):t).nodeName?this.constructor.call(this,t):(this.constructor.call(this,a.create("svg")),t.appendChild(this.node),this.size("100%","100%")),this.namespace().defs());},inherit:a.Container,extend:{namespace:function(){return this.attr({xmlns:a.ns,version:"1.1"}).attr("xmlns:xlink",a.xlink,a.xmlns).attr("xmlns:svgjs",a.svgjs,a.xmlns)},defs:function(){var t;return this._defs||((t=this.node.getElementsByTagName("defs")[0])?this._defs=a.adopt(t):this._defs=new a.Defs,this.node.appendChild(this._defs.node)),this._defs},parent:function(){return this.node.parentNode&&"#document"!=this.node.parentNode.nodeName?this.node.parentNode:null},remove:function(){return this.parent()&&this.parent().removeChild(this.node),this},clear:function(){for(;this.node.hasChildNodes();)this.node.removeChild(this.node.lastChild);return delete this._defs,a.parser.draw&&!a.parser.draw.parentNode&&this.node.appendChild(a.parser.draw),this},clone:function(t){this.writeDataToDom();var e=this.node,i=x(e.cloneNode(!0));return t?(t.node||t).appendChild(i.node):e.parentNode.insertBefore(i.node,e.nextSibling),i}}}),a.extend(a.Element,{}),a.Gradient=a.invent({create:function(t){this.constructor.call(this,a.create(t+"Gradient")),this.type=t;},inherit:a.Container,extend:{at:function(t,e,i){return this.put(new a.Stop).update(t,e,i)},update:function(t){return this.clear(),"function"==typeof t&&t.call(this,this),this},fill:function(){return "url(#"+this.id()+")"},toString:function(){return this.fill()},attr:function(t,e,i){return "transform"==t&&(t="gradientTransform"),a.Container.prototype.attr.call(this,t,e,i)}},construct:{gradient:function(t,e){return this.defs().gradient(t,e)}}}),a.extend(a.Gradient,a.FX,{from:function(t,e){return "radial"==(this._target||this).type?this.attr({fx:new a.Number(t),fy:new a.Number(e)}):this.attr({x1:new a.Number(t),y1:new a.Number(e)})},to:function(t,e){return "radial"==(this._target||this).type?this.attr({cx:new a.Number(t),cy:new a.Number(e)}):this.attr({x2:new a.Number(t),y2:new a.Number(e)})}}),a.extend(a.Defs,{gradient:function(t,e){return this.put(new a.Gradient(t)).update(e)}}),a.Stop=a.invent({create:"stop",inherit:a.Element,extend:{update:function(t){return ("number"==typeof t||t instanceof a.Number)&&(t={offset:arguments[0],color:arguments[1],opacity:arguments[2]}),null!=t.opacity&&this.attr("stop-opacity",t.opacity),null!=t.color&&this.attr("stop-color",t.color),null!=t.offset&&this.attr("offset",new a.Number(t.offset)),this}}}),a.Pattern=a.invent({create:"pattern",inherit:a.Container,extend:{fill:function(){return "url(#"+this.id()+")"},update:function(t){return this.clear(),"function"==typeof t&&t.call(this,this),this},toString:function(){return this.fill()},attr:function(t,e,i){return "transform"==t&&(t="patternTransform"),a.Container.prototype.attr.call(this,t,e,i)}},construct:{pattern:function(t,e,i){return this.defs().pattern(t,e,i)}}}),a.extend(a.Defs,{pattern:function(t,e,i){return this.put(new a.Pattern).update(i).attr({x:0,y:0,width:t,height:e,patternUnits:"userSpaceOnUse"})}}),a.Shape=a.invent({create:function(t){this.constructor.call(this,t);},inherit:a.Element}),a.Symbol=a.invent({create:"symbol",inherit:a.Container,construct:{symbol:function(){return this.put(new a.Symbol)}}}),a.Use=a.invent({create:"use",inherit:a.Shape,extend:{element:function(t,e){return this.attr("href",(e||"")+"#"+t,a.xlink)}},construct:{use:function(t,e){return this.put(new a.Use).element(t,e)}}}),a.Rect=a.invent({create:"rect",inherit:a.Shape,construct:{rect:function(t,e){return this.put(new a.Rect).size(t,e)}}}),a.Circle=a.invent({create:"circle",inherit:a.Shape,construct:{circle:function(t){return this.put(new a.Circle).rx(new a.Number(t).divide(2)).move(0,0)}}}),a.extend(a.Circle,a.FX,{rx:function(t){return this.attr("r",t)},ry:function(t){return this.rx(t)}}),a.Ellipse=a.invent({create:"ellipse",inherit:a.Shape,construct:{ellipse:function(t,e){return this.put(new a.Ellipse).size(t,e).move(0,0)}}}),a.extend(a.Ellipse,a.Rect,a.FX,{rx:function(t){return this.attr("rx",t)},ry:function(t){return this.attr("ry",t)}}),a.extend(a.Circle,a.Ellipse,{x:function(t){return null==t?this.cx()-this.rx():this.cx(t+this.rx())},y:function(t){return null==t?this.cy()-this.ry():this.cy(t+this.ry())},cx:function(t){return null==t?this.attr("cx"):this.attr("cx",t)},cy:function(t){return null==t?this.attr("cy"):this.attr("cy",t)},width:function(t){return null==t?2*this.rx():this.rx(new a.Number(t).divide(2))},height:function(t){return null==t?2*this.ry():this.ry(new a.Number(t).divide(2))},size:function(t,e){var i=u(this,t,e);return this.rx(new a.Number(i.width).divide(2)).ry(new a.Number(i.height).divide(2))}}),a.Line=a.invent({create:"line",inherit:a.Shape,extend:{array:function(){return new a.PointArray([[this.attr("x1"),this.attr("y1")],[this.attr("x2"),this.attr("y2")]])},plot:function(t,e,i,s){return null==t?this.array():(t=void 0!==e?{x1:t,y1:e,x2:i,y2:s}:new a.PointArray(t).toLine(),this.attr(t))},move:function(t,e){return this.attr(this.array().move(t,e).toLine())},size:function(t,e){var i=u(this,t,e);return this.attr(this.array().size(i.width,i.height).toLine())}},construct:{line:function(t,e,i,s){return a.Line.prototype.plot.apply(this.put(new a.Line),null!=t?[t,e,i,s]:[0,0,0,0])}}}),a.Polyline=a.invent({create:"polyline",inherit:a.Shape,construct:{polyline:function(t){return this.put(new a.Polyline).plot(t||new a.PointArray)}}}),a.Polygon=a.invent({create:"polygon",inherit:a.Shape,construct:{polygon:function(t){return this.put(new a.Polygon).plot(t||new a.PointArray)}}}),a.extend(a.Polyline,a.Polygon,{array:function(){return this._array||(this._array=new a.PointArray(this.attr("points")))},plot:function(t){return null==t?this.array():this.clear().attr("points","string"==typeof t?t:this._array=new a.PointArray(t))},clear:function(){return delete this._array,this},move:function(t,e){return this.attr("points",this.array().move(t,e))},size:function(t,e){var i=u(this,t,e);return this.attr("points",this.array().size(i.width,i.height))}}),a.extend(a.Line,a.Polyline,a.Polygon,{morphArray:a.PointArray,x:function(t){return null==t?this.bbox().x:this.move(t,this.bbox().y)},y:function(t){return null==t?this.bbox().y:this.move(this.bbox().x,t)},width:function(t){var e=this.bbox();return null==t?e.width:this.size(t,e.height)},height:function(t){var e=this.bbox();return null==t?e.height:this.size(e.width,t)}}),a.Path=a.invent({create:"path",inherit:a.Shape,extend:{morphArray:a.PathArray,array:function(){return this._array||(this._array=new a.PathArray(this.attr("d")))},plot:function(t){return null==t?this.array():this.clear().attr("d","string"==typeof t?t:this._array=new a.PathArray(t))},clear:function(){return delete this._array,this}},construct:{path:function(t){return this.put(new a.Path).plot(t||new a.PathArray)}}}),a.Image=a.invent({create:"image",inherit:a.Shape,extend:{load:function(e){if(!e)return this;var i=this,s=new t.Image;return a.on(s,"load",(function(){a.off(s);var t=i.parent(a.Pattern);null!==t&&(0==i.width()&&0==i.height()&&i.size(s.width,s.height),t&&0==t.width()&&0==t.height()&&t.size(i.width(),i.height()),"function"==typeof i._loaded&&i._loaded.call(i,{width:s.width,height:s.height,ratio:s.width/s.height,url:e}));})),a.on(s,"error",(function(t){a.off(s),"function"==typeof i._error&&i._error.call(i,t);})),this.attr("href",s.src=this.src=e,a.xlink)},loaded:function(t){return this._loaded=t,this},error:function(t){return this._error=t,this}},construct:{image:function(t,e,i){return this.put(new a.Image).load(t).size(e||0,i||e||0)}}}),a.Text=a.invent({create:function(){this.constructor.call(this,a.create("text")),this.dom.leading=new a.Number(1.3),this._rebuild=!0,this._build=!1,this.attr("font-family",a.defaults.attrs["font-family"]);},inherit:a.Shape,extend:{x:function(t){return null==t?this.attr("x"):this.attr("x",t)},text:function(t){if(void 0===t){t="";for(var e=this.node.childNodes,i=0,s=e.length;i<s;++i)0!=i&&3!=e[i].nodeType&&1==a.adopt(e[i]).dom.newLined&&(t+="\n"),t+=e[i].textContent;return t}if(this.clear().build(!0),"function"==typeof t)t.call(this,this);else {i=0;for(var r=(t=t.split("\n")).length;i<r;i++)this.tspan(t[i]).newLine();}return this.build(!1).rebuild()},size:function(t){return this.attr("font-size",t).rebuild()},leading:function(t){return null==t?this.dom.leading:(this.dom.leading=new a.Number(t),this.rebuild())},lines:function(){var t=(this.textPath&&this.textPath()||this).node,e=a.utils.map(a.utils.filterSVGElements(t.childNodes),(function(t){return a.adopt(t)}));return new a.Set(e)},rebuild:function(t){if("boolean"==typeof t&&(this._rebuild=t),this._rebuild){var e=this,i=0,s=this.dom.leading*new a.Number(this.attr("font-size"));this.lines().each((function(){this.dom.newLined&&(e.textPath()||this.attr("x",e.attr("x")),"\n"==this.text()?i+=s:(this.attr("dy",s+i),i=0));})),this.fire("rebuild");}return this},build:function(t){return this._build=!!t,this},setData:function(t){return this.dom=t,this.dom.leading=new a.Number(t.leading||1.3),this}},construct:{text:function(t){return this.put(new a.Text).text(t)},plain:function(t){return this.put(new a.Text).plain(t)}}}),a.Tspan=a.invent({create:"tspan",inherit:a.Shape,extend:{text:function(t){return null==t?this.node.textContent+(this.dom.newLined?"\n":""):("function"==typeof t?t.call(this,this):this.plain(t),this)},dx:function(t){return this.attr("dx",t)},dy:function(t){return this.attr("dy",t)},newLine:function(){var t=this.parent(a.Text);return this.dom.newLined=!0,this.dy(t.dom.leading*t.attr("font-size")).attr("x",t.x())}}}),a.extend(a.Text,a.Tspan,{plain:function(t){return !1===this._build&&this.clear(),this.node.appendChild(e.createTextNode(t)),this},tspan:function(t){var e=(this.textPath&&this.textPath()||this).node,i=new a.Tspan;return !1===this._build&&this.clear(),e.appendChild(i.node),i.text(t)},clear:function(){for(var t=(this.textPath&&this.textPath()||this).node;t.hasChildNodes();)t.removeChild(t.lastChild);return this},length:function(){return this.node.getComputedTextLength()}}),a.TextPath=a.invent({create:"textPath",inherit:a.Parent,parent:a.Text,construct:{morphArray:a.PathArray,array:function(){var t=this.track();return t?t.array():null},plot:function(t){var e=this.track(),i=null;return e&&(i=e.plot(t)),null==t?i:this},track:function(){var t=this.textPath();if(t)return t.reference("href")},textPath:function(){if(this.node.firstChild&&"textPath"==this.node.firstChild.nodeName)return a.adopt(this.node.firstChild)}}}),a.Nested=a.invent({create:function(){this.constructor.call(this,a.create("svg")),this.style("overflow","visible");},inherit:a.Container,construct:{nested:function(){return this.put(new a.Nested)}}});var l={stroke:["color","width","opacity","linecap","linejoin","miterlimit","dasharray","dashoffset"],fill:["color","opacity","rule"],prefix:function(t,e){return "color"==e?t:t+"-"+e}};function h(t,e,i,s){return i+s.replace(a.regex.dots," .")}function c(t){return t.toLowerCase().replace(/-(.)/g,(function(t,e){return e.toUpperCase()}))}function d(t){return t.charAt(0).toUpperCase()+t.slice(1)}function g(t){var e=t.toString(16);return 1==e.length?"0"+e:e}function u(t,e,i){if(null==e||null==i){var a=t.bbox();null==e?e=a.width/a.height*i:null==i&&(i=a.height/a.width*e);}return {width:e,height:i}}function p(t,e,i){return {x:e*t.a+i*t.c+0,y:e*t.b+i*t.d+0}}function f(t){return {a:t[0],b:t[1],c:t[2],d:t[3],e:t[4],f:t[5]}}function x(e){for(var i=e.childNodes.length-1;i>=0;i--)e.childNodes[i]instanceof t.SVGElement&&x(e.childNodes[i]);return a.adopt(e).id(a.eid(e.nodeName))}function b(t){return Math.abs(t)>1e-37?t:0}["fill","stroke"].forEach((function(t){var e={};e[t]=function(e){if(void 0===e)return this;if("string"==typeof e||a.Color.isRgb(e)||e&&"function"==typeof e.fill)this.attr(t,e);else for(var i=l[t].length-1;i>=0;i--)null!=e[l[t][i]]&&this.attr(l.prefix(t,l[t][i]),e[l[t][i]]);return this},a.extend(a.Element,a.FX,e);})),a.extend(a.Element,a.FX,{translate:function(t,e){return this.transform({x:t,y:e})},matrix:function(t){return this.attr("transform",new a.Matrix(6==arguments.length?[].slice.call(arguments):t))},opacity:function(t){return this.attr("opacity",t)},dx:function(t){return this.x(new a.Number(t).plus(this instanceof a.FX?0:this.x()),!0)},dy:function(t){return this.y(new a.Number(t).plus(this instanceof a.FX?0:this.y()),!0)}}),a.extend(a.Path,{length:function(){return this.node.getTotalLength()},pointAt:function(t){return this.node.getPointAtLength(t)}}),a.Set=a.invent({create:function(t){Array.isArray(t)?this.members=t:this.clear();},extend:{add:function(){for(var t=[].slice.call(arguments),e=0,i=t.length;e<i;e++)this.members.push(t[e]);return this},remove:function(t){var e=this.index(t);return e>-1&&this.members.splice(e,1),this},each:function(t){for(var e=0,i=this.members.length;e<i;e++)t.apply(this.members[e],[e,this.members]);return this},clear:function(){return this.members=[],this},length:function(){return this.members.length},has:function(t){return this.index(t)>=0},index:function(t){return this.members.indexOf(t)},get:function(t){return this.members[t]},first:function(){return this.get(0)},last:function(){return this.get(this.members.length-1)},valueOf:function(){return this.members}},construct:{set:function(t){return new a.Set(t)}}}),a.FX.Set=a.invent({create:function(t){this.set=t;}}),a.Set.inherit=function(){var t=[];for(var e in a.Shape.prototype)"function"==typeof a.Shape.prototype[e]&&"function"!=typeof a.Set.prototype[e]&&t.push(e);for(var e in t.forEach((function(t){a.Set.prototype[t]=function(){for(var e=0,i=this.members.length;e<i;e++)this.members[e]&&"function"==typeof this.members[e][t]&&this.members[e][t].apply(this.members[e],arguments);return "animate"==t?this.fx||(this.fx=new a.FX.Set(this)):this};})),t=[],a.FX.prototype)"function"==typeof a.FX.prototype[e]&&"function"!=typeof a.FX.Set.prototype[e]&&t.push(e);t.forEach((function(t){a.FX.Set.prototype[t]=function(){for(var e=0,i=this.set.members.length;e<i;e++)this.set.members[e].fx[t].apply(this.set.members[e].fx,arguments);return this};}));},a.extend(a.Element,{}),a.extend(a.Element,{remember:function(t,e){if("object"===i(arguments[0]))for(var a in t)this.remember(a,t[a]);else {if(1==arguments.length)return this.memory()[t];this.memory()[t]=e;}return this},forget:function(){if(0==arguments.length)this._memory={};else for(var t=arguments.length-1;t>=0;t--)delete this.memory()[arguments[t]];return this},memory:function(){return this._memory||(this._memory={})}}),a.get=function(t){var i=e.getElementById(function(t){var e=(t||"").toString().match(a.regex.reference);if(e)return e[1]}(t)||t);return a.adopt(i)},a.select=function(t,i){return new a.Set(a.utils.map((i||e).querySelectorAll(t),(function(t){return a.adopt(t)})))},a.extend(a.Parent,{select:function(t){return a.select(t,this.node)}});var v="abcdef".split("");if("function"!=typeof t.CustomEvent){var m=function(t,i){i=i||{bubbles:!1,cancelable:!1,detail:void 0};var a=e.createEvent("CustomEvent");return a.initCustomEvent(t,i.bubbles,i.cancelable,i.detail),a};m.prototype=t.Event.prototype,a.CustomEvent=m;}else a.CustomEvent=t.CustomEvent;return a},"object"===(i(exports))&&"undefined"!='object'?module.exports=Rt.document?Ht(Rt,Rt.document):function(t){return Ht(t,t.document)}:Rt.SVG=Ht(Rt,Rt.document),
/*! svg.filter.js - v2.0.2 - 2016-02-24
* https://github.com/wout/svg.filter.js
* Copyright (c) 2016 Wout Fierens; Licensed MIT */
function(){SVG.Filter=SVG.invent({create:"filter",inherit:SVG.Parent,extend:{source:"SourceGraphic",sourceAlpha:"SourceAlpha",background:"BackgroundImage",backgroundAlpha:"BackgroundAlpha",fill:"FillPaint",stroke:"StrokePaint",autoSetIn:!0,put:function(t,e){return this.add(t,e),!t.attr("in")&&this.autoSetIn&&t.attr("in",this.source),t.attr("result")||t.attr("result",t),t},blend:function(t,e,i){return this.put(new SVG.BlendEffect(t,e,i))},colorMatrix:function(t,e){return this.put(new SVG.ColorMatrixEffect(t,e))},convolveMatrix:function(t){return this.put(new SVG.ConvolveMatrixEffect(t))},componentTransfer:function(t){return this.put(new SVG.ComponentTransferEffect(t))},composite:function(t,e,i){return this.put(new SVG.CompositeEffect(t,e,i))},flood:function(t,e){return this.put(new SVG.FloodEffect(t,e))},offset:function(t,e){return this.put(new SVG.OffsetEffect(t,e))},image:function(t){return this.put(new SVG.ImageEffect(t))},merge:function(){var t=[void 0];for(var e in arguments)t.push(arguments[e]);return this.put(new(SVG.MergeEffect.bind.apply(SVG.MergeEffect,t)))},gaussianBlur:function(t,e){return this.put(new SVG.GaussianBlurEffect(t,e))},morphology:function(t,e){return this.put(new SVG.MorphologyEffect(t,e))},diffuseLighting:function(t,e,i){return this.put(new SVG.DiffuseLightingEffect(t,e,i))},displacementMap:function(t,e,i,a,s){return this.put(new SVG.DisplacementMapEffect(t,e,i,a,s))},specularLighting:function(t,e,i,a){return this.put(new SVG.SpecularLightingEffect(t,e,i,a))},tile:function(){return this.put(new SVG.TileEffect)},turbulence:function(t,e,i,a,s){return this.put(new SVG.TurbulenceEffect(t,e,i,a,s))},toString:function(){return "url(#"+this.attr("id")+")"}}}),SVG.extend(SVG.Defs,{filter:function(t){var e=this.put(new SVG.Filter);return "function"==typeof t&&t.call(e,e),e}}),SVG.extend(SVG.Container,{filter:function(t){return this.defs().filter(t)}}),SVG.extend(SVG.Element,SVG.G,SVG.Nested,{filter:function(t){return this.filterer=t instanceof SVG.Element?t:this.doc().filter(t),this.doc()&&this.filterer.doc()!==this.doc()&&this.doc().defs().add(this.filterer),this.attr("filter",this.filterer),this.filterer},unfilter:function(t){return this.filterer&&!0===t&&this.filterer.remove(),delete this.filterer,this.attr("filter",null)}}),SVG.Effect=SVG.invent({create:function(){this.constructor.call(this);},inherit:SVG.Element,extend:{in:function(t){return null==t?this.parent()&&this.parent().select('[result="'+this.attr("in")+'"]').get(0)||this.attr("in"):this.attr("in",t)},result:function(t){return null==t?this.attr("result"):this.attr("result",t)},toString:function(){return this.result()}}}),SVG.ParentEffect=SVG.invent({create:function(){this.constructor.call(this);},inherit:SVG.Parent,extend:{in:function(t){return null==t?this.parent()&&this.parent().select('[result="'+this.attr("in")+'"]').get(0)||this.attr("in"):this.attr("in",t)},result:function(t){return null==t?this.attr("result"):this.attr("result",t)},toString:function(){return this.result()}}});var t={blend:function(t,e){return this.parent()&&this.parent().blend(this,t,e)},colorMatrix:function(t,e){return this.parent()&&this.parent().colorMatrix(t,e).in(this)},convolveMatrix:function(t){return this.parent()&&this.parent().convolveMatrix(t).in(this)},componentTransfer:function(t){return this.parent()&&this.parent().componentTransfer(t).in(this)},composite:function(t,e){return this.parent()&&this.parent().composite(this,t,e)},flood:function(t,e){return this.parent()&&this.parent().flood(t,e)},offset:function(t,e){return this.parent()&&this.parent().offset(t,e).in(this)},image:function(t){return this.parent()&&this.parent().image(t)},merge:function(){return this.parent()&&this.parent().merge.apply(this.parent(),[this].concat(arguments))},gaussianBlur:function(t,e){return this.parent()&&this.parent().gaussianBlur(t,e).in(this)},morphology:function(t,e){return this.parent()&&this.parent().morphology(t,e).in(this)},diffuseLighting:function(t,e,i){return this.parent()&&this.parent().diffuseLighting(t,e,i).in(this)},displacementMap:function(t,e,i,a){return this.parent()&&this.parent().displacementMap(this,t,e,i,a)},specularLighting:function(t,e,i,a){return this.parent()&&this.parent().specularLighting(t,e,i,a).in(this)},tile:function(){return this.parent()&&this.parent().tile().in(this)},turbulence:function(t,e,i,a,s){return this.parent()&&this.parent().turbulence(t,e,i,a,s).in(this)}};SVG.extend(SVG.Effect,t),SVG.extend(SVG.ParentEffect,t),SVG.ChildEffect=SVG.invent({create:function(){this.constructor.call(this);},inherit:SVG.Element,extend:{in:function(t){this.attr("in",t);}}});var e={blend:function(t,e,i){this.attr({in:t,in2:e,mode:i||"normal"});},colorMatrix:function(t,e){"matrix"==t&&(e=s(e)),this.attr({type:t,values:void 0===e?null:e});},convolveMatrix:function(t){t=s(t),this.attr({order:Math.sqrt(t.split(" ").length),kernelMatrix:t});},composite:function(t,e,i){this.attr({in:t,in2:e,operator:i});},flood:function(t,e){this.attr("flood-color",t),null!=e&&this.attr("flood-opacity",e);},offset:function(t,e){this.attr({dx:t,dy:e});},image:function(t){this.attr("href",t,SVG.xlink);},displacementMap:function(t,e,i,a,s){this.attr({in:t,in2:e,scale:i,xChannelSelector:a,yChannelSelector:s});},gaussianBlur:function(t,e){null!=t||null!=e?this.attr("stdDeviation",function(t){if(!Array.isArray(t))return t;for(var e=0,i=t.length,a=[];e<i;e++)a.push(t[e]);return a.join(" ")}(Array.prototype.slice.call(arguments))):this.attr("stdDeviation","0 0");},morphology:function(t,e){this.attr({operator:t,radius:e});},tile:function(){},turbulence:function(t,e,i,a,s){this.attr({numOctaves:e,seed:i,stitchTiles:a,baseFrequency:t,type:s});}},i={merge:function(){var t;if(arguments[0]instanceof SVG.Set){var e=this;arguments[0].each((function(t){this instanceof SVG.MergeNode?e.put(this):(this instanceof SVG.Effect||this instanceof SVG.ParentEffect)&&e.put(new SVG.MergeNode(this));}));}else {t=Array.isArray(arguments[0])?arguments[0]:arguments;for(var i=0;i<t.length;i++)t[i]instanceof SVG.MergeNode?this.put(t[i]):this.put(new SVG.MergeNode(t[i]));}},componentTransfer:function(t){if(this.rgb=new SVG.Set,["r","g","b","a"].forEach(function(t){this[t]=new(SVG["Func"+t.toUpperCase()])("identity"),this.rgb.add(this[t]),this.node.appendChild(this[t].node);}.bind(this)),t)for(var e in t.rgb&&(["r","g","b"].forEach(function(e){this[e].attr(t.rgb);}.bind(this)),delete t.rgb),t)this[e].attr(t[e]);},diffuseLighting:function(t,e,i){this.attr({surfaceScale:t,diffuseConstant:e,kernelUnitLength:i});},specularLighting:function(t,e,i,a){this.attr({surfaceScale:t,diffuseConstant:e,specularExponent:i,kernelUnitLength:a});}},a={distantLight:function(t,e){this.attr({azimuth:t,elevation:e});},pointLight:function(t,e,i){this.attr({x:t,y:e,z:i});},spotLight:function(t,e,i,a,s,r){this.attr({x:t,y:e,z:i,pointsAtX:a,pointsAtY:s,pointsAtZ:r});},mergeNode:function(t){this.attr("in",t);}};function s(t){return Array.isArray(t)&&(t=new SVG.Array(t)),t.toString().replace(/^\s+/,"").replace(/\s+$/,"").replace(/\s+/g," ")}function r(){var t=function(){};for(var e in "function"==typeof arguments[arguments.length-1]&&(t=arguments[arguments.length-1],Array.prototype.splice.call(arguments,arguments.length-1,1)),arguments)for(var i in arguments[e])t(arguments[e][i],i,arguments[e]);}["r","g","b","a"].forEach((function(t){a["Func"+t.toUpperCase()]=function(t){switch(this.attr("type",t),t){case"table":this.attr("tableValues",arguments[1]);break;case"linear":this.attr("slope",arguments[1]),this.attr("intercept",arguments[2]);break;case"gamma":this.attr("amplitude",arguments[1]),this.attr("exponent",arguments[2]),this.attr("offset",arguments[2]);}};})),r(e,(function(t,e){var i=e.charAt(0).toUpperCase()+e.slice(1);SVG[i+"Effect"]=SVG.invent({create:function(){this.constructor.call(this,SVG.create("fe"+i)),t.apply(this,arguments),this.result(this.attr("id")+"Out");},inherit:SVG.Effect,extend:{}});})),r(i,(function(t,e){var i=e.charAt(0).toUpperCase()+e.slice(1);SVG[i+"Effect"]=SVG.invent({create:function(){this.constructor.call(this,SVG.create("fe"+i)),t.apply(this,arguments),this.result(this.attr("id")+"Out");},inherit:SVG.ParentEffect,extend:{}});})),r(a,(function(t,e){var i=e.charAt(0).toUpperCase()+e.slice(1);SVG[i]=SVG.invent({create:function(){this.constructor.call(this,SVG.create("fe"+i)),t.apply(this,arguments);},inherit:SVG.ChildEffect,extend:{}});})),SVG.extend(SVG.MergeEffect,{in:function(t){return t instanceof SVG.MergeNode?this.add(t,0):this.add(new SVG.MergeNode(t),0),this}}),SVG.extend(SVG.CompositeEffect,SVG.BlendEffect,SVG.DisplacementMapEffect,{in2:function(t){return null==t?this.parent()&&this.parent().select('[result="'+this.attr("in2")+'"]').get(0)||this.attr("in2"):this.attr("in2",t)}}),SVG.filter={sepiatone:[.343,.669,.119,0,0,.249,.626,.13,0,0,.172,.334,.111,0,0,0,0,0,1,0]};}.call(void 0),function(){function t(t,s,r,o,n,l,h){for(var c=t.slice(s,r||h),d=o.slice(n,l||h),g=0,u={pos:[0,0],start:[0,0]},p={pos:[0,0],start:[0,0]};;){if(c[g]=e.call(u,c[g]),d[g]=e.call(p,d[g]),c[g][0]!=d[g][0]||"M"==c[g][0]||"A"==c[g][0]&&(c[g][4]!=d[g][4]||c[g][5]!=d[g][5])?(Array.prototype.splice.apply(c,[g,1].concat(a.call(u,c[g]))),Array.prototype.splice.apply(d,[g,1].concat(a.call(p,d[g])))):(c[g]=i.call(u,c[g]),d[g]=i.call(p,d[g])),++g==c.length&&g==d.length)break;g==c.length&&c.push(["C",u.pos[0],u.pos[1],u.pos[0],u.pos[1],u.pos[0],u.pos[1]]),g==d.length&&d.push(["C",p.pos[0],p.pos[1],p.pos[0],p.pos[1],p.pos[0],p.pos[1]]);}return {start:c,dest:d}}function e(t){switch(t[0]){case"z":case"Z":t[0]="L",t[1]=this.start[0],t[2]=this.start[1];break;case"H":t[0]="L",t[2]=this.pos[1];break;case"V":t[0]="L",t[2]=t[1],t[1]=this.pos[0];break;case"T":t[0]="Q",t[3]=t[1],t[4]=t[2],t[1]=this.reflection[1],t[2]=this.reflection[0];break;case"S":t[0]="C",t[6]=t[4],t[5]=t[3],t[4]=t[2],t[3]=t[1],t[2]=this.reflection[1],t[1]=this.reflection[0];}return t}function i(t){var e=t.length;return this.pos=[t[e-2],t[e-1]],-1!="SCQT".indexOf(t[0])&&(this.reflection=[2*this.pos[0]-t[e-4],2*this.pos[1]-t[e-3]]),t}function a(t){var e=[t];switch(t[0]){case"M":return this.pos=this.start=[t[1],t[2]],e;case"L":t[5]=t[3]=t[1],t[6]=t[4]=t[2],t[1]=this.pos[0],t[2]=this.pos[1];break;case"Q":t[6]=t[4],t[5]=t[3],t[4]=1*t[4]/3+2*t[2]/3,t[3]=1*t[3]/3+2*t[1]/3,t[2]=1*this.pos[1]/3+2*t[2]/3,t[1]=1*this.pos[0]/3+2*t[1]/3;break;case"A":e=function(t,e){var i,a,s,r,o,n,l,h,c,d,g,u,p,f,x,b,v,m,y,w,k,A,S,C,L,P,M=Math.abs(e[1]),I=Math.abs(e[2]),T=e[3]%360,z=e[4],X=e[5],E=e[6],Y=e[7],F=new SVG.Point(t),R=new SVG.Point(E,Y),H=[];if(0===M||0===I||F.x===R.x&&F.y===R.y)return [["C",F.x,F.y,R.x,R.y,R.x,R.y]];i=new SVG.Point((F.x-R.x)/2,(F.y-R.y)/2).transform((new SVG.Matrix).rotate(T)),(a=i.x*i.x/(M*M)+i.y*i.y/(I*I))>1&&(M*=a=Math.sqrt(a),I*=a);s=(new SVG.Matrix).rotate(T).scale(1/M,1/I).rotate(-T),F=F.transform(s),R=R.transform(s),r=[R.x-F.x,R.y-F.y],n=r[0]*r[0]+r[1]*r[1],o=Math.sqrt(n),r[0]/=o,r[1]/=o,l=n<4?Math.sqrt(1-n/4):0,z===X&&(l*=-1);h=new SVG.Point((R.x+F.x)/2+l*-r[1],(R.y+F.y)/2+l*r[0]),c=new SVG.Point(F.x-h.x,F.y-h.y),d=new SVG.Point(R.x-h.x,R.y-h.y),g=Math.acos(c.x/Math.sqrt(c.x*c.x+c.y*c.y)),c.y<0&&(g*=-1);u=Math.acos(d.x/Math.sqrt(d.x*d.x+d.y*d.y)),d.y<0&&(u*=-1);X&&g>u&&(u+=2*Math.PI);!X&&g<u&&(u-=2*Math.PI);for(f=Math.ceil(2*Math.abs(g-u)/Math.PI),b=[],v=g,p=(u-g)/f,x=4*Math.tan(p/4)/3,k=0;k<=f;k++)y=Math.cos(v),m=Math.sin(v),w=new SVG.Point(h.x+y,h.y+m),b[k]=[new SVG.Point(w.x+x*m,w.y-x*y),w,new SVG.Point(w.x-x*m,w.y+x*y)],v+=p;for(b[0][0]=b[0][1].clone(),b[b.length-1][2]=b[b.length-1][1].clone(),s=(new SVG.Matrix).rotate(T).scale(M,I).rotate(-T),k=0,A=b.length;k<A;k++)b[k][0]=b[k][0].transform(s),b[k][1]=b[k][1].transform(s),b[k][2]=b[k][2].transform(s);for(k=1,A=b.length;k<A;k++)S=(w=b[k-1][2]).x,C=w.y,L=(w=b[k][0]).x,P=w.y,E=(w=b[k][1]).x,Y=w.y,H.push(["C",S,C,L,P,E,Y]);return H}(this.pos,t),t=e[0];}return t[0]="C",this.pos=[t[5],t[6]],this.reflection=[2*t[5]-t[3],2*t[6]-t[4]],e}function s(t,e){if(!1===e)return !1;for(var i=e,a=t.length;i<a;++i)if("M"==t[i][0])return i;return !1}SVG.extend(SVG.PathArray,{morph:function(e){for(var i=this.value,a=this.parse(e),r=0,o=0,n=!1,l=!1;!1!==r||!1!==o;){var h;n=s(i,!1!==r&&r+1),l=s(a,!1!==o&&o+1),!1===r&&(r=0==(h=new SVG.PathArray(c.start).bbox()).height||0==h.width?i.push(i[0])-1:i.push(["M",h.x+h.width/2,h.y+h.height/2])-1),!1===o&&(o=0==(h=new SVG.PathArray(c.dest).bbox()).height||0==h.width?a.push(a[0])-1:a.push(["M",h.x+h.width/2,h.y+h.height/2])-1);var c=t(i,r,n,a,o,l);i=i.slice(0,r).concat(c.start,!1===n?[]:i.slice(n)),a=a.slice(0,o).concat(c.dest,!1===l?[]:a.slice(l)),r=!1!==n&&r+c.start.length,o=!1!==l&&o+c.dest.length;}return this.value=i,this.destination=new SVG.PathArray,this.destination.value=a,this}});}(),
/*! svg.draggable.js - v2.2.2 - 2019-01-08
* https://github.com/svgdotjs/svg.draggable.js
* Copyright (c) 2019 Wout Fierens; Licensed MIT */
function(){function t(t){t.remember("_draggable",this),this.el=t;}t.prototype.init=function(t,e){var i=this;this.constraint=t,this.value=e,this.el.on("mousedown.drag",(function(t){i.start(t);})),this.el.on("touchstart.drag",(function(t){i.start(t);}));},t.prototype.transformPoint=function(t,e){var i=(t=t||window.event).changedTouches&&t.changedTouches[0]||t;return this.p.x=i.clientX-(e||0),this.p.y=i.clientY,this.p.matrixTransform(this.m)},t.prototype.getBBox=function(){var t=this.el.bbox();return this.el instanceof SVG.Nested&&(t=this.el.rbox()),(this.el instanceof SVG.G||this.el instanceof SVG.Use||this.el instanceof SVG.Nested)&&(t.x=this.el.x(),t.y=this.el.y()),t},t.prototype.start=function(t){if("click"!=t.type&&"mousedown"!=t.type&&"mousemove"!=t.type||1==(t.which||t.buttons)){var e=this;if(this.el.fire("beforedrag",{event:t,handler:this}),!this.el.event().defaultPrevented){t.preventDefault(),t.stopPropagation(),this.parent=this.parent||this.el.parent(SVG.Nested)||this.el.parent(SVG.Doc),this.p=this.parent.node.createSVGPoint(),this.m=this.el.node.getScreenCTM().inverse();var i,a=this.getBBox();if(this.el instanceof SVG.Text)switch(i=this.el.node.getComputedTextLength(),this.el.attr("text-anchor")){case"middle":i/=2;break;case"start":i=0;}this.startPoints={point:this.transformPoint(t,i),box:a,transform:this.el.transform()},SVG.on(window,"mousemove.drag",(function(t){e.drag(t);})),SVG.on(window,"touchmove.drag",(function(t){e.drag(t);})),SVG.on(window,"mouseup.drag",(function(t){e.end(t);})),SVG.on(window,"touchend.drag",(function(t){e.end(t);})),this.el.fire("dragstart",{event:t,p:this.startPoints.point,m:this.m,handler:this});}}},t.prototype.drag=function(t){var e=this.getBBox(),i=this.transformPoint(t),a=this.startPoints.box.x+i.x-this.startPoints.point.x,s=this.startPoints.box.y+i.y-this.startPoints.point.y,r=this.constraint,o=i.x-this.startPoints.point.x,n=i.y-this.startPoints.point.y;if(this.el.fire("dragmove",{event:t,p:i,m:this.m,handler:this}),this.el.event().defaultPrevented)return i;if("function"==typeof r){var l=r.call(this.el,a,s,this.m);"boolean"==typeof l&&(l={x:l,y:l}),!0===l.x?this.el.x(a):!1!==l.x&&this.el.x(l.x),!0===l.y?this.el.y(s):!1!==l.y&&this.el.y(l.y);}else "object"==typeof r&&(null!=r.minX&&a<r.minX?o=(a=r.minX)-this.startPoints.box.x:null!=r.maxX&&a>r.maxX-e.width&&(o=(a=r.maxX-e.width)-this.startPoints.box.x),null!=r.minY&&s<r.minY?n=(s=r.minY)-this.startPoints.box.y:null!=r.maxY&&s>r.maxY-e.height&&(n=(s=r.maxY-e.height)-this.startPoints.box.y),null!=r.snapToGrid&&(a-=a%r.snapToGrid,s-=s%r.snapToGrid,o-=o%r.snapToGrid,n-=n%r.snapToGrid),this.el instanceof SVG.G?this.el.matrix(this.startPoints.transform).transform({x:o,y:n},!0):this.el.move(a,s));return i},t.prototype.end=function(t){var e=this.drag(t);this.el.fire("dragend",{event:t,p:e,m:this.m,handler:this}),SVG.off(window,"mousemove.drag"),SVG.off(window,"touchmove.drag"),SVG.off(window,"mouseup.drag"),SVG.off(window,"touchend.drag");},SVG.extend(SVG.Element,{draggable:function(e,i){"function"!=typeof e&&"object"!=typeof e||(i=e,e=!0);var a=this.remember("_draggable")||new t(this);return (e=void 0===e||e)?a.init(i||{},e):(this.off("mousedown.drag"),this.off("touchstart.drag")),this}});}.call(void 0),function(){function t(t){this.el=t,t.remember("_selectHandler",this),this.pointSelection={isSelected:!1},this.rectSelection={isSelected:!1},this.pointsList={lt:[0,0],rt:["width",0],rb:["width","height"],lb:[0,"height"],t:["width",0],r:["width","height"],b:["width","height"],l:[0,"height"]},this.pointCoord=function(t,e,i){var a="string"!=typeof t?t:e[t];return i?a/2:a},this.pointCoords=function(t,e){var i=this.pointsList[t];return {x:this.pointCoord(i[0],e,"t"===t||"b"===t),y:this.pointCoord(i[1],e,"r"===t||"l"===t)}};}t.prototype.init=function(t,e){var i=this.el.bbox();this.options={};var a=this.el.selectize.defaults.points;for(var s in this.el.selectize.defaults)this.options[s]=this.el.selectize.defaults[s],void 0!==e[s]&&(this.options[s]=e[s]);var r=["points","pointsExclude"];for(var s in r){var o=this.options[r[s]];"string"==typeof o?o=o.length>0?o.split(/\s*,\s*/i):[]:"boolean"==typeof o&&"points"===r[s]&&(o=o?a:[]),this.options[r[s]]=o;}this.options.points=[a,this.options.points].reduce((function(t,e){return t.filter((function(t){return e.indexOf(t)>-1}))})),this.options.points=[this.options.points,this.options.pointsExclude].reduce((function(t,e){return t.filter((function(t){return e.indexOf(t)<0}))})),this.parent=this.el.parent(),this.nested=this.nested||this.parent.group(),this.nested.matrix(new SVG.Matrix(this.el).translate(i.x,i.y)),this.options.deepSelect&&-1!==["line","polyline","polygon"].indexOf(this.el.type)?this.selectPoints(t):this.selectRect(t),this.observe(),this.cleanup();},t.prototype.selectPoints=function(t){return this.pointSelection.isSelected=t,this.pointSelection.set||(this.pointSelection.set=this.parent.set(),this.drawPoints()),this},t.prototype.getPointArray=function(){var t=this.el.bbox();return this.el.array().valueOf().map((function(e){return [e[0]-t.x,e[1]-t.y]}))},t.prototype.drawPoints=function(){for(var t=this,e=this.getPointArray(),i=0,a=e.length;i<a;++i){var s=function(e){return function(i){(i=i||window.event).preventDefault?i.preventDefault():i.returnValue=!1,i.stopPropagation();var a=i.pageX||i.touches[0].pageX,s=i.pageY||i.touches[0].pageY;t.el.fire("point",{x:a,y:s,i:e,event:i});}}(i),r=this.drawPoint(e[i][0],e[i][1]).addClass(this.options.classPoints).addClass(this.options.classPoints+"_point").on("touchstart",s).on("mousedown",s);this.pointSelection.set.add(r);}},t.prototype.drawPoint=function(t,e){var i=this.options.pointType;switch(i){case"circle":return this.drawCircle(t,e);case"rect":return this.drawRect(t,e);default:if("function"==typeof i)return i.call(this,t,e);throw new Error("Unknown "+i+" point type!")}},t.prototype.drawCircle=function(t,e){return this.nested.circle(this.options.pointSize).center(t,e)},t.prototype.drawRect=function(t,e){return this.nested.rect(this.options.pointSize,this.options.pointSize).center(t,e)},t.prototype.updatePointSelection=function(){var t=this.getPointArray();this.pointSelection.set.each((function(e){this.cx()===t[e][0]&&this.cy()===t[e][1]||this.center(t[e][0],t[e][1]);}));},t.prototype.updateRectSelection=function(){var t=this,e=this.el.bbox();if(this.rectSelection.set.get(0).attr({width:e.width,height:e.height}),this.options.points.length&&this.options.points.map((function(i,a){var s=t.pointCoords(i,e);t.rectSelection.set.get(a+1).center(s.x,s.y);})),this.options.rotationPoint){var i=this.rectSelection.set.length();this.rectSelection.set.get(i-1).center(e.width/2,20);}},t.prototype.selectRect=function(t){var e=this,i=this.el.bbox();function a(t){return function(i){(i=i||window.event).preventDefault?i.preventDefault():i.returnValue=!1,i.stopPropagation();var a=i.pageX||i.touches[0].pageX,s=i.pageY||i.touches[0].pageY;e.el.fire(t,{x:a,y:s,event:i});}}if(this.rectSelection.isSelected=t,this.rectSelection.set=this.rectSelection.set||this.parent.set(),this.rectSelection.set.get(0)||this.rectSelection.set.add(this.nested.rect(i.width,i.height).addClass(this.options.classRect)),this.options.points.length&&this.rectSelection.set.length()<2){this.options.points.map((function(t,s){var r=e.pointCoords(t,i),o=e.drawPoint(r.x,r.y).attr("class",e.options.classPoints+"_"+t).on("mousedown",a(t)).on("touchstart",a(t));e.rectSelection.set.add(o);})),this.rectSelection.set.each((function(){this.addClass(e.options.classPoints);}));}if(this.options.rotationPoint&&(this.options.points&&!this.rectSelection.set.get(9)||!this.options.points&&!this.rectSelection.set.get(1))){var s=function(t){(t=t||window.event).preventDefault?t.preventDefault():t.returnValue=!1,t.stopPropagation();var i=t.pageX||t.touches[0].pageX,a=t.pageY||t.touches[0].pageY;e.el.fire("rot",{x:i,y:a,event:t});},r=this.drawPoint(i.width/2,20).attr("class",this.options.classPoints+"_rot").on("touchstart",s).on("mousedown",s);this.rectSelection.set.add(r);}},t.prototype.handler=function(){var t=this.el.bbox();this.nested.matrix(new SVG.Matrix(this.el).translate(t.x,t.y)),this.rectSelection.isSelected&&this.updateRectSelection(),this.pointSelection.isSelected&&this.updatePointSelection();},t.prototype.observe=function(){var t=this;if(MutationObserver)if(this.rectSelection.isSelected||this.pointSelection.isSelected)this.observerInst=this.observerInst||new MutationObserver((function(){t.handler();})),this.observerInst.observe(this.el.node,{attributes:!0});else try{this.observerInst.disconnect(),delete this.observerInst;}catch(t){}else this.el.off("DOMAttrModified.select"),(this.rectSelection.isSelected||this.pointSelection.isSelected)&&this.el.on("DOMAttrModified.select",(function(){t.handler();}));},t.prototype.cleanup=function(){!this.rectSelection.isSelected&&this.rectSelection.set&&(this.rectSelection.set.each((function(){this.remove();})),this.rectSelection.set.clear(),delete this.rectSelection.set),!this.pointSelection.isSelected&&this.pointSelection.set&&(this.pointSelection.set.each((function(){this.remove();})),this.pointSelection.set.clear(),delete this.pointSelection.set),this.pointSelection.isSelected||this.rectSelection.isSelected||(this.nested.remove(),delete this.nested);},SVG.extend(SVG.Element,{selectize:function(e,i){return "object"==typeof e&&(i=e,e=!0),(this.remember("_selectHandler")||new t(this)).init(void 0===e||e,i||{}),this}}),SVG.Element.prototype.selectize.defaults={points:["lt","rt","rb","lb","t","r","b","l"],pointsExclude:[],classRect:"svg_select_boundingRect",classPoints:"svg_select_points",pointSize:7,rotationPoint:!0,deepSelect:!1,pointType:"circle"};}(),function(){(function(){function t(t){t.remember("_resizeHandler",this),this.el=t,this.parameters={},this.lastUpdateCall=null,this.p=t.doc().node.createSVGPoint();}t.prototype.transformPoint=function(t,e,i){return this.p.x=t-(this.offset.x-window.pageXOffset),this.p.y=e-(this.offset.y-window.pageYOffset),this.p.matrixTransform(i||this.m)},t.prototype._extractPosition=function(t){return {x:null!=t.clientX?t.clientX:t.touches[0].clientX,y:null!=t.clientY?t.clientY:t.touches[0].clientY}},t.prototype.init=function(t){var e=this;if(this.stop(),"stop"!==t){for(var i in this.options={},this.el.resize.defaults)this.options[i]=this.el.resize.defaults[i],void 0!==t[i]&&(this.options[i]=t[i]);this.el.on("lt.resize",(function(t){e.resize(t||window.event);})),this.el.on("rt.resize",(function(t){e.resize(t||window.event);})),this.el.on("rb.resize",(function(t){e.resize(t||window.event);})),this.el.on("lb.resize",(function(t){e.resize(t||window.event);})),this.el.on("t.resize",(function(t){e.resize(t||window.event);})),this.el.on("r.resize",(function(t){e.resize(t||window.event);})),this.el.on("b.resize",(function(t){e.resize(t||window.event);})),this.el.on("l.resize",(function(t){e.resize(t||window.event);})),this.el.on("rot.resize",(function(t){e.resize(t||window.event);})),this.el.on("point.resize",(function(t){e.resize(t||window.event);})),this.update();}},t.prototype.stop=function(){return this.el.off("lt.resize"),this.el.off("rt.resize"),this.el.off("rb.resize"),this.el.off("lb.resize"),this.el.off("t.resize"),this.el.off("r.resize"),this.el.off("b.resize"),this.el.off("l.resize"),this.el.off("rot.resize"),this.el.off("point.resize"),this},t.prototype.resize=function(t){var e=this;this.m=this.el.node.getScreenCTM().inverse(),this.offset={x:window.pageXOffset,y:window.pageYOffset};var i=this._extractPosition(t.detail.event);if(this.parameters={type:this.el.type,p:this.transformPoint(i.x,i.y),x:t.detail.x,y:t.detail.y,box:this.el.bbox(),rotation:this.el.transform().rotation},"text"===this.el.type&&(this.parameters.fontSize=this.el.attr()["font-size"]),void 0!==t.detail.i){var a=this.el.array().valueOf();this.parameters.i=t.detail.i,this.parameters.pointCoords=[a[t.detail.i][0],a[t.detail.i][1]];}switch(t.type){case"lt":this.calc=function(t,e){var i=this.snapToGrid(t,e);if(this.parameters.box.width-i[0]>0&&this.parameters.box.height-i[1]>0){if("text"===this.parameters.type)return this.el.move(this.parameters.box.x+i[0],this.parameters.box.y),void this.el.attr("font-size",this.parameters.fontSize-i[0]);i=this.checkAspectRatio(i),this.el.move(this.parameters.box.x+i[0],this.parameters.box.y+i[1]).size(this.parameters.box.width-i[0],this.parameters.box.height-i[1]);}};break;case"rt":this.calc=function(t,e){var i=this.snapToGrid(t,e,2);if(this.parameters.box.width+i[0]>0&&this.parameters.box.height-i[1]>0){if("text"===this.parameters.type)return this.el.move(this.parameters.box.x-i[0],this.parameters.box.y),void this.el.attr("font-size",this.parameters.fontSize+i[0]);i=this.checkAspectRatio(i,!0),this.el.move(this.parameters.box.x,this.parameters.box.y+i[1]).size(this.parameters.box.width+i[0],this.parameters.box.height-i[1]);}};break;case"rb":this.calc=function(t,e){var i=this.snapToGrid(t,e,0);if(this.parameters.box.width+i[0]>0&&this.parameters.box.height+i[1]>0){if("text"===this.parameters.type)return this.el.move(this.parameters.box.x-i[0],this.parameters.box.y),void this.el.attr("font-size",this.parameters.fontSize+i[0]);i=this.checkAspectRatio(i),this.el.move(this.parameters.box.x,this.parameters.box.y).size(this.parameters.box.width+i[0],this.parameters.box.height+i[1]);}};break;case"lb":this.calc=function(t,e){var i=this.snapToGrid(t,e,1);if(this.parameters.box.width-i[0]>0&&this.parameters.box.height+i[1]>0){if("text"===this.parameters.type)return this.el.move(this.parameters.box.x+i[0],this.parameters.box.y),void this.el.attr("font-size",this.parameters.fontSize-i[0]);i=this.checkAspectRatio(i,!0),this.el.move(this.parameters.box.x+i[0],this.parameters.box.y).size(this.parameters.box.width-i[0],this.parameters.box.height+i[1]);}};break;case"t":this.calc=function(t,e){var i=this.snapToGrid(t,e,2);if(this.parameters.box.height-i[1]>0){if("text"===this.parameters.type)return;this.el.move(this.parameters.box.x,this.parameters.box.y+i[1]).height(this.parameters.box.height-i[1]);}};break;case"r":this.calc=function(t,e){var i=this.snapToGrid(t,e,0);if(this.parameters.box.width+i[0]>0){if("text"===this.parameters.type)return;this.el.move(this.parameters.box.x,this.parameters.box.y).width(this.parameters.box.width+i[0]);}};break;case"b":this.calc=function(t,e){var i=this.snapToGrid(t,e,0);if(this.parameters.box.height+i[1]>0){if("text"===this.parameters.type)return;this.el.move(this.parameters.box.x,this.parameters.box.y).height(this.parameters.box.height+i[1]);}};break;case"l":this.calc=function(t,e){var i=this.snapToGrid(t,e,1);if(this.parameters.box.width-i[0]>0){if("text"===this.parameters.type)return;this.el.move(this.parameters.box.x+i[0],this.parameters.box.y).width(this.parameters.box.width-i[0]);}};break;case"rot":this.calc=function(t,e){var i=t+this.parameters.p.x,a=e+this.parameters.p.y,s=Math.atan2(this.parameters.p.y-this.parameters.box.y-this.parameters.box.height/2,this.parameters.p.x-this.parameters.box.x-this.parameters.box.width/2),r=Math.atan2(a-this.parameters.box.y-this.parameters.box.height/2,i-this.parameters.box.x-this.parameters.box.width/2),o=this.parameters.rotation+180*(r-s)/Math.PI+this.options.snapToAngle/2;this.el.center(this.parameters.box.cx,this.parameters.box.cy).rotate(o-o%this.options.snapToAngle,this.parameters.box.cx,this.parameters.box.cy);};break;case"point":this.calc=function(t,e){var i=this.snapToGrid(t,e,this.parameters.pointCoords[0],this.parameters.pointCoords[1]),a=this.el.array().valueOf();a[this.parameters.i][0]=this.parameters.pointCoords[0]+i[0],a[this.parameters.i][1]=this.parameters.pointCoords[1]+i[1],this.el.plot(a);};}this.el.fire("resizestart",{dx:this.parameters.x,dy:this.parameters.y,event:t}),SVG.on(window,"touchmove.resize",(function(t){e.update(t||window.event);})),SVG.on(window,"touchend.resize",(function(){e.done();})),SVG.on(window,"mousemove.resize",(function(t){e.update(t||window.event);})),SVG.on(window,"mouseup.resize",(function(){e.done();}));},t.prototype.update=function(t){if(t){var e=this._extractPosition(t),i=this.transformPoint(e.x,e.y),a=i.x-this.parameters.p.x,s=i.y-this.parameters.p.y;this.lastUpdateCall=[a,s],this.calc(a,s),this.el.fire("resizing",{dx:a,dy:s,event:t});}else this.lastUpdateCall&&this.calc(this.lastUpdateCall[0],this.lastUpdateCall[1]);},t.prototype.done=function(){this.lastUpdateCall=null,SVG.off(window,"mousemove.resize"),SVG.off(window,"mouseup.resize"),SVG.off(window,"touchmove.resize"),SVG.off(window,"touchend.resize"),this.el.fire("resizedone");},t.prototype.snapToGrid=function(t,e,i,a){var s;return void 0!==a?s=[(i+t)%this.options.snapToGrid,(a+e)%this.options.snapToGrid]:(i=null==i?3:i,s=[(this.parameters.box.x+t+(1&i?0:this.parameters.box.width))%this.options.snapToGrid,(this.parameters.box.y+e+(2&i?0:this.parameters.box.height))%this.options.snapToGrid]),t<0&&(s[0]-=this.options.snapToGrid),e<0&&(s[1]-=this.options.snapToGrid),t-=Math.abs(s[0])<this.options.snapToGrid/2?s[0]:s[0]-(t<0?-this.options.snapToGrid:this.options.snapToGrid),e-=Math.abs(s[1])<this.options.snapToGrid/2?s[1]:s[1]-(e<0?-this.options.snapToGrid:this.options.snapToGrid),this.constraintToBox(t,e,i,a)},t.prototype.constraintToBox=function(t,e,i,a){var s,r,o=this.options.constraint||{};return void 0!==a?(s=i,r=a):(s=this.parameters.box.x+(1&i?0:this.parameters.box.width),r=this.parameters.box.y+(2&i?0:this.parameters.box.height)),void 0!==o.minX&&s+t<o.minX&&(t=o.minX-s),void 0!==o.maxX&&s+t>o.maxX&&(t=o.maxX-s),void 0!==o.minY&&r+e<o.minY&&(e=o.minY-r),void 0!==o.maxY&&r+e>o.maxY&&(e=o.maxY-r),[t,e]},t.prototype.checkAspectRatio=function(t,e){if(!this.options.saveAspectRatio)return t;var i=t.slice(),a=this.parameters.box.width/this.parameters.box.height,s=this.parameters.box.width+t[0],r=this.parameters.box.height-t[1],o=s/r;return o<a?(i[1]=s/a-this.parameters.box.height,e&&(i[1]=-i[1])):o>a&&(i[0]=this.parameters.box.width-r*a,e&&(i[0]=-i[0])),i},SVG.extend(SVG.Element,{resize:function(e){return (this.remember("_resizeHandler")||new t(this)).init(e||{}),this}}),SVG.Element.prototype.resize.defaults={snapToAngle:.1,snapToGrid:1,constraint:{},saveAspectRatio:!1};}).call(this);}(),void 0===window.Apex&&(window.Apex={});var Gt=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w;}return r(t,[{key:"initModules",value:function(){this.ctx.publicMethods=["updateOptions","updateSeries","appendData","appendSeries","isSeriesHidden","toggleSeries","showSeries","hideSeries","setLocale","resetSeries","zoomX","toggleDataPointSelection","dataURI","exportToCSV","addXaxisAnnotation","addYaxisAnnotation","addPointAnnotation","clearAnnotations","removeAnnotation","paper","destroy"],this.ctx.eventList=["click","mousedown","mousemove","mouseleave","touchstart","touchmove","touchleave","mouseup","touchend"],this.ctx.animations=new b(this.ctx),this.ctx.axes=new J(this.ctx),this.ctx.core=new Wt(this.ctx.el,this.ctx),this.ctx.config=new Y({}),this.ctx.data=new B(this.ctx),this.ctx.grid=new j(this.ctx),this.ctx.graphics=new m(this.ctx),this.ctx.coreUtils=new y(this.ctx),this.ctx.crosshairs=new Q(this.ctx),this.ctx.events=new Z(this.ctx),this.ctx.exports=new G(this.ctx),this.ctx.localization=new $(this.ctx),this.ctx.options=new I,this.ctx.responsive=new K(this.ctx),this.ctx.series=new W(this.ctx),this.ctx.theme=new tt(this.ctx),this.ctx.formatters=new S(this.ctx),this.ctx.titleSubtitle=new et(this.ctx),this.ctx.legend=new lt(this.ctx),this.ctx.toolbar=new ht(this.ctx),this.ctx.tooltip=new bt(this.ctx),this.ctx.dimensions=new ot(this.ctx),this.ctx.updateHelpers=new Bt(this.ctx),this.ctx.zoomPanSelection=new ct(this.ctx),this.ctx.w.globals.tooltip=new bt(this.ctx);}}]),t}(),Vt=function(){function t(e){a(this,t),this.ctx=e,this.w=e.w;}return r(t,[{key:"clear",value:function(t){var e=t.isUpdating;this.ctx.zoomPanSelection&&this.ctx.zoomPanSelection.destroy(),this.ctx.toolbar&&this.ctx.toolbar.destroy(),this.ctx.animations=null,this.ctx.axes=null,this.ctx.annotations=null,this.ctx.core=null,this.ctx.data=null,this.ctx.grid=null,this.ctx.series=null,this.ctx.responsive=null,this.ctx.theme=null,this.ctx.formatters=null,this.ctx.titleSubtitle=null,this.ctx.legend=null,this.ctx.dimensions=null,this.ctx.options=null,this.ctx.crosshairs=null,this.ctx.zoomPanSelection=null,this.ctx.updateHelpers=null,this.ctx.toolbar=null,this.ctx.localization=null,this.ctx.w.globals.tooltip=null,this.clearDomElements({isUpdating:e});}},{key:"killSVG",value:function(t){t.each((function(t,e){this.removeClass("*"),this.off(),this.stop();}),!0),t.ungroup(),t.clear();}},{key:"clearDomElements",value:function(t){var e=this,i=t.isUpdating,a=this.w.globals.dom.Paper.node;a.parentNode&&a.parentNode.parentNode&&!i&&(a.parentNode.parentNode.style.minHeight="unset");var s=this.w.globals.dom.baseEl;s&&this.ctx.eventList.forEach((function(t){s.removeEventListener(t,e.ctx.events.documentEvent);}));var r=this.w.globals.dom;if(null!==this.ctx.el)for(;this.ctx.el.firstChild;)this.ctx.el.removeChild(this.ctx.el.firstChild);this.killSVG(r.Paper),r.Paper.remove(),r.elWrap=null,r.elGraphical=null,r.elLegendWrap=null,r.elLegendForeign=null,r.baseEl=null,r.elGridRect=null,r.elGridRectMask=null,r.elGridRectMarkerMask=null,r.elForecastMask=null,r.elNonForecastMask=null,r.elDefs=null;}}]),t}(),jt=new WeakMap;var _t=function(){function t(e,i){a(this,t),this.opts=i,this.ctx=this,this.w=new R(i).init(),this.el=e,this.w.globals.cuid=x.randomId(),this.w.globals.chartID=this.w.config.chart.id?x.escapeString(this.w.config.chart.id):this.w.globals.cuid,new Gt(this).initModules(),this.create=x.bind(this.create,this),this.windowResizeHandler=this._windowResizeHandler.bind(this),this.parentResizeHandler=this._parentResizeCallback.bind(this);}return r(t,[{key:"render",value:function(){var t=this;return new Promise((function(e,i){if(null!==t.el){void 0===Apex._chartInstances&&(Apex._chartInstances=[]),t.w.config.chart.id&&Apex._chartInstances.push({id:t.w.globals.chartID,group:t.w.config.chart.group,chart:t}),t.setLocale(t.w.config.chart.defaultLocale);var a=t.w.config.chart.events.beforeMount;"function"==typeof a&&a(t,t.w),t.events.fireEvent("beforeMount",[t,t.w]),window.addEventListener("resize",t.windowResizeHandler),function(t,e){var i=!1;if(t.nodeType!==Node.DOCUMENT_FRAGMENT_NODE){var a=t.getBoundingClientRect();"none"!==t.style.display&&0!==a.width||(i=!0);}var s=new ResizeObserver((function(a){i&&e.call(t,a),i=!0;}));t.nodeType===Node.DOCUMENT_FRAGMENT_NODE?Array.from(t.children).forEach((function(t){return s.observe(t)})):s.observe(t),jt.set(e,s);}(t.el.parentNode,t.parentResizeHandler);var s=t.el.getRootNode&&t.el.getRootNode(),r=x.is("ShadowRoot",s),o=t.el.ownerDocument,n=r?s.getElementById("apexcharts-css"):o.getElementById("apexcharts-css");if(!n){var l;(n=document.createElement("style")).id="apexcharts-css",n.textContent='@keyframes opaque {\n  0% {\n      opacity: 0\n  }\n\n  to {\n      opacity: 1\n  }\n}\n\n@keyframes resizeanim {\n  0%,to {\n      opacity: 0\n  }\n}\n\n.apexcharts-canvas {\n  position: relative;\n  user-select: none\n}\n\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0,0,0,.5);\n  box-shadow: 0 0 1px rgba(255,255,255,.5);\n  -webkit-box-shadow: 0 0 1px rgba(255,255,255,.5)\n}\n\n.apexcharts-inner {\n  position: relative\n}\n\n.apexcharts-text tspan {\n  font-family: inherit\n}\n\n.legend-mouseover-inactive {\n  transition: .15s ease all;\n  opacity: .2\n}\n\n.apexcharts-legend-text {\n  padding-left: 15px;\n  margin-left: -15px;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255,255,255,.96)\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30,30,30,.8)\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit\n}\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #eceff1;\n  border-bottom: 1px solid #ddd\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0,0,0,.7);\n  border-bottom: 1px solid #333\n}\n\n.apexcharts-tooltip-text-goals-value,.apexcharts-tooltip-text-y-value,.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  margin-left: 5px;\n  font-weight: 600\n}\n\n.apexcharts-tooltip-text-goals-label:empty,.apexcharts-tooltip-text-goals-value:empty,.apexcharts-tooltip-text-y-label:empty,.apexcharts-tooltip-text-y-value:empty,.apexcharts-tooltip-text-z-value:empty,.apexcharts-tooltip-title:empty {\n  display: none\n}\n\n.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {\n  padding: 6px 0 5px\n}\n\n.apexcharts-tooltip-goals-group,.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {\n  display: flex\n}\n\n.apexcharts-tooltip-text-goals-label:not(:empty),.apexcharts-tooltip-text-goals-value:not(:empty) {\n  margin-top: -6px\n}\n\n.apexcharts-tooltip-marker {\n  width: 12px;\n  height: 12px;\n  position: relative;\n  top: 0;\n  margin-right: 10px;\n  border-radius: 50%\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px\n}\n\n.apexcharts-tooltip-series-group-hidden {\n  opacity: 0;\n  height: 0;\n  line-height: 0;\n  padding: 0!important\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px\n}\n\n.apexcharts-custom-tooltip,.apexcharts-tooltip-box {\n  padding: 4px 8px\n}\n\n.apexcharts-tooltip-boxPlot {\n  display: flex;\n  flex-direction: column-reverse\n}\n\n.apexcharts-tooltip-box>div {\n  margin: 4px 0\n}\n\n.apexcharts-tooltip-box span.value {\n  font-weight: 700\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: 700;\n  display: block;\n  margin-bottom: 5px\n}\n\n.apexcharts-xaxistooltip,.apexcharts-yaxistooltip {\n  opacity: 0;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #eceff1;\n  border: 1px solid #90a4ae\n}\n\n.apexcharts-xaxistooltip {\n  padding: 9px 10px;\n  transition: .15s ease all\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0,0,0,.7);\n  border: 1px solid rgba(0,0,0,.5);\n  color: #fff\n}\n\n.apexcharts-xaxistooltip:after,.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-left: -6px\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-left: -7px\n}\n\n.apexcharts-xaxistooltip-bottom:after,.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%\n}\n\n.apexcharts-xaxistooltip-top:after,.apexcharts-xaxistooltip-top:before {\n  top: 100%\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-yaxistooltip {\n  padding: 4px 10px\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0,0,0,.7);\n  border: 1px solid rgba(0,0,0,.5);\n  color: #fff\n}\n\n.apexcharts-yaxistooltip:after,.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-top: -6px\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-top: -7px\n}\n\n.apexcharts-yaxistooltip-left:after,.apexcharts-yaxistooltip-left:before {\n  left: 100%\n}\n\n.apexcharts-yaxistooltip-right:after,.apexcharts-yaxistooltip-right:before {\n  right: 100%\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none\n}\n\n.apexcharts-xcrosshairs,.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: .15s ease all\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0\n}\n\n.apexcharts-selection-rect {\n  cursor: move\n}\n\n.svg_select_boundingRect,.svg_select_points_rot {\n  pointer-events: none;\n  opacity: 0;\n  visibility: hidden\n}\n\n.apexcharts-selection-rect+g .svg_select_boundingRect,.apexcharts-selection-rect+g .svg_select_points_rot {\n  opacity: 0;\n  visibility: hidden\n}\n\n.apexcharts-selection-rect+g .svg_select_points_l,.apexcharts-selection-rect+g .svg_select_points_r {\n  cursor: ew-resize;\n  opacity: 1;\n  visibility: visible\n}\n\n.svg_select_points {\n  fill: #efefef;\n  stroke: #333;\n  rx: 2\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-menu-icon,.apexcharts-pan-icon,.apexcharts-reset-icon,.apexcharts-selection-icon,.apexcharts-toolbar-custom-icon,.apexcharts-zoom-icon,.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6e8192;\n  text-align: center\n}\n\n.apexcharts-menu-icon svg,.apexcharts-reset-icon svg,.apexcharts-zoom-icon svg,.apexcharts-zoomin-icon svg,.apexcharts-zoomout-icon svg {\n  fill: #6e8192\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(.76)\n}\n\n.apexcharts-theme-dark .apexcharts-menu-icon svg,.apexcharts-theme-dark .apexcharts-pan-icon svg,.apexcharts-theme-dark .apexcharts-reset-icon svg,.apexcharts-theme-dark .apexcharts-selection-icon svg,.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,.apexcharts-theme-dark .apexcharts-zoom-icon svg,.apexcharts-theme-dark .apexcharts-zoomin-icon svg,.apexcharts-theme-dark .apexcharts-zoomout-icon svg {\n  fill: #f3f4f5\n}\n\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {\n  fill: #008ffb\n}\n\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg,.apexcharts-theme-light .apexcharts-reset-icon:hover svg,.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {\n  fill: #333\n}\n\n.apexcharts-menu-icon,.apexcharts-selection-icon {\n  position: relative\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px\n}\n\n.apexcharts-menu-icon,.apexcharts-reset-icon,.apexcharts-zoom-icon {\n  transform: scale(.85)\n}\n\n.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {\n  transform: scale(.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px\n}\n\n.apexcharts-pan-icon {\n  transform: scale(.62);\n  position: relative;\n  left: 1px;\n  top: 0\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6e8192;\n  stroke-width: 2\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008ffb\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0 6px 2px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: .15s ease all;\n  pointer-events: none\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: .15s ease all\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0,0,0,.7);\n  color: #fff\n}\n\n@media screen and (min-width:768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n      opacity: 1\n  }\n}\n\n.apexcharts-canvas .apexcharts-element-hidden,.apexcharts-datalabel.apexcharts-element-hidden,.apexcharts-hide .apexcharts-series-points {\n  display: none;\n}\n\n.apexcharts-hidden-element-shown {\n  opacity: 1;\n  transition: 0.25s ease all;\n}\n.apexcharts-datalabel,.apexcharts-datalabel-label,.apexcharts-datalabel-value,.apexcharts-datalabels,.apexcharts-pie-label {\n  cursor: default;\n  pointer-events: none\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: .3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease\n}\n\n.apexcharts-radialbar-label {\n  cursor: pointer;\n}\n\n.apexcharts-annotation-rect,.apexcharts-area-series .apexcharts-area,.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-gridline,.apexcharts-line,.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-point-annotation-label,.apexcharts-radar-series path,.apexcharts-radar-series polygon,.apexcharts-toolbar svg,.apexcharts-tooltip .apexcharts-marker,.apexcharts-xaxis-annotation-label,.apexcharts-yaxis-annotation-label,.apexcharts-zoom-rect {\n  pointer-events: none\n}\n\n.apexcharts-marker {\n  transition: .15s ease all\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden\n}\n\n.contract-trigger:before,.resize-triggers,.resize-triggers>div {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0\n}\n\n.resize-triggers>div {\n  height: 100%;\n  width: 100%;\n  background: #eee;\n  overflow: auto\n}\n\n.contract-trigger:before {\n  overflow: hidden;\n  width: 200%;\n  height: 200%\n}\n\n.apexcharts-bar-goals-markers{\n  pointer-events: none\n}\n\n.apexcharts-bar-shadows{\n  pointer-events: none\n}\n\n.apexcharts-rangebar-goals-markers{\n  pointer-events: none\n}';var h=(null===(l=t.opts.chart)||void 0===l?void 0:l.nonce)||t.w.config.chart.nonce;h&&n.setAttribute("nonce",h),r?s.prepend(n):o.head.appendChild(n);}var c=t.create(t.w.config.series,{});if(!c)return e(t);t.mount(c).then((function(){"function"==typeof t.w.config.chart.events.mounted&&t.w.config.chart.events.mounted(t,t.w),t.events.fireEvent("mounted",[t,t.w]),e(c);})).catch((function(t){i(t);}));}else i(new Error("Element not found"));}))}},{key:"create",value:function(t,e){var i=this.w;new Gt(this).initModules();var a=this.w.globals;(a.noData=!1,a.animationEnded=!1,this.responsive.checkResponsiveConfig(e),i.config.xaxis.convertedCatToNumeric)&&new E(i.config).convertCatToNumericXaxis(i.config,this.ctx);if(null===this.el)return a.animationEnded=!0,null;if(this.core.setupElements(),"treemap"===i.config.chart.type&&(i.config.grid.show=!1,i.config.yaxis[0].show=!1),0===a.svgWidth)return a.animationEnded=!0,null;var s=y.checkComboSeries(t,i.config.chart.type);a.comboCharts=s.comboCharts,a.comboBarCount=s.comboBarCount;var r=t.every((function(t){return t.data&&0===t.data.length}));(0===t.length||r&&a.collapsedSeries.length<1)&&this.series.handleNoData(),this.events.setupEventHandlers(),this.data.parseData(t),this.theme.init(),new D(this).setGlobalMarkerSize(),this.formatters.setLabelFormatters(),this.titleSubtitle.draw(),a.noData&&a.collapsedSeries.length!==a.series.length&&!i.config.legend.showForSingleSeries||this.legend.init(),this.series.hasAllSeriesEqualX(),a.axisCharts&&(this.core.coreCalculations(),"category"!==i.config.xaxis.type&&this.formatters.setLabelFormatters(),this.ctx.toolbar.minX=i.globals.minX,this.ctx.toolbar.maxX=i.globals.maxX),this.formatters.heatmapLabelFormatters(),new y(this).getLargestMarkerSize(),this.dimensions.plotCoords();var o=this.core.xySettings();this.grid.createGridMask();var n=this.core.plotChartType(t,o),l=new N(this);return l.bringForward(),i.config.dataLabels.background.enabled&&l.dataLabelsBackground(),this.core.shiftGraphPosition(),{elGraph:n,xyRatios:o,dimensions:{plot:{left:i.globals.translateX,top:i.globals.translateY,width:i.globals.gridWidth,height:i.globals.gridHeight}}}}},{key:"mount",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,i=this,a=i.w;return new Promise((function(s,r){if(null===i.el)return r(new Error("Not enough data to display or target element not found"));(null===e||a.globals.allSeriesCollapsed)&&i.series.handleNoData(),i.grid=new j(i);var o,n,l=i.grid.drawGrid();(i.annotations=new T(i),i.annotations.drawImageAnnos(),i.annotations.drawTextAnnos(),"back"===a.config.grid.position)&&(l&&a.globals.dom.elGraphical.add(l.el),null!=l&&null!==(o=l.elGridBorders)&&void 0!==o&&o.node&&a.globals.dom.elGraphical.add(l.elGridBorders));if(Array.isArray(e.elGraph))for(var h=0;h<e.elGraph.length;h++)a.globals.dom.elGraphical.add(e.elGraph[h]);else a.globals.dom.elGraphical.add(e.elGraph);"front"===a.config.grid.position&&(l&&a.globals.dom.elGraphical.add(l.el),null!=l&&null!==(n=l.elGridBorders)&&void 0!==n&&n.node&&a.globals.dom.elGraphical.add(l.elGridBorders));"front"===a.config.xaxis.crosshairs.position&&i.crosshairs.drawXCrosshairs(),"front"===a.config.yaxis[0].crosshairs.position&&i.crosshairs.drawYCrosshairs(),"treemap"!==a.config.chart.type&&i.axes.drawAxis(a.config.chart.type,l);var c=new V(t.ctx,l),d=new q(t.ctx,l);if(null!==l&&(c.xAxisLabelCorrections(l.xAxisTickWidth),d.setYAxisTextAlignments(),a.config.yaxis.map((function(t,e){-1===a.globals.ignoreYAxisIndexes.indexOf(e)&&d.yAxisTitleRotate(e,t.opposite);}))),i.annotations.drawAxesAnnotations(),!a.globals.noData){if(a.config.tooltip.enabled&&!a.globals.noData&&i.w.globals.tooltip.drawTooltip(e.xyRatios),a.globals.axisCharts&&(a.globals.isXNumeric||a.config.xaxis.convertedCatToNumeric||a.globals.isRangeBar))(a.config.chart.zoom.enabled||a.config.chart.selection&&a.config.chart.selection.enabled||a.config.chart.pan&&a.config.chart.pan.enabled)&&i.zoomPanSelection.init({xyRatios:e.xyRatios});else {var g=a.config.chart.toolbar.tools;["zoom","zoomin","zoomout","selection","pan","reset"].forEach((function(t){g[t]=!1;}));}a.config.chart.toolbar.show&&!a.globals.allSeriesCollapsed&&i.toolbar.createToolbar();}a.globals.memory.methodsToExec.length>0&&a.globals.memory.methodsToExec.forEach((function(t){t.method(t.params,!1,t.context);})),a.globals.axisCharts||a.globals.noData||i.core.resizeNonAxisCharts(),s(i);}))}},{key:"destroy",value:function(){var t,e;window.removeEventListener("resize",this.windowResizeHandler),this.el.parentNode,t=this.parentResizeHandler,(e=jt.get(t))&&(e.disconnect(),jt.delete(t));var i=this.w.config.chart.id;i&&Apex._chartInstances.forEach((function(t,e){t.id===x.escapeString(i)&&Apex._chartInstances.splice(e,1);})),new Vt(this.ctx).clear({isUpdating:!1});}},{key:"updateOptions",value:function(t){var e=this,i=arguments.length>1&&void 0!==arguments[1]&&arguments[1],a=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],s=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],o=this.w;return o.globals.selection=void 0,t.series&&(this.series.resetSeries(!1,!0,!1),t.series.length&&t.series[0].data&&(t.series=t.series.map((function(t,i){return e.updateHelpers._extendSeries(t,i)}))),this.updateHelpers.revertDefaultAxisMinMax()),t.xaxis&&(t=this.updateHelpers.forceXAxisUpdate(t)),t.yaxis&&(t=this.updateHelpers.forceYAxisUpdate(t)),o.globals.collapsedSeriesIndices.length>0&&this.series.clearPreviousPaths(),t.theme&&(t=this.theme.updateThemeOptions(t)),this.updateHelpers._updateOptions(t,i,a,s,r)}},{key:"updateSeries",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.series.resetSeries(!1),this.updateHelpers.revertDefaultAxisMinMax(),this.updateHelpers._updateSeries(t,e,i)}},{key:"appendSeries",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],a=this.w.config.series.slice();return a.push(t),this.series.resetSeries(!1),this.updateHelpers.revertDefaultAxisMinMax(),this.updateHelpers._updateSeries(a,e,i)}},{key:"appendData",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=this;i.w.globals.dataChanged=!0,i.series.getPreviousPaths();for(var a=i.w.config.series.slice(),s=0;s<a.length;s++)if(null!==t[s]&&void 0!==t[s])for(var r=0;r<t[s].data.length;r++)a[s].data.push(t[s].data[r]);return i.w.config.series=a,e&&(i.w.globals.initialSeries=x.clone(i.w.config.series)),this.update()}},{key:"update",value:function(t){var e=this;return new Promise((function(i,a){new Vt(e.ctx).clear({isUpdating:!0});var s=e.create(e.w.config.series,t);if(!s)return i(e);e.mount(s).then((function(){"function"==typeof e.w.config.chart.events.updated&&e.w.config.chart.events.updated(e,e.w),e.events.fireEvent("updated",[e,e.w]),e.w.globals.isDirty=!0,i(e);})).catch((function(t){a(t);}));}))}},{key:"getSyncedCharts",value:function(){var t=this.getGroupedCharts(),e=[this];return t.length&&(e=[],t.forEach((function(t){e.push(t);}))),e}},{key:"getGroupedCharts",value:function(){var t=this;return Apex._chartInstances.filter((function(t){if(t.group)return !0})).map((function(e){return t.w.config.chart.group===e.group?e.chart:t}))}},{key:"toggleSeries",value:function(t){return this.series.toggleSeries(t)}},{key:"highlightSeriesOnLegendHover",value:function(t,e){return this.series.toggleSeriesOnHover(t,e)}},{key:"showSeries",value:function(t){this.series.showSeries(t);}},{key:"hideSeries",value:function(t){this.series.hideSeries(t);}},{key:"isSeriesHidden",value:function(t){this.series.isSeriesHidden(t);}},{key:"resetSeries",value:function(){var t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];this.series.resetSeries(t,e);}},{key:"addEventListener",value:function(t,e){this.events.addEventListener(t,e);}},{key:"removeEventListener",value:function(t,e){this.events.removeEventListener(t,e);}},{key:"addXaxisAnnotation",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0,a=this;i&&(a=i),a.annotations.addXaxisAnnotationExternal(t,e,a);}},{key:"addYaxisAnnotation",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0,a=this;i&&(a=i),a.annotations.addYaxisAnnotationExternal(t,e,a);}},{key:"addPointAnnotation",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0,a=this;i&&(a=i),a.annotations.addPointAnnotationExternal(t,e,a);}},{key:"clearAnnotations",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0,e=this;t&&(e=t),e.annotations.clearAnnotations(e);}},{key:"removeAnnotation",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,i=this;e&&(i=e),i.annotations.removeAnnotation(i,t);}},{key:"getChartArea",value:function(){return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner")}},{key:"getSeriesTotalXRange",value:function(t,e){return this.coreUtils.getSeriesTotalsXRange(t,e)}},{key:"getHighestValueInSeries",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return new U(this.ctx).getMinYMaxY(t).highestY}},{key:"getLowestValueInSeries",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return new U(this.ctx).getMinYMaxY(t).lowestY}},{key:"getSeriesTotal",value:function(){return this.w.globals.seriesTotals}},{key:"toggleDataPointSelection",value:function(t,e){return this.updateHelpers.toggleDataPointSelection(t,e)}},{key:"zoomX",value:function(t,e){this.ctx.toolbar.zoomUpdateOptions(t,e);}},{key:"setLocale",value:function(t){this.localization.setCurrentLocaleValues(t);}},{key:"dataURI",value:function(t){return new G(this.ctx).dataURI(t)}},{key:"exportToCSV",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return new G(this.ctx).exportToCSV(t)}},{key:"paper",value:function(){return this.w.globals.dom.Paper}},{key:"_parentResizeCallback",value:function(){this.w.globals.animationEnded&&this.w.config.chart.redrawOnParentResize&&this._windowResize();}},{key:"_windowResize",value:function(){var t=this;clearTimeout(this.w.globals.resizeTimer),this.w.globals.resizeTimer=window.setTimeout((function(){t.w.globals.resized=!0,t.w.globals.dataChanged=!1,t.ctx.update();}),150);}},{key:"_windowResizeHandler",value:function(){var t=this.w.config.chart.redrawOnWindowResize;"function"==typeof t&&(t=t()),t&&this._windowResize();}}],[{key:"getChartByID",value:function(t){var e=x.escapeString(t);if(Apex._chartInstances){var i=Apex._chartInstances.filter((function(t){return t.id===e}))[0];return i&&i.chart}}},{key:"initOnLoad",value:function(){for(var e=document.querySelectorAll("[data-apexcharts]"),i=0;i<e.length;i++){new t(e[i],JSON.parse(e[i].getAttribute("data-options"))).render();}}},{key:"exec",value:function(t,e){var i=this.getChartByID(t);if(i){i.w.globals.isExecCalled=!0;var a=null;if(-1!==i.publicMethods.indexOf(e)){for(var s=arguments.length,r=new Array(s>2?s-2:0),o=2;o<s;o++)r[o-2]=arguments[o];a=i[e].apply(i,r);}return a}}},{key:"merge",value:function(t,e){return x.extend(t,e)}}]),t}();module.exports=_t;
});

let EcoChart = class EcoChart extends s {
    constructor() {
        super(...arguments);
        this.ecoData = { bonusRange: 0, acceleration: 0, constant: 0, freeWheel: 0 };
        this.options = {
            series: [0, 0, 0], // Dummy data to initialize the chart
            chart: {
                height: 350,
                width: 350,
                type: 'radialBar',
            },
            plotOptions: {
                radialBar: {
                    offsetY: 0,
                    startAngle: 0,
                    endAngle: 270,
                    hollow: {
                        margin: 5,
                        size: '40%',
                        background: '#ffffff',
                        image: undefined,
                    },
                    dataLabels: {
                        textAnchor: 'middle',
                        distributed: false,
                        name: {
                            show: true,
                        },
                        value: {
                            show: true,
                            fontSize: '24px',
                            fontWeight: 'bold',
                        },
                        total: {
                            show: true,
                            label: 'Bonus range',
                            formatter: () => {
                                return `${this.ecoData.bonusRange || 0} km`;
                            },
                            offsetX: 50,
                            offsetY: 10,
                        },
                    },
                    barLabels: {
                        enabled: true,
                        useSeriesColors: true,
                        margin: 8,
                        fontSize: '16px',
                        formatter: (seriesName, opts) => {
                            return `${seriesName}:  ${opts.w.globals.series[opts.seriesIndex]}`;
                        },
                    },
                },
            },
            colors: ['#1ab7ea', '#0084ff', '#39539E'],
            labels: ['Acceleration', 'Constant', 'Free wheel'],
            responsive: [
                {
                    breakpoint: 480,
                    options: {
                        legend: {
                            show: false,
                        },
                    },
                },
            ],
        };
    }
    firstUpdated() {
        var _a;
        this.chart = new apexcharts_common((_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.getElementById('chart'), this.options);
        this.chart.render();
    }
    updated(changedProperties) {
        if (changedProperties.has('ecoData')) {
            this.updateChart();
        }
    }
    updateChart() {
        if (this.chart) {
            this.chart.updateOptions({
                series: [this.ecoData.acceleration, this.ecoData.constant, this.ecoData.freeWheel],
                plotOptions: {
                    radialBar: {
                        dataLabels: {
                            total: {
                                formatter: () => {
                                    return `${this.ecoData.bonusRange || 0} km`;
                                },
                            },
                        },
                    },
                },
            });
        }
    }
    render() {
        return x `<div id="chart"></div>`;
    }
};
EcoChart.styles = i$2 `
    #chart {
      display: flex;
      justify-content: center;
      position: relative;
      width: 100%;
      max-height: 350px;
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,
        'Open Sans', 'Helvetica Neue', sans-serif !important;
    }
    .apexcharts-datalabels-group .apexcharts-text {
      font-size: 1.2rem;
      fill: var(--primary-text-color);
    }
    .apexcharts-radialbar-track > path {
      stroke: var(--divider-color);
    }
    .apexcharts-radialbar-hollow {
      fill: var(--ha-card-background, var(--card-background-color, #fff));
    }
  `;
__decorate([
    n$1({ type: Object })
], EcoChart.prototype, "ecoData", void 0);
__decorate([
    t$1()
], EcoChart.prototype, "chart", void 0);
EcoChart = __decorate([
    e$1('eco-chart')
], EcoChart);

logCardInfo();
console.info('Developed by John Nguyen');
window.customCards = window.customCards || [];
window.customCards.push({
    type: 'vehicle-info-card',
    name: 'Vehicle Card',
    preview: true,
    description: 'A custom card to display vehicle data with a map and additional cards.',
    documentationURL: 'https://github.com/ngocjohn/vehicle-info-card?tab=readme-ov-file#configuration',
});
const HELPERS = window.loadCardHelpers ? window.loadCardHelpers() : undefined;
let VehicleCard = class VehicleCard extends s {
    constructor() {
        super(...arguments);
        this.vehicleEntities = {};
        this.additionalCards = {};
        this.activeCardType = null;
        this.lockAttributesVisible = false;
        this.windowAttributesVisible = false;
        this.chargingInfoVisible = false;
        /* -------------------------------------------------------------------------- */
        /* ADDED CARD FUNCTIONALITY                                                   */
        /* -------------------------------------------------------------------------- */
        this.toggleCard = (action) => {
            var _a;
            const cardElement = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('.card-element');
            if (!this.activeCardType || !cardElement)
                return;
            if (action === 'next' || action === 'prev') {
                const currentIndex = cardTypes.findIndex((card) => card.type === this.activeCardType);
                const newIndex = action === 'next'
                    ? (currentIndex + 1) % cardTypes.length
                    : (currentIndex - 1 + cardTypes.length) % cardTypes.length;
                cardElement.style.animation = 'none';
                setTimeout(() => {
                    this.activeCardType = cardTypes[newIndex].type;
                    cardElement.style.animation = 'fadeIn 0.3s ease';
                }, 300);
                // this.activeCardType = cardTypes[newIndex].type;
            }
            else if (action === 'close') {
                this.activeCardType = null;
            }
        };
        this.toggleCardFromButtons = (cardType) => {
            setTimeout(() => {
                this.activeCardType = this.activeCardType === cardType ? null : cardType;
            }, 200);
        };
        /* ----------------------------- PRIVATE METHODS ---------------------------- */
        this.toggleChargingInfo = () => {
            this.chargingInfoVisible = !this.chargingInfoVisible;
            this.requestUpdate();
        };
        this.showMapOnCard = () => {
            this.activeCardType = 'mapDialog';
        };
        // Method to toggle the visibility of lock attributes
        this.toggleLockAttributes = () => {
            this.lockAttributesVisible = !this.lockAttributesVisible;
            this.requestUpdate(); // Trigger a re-render
        };
        this.toggleWindowAttributes = () => {
            this.windowAttributesVisible = !this.windowAttributesVisible;
            this.requestUpdate();
        };
        /* -------------------------------------------------------------------------- */
        /* GET ENTITIES STATE AND ATTRIBUTES                                          */
        /* -------------------------------------------------------------------------- */
        this.createItemDataRow = (title, data) => {
            return x `
      <div class="default-card">
        <div class="data-header">${title}</div>
        ${data.map(({ key, name, icon, state }) => {
                if (key && name && state) {
                    return x `
              <div class="data-row">
                <div>
                  <ha-icon class="data-icon" .icon="${icon}"></ha-icon>
                  <span>${name}</span>
                </div>
                <div class="data-value-unit" @click=${() => { var _a; return this.toggleMoreInfo((_a = this.vehicleEntities[key]) === null || _a === void 0 ? void 0 : _a.entity_id); }}>
                  <span>${state}</span>
                </div>
              </div>
            `;
                }
                else {
                    return x ``;
                }
            })}
      </div>
    `;
        };
        this.createDataArray = (keys) => {
            return keys.map((config) => this.getEntityInfoByKey(config));
        };
        this.getEntityInfoByKey = ({ key, name, icon, state, unit, }) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
            if (!key) {
                return {
                    key: '',
                    name: '',
                    icon: '',
                    unit: '',
                    state: '',
                };
            }
            if (!this.vehicleEntities[key]) {
                if (key === 'selectedProgram') {
                    return {
                        key,
                        name: name !== null && name !== void 0 ? name : 'Program',
                        icon: icon !== null && icon !== void 0 ? icon : 'mdi:ev-station',
                        state: (_b = selectedProgramMapping[this.getEntityAttribute((_a = this.vehicleEntities.rangeElectric) === null || _a === void 0 ? void 0 : _a.entity_id, 'selectedChargeProgram')]) !== null && _b !== void 0 ? _b : '',
                        unit: unit !== null && unit !== void 0 ? unit : '',
                    };
                }
            }
            if (this.vehicleEntities[key]) {
                if (key === 'soc') {
                    const currentState = this.getEntityState((_c = this.vehicleEntities.soc) === null || _c === void 0 ? void 0 : _c.entity_id);
                    const stateValue = currentState ? parseFloat(currentState) : 0;
                    const socIcon = stateValue < 35
                        ? 'mdi:battery-charging-low'
                        : stateValue < 70
                            ? 'mdi:battery-charging-medium'
                            : 'mdi:battery-charging-high';
                    return {
                        key,
                        name: name !== null && name !== void 0 ? name : (_d = this.vehicleEntities.soc) === null || _d === void 0 ? void 0 : _d.original_name,
                        icon: (_e = icon !== null && icon !== void 0 ? icon : socIcon) !== null && _e !== void 0 ? _e : '',
                        state: state !== null && state !== void 0 ? state : this.getStateDisplay((_f = this.vehicleEntities.soc) === null || _f === void 0 ? void 0 : _f.entity_id),
                        unit: unit !== null && unit !== void 0 ? unit : this.getEntityAttribute((_g = this.vehicleEntities.soc) === null || _g === void 0 ? void 0 : _g.entity_id, 'unit_of_measurement'),
                    };
                }
                else if (key === 'maxSoc') {
                    const maxSocState = this.getEntityState((_h = this.vehicleEntities.maxSoc) === null || _h === void 0 ? void 0 : _h.entity_id) || '0';
                    return {
                        key,
                        name: name !== null && name !== void 0 ? name : (_j = this.vehicleEntities.maxSoc) === null || _j === void 0 ? void 0 : _j.original_name,
                        icon: icon !== null && icon !== void 0 ? icon : `mdi:battery-charging-${maxSocState}`,
                        state: state !== null && state !== void 0 ? state : this.getStateDisplay((_k = this.vehicleEntities.maxSoc) === null || _k === void 0 ? void 0 : _k.entity_id),
                        unit: unit !== null && unit !== void 0 ? unit : this.getEntityAttribute((_l = this.vehicleEntities.maxSoc) === null || _l === void 0 ? void 0 : _l.entity_id, 'unit_of_measurement'),
                    };
                }
                else if (key === 'parkBrake') {
                    return {
                        key,
                        name: name !== null && name !== void 0 ? name : 'Park brake',
                        icon: icon !== null && icon !== void 0 ? icon : 'mdi:car-brake-parking',
                        state: (state !== null && state !== void 0 ? state : this.getBooleanState((_m = this.vehicleEntities.parkBrake) === null || _m === void 0 ? void 0 : _m.entity_id)) ? 'Engaged' : 'Released',
                        unit: unit !== null && unit !== void 0 ? unit : '',
                    };
                }
                else if (key === 'windowsClosed') {
                    return {
                        key,
                        name: name !== null && name !== void 0 ? name : 'Windows',
                        state: (state !== null && state !== void 0 ? state : this.getBooleanState((_o = this.vehicleEntities.windowsClosed) === null || _o === void 0 ? void 0 : _o.entity_id)) ? 'Closed' : 'Opened',
                        icon: icon !== null && icon !== void 0 ? icon : this.getEntityAttribute((_p = this.vehicleEntities.windowsClosed) === null || _p === void 0 ? void 0 : _p.entity_id, 'icon'),
                        unit: unit !== null && unit !== void 0 ? unit : '',
                    };
                }
            }
            // Directly handle warning states
            if (['tirePressureWarning', 'lowBrakeFluid', 'lowCoolantLevel', 'engineLight', 'lowWashWater'].includes(key)) {
                return {
                    key,
                    name: name !== null && name !== void 0 ? name : (_q = this.vehicleEntities[key]) === null || _q === void 0 ? void 0 : _q.original_name,
                    icon: (_s = icon !== null && icon !== void 0 ? icon : this.getEntityAttribute((_r = this.vehicleEntities[key]) === null || _r === void 0 ? void 0 : _r.entity_id, 'icon')) !== null && _s !== void 0 ? _s : '',
                    state: this.getBooleanState((_t = this.vehicleEntities[key]) === null || _t === void 0 ? void 0 : _t.entity_id) ? 'Problem' : 'OK',
                    unit: unit !== null && unit !== void 0 ? unit : '',
                };
            }
            return {
                key,
                name: name !== null && name !== void 0 ? name : (_u = this.vehicleEntities[key]) === null || _u === void 0 ? void 0 : _u.original_name,
                icon: icon !== null && icon !== void 0 ? icon : this.getEntityAttribute((_v = this.vehicleEntities[key]) === null || _v === void 0 ? void 0 : _v.entity_id, 'icon'),
                unit: unit !== null && unit !== void 0 ? unit : this.getEntityAttribute((_w = this.vehicleEntities[key]) === null || _w === void 0 ? void 0 : _w.entity_id, 'unit_of_measurement'),
                state: state !== null && state !== void 0 ? state : this.getStateDisplay((_x = this.vehicleEntities[key]) === null || _x === void 0 ? void 0 : _x.entity_id),
            };
        };
        this.getLockEntityInfo = () => {
            var _a, _b, _c;
            const lockState = this.getEntityState((_a = this.vehicleEntities.lockSensor) === null || _a === void 0 ? void 0 : _a.entity_id);
            const lockStateFormatted = lockStateMapping[lockState] || lockStateMapping['4'];
            const lockIcon = lockState === '2' || lockState === '1' ? 'mdi:lock' : 'mdi:lock-open';
            const lockColor = lockState === '2' || lockState === '1' ? 'warning' : '';
            const lockName = (_b = this.vehicleEntities.lock) === null || _b === void 0 ? void 0 : _b.original_name;
            return {
                key: 'lock',
                name: lockName,
                icon: lockIcon,
                state: lockStateFormatted,
                color: lockColor,
                lockId: (_c = this.vehicleEntities.lockSensor) === null || _c === void 0 ? void 0 : _c.entity_id,
            };
        };
        this.getStateDisplay = (entityId) => {
            if (!entityId || !this.hass.states[entityId] || !this.hass.locale)
                return '';
            return W(this.hass.localize, this.hass.states[entityId], this.hass.locale);
        };
        this.getSecondaryInfo = (cardType) => {
            var _a, _b, _c, _d;
            const { vehicleEntities } = this;
            switch (cardType) {
                case 'tripCards':
                    return this.getStateDisplay((_a = vehicleEntities.odometer) === null || _a === void 0 ? void 0 : _a.entity_id);
                case 'vehicleCards':
                    const lockedDisplayText = lockStateMapping[this.getEntityState((_b = vehicleEntities.lockSensor) === null || _b === void 0 ? void 0 : _b.entity_id)] || lockStateMapping['4'];
                    return lockedDisplayText;
                case 'ecoCards':
                    return this.getStateDisplay((_c = vehicleEntities.ecoScoreBonusRange) === null || _c === void 0 ? void 0 : _c.entity_id);
                case 'tyreCards':
                    const tireAttributes = [
                        'tirePressureFrontRight',
                        'tirePressureFrontRight',
                        'tirePressureRearLeft',
                        'tirePressureRearRight',
                    ];
                    // Store pressures with their original units
                    const pressuresWithUnits = tireAttributes.map((key) => {
                        var _a, _b;
                        return ({
                            pressure: this.getEntityState((_a = vehicleEntities[key]) === null || _a === void 0 ? void 0 : _a.entity_id) || '',
                            unit: this.getEntityAttribute((_b = vehicleEntities[key]) === null || _b === void 0 ? void 0 : _b.entity_id, 'unit_of_measurement'),
                        });
                    });
                    // Find the minimum and maximum pressures
                    const minPressure = Math.min(...pressuresWithUnits.map(({ pressure }) => parseFloat(pressure)));
                    const maxPressure = Math.max(...pressuresWithUnits.map(({ pressure }) => parseFloat(pressure)));
                    // Format the minimum and maximum pressures with their original units
                    const tireUnit = ((_d = pressuresWithUnits[0]) === null || _d === void 0 ? void 0 : _d.unit) || '';
                    const formattedMinPressure = minPressure % 1 === 0 ? minPressure.toFixed(0) : minPressure.toFixed(1);
                    const formattedMaxPressure = maxPressure % 1 === 0 ? maxPressure.toFixed(0) : maxPressure.toFixed(1);
                    return `${formattedMinPressure} - ${formattedMaxPressure} ${tireUnit}`;
                default:
                    return 'Unknown Card';
            }
        };
        this.getEntityInfo = (entity) => {
            const state = this.getEntityState(entity);
            const unit = this.getEntityAttribute(entity, 'unit_of_measurement');
            return { state, unit };
        };
        this.getBooleanState = (entity) => {
            if (!entity || !this.hass.states[entity])
                return false;
            return this.hass.states[entity].state === 'on';
        };
        this.getEntityState = (entity) => {
            if (!entity || !this.hass.states[entity])
                return '';
            return this.hass.states[entity].state;
        };
        this.getEntityAttribute = (entity, attribute) => {
            if (!entity || !this.hass.states[entity] || !this.hass.states[entity].attributes)
                return undefined;
            return this.hass.states[entity].attributes[attribute];
        };
        this.toggleMoreInfo = (entity) => {
            ne(this, 'hass-more-info', { entityId: entity });
        };
    }
    static async getConfigElement() {
        await Promise.resolve().then(function () { return editor; });
        return document.createElement('vehicle-info-card-editor');
    }
    get isCharging() {
        var _a;
        return this.getEntityAttribute((_a = this.vehicleEntities.rangeElectric) === null || _a === void 0 ? void 0 : _a.entity_id, 'chargingactive');
    }
    get isDark() {
        return this.hass.themes.darkMode;
    }
    // https://lit.dev/docs/components/styles/
    static get styles() {
        return css_248z$2;
    }
    async setConfig(config) {
        var _a, _b, _c;
        if (!config) {
            throw new Error(localize('common.invalid_configuration'));
        }
        this.config = Object.assign({}, config);
        for (const cardType of cardTypes) {
            if (this.config[cardType.config]) {
                this.createCards(this.config[cardType.config], cardType.type);
            }
        }
        if (this.config.device_tracker) {
            const haMapConfig = {
                type: 'map',
                default_zoom: (_a = this.config.map_popup_config) === null || _a === void 0 ? void 0 : _a.default_zoom,
                hours_to_show: (_b = this.config.map_popup_config) === null || _b === void 0 ? void 0 : _b.hours_to_show,
                theme_mode: (_c = this.config.map_popup_config) === null || _c === void 0 ? void 0 : _c.theme_mode,
                entities: [
                    {
                        entity: this.config.device_tracker,
                    },
                ],
            };
            this.createCards([haMapConfig], 'mapDialog');
        }
    }
    getCardSize() {
        return 3;
    }
    firstUpdated(changedProperties) {
        super.firstUpdated(changedProperties);
        this.configureAsync();
    }
    async configureAsync() {
        this.vehicleEntities = await getVehicleEntities(this.hass, this.config);
        this.requestUpdate();
    }
    connectedCallback() {
        super.connectedCallback();
        window.BenzCard = this;
        this.manageButtonEventListeners('addEventListener');
    }
    disconnectedCallback() {
        if (window.BenzCard === this) {
            window.BenzCard = undefined;
        }
        this.manageButtonEventListeners('removeEventListener');
        super.disconnectedCallback();
    }
    manageButtonEventListeners(action) {
        var _a;
        const buttons = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelectorAll('.grid-item');
        if (!buttons)
            return;
        buttons.forEach((button) => {
            button[action]('click', () => tapFeedback(button));
        });
    }
    async createCards(cardConfigs, stateProperty) {
        if (HELPERS) {
            const helpers = await HELPERS;
            const cards = await Promise.all(cardConfigs.map(async (cardConfig) => {
                const element = await helpers.createCardElement(cardConfig);
                element.hass = this.hass;
                return element;
            }));
            this.additionalCards[stateProperty] = cards;
        }
    }
    updated(changedProps) {
        var _a;
        super.updated(changedProps);
        if (changedProps.has('hass')) {
            Object.values(this.additionalCards).forEach((cards) => {
                cards.forEach((card) => {
                    card.hass = this.hass;
                });
            });
        }
        if (changedProps.has('activeCardType') && this.activeCardType !== 'mapDialog') {
            const cardElement = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('.card-element');
            if (!cardElement)
                return;
            setupCardListeners(cardElement, this.toggleCard.bind(this));
        }
        if (changedProps.has('activeCardType') && this.activeCardType === null) {
            this.manageButtonEventListeners('addEventListener');
        }
    }
    // https://lit.dev/docs/components/lifecycle/#reactive-update-cycle-performing
    shouldUpdate(changedProps) {
        if (!this.config) {
            return false;
        }
        if (changedProps.has('hass')) {
            return true;
        }
        return _e(this, changedProps, false);
    }
    /* -------------------------------------------------------------------------- */
    /* MAIN RENDER                                                                */
    /* -------------------------------------------------------------------------- */
    // https://lit.dev/docs/components/rendering/
    render() {
        if (!this.config || !this.hass) {
            return x ``;
        }
        const isDark = this.isDark ? 'dark' : '';
        const name = this.config.name || '';
        return x `
      <ha-card class=${isDark ? 'dark' : ''}>
        ${this._renderHeaderBackground()}
        <header>
          <h1>${name}</h1>
        </header>
        ${this.activeCardType ? this._renderCustomCard() : this._renderMainCard()}
      </ha-card>
    `;
    }
    _renderHeaderBackground() {
        if (!this.config.show_background)
            return x ``;
        const isDark = this.isDark;
        const background = isDark ? amgWhite : amgBlack;
        return x ` <div class="header-background" style="background-image: url(${background})"></div> `;
    }
    _renderMainCard() {
        return x `
      <main id="main-wrapper">
        <div class="header-info-box">
          ${this._renderWarnings()} ${this._renderChargingInfo()} ${this._renderRangeInfo()}
        </div>
        ${this._renderHeaderSlides()} ${this._renderMap()} ${this._renderButtons()}
      </main>
    `;
    }
    _renderWarnings() {
        var _a, _b, _c;
        const { vehicleEntities } = this;
        // Get the current state of the lock and park brake
        const lockState = lockStateMapping[this.getEntityState((_a = vehicleEntities.lockSensor) === null || _a === void 0 ? void 0 : _a.entity_id)] || lockStateMapping['4'];
        const lockSensorState = this.getEntityState((_b = vehicleEntities.lockSensor) === null || _b === void 0 ? void 0 : _b.entity_id);
        const lockIconDisplay = lockSensorState === '2' || lockSensorState === '1' ? 'mdi:lock' : 'mdi:lock-open';
        const parkBrakeState = this.getBooleanState((_c = vehicleEntities.parkBrake) === null || _c === void 0 ? void 0 : _c.entity_id) ? 'Parked' : 'Released';
        const itemsData = [
            { key: 'lock', state: lockState, icon: lockIconDisplay },
            { key: 'parkBrake', state: parkBrakeState, icon: 'mdi:car-brake-parking' },
        ];
        const chargingIcon = 'mdi:ev-station';
        const defaultIdicator = itemsData.map(({ state, icon }) => {
            return x `
        <div class="item">
          <ha-icon icon=${icon}></ha-icon>
          <div><span>${state}</span></div>
        </div>
      `;
        });
        const addedChargingInfo = this.isCharging
            ? x ` <div class="item chargeinfo" @click=${() => this.toggleChargingInfo()}>
          <ha-icon icon=${chargingIcon}></ha-icon>
          <div>
            <span>Charging</span>
            <ha-icon icon=${this.chargingInfoVisible ? 'mdi:chevron-up' : 'mdi:chevron-right'}></ha-icon>
          </div>
        </div>`
            : x ``;
        return x `<div class="info-box">${defaultIdicator} ${addedChargingInfo}</div> `;
    }
    _renderChargingInfo() {
        if (!this.isCharging)
            return;
        const generateDataArray = (keys) => {
            return keys.map(({ key, name, icon, state, unit }) => {
                var _a, _b, _c, _d, _e;
                if (!this.vehicleEntities[key] && key === 'selectedProgram') {
                    // Return the attributes directly for the 'mode' key if it doesn't exist in sensorDevices
                    return {
                        key,
                        name: name !== null && name !== void 0 ? name : 'Program',
                        icon: icon !== null && icon !== void 0 ? icon : 'mdi:ev-station',
                        state: selectedProgramMapping[this.getEntityAttribute((_a = this.vehicleEntities.rangeElectric) === null || _a === void 0 ? void 0 : _a.entity_id, 'selectedChargeProgram')],
                        unit: unit !== null && unit !== void 0 ? unit : '',
                    };
                }
                return {
                    key,
                    name: name !== null && name !== void 0 ? name : (_b = this.vehicleEntities[key]) === null || _b === void 0 ? void 0 : _b.original_name,
                    icon: icon !== null && icon !== void 0 ? icon : this.getEntityAttribute((_c = this.vehicleEntities[key]) === null || _c === void 0 ? void 0 : _c.entity_id, 'icon'),
                    state: state !== null && state !== void 0 ? state : this.getEntityState((_d = this.vehicleEntities[key]) === null || _d === void 0 ? void 0 : _d.entity_id),
                    unit: unit !== null && unit !== void 0 ? unit : this.getEntityAttribute((_e = this.vehicleEntities[key]) === null || _e === void 0 ? void 0 : _e.entity_id, 'unit_of_measurement'),
                };
            });
        };
        const chargingDataKeys = [
            { key: 'chargingPower', name: 'Power', icon: 'mdi:flash' },
            { key: 'soc', name: 'Current state', unit: '%' },
            { key: 'maxSoc', name: 'Maximum', unit: '%' },
            { key: 'selectedProgram' },
        ];
        const chargingData = generateDataArray(chargingDataKeys);
        const chargingClass = this.chargingInfoVisible ? 'info-box charge active' : 'info-box charge';
        return x `
      <div class=${chargingClass}>
        ${chargingData.map(({ name, state, icon, unit }) => {
            return x `
            <div class="item charge">
              <div>
                <ha-icon .icon=${icon}></ha-icon>
                <span>${state} ${unit}</span>
              </div>
              <div class="item-name">
                <span>${name}</span>
              </div>
            </div>
          `;
        })}
      </div>
    `;
    }
    _renderRangeInfo() {
        if (this.chargingInfoVisible)
            return;
        const { fuelLevel, rangeLiquid, rangeElectric, soc } = this.vehicleEntities;
        const fuelInfo = this.getEntityInfo(fuelLevel === null || fuelLevel === void 0 ? void 0 : fuelLevel.entity_id);
        const rangeLiquidInfo = this.getEntityInfo(rangeLiquid === null || rangeLiquid === void 0 ? void 0 : rangeLiquid.entity_id);
        const rangeElectricInfo = this.getEntityInfo(rangeElectric === null || rangeElectric === void 0 ? void 0 : rangeElectric.entity_id);
        const socInfo = this.getEntityInfo(soc === null || soc === void 0 ? void 0 : soc.entity_id);
        const renderInfoBox = (icon, state, unit, rangeState, rangeUnit) => x `
      <div class="info-box">
        <div class="item">
          <ha-icon icon="${icon}"></ha-icon>
          <div><span>${state} ${unit}</span></div>
        </div>
        <div class="fuel-wrapper">
          <div class="fuel-level-bar" style="width: ${state}%;"></div>
        </div>
        <div class="item">
          <span>${rangeState} ${rangeUnit}</span>
        </div>
      </div>
    `;
        if (fuelInfo.state && rangeLiquidInfo.state) {
            return renderInfoBox('mdi:gas-station', fuelInfo.state, fuelInfo.unit, rangeLiquidInfo.state, rangeLiquidInfo.unit);
        }
        else if (rangeElectricInfo.state && socInfo.state) {
            return renderInfoBox('mdi:ev-station', socInfo.state, socInfo.unit, rangeElectricInfo.state, rangeElectricInfo.unit);
        }
    }
    _renderHeaderSlides() {
        if (!this.config.images || !this.config.show_slides)
            return x ``;
        const images = this.config.images;
        return x `<header-slide .images=${images}></header-slide>`;
    }
    _renderMap() {
        const { config, hass } = this;
        if (!config.show_map) {
            return;
        }
        if (!config.device_tracker && config.show_map) {
            return this._showWarning('No device_tracker entity provided.');
        }
        const darkMode = this.isDark;
        return x `
      <div id="map-box">
        <vehicle-map
          .hass=${hass}
          .darkMode=${darkMode}
          .apiKey=${this.config.google_api_key || ''}
          .deviceTracker=${config.device_tracker || ''}
          .popup=${config.enable_map_popup || false}
          @toggle-map-popup=${this.showMapOnCard}
        ></vehicle-map>
      </div>
    `;
    }
    _renderEcoChart() {
        var _a, _b, _c, _d;
        if (this.activeCardType !== 'ecoCards')
            return x ``;
        const ecoData = {
            bonusRange: parseFloat(this.getEntityState((_a = this.vehicleEntities.ecoScoreBonusRange) === null || _a === void 0 ? void 0 : _a.entity_id)) || 0,
            acceleration: parseFloat(this.getEntityState((_b = this.vehicleEntities.ecoScoreAcceleraion) === null || _b === void 0 ? void 0 : _b.entity_id)) || 0,
            constant: parseFloat(this.getEntityState((_c = this.vehicleEntities.ecoScoreConstant) === null || _c === void 0 ? void 0 : _c.entity_id)) || 0,
            freeWheel: parseFloat(this.getEntityState((_d = this.vehicleEntities.ecoScoreFreeWheel) === null || _d === void 0 ? void 0 : _d.entity_id)) || 0,
        };
        return x `<eco-chart .ecoData=${ecoData}></eco-chart>`;
    }
    _renderButtons() {
        if (!this.config.show_buttons)
            return x ``;
        return x `
      <div class="grid-container">
        ${cardTypes.map((cardType) => x `
            <div class="grid-item click-shrink" @click=${() => this.toggleCardFromButtons(cardType.type)}>
              <div class="item-icon">
                <ha-icon .icon="${cardType.icon}"></ha-icon>
              </div>
              <div class="item-content">
                <span class="primary">${cardType.name}</span>
                <span class="secondary">${this.getSecondaryInfo(cardType.type)}</span>
              </div>
            </div>
          `)}
      </div>
    `;
    }
    _renderCustomCard() {
        if (!this.activeCardType)
            return x ``;
        const cardConfigMap = {
            tripCards: {
                config: this.config.trip_card,
                defaultRender: this._renderDefaultTripCard.bind(this),
            },
            vehicleCards: {
                config: this.config.vehicle_card,
                defaultRender: this._renderDefaultVehicleCard.bind(this),
            },
            ecoCards: {
                config: this.config.eco_card,
                defaultRender: this._renderDefaultEcoCard.bind(this),
            },
            tyreCards: {
                config: this.config.tyre_card,
                defaultRender: this._renderDefaultTyreCard.bind(this),
            },
            mapDialog: {
                config: [],
                defaultRender: () => this.additionalCards['mapDialog'],
            },
        };
        const cardInfo = cardConfigMap[this.activeCardType];
        if (!cardInfo) {
            return x ``;
        }
        const isDefaultCard = !cardInfo.config || cardInfo.config.length === 0;
        const cards = isDefaultCard ? cardInfo.defaultRender() : this.additionalCards[this.activeCardType];
        const lastCarUpdate = this.config.entity ? this.hass.states[this.config.entity].last_changed : '';
        const formattedDate = this.hass.locale
            ? v(new Date(lastCarUpdate), this.hass.locale)
            : formatTimestamp(lastCarUpdate);
        const cardHeaderBox = x ` <div class="added-card-header">
      <div class="headder-btn" @click="${() => this.toggleCard('close')}">
        <ha-icon icon="mdi:close"></ha-icon>
      </div>
      <div class="card-toggle">
        <div class="headder-btn" @click=${() => this.toggleCard('prev')}>
          <ha-icon icon="mdi:chevron-left"></ha-icon>
        </div>
        <div class="headder-btn" @click=${() => this.toggleCard('next')}>
          <ha-icon icon="mdi:chevron-right"></ha-icon>
        </div>
      </div>
    </div>`;
        return x `
      <main id="cards-wrapper">
        ${cardHeaderBox}
        <section class="card-element">
          ${isDefaultCard ? cards : cards.map((card) => x `<div class="added-card">${card}</div>`)}
        </section>
        ${isDefaultCard ? x `<div class="last-update"><span>Last update: ${formattedDate}</span></div>` : ''}
      </main>
    `;
    }
    _renderDefaultTripCard() {
        const overViewDataKeys = [
            { key: 'odometer' },
            { key: 'fuelLevel' },
            { key: 'rangeLiquid', name: 'Range' },
            { key: 'rangeElectric', name: 'Range' },
            { key: 'soc' },
            { key: 'maxSoc' },
        ];
        const tripFromResetDataKeys = [
            { key: 'distanceReset' },
            { key: 'averageSpeedReset', icon: 'mdi:speedometer' },
            { key: 'liquidConsumptionReset', name: 'Consumption reset' },
            { key: 'electricConsumptionReset', name: 'Consumption reset' },
        ];
        const tripFromStartDataKeys = [
            { key: 'distanceStart' },
            { key: 'averageSpeedStart', icon: 'mdi:speedometer-slow' },
            { key: 'liquidConsumptionStart', name: 'Consumption start' },
            { key: 'electricConsumptionStart', name: 'Consumption start' },
        ];
        const sections = [
            { title: 'Overview', data: this.createDataArray(overViewDataKeys) },
            { title: 'From start', data: this.createDataArray(tripFromStartDataKeys) },
            { title: 'From reset', data: this.createDataArray(tripFromResetDataKeys) },
        ];
        return x ` ${sections.map((section) => this.createItemDataRow(section.title, section.data))} `;
    }
    _renderDefaultVehicleCard() {
        const { vehicleEntities } = this;
        const warningsDataKeys = [
            { key: 'tirePressureWarning' },
            { key: 'lowBrakeFluid' },
            { key: 'lowCoolantLevel' },
            { key: 'engineLight' },
            { key: 'lowWashWater' },
        ];
        const lockInfoData = this.getLockEntityInfo();
        const windowData = this.createDataArray([{ key: 'windowsClosed' }]);
        const parkBrakeData = this.createDataArray([{ key: 'parkBrake' }]);
        const warningsData = this.createDataArray(warningsDataKeys);
        return x `
      <div class="default-card">
        <div class="data-header">Vehicle status</div>
        <div class="data-row">
          <div>
            <ha-icon class="data-icon ${lockInfoData.color}" .icon=${lockInfoData.icon}></ha-icon>
            <span>${lockInfoData.name}</span>
          </div>
          <div class="data-value-unit" @click=${() => this.toggleLockAttributes()}>
            <span>${lockInfoData.state}</span>
            <ha-icon icon="${this.lockAttributesVisible ? 'mdi:chevron-up' : 'mdi:chevron-right'}"></ha-icon>
          </div>
        </div>

        ${this._renderLockAttributes()}
        ${windowData.map(({ name, icon, state }) => {
            return x `
            <div class="data-row">
              <div>
                <ha-icon
                  class="data-icon"
                  .icon="${icon}"
                  @click=${() => { var _a; return this.toggleMoreInfo((_a = vehicleEntities.windowsClosed) === null || _a === void 0 ? void 0 : _a.entity_id); }}
                ></ha-icon>
                <span>${name}</span>
              </div>
              <div class="data-value-unit" @click=${() => this.toggleWindowAttributes()}>
                <span>${state}</span>
                <ha-icon icon="${this.windowAttributesVisible ? 'mdi:chevron-up' : 'mdi:chevron-right'}"></ha-icon>
              </div>
            </div>
          `;
        })}
        ${this._renderWindowAttributes()}
        ${parkBrakeData.map(({ name, icon, state }) => {
            return x `
            <div class="data-row">
              <div>
                <ha-icon
                  class="data-icon ${state === 'Parked' ? '' : 'warning'}"
                  .icon="${icon}"
                  @click=${() => { var _a; return this.toggleMoreInfo((_a = vehicleEntities.parkBrake) === null || _a === void 0 ? void 0 : _a.entity_id); }}
                ></ha-icon>
                <span>${name}</span>
              </div>
              <div
                class="data-value
              ${state === 'Parked' ? '' : 'warning'}"
                @click=${() => { var _a; return this.toggleMoreInfo((_a = vehicleEntities.parkBrake) === null || _a === void 0 ? void 0 : _a.entity_id); }}
              >
                <span>${state}</span>
                <ha-icon icon="mdi:chevron-double-right" style="opacity: 0"></ha-icon>
              </div>
            </div>
          `;
        })}
      </div>
      <div class="default-card">
        <div class="data-header">Warnings</div>
        ${warningsData.map(({ key, icon, state, name }) => {
            var _a;
            return x `
            <div class="data-row">
              <div>
                <ha-icon
                  class="data-icon"
                  .icon="${icon}"
                  @click=${() => { var _a; return this.toggleMoreInfo((_a = vehicleEntities[key]) === null || _a === void 0 ? void 0 : _a.entity_id); }}
                ></ha-icon>
                <span>${name}</span>
              </div>
              <div
                class="data-value-unit ${this.getBooleanState((_a = vehicleEntities[key]) === null || _a === void 0 ? void 0 : _a.entity_id) ? 'error' : ''} "
                @click=${() => { var _a; return this.toggleMoreInfo((_a = vehicleEntities[key]) === null || _a === void 0 ? void 0 : _a.entity_id); }}
              >
                <span>${state}</span>
              </div>
            </div>
          `;
        })}
      </div>
    `;
    }
    _renderDefaultEcoCard() {
        const ecoDataKeys = [
            { key: 'ecoScoreBonusRange', name: 'Bonus range' },
            { key: 'ecoScoreAcceleraion', name: 'Acceleration' },
            { key: 'ecoScoreConstant', name: 'Constant' },
            { key: 'ecoScoreFreeWheel', name: 'Free wheel' },
        ];
        const ecoData = this.createDataArray(ecoDataKeys);
        return x `<div class="default-card">
        <div class="data-header">Eco display</div>
        ${this._renderEcoChart()}
      </div>
      ${this.createItemDataRow('Scores', ecoData)}`;
    }
    _renderDefaultTyreCard() {
        const tyreDataKeys = [
            { key: 'tirePressureFrontLeft', name: 'Front left', icon: 'mdi:tire' },
            { key: 'tirePressureFrontRight', name: 'Front right', icon: 'mdi:tire' },
            { key: 'tirePressureRearLeft', name: 'Rear left', icon: 'mdi:tire' },
            { key: 'tirePressureRearRight', name: 'Rear right', icon: 'mdi:tire' },
        ];
        const tyreData = this.createDataArray(tyreDataKeys);
        return this.createItemDataRow('Tyre pressures', tyreData);
    }
    _renderLockAttributes() {
        const lockAttributeStates = {};
        // Iterate over the keys of the lockAttrMapping object
        Object.keys(lockAttrMapping).forEach((attribute) => {
            var _a;
            const attributeState = this.getEntityAttribute((_a = this.vehicleEntities.lockSensor) === null || _a === void 0 ? void 0 : _a.entity_id, attribute);
            if (attributeState !== undefined && attributeState !== null) {
                lockAttributeStates[attribute] = attributeState;
            }
        });
        const attributesClass = this.lockAttributesVisible ? 'sub-attributes active' : 'sub-attributes';
        // Render the lock attributes
        return x `
      <div class=${attributesClass}>
        ${Object.keys(lockAttributeStates).map((attribute) => {
            const rawState = lockAttributeStates[attribute];
            // Check if the state is valid and the attribute mapping exists
            if (rawState !== undefined && rawState !== null && lockAttrMapping[attribute]) {
                const readableState = lockAttrMapping[attribute].state[rawState] || 'Unknown';
                return x `
              <div class="data-row">
                <span>${lockAttrMapping[attribute].name}</span>
                <div class="data-value-unit">
                  <span style="text-transform: capitalize">${readableState}</span>
                </div>
              </div>
            `;
            }
            // Return nothing if the attribute state is not valid or attribute mapping does not exist
            return '';
        })}
      </div>
    `;
    }
    _renderWindowAttributes() {
        const windowAttributeStates = {};
        // Iterate over the keys of the Windows object
        Object.keys(windowsStateMapping).forEach((attribute) => {
            var _a;
            const attributeState = this.getEntityAttribute((_a = this.vehicleEntities.windowsClosed) === null || _a === void 0 ? void 0 : _a.entity_id, attribute);
            if (attributeState !== undefined && attributeState !== null) {
                windowAttributeStates[attribute] = attributeState;
            }
        });
        const attributesClass = this.windowAttributesVisible ? 'sub-attributes active' : 'sub-attributes';
        // Render the window attributes
        return x `
      <div class=${attributesClass}>
        ${Object.keys(windowAttributeStates).map((attribute) => {
            const rawState = windowAttributeStates[attribute];
            // Check if the state is valid and the attribute mapping exists
            if (rawState !== undefined && rawState !== null && windowsStateMapping[attribute]) {
                const readableState = windowsStateMapping[attribute].state[rawState] || 'Unknown';
                return x `
              <div class="data-row">
                <span>${windowsStateMapping[attribute].name}</span>
                <div class="data-value-unit">
                  <span style="text-transform: capitalize">${readableState}</span>
                </div>
              </div>
            `;
            }
            // Return nothing if the attribute state is not valid or attribute mapping does not exist
            return '';
        })}
      </div>
    `;
    }
    _showWarning(warning) {
        return x ` <hui-warning>${warning}</hui-warning> `;
    }
};
VehicleCard.getStubConfig = () => {
    return Object.assign({}, defaultConfig);
};
__decorate([
    n$1({ attribute: false })
], VehicleCard.prototype, "hass", void 0);
__decorate([
    n$1({ type: Object })
], VehicleCard.prototype, "config", void 0);
__decorate([
    t$1()
], VehicleCard.prototype, "vehicleEntities", void 0);
__decorate([
    t$1()
], VehicleCard.prototype, "additionalCards", void 0);
__decorate([
    t$1()
], VehicleCard.prototype, "activeCardType", void 0);
VehicleCard = __decorate([
    e$1('vehicle-info-card')
], VehicleCard);

let VehicleCardEditor = class VehicleCardEditor extends s {
    async setConfig(config) {
        this._config = config;
        if (!this._config.entity) {
            this._config.entity = this.getCarEntity();
            this._config.name = await this.getDeviceModelName();
            ne(this, 'config-changed', { config: this._config });
        }
        this.loadCardHelpers();
    }
    getCarEntity() {
        if (!this.hass)
            return '';
        const entities = Object.keys(this.hass.states).filter((entity) => entity.startsWith('sensor') && entity.endsWith('_car'));
        return entities[0] || '';
    }
    async getDeviceModelName() {
        var _a;
        if (!((_a = this._config) === null || _a === void 0 ? void 0 : _a.entity))
            return '';
        const carEntityId = this._config.entity;
        // Fetch all entities
        const allEntities = await this.hass.callWS({
            type: 'config/entity_registry/list',
        });
        // Find the car entity
        const carEntity = allEntities.find((entity) => entity.entity_id === carEntityId);
        if (!carEntity)
            return '';
        console.log('Car Entity:', carEntity);
        const deviceId = carEntity.device_id;
        if (!deviceId)
            return '';
        // Fetch all devices
        const allDevices = await this.hass.callWS({
            type: 'config/device_registry/list',
        });
        // Find the device by ID
        const device = allDevices.find((device) => device.id === deviceId);
        if (!device)
            return '';
        console.log('Device:', device);
        return device.model || '';
    }
    get _name() {
        var _a;
        return ((_a = this._config) === null || _a === void 0 ? void 0 : _a.name) || '';
    }
    get _entity() {
        var _a;
        return ((_a = this._config) === null || _a === void 0 ? void 0 : _a.entity) || '';
    }
    get _device_tracker() {
        var _a;
        return ((_a = this._config) === null || _a === void 0 ? void 0 : _a.device_tracker) || '';
    }
    get _show_slides() {
        var _a;
        return ((_a = this._config) === null || _a === void 0 ? void 0 : _a.show_slides) || false;
    }
    get _show_map() {
        var _a;
        return ((_a = this._config) === null || _a === void 0 ? void 0 : _a.show_map) || false;
    }
    get _show_buttons() {
        var _a;
        return ((_a = this._config) === null || _a === void 0 ? void 0 : _a.show_buttons) || false;
    }
    get _show_background() {
        var _a;
        return ((_a = this._config) === null || _a === void 0 ? void 0 : _a.show_background) || false;
    }
    get _enable_map_popup() {
        var _a;
        return ((_a = this._config) === null || _a === void 0 ? void 0 : _a.enable_map_popup) || false;
    }
    get _google_api_key() {
        var _a;
        return ((_a = this._config) === null || _a === void 0 ? void 0 : _a.google_api_key) || '';
    }
    render() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (!this.hass || !this._helpers) {
            return x ``;
        }
        // You can restrict on domain type
        // const entities = Object.keys(this.hass.states).filter((entity) => entity.startsWith('sensor'));
        const entities = Object.keys(this.hass.states).filter((entity) => entity.startsWith('sensor') && entity.endsWith('_car'));
        const device_trackers = Object.keys(this.hass.states).filter((entity) => entity.startsWith('device_tracker'));
        let images = '';
        if (this._config && Array.isArray(this._config.images)) {
            images = this._config.images.join('\n');
        }
        else if (this._config && typeof this._config.images === 'string') {
            images = this._config.images;
        }
        return x `
      <div class="card-config">
        <ha-textfield
          label="Name (Optional)"
          .value=${this._name}
          .configValue=${'name'}
          @input=${this._valueChanged}
        ></ha-textfield>
        <ha-select
          naturalMenuWidth
          fixedMenuPosition
          label="Entity (Required)"
          .configValue=${'entity'}
          .value=${this._entity}
          @selected=${this._valueChanged}
          @closed=${(ev) => ev.stopPropagation()}
        >
          ${entities.map((entity) => {
            return x `<mwc-list-item .value=${entity}>${entity}</mwc-list-item>`;
        })}
        </ha-select>

        <ha-select
          naturalMenuWidth
          fixedMenuPosition
          label="Device Tracker (Optional)"
          .configValue=${'device_tracker'}
          .value=${this._device_tracker}
          @selected=${this._valueChanged}
          @closed=${(ev) => ev.stopPropagation()}
        >
          <mwc-list-item value=""></mwc-list-item>
          ${device_trackers.map((entity) => {
            return x `<mwc-list-item .value=${entity}>${entity}</mwc-list-item>`;
        })}
        </ha-select>
        <ha-textfield
          label="Google API Key (Optional)"
          type="password"
          .value=${this._google_api_key}
          .configValue=${'google_api_key'}
          @input=${this._valueChanged}
        ></ha-textfield>
        <div class="panel-container">
          <ha-expansion-panel .open=${false} .outlined=${true}>
            <h3 slot="header">
              <ha-icon icon="mdi:map"></ha-icon>
              Map Popup Configuration
            </h3>
            <div class="map-config">
              <ha-textfield
              label="Hours to show"
              type="number"
              .value=${((_b = (_a = this._config) === null || _a === void 0 ? void 0 : _a.map_popup_config) === null || _b === void 0 ? void 0 : _b.hours_to_show) || 0}
              .configValue=${'hours_to_show'}
              @input=${this._valueChanged}
            ></ha-textfield>
            <ha-textfield
              label="Default zoom"
              type="number"
              .value=${((_d = (_c = this._config) === null || _c === void 0 ? void 0 : _c.map_popup_config) === null || _d === void 0 ? void 0 : _d.default_zoom) || 14}
              .configValue=${'default_zoom'}
              @input=${this._valueChanged}
            ></ha-textfield>
            <ha-select
              label="Theme mode"
              .value=${((_f = (_e = this._config) === null || _e === void 0 ? void 0 : _e.map_popup_config) === null || _f === void 0 ? void 0 : _f.theme_mode) || 'auto'}
              .configValue=${'theme_mode'}
              @selected=${this._valueChanged}
              @closed=${(ev) => ev.stopPropagation()}
            >
              <mwc-list-item value="auto">Auto</mwc-list-item>
              <mwc-list-item value="dark">Dark</mwc-list-item>
              <mwc-list-item value="light">Light</mwc-list-item>
            </ha-select>
            </div>
          </ha-expansion-panel>
        </div>
        <div class="panel-container">
          <ha-expansion-panel .open=${false} .outlined=${true}>
            <h3 slot="header">
              <ha-icon icon="mdi:code-array"></ha-icon>
              Images Configuration
            </h3>
            <div class="code-editor">
              <ha-alert alert-type="info">There is no need to add a '-' for each line. Each line will be treated as a separate URL automatically.</ha-alert>
              <ha-code-editor
              autofocus
              autocomplete-entities
              autocomplete-icons
              .hass=${this.hass}
              .value=${images}
              .configValue="${'images'}"
              @blur=${this._valueChanged}
            ></ha-code-editor>
            </div>
          </ha-expansion-panel>
        </div>
          <div class="switches">
            <ha-formfield .label=${`Show slides`}>
              <ha-switch
                .disabled=${!((_g = this._config) === null || _g === void 0 ? void 0 : _g.images) || ((_h = this._config) === null || _h === void 0 ? void 0 : _h.images.length) === 0}
                .checked=${this._show_slides !== false}
                .configValue=${'show_slides'}
                @change=${this._valueChanged}
              ></ha-switch>
            </ha-formfield>

            <ha-formfield .label=${`Show buttons`}>
              <ha-switch
                .checked=${this._show_buttons !== false}
                .configValue=${'show_buttons'}
                @change=${this._valueChanged}
              ></ha-switch>
            </ha-formfield>

            <ha-formfield .label=${`Show map`}>
              <ha-switch
                .checked=${this._show_map !== false}
                .configValue=${'show_map'}
                @change=${this._valueChanged}
              ></ha-switch>
            </ha-formfield>
            <ha-formfield .label=${`Show background`}>
              <ha-switch
                .checked=${this._show_background !== false}
                .configValue=${'show_background'}
                @change=${this._valueChanged}
              ></ha-switch>
            </ha-formfield>
            <ha-formfield .label=${`Enable map popup`}>
              <ha-switch
                .disabled=${this._show_map === false || this._show_map === undefined || !((_j = this._config) === null || _j === void 0 ? void 0 : _j.device_tracker)}
                .checked=${this._enable_map_popup !== false}
                .configValue=${'enable_map_popup'}
                @change=${this._valueChanged}
              ></ha-switch>
            </ha-formfield>
          </div>
          <div class="note">
            <p>version: ${CARD_VERSION}</p>
            <i>Note: For another card configuration, use code editor.</i>
          </div>
        </div>
      </div>
    `;
    }
    async loadCardHelpers() {
        this._helpers = await window.loadCardHelpers();
    }
    _valueChanged(ev) {
        if (!this._config || !this.hass) {
            return;
        }
        const target = ev.target;
        const configValue = target.configValue;
        if (this[`_${configValue}`] === target.value) {
            return;
        }
        let newValue;
        if (configValue === 'images') {
            newValue = target.value
                .split('\n')
                .map((line) => line.trim())
                .filter((line) => line); // Remove empty lines
        }
        else if (['hours_to_show', 'default_zoom'].includes(configValue)) {
            newValue = target.value === '' ? undefined : Number(target.value);
            if (!isNaN(newValue)) {
                this._config = Object.assign(Object.assign({}, this._config), { map_popup_config: Object.assign(Object.assign({}, this._config.map_popup_config), { [configValue]: newValue }) });
            }
        }
        else if (configValue === 'theme_mode') {
            newValue = target.value;
            this._config = Object.assign(Object.assign({}, this._config), { map_popup_config: Object.assign(Object.assign({}, this._config.map_popup_config), { [configValue]: newValue }) });
        }
        else {
            newValue = target.checked !== undefined ? target.checked : target.value;
            this._config = Object.assign(Object.assign({}, this._config), { [configValue]: newValue });
        }
        if (newValue.length === 0) {
            // Check for an empty array
            const tmpConfig = Object.assign({}, this._config);
            delete tmpConfig[configValue];
            this._config = tmpConfig;
        }
        ne(this, 'config-changed', { config: this._config });
    }
};
VehicleCardEditor.styles = i$2 `
    .card-config {
      width: 100%;
    }
    .panel-container {
      margin-top: 16px;
    }

    .switches {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      margin-block: 2rem;
    }
    ha-select,
    ha-textfield {
      margin-bottom: 16px;
      display: block;
      width: 100%;
    }
    ha-formfield {
      padding-bottom: 8px;
      width: 100%;
    }
    ha-switch {
      --mdc-theme-secondary: var(--switch-checked-color);
    }

    h3 {
      color: var(--secondary-text-color);
    }

    .note {
      color: var(--secondary-text-color);
      text-align: start;
    }
  `;
__decorate([
    n$1({ attribute: false })
], VehicleCardEditor.prototype, "hass", void 0);
__decorate([
    t$1()
], VehicleCardEditor.prototype, "_config", void 0);
__decorate([
    t$1()
], VehicleCardEditor.prototype, "_helpers", void 0);
VehicleCardEditor = __decorate([
    e$1('vehicle-info-card-editor')
], VehicleCardEditor);

var editor = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get VehicleCardEditor () { return VehicleCardEditor; }
});

export { VehicleCard };
//# sourceMappingURL=vehicle-info-card-dev.js.map
